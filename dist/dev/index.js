import {
  AbortError,
  ExcalidrawError,
  Fonts,
  ImageSceneDataError,
  ImageURLToFile,
  RequestError,
  SVGStringToFile,
  bootstrapCanvas,
  calculateScrollCenter,
  canChangeRoundness,
  canHaveArrowheads,
  canvasToBlob,
  centerScrollOn,
  createFile,
  dataURLToString,
  encodePngMetadata,
  exportToCanvas,
  exportToSvg,
  fileOpen,
  fileSave,
  fillCircle,
  frameClip,
  generateIdFromFile,
  getDataURL,
  getDataURL_sync,
  getDefaultAppState,
  getElementsWithinSelection,
  getExportSize,
  getFileHandle,
  getFileHandleType,
  getLinkHandleFromCoords,
  getNormalizedCanvasDimensions,
  getNormalizedGridStep,
  getNormalizedZoom,
  getSelectedElements,
  getTargetElements,
  hasBackground,
  hasStrokeStyle,
  hasStrokeWidth,
  isEraserActive,
  isHandToolActive,
  isImageFileHandle,
  isImageFileHandleType,
  isPointHittingLink,
  isPointHittingLinkIcon,
  isSomeElementSelected,
  isSupportedImageFile,
  isSupportedImageFileType,
  loadFromBlob,
  loadFromJSON,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  nativeFileSystemSupported,
  normalizeFile,
  parseLibraryJSON,
  renderStaticScene,
  renderStaticSceneThrottled,
  resizeImageFile,
  restoreAppState,
  restoreElement,
  restoreElements,
  restoreLibraryItems,
  saveAsJSON,
  saveLibraryAsJSON,
  serializeAsJSON,
  serializeLibraryAsJSON,
  strokeRectWithRotation_simple
} from "./chunk-QOIZBBOR.js";
import {
  define_import_meta_env_default
} from "./chunk-SL6EXH2C.js";
import {
  en_default
} from "./chunk-EWSB5O67.js";
import {
  percentages_default
} from "./chunk-URPEKBQ3.js";
import {
  __export,
  __glob,
  __publicField
} from "./chunk-XDFCUUT6.js";

// index.tsx
import React49, { useEffect as useEffect51 } from "react";
import { DEFAULT_UI_OPTIONS, isShallowEqual as isShallowEqual10 } from "@excalidraw/common";

// components/App.tsx
import clsx62 from "clsx";
import throttle2 from "lodash.throttle";
import React47, { useContext as useContext3 } from "react";
import { flushSync as flushSync3 } from "react-dom";
import rough3 from "roughjs/bin/rough";
import { nanoid } from "nanoid";
import {
  clamp as clamp6,
  pointFrom as pointFrom26,
  pointDistance as pointDistance8,
  vector as vector3,
  pointRotateRads as pointRotateRads18,
  vectorFromPoint as vectorFromPoint10,
  vectorSubtract as vectorSubtract2,
  vectorDot,
  vectorNormalize as vectorNormalize5
} from "@excalidraw/math";
import {
  COLOR_PALETTE as COLOR_PALETTE8,
  CODES as CODES13,
  DEFAULT_BOUND_TEXT_STROKE_COLOR,
  DEFAULT_ELEMENT_PROPS as DEFAULT_ELEMENT_PROPS2,
  DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX as DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX2,
  ROUGHNESS as ROUGHNESS2,
  shouldResizeFromCenter,
  shouldMaintainAspectRatio,
  shouldRotateWithDiscreteAngle as shouldRotateWithDiscreteAngle3,
  isArrowKey as isArrowKey2,
  KEYS as KEYS54,
  APP_NAME as APP_NAME2,
  CURSOR_TYPE as CURSOR_TYPE4,
  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,
  DEFAULT_VERTICAL_ALIGN,
  DRAGGING_THRESHOLD as DRAGGING_THRESHOLD2,
  ELEMENT_SHIFT_TRANSLATE_AMOUNT,
  ELEMENT_TRANSLATE_AMOUNT,
  EVENT as EVENT13,
  FRAME_STYLE as FRAME_STYLE5,
  IMAGE_MIME_TYPES as IMAGE_MIME_TYPES2,
  IMAGE_RENDER_TIMEOUT,
  LINE_CONFIRM_THRESHOLD as LINE_CONFIRM_THRESHOLD2,
  MAX_ALLOWED_FILE_BYTES,
  MIME_TYPES as MIME_TYPES9,
  MQ_RIGHT_SIDEBAR_MIN_WIDTH,
  POINTER_BUTTON as POINTER_BUTTON2,
  ROUNDNESS as ROUNDNESS6,
  SCROLL_TIMEOUT,
  STICKY_NOTE_PADDING as STICKY_NOTE_PADDING3,
  TAP_TWICE_TIMEOUT,
  TEXT_TO_CENTER_SNAP_THRESHOLD,
  THEME as THEME18,
  TOUCH_CTX_MENU_TIMEOUT,
  VERTICAL_ALIGN as VERTICAL_ALIGN6,
  YOUTUBE_STATES,
  ZOOM_STEP as ZOOM_STEP2,
  POINTER_EVENTS,
  TOOL_TYPE as TOOL_TYPE3,
  supportsResizeObserver as supportsResizeObserver2,
  DEFAULT_COLLISION_THRESHOLD,
  DEFAULT_TEXT_ALIGN as DEFAULT_TEXT_ALIGN3,
  ARROW_TYPE as ARROW_TYPE2,
  DEFAULT_REDUCED_GLOBAL_ALPHA as DEFAULT_REDUCED_GLOBAL_ALPHA2,
  isLocalLink as isLocalLink2,
  normalizeLink as normalizeLink3,
  toValidURL as toValidURL2,
  getGridPoint as getGridPoint2,
  getLineHeight as getLineHeight4,
  debounce as debounce4,
  distance as distance2,
  getFontString as getFontString9,
  getNearestScrollableContainer,
  isInputLike,
  isToolIcon,
  isWritableElement as isWritableElement5,
  sceneCoordsToViewportCoords as sceneCoordsToViewportCoords8,
  tupleToCoors,
  viewportCoordsToSceneCoords as viewportCoordsToSceneCoords3,
  wrapEvent as wrapEvent2,
  updateObject as updateObject2,
  updateActiveTool as updateActiveTool7,
  isTransparent as isTransparent6,
  easeToValuesRAF,
  muteFSAbortError as muteFSAbortError2,
  isTestEnv as isTestEnv5,
  isDevEnv as isDevEnv9,
  easeOut as easeOut4,
  updateStable,
  addEventListener as addEventListener3,
  normalizeEOL as normalizeEOL2,
  getDateTime,
  isShallowEqual as isShallowEqual9,
  arrayToMap as arrayToMap26,
  applyDarkModeFilter as applyDarkModeFilter5,
  randomInteger as randomInteger4,
  CLASSES as CLASSES11,
  Emitter as Emitter3,
  MINIMUM_ARROW_SIZE,
  DOUBLE_TAP_POSITION_THRESHOLD,
  BIND_MODE_TIMEOUT as BIND_MODE_TIMEOUT2,
  invariant as invariant16,
  getFeatureFlag as getFeatureFlag4,
  createUserAgentDescriptor,
  getFormFactor,
  deriveStylesPanelMode as deriveStylesPanelMode2,
  isIOS,
  isBrave,
  isSafari as isSafari2,
  loadDesktopUIModePreference,
  setDesktopUIMode,
  isSelectionLikeTool
} from "@excalidraw/common";
import {
  getObservedAppState,
  getCommonBounds as getCommonBounds8,
  getElementAbsoluteCoords as getElementAbsoluteCoords9,
  bindBindingElement as bindBindingElement2,
  bindOrUnbindBindingElements as bindOrUnbindBindingElements2,
  fixBindingsAfterDeletion as fixBindingsAfterDeletion2,
  getHoveredElementForBinding as getHoveredElementForBinding2,
  isBindingEnabled as isBindingEnabled2,
  shouldEnableBindingForPointerEvent,
  updateBoundElements as updateBoundElements3,
  LinearElementEditor as LinearElementEditor11,
  newElementWith as newElementWith11,
  newFrameElement as newFrameElement2,
  newFreeDrawElement,
  newEmbeddableElement,
  newMagicFrameElement,
  newIframeElement,
  newArrowElement as newArrowElement2,
  newElement as newElement4,
  newImageElement,
  newLinearElement as newLinearElement3,
  newTextElement as newTextElement3,
  refreshTextDimensions,
  deepCopyElement as deepCopyElement4,
  duplicateElements as duplicateElements3,
  hasBoundTextElement as hasBoundTextElement7,
  isArrowElement as isArrowElement12,
  isBindingElement as isBindingElement3,
  isBindingElementType,
  isBoundToContainer as isBoundToContainer9,
  isFrameLikeElement as isFrameLikeElement12,
  isImageElement as isImageElement6,
  isEmbeddableElement as isEmbeddableElement4,
  isInitializedImageElement as isInitializedImageElement3,
  isLinearElement as isLinearElement12,
  isLinearElementType as isLinearElementType2,
  isUsingAdaptiveRadius as isUsingAdaptiveRadius4,
  isIframeElement as isIframeElement2,
  isIframeLikeElement as isIframeLikeElement2,
  isMagicFrameElement as isMagicFrameElement2,
  isTextBindableContainer as isTextBindableContainer3,
  isElbowArrow as isElbowArrow9,
  isFlowchartNodeElement as isFlowchartNodeElement2,
  isBindableElement as isBindableElement3,
  isTextElement as isTextElement16,
  getNormalizedDimensions,
  isElementCompletelyInViewport as isElementCompletelyInViewport2,
  isElementInViewport as isElementInViewport3,
  isInvisiblySmallElement as isInvisiblySmallElement3,
  getCornerRadius as getCornerRadius2,
  isPathALoop as isPathALoop4,
  createSrcDoc,
  embeddableURLValidator as embeddableURLValidator2,
  maybeParseEmbedSrc,
  getEmbedLink as getEmbedLink2,
  getInitializedImageElements,
  normalizeSVG,
  updateImageCache as _updateImageCache,
  getBoundTextElement as getBoundTextElement9,
  getContainerCenter,
  getContainerElement as getContainerElement7,
  isValidTextContainer,
  redrawTextBoundingBox as redrawTextBoundingBox6,
  hasBoundingBox as hasBoundingBox2,
  getFrameChildren as getFrameChildren5,
  isCursorInFrame,
  addElementsToFrame as addElementsToFrame2,
  replaceAllElementsInFrame as replaceAllElementsInFrame2,
  removeElementsFromFrame as removeElementsFromFrame2,
  getElementsInResizingFrame as getElementsInResizingFrame2,
  getElementsInNewFrame,
  getContainingFrame as getContainingFrame3,
  elementOverlapsWithFrame as elementOverlapsWithFrame2,
  updateFrameMembershipOfSelectedElements as updateFrameMembershipOfSelectedElements4,
  isElementInFrame,
  getFrameLikeTitle,
  getElementsOverlappingFrame as getElementsOverlappingFrame2,
  filterElementsEligibleAsFrameChildren,
  hitElementBoundText,
  hitElementBoundingBoxOnly,
  hitElementItself as hitElementItself3,
  getVisibleSceneBounds,
  FlowChartCreator,
  FlowChartNavigator,
  getLinkDirectionFromKey,
  cropElement,
  wrapText as wrapText4,
  isElementLink as isElementLink2,
  parseElementLinkFromURL,
  isMeasureTextSupported,
  normalizeText as normalizeText2,
  measureText as measureText6,
  getLineHeightInPx as getLineHeightInPx3,
  getApproxMinLineWidth,
  getApproxMinLineHeight,
  getMinTextElementWidth,
  ShapeCache as ShapeCache4,
  getRenderOpacity,
  editGroupForSelectedElement,
  getElementsInGroup as getElementsInGroup8,
  getSelectedGroupIdForElement,
  getSelectedGroupIds as getSelectedGroupIds3,
  isElementInGroup as isElementInGroup2,
  isSelectedViaGroup as isSelectedViaGroup2,
  selectGroupsForSelectedElements as selectGroupsForSelectedElements6,
  syncInvalidIndices,
  syncMovedIndices as syncMovedIndices4,
  excludeElementsInFramesFromSelection,
  getSelectionStateForElements as getSelectionStateForElements2,
  makeNextSelectedElementIds as makeNextSelectedElementIds2,
  getResizeOffsetXY,
  getResizeArrowDirection,
  transformElements,
  getCursorForResizingElement,
  getElementWithTransformHandleType,
  getTransformHandleTypeFromCoords,
  dragNewElement,
  dragSelectedElements,
  getDragOffsetXY,
  isNonDeletedElement,
  Scene,
  Store,
  CaptureUpdateAction as CaptureUpdateAction36,
  hitElementBoundingBox as hitElementBoundingBox2,
  isLineElement as isLineElement8,
  isSimpleArrow,
  StoreDelta as StoreDelta2,
  positionElementsOnGrid,
  calculateFixedPointForNonElbowArrowBinding as calculateFixedPointForNonElbowArrowBinding2,
  bindOrUnbindBindingElement as bindOrUnbindBindingElement2,
  mutateElement as mutateElement6,
  getElementBounds as getElementBounds5,
  doBoundsIntersect as doBoundsIntersect4,
  isPointInElement as isPointInElement3,
  maxBindingDistance_simple as maxBindingDistance_simple2,
  convertToExcalidrawElements as convertToExcalidrawElements2,
  getSnapOutlineMidPoint as getSnapOutlineMidPoint2,
  handleFocusPointDrag,
  handleFocusPointHover,
  handleFocusPointPointerDown,
  handleFocusPointPointerUp,
  maybeHandleArrowPointlikeDrag,
  getUncroppedWidthAndHeight
} from "@excalidraw/element";

// actions/actionDeleteSelected.tsx
import {
  KEYS,
  MOBILE_ACTION_BUTTON_BG,
  updateActiveTool
} from "@excalidraw/common";
import { getNonDeletedElements } from "@excalidraw/element";
import { fixBindingsAfterDeletion } from "@excalidraw/element";
import { LinearElementEditor } from "@excalidraw/element";
import { newElementWith } from "@excalidraw/element";
import { getContainerElement } from "@excalidraw/element";
import {
  isBoundToContainer,
  isElbowArrow,
  isFrameLikeElement
} from "@excalidraw/element";
import { getFrameChildren } from "@excalidraw/element";
import {
  getElementsInGroup,
  selectGroupsForSelectedElements
} from "@excalidraw/element";
import { CaptureUpdateAction } from "@excalidraw/element";

// i18n.ts
import { isDevEnv } from "@excalidraw/common";

// editor-jotai.ts
import {
  atom,
  createStore
} from "jotai";
import { createIsolation } from "jotai-scope";
var jotai = createIsolation();
var { useAtom, useSetAtom, useAtomValue, useStore } = jotai;
var EditorJotaiProvider = jotai.Provider;
var editorJotaiStore = createStore();

// import("./locales/**/*.json") in i18n.ts
var globImport_locales_json = __glob({
  "./locales/ar-SA.json": () => import("./locales/ar-SA-AGVJN2FU.js"),
  "./locales/az-AZ.json": () => import("./locales/az-AZ-62IXPX5D.js"),
  "./locales/bg-BG.json": () => import("./locales/bg-BG-UBDZF4KA.js"),
  "./locales/bn-BD.json": () => import("./locales/bn-BD-4TAUVZOD.js"),
  "./locales/bn-IN.json": () => import("./locales/bn-IN-PUGL2LDE.js"),
  "./locales/ca-ES.json": () => import("./locales/ca-ES-GEEW5L7T.js"),
  "./locales/cs-CZ.json": () => import("./locales/cs-CZ-LNVE3QM5.js"),
  "./locales/da-DK.json": () => import("./locales/da-DK-CAYJG7FJ.js"),
  "./locales/de-CH.json": () => import("./locales/de-CH-GCXOD4LK.js"),
  "./locales/de-DE.json": () => import("./locales/de-DE-CGDBECYD.js"),
  "./locales/el-GR.json": () => import("./locales/el-GR-G5QZC24A.js"),
  "./locales/en.json": () => import("./locales/en-52S2TQZX.js"),
  "./locales/es-ES.json": () => import("./locales/es-ES-UMEOH76W.js"),
  "./locales/eu-ES.json": () => import("./locales/eu-ES-IWRZXJC5.js"),
  "./locales/fa-IR.json": () => import("./locales/fa-IR-QOYVIIJA.js"),
  "./locales/fi-FI.json": () => import("./locales/fi-FI-BXRW65OA.js"),
  "./locales/fr-FR.json": () => import("./locales/fr-FR-R2QH5VCW.js"),
  "./locales/gl-ES.json": () => import("./locales/gl-ES-4ES3ZADP.js"),
  "./locales/he-IL.json": () => import("./locales/he-IL-TRQRRYPH.js"),
  "./locales/hi-IN.json": () => import("./locales/hi-IN-U46BOJEC.js"),
  "./locales/hu-HU.json": () => import("./locales/hu-HU-JDULJ6XL.js"),
  "./locales/id-ID.json": () => import("./locales/id-ID-BLIXNCUT.js"),
  "./locales/it-IT.json": () => import("./locales/it-IT-6TBW7RUK.js"),
  "./locales/ja-JP.json": () => import("./locales/ja-JP-6HYAQFYX.js"),
  "./locales/kaa.json": () => import("./locales/kaa-Z5UP62XJ.js"),
  "./locales/kab-KAB.json": () => import("./locales/kab-KAB-Z7STWQKS.js"),
  "./locales/kk-KZ.json": () => import("./locales/kk-KZ-BWHY45DX.js"),
  "./locales/km-KH.json": () => import("./locales/km-KH-HGLNWNRU.js"),
  "./locales/ko-KR.json": () => import("./locales/ko-KR-CO36WKPC.js"),
  "./locales/ku-TR.json": () => import("./locales/ku-TR-AACVIARC.js"),
  "./locales/lt-LT.json": () => import("./locales/lt-LT-CFYYFLDV.js"),
  "./locales/lv-LV.json": () => import("./locales/lv-LV-QCBBOFFU.js"),
  "./locales/mr-IN.json": () => import("./locales/mr-IN-B2CM5GK5.js"),
  "./locales/my-MM.json": () => import("./locales/my-MM-756BNN36.js"),
  "./locales/nb-NO.json": () => import("./locales/nb-NO-5BLHQI4J.js"),
  "./locales/nl-NL.json": () => import("./locales/nl-NL-225BLGAH.js"),
  "./locales/nn-NO.json": () => import("./locales/nn-NO-4J7MR6GH.js"),
  "./locales/oc-FR.json": () => import("./locales/oc-FR-XCETH7KF.js"),
  "./locales/pa-IN.json": () => import("./locales/pa-IN-32NBAN5L.js"),
  "./locales/percentages.json": () => import("./locales/percentages-ZRLRVMSI.js"),
  "./locales/pl-PL.json": () => import("./locales/pl-PL-R6OJ54BT.js"),
  "./locales/pt-BR.json": () => import("./locales/pt-BR-7AFGAKGR.js"),
  "./locales/pt-PT.json": () => import("./locales/pt-PT-S6BMW6MY.js"),
  "./locales/ro-RO.json": () => import("./locales/ro-RO-4JVGQHS2.js"),
  "./locales/ru-RU.json": () => import("./locales/ru-RU-IESI752T.js"),
  "./locales/si-LK.json": () => import("./locales/si-LK-H75E7PKD.js"),
  "./locales/sk-SK.json": () => import("./locales/sk-SK-EUK2NR2F.js"),
  "./locales/sl-SI.json": () => import("./locales/sl-SI-AKW7R5PW.js"),
  "./locales/sv-SE.json": () => import("./locales/sv-SE-QIBOOXLJ.js"),
  "./locales/ta-IN.json": () => import("./locales/ta-IN-LBK2NQ5K.js"),
  "./locales/th-TH.json": () => import("./locales/th-TH-YJ2E6GVT.js"),
  "./locales/tr-TR.json": () => import("./locales/tr-TR-Y5GO2XJW.js"),
  "./locales/uk-UA.json": () => import("./locales/uk-UA-XYAFHHJW.js"),
  "./locales/uz-UZ.json": () => import("./locales/uz-UZ-LF3CBRYE.js"),
  "./locales/vi-VN.json": () => import("./locales/vi-VN-WDPZEUOJ.js"),
  "./locales/zh-CN.json": () => import("./locales/zh-CN-SZ37453H.js"),
  "./locales/zh-HK.json": () => import("./locales/zh-HK-QDQ5QNBC.js"),
  "./locales/zh-TW.json": () => import("./locales/zh-TW-CYU6GFBV.js")
});

// i18n.ts
var COMPLETION_THRESHOLD = 85;
var defaultLang = { code: "en", label: "English" };
var languages = [
  defaultLang,
  ...[
    { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: true },
    { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
    { code: "ca-ES", label: "Catal\xE0" },
    { code: "cs-CZ", label: "\u010Cesky" },
    { code: "de-DE", label: "Deutsch" },
    { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
    { code: "es-ES", label: "Espa\xF1ol" },
    { code: "eu-ES", label: "Euskara" },
    { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: true },
    { code: "fi-FI", label: "Suomi" },
    { code: "fr-FR", label: "Fran\xE7ais" },
    { code: "gl-ES", label: "Galego" },
    { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: true },
    { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { code: "hu-HU", label: "Magyar" },
    { code: "id-ID", label: "Bahasa Indonesia" },
    { code: "it-IT", label: "Italiano" },
    { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
    { code: "kab-KAB", label: "Taqbaylit" },
    { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
    { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
    { code: "ku-TR", label: "Kurd\xEE" },
    { code: "lt-LT", label: "Lietuvi\u0173" },
    { code: "lv-LV", label: "Latvie\u0161u" },
    { code: "my-MM", label: "Burmese" },
    { code: "nb-NO", label: "Norsk bokm\xE5l" },
    { code: "nl-NL", label: "Nederlands" },
    { code: "nn-NO", label: "Norsk nynorsk" },
    { code: "oc-FR", label: "Occitan" },
    { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
    { code: "pl-PL", label: "Polski" },
    { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
    { code: "pt-PT", label: "Portugu\xEAs" },
    { code: "ro-RO", label: "Rom\xE2n\u0103" },
    { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "sk-SK", label: "Sloven\u010Dina" },
    { code: "sv-SE", label: "Svenska" },
    { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
    { code: "tr-TR", label: "T\xFCrk\xE7e" },
    { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
    { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
    { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
    { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
    { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" }
  ].filter(
    (lang) => percentages_default[lang.code] >= COMPLETION_THRESHOLD
  ).sort((left, right) => left.label > right.label ? 1 : -1)
];
var TEST_LANG_CODE = "__test__";
if (isDevEnv()) {
  languages.unshift(
    { code: TEST_LANG_CODE, label: "test language" },
    {
      code: `${TEST_LANG_CODE}.rtl`,
      label: "\u202Atest language (rtl)\u202C",
      rtl: true
    }
  );
}
var currentLang = defaultLang;
var currentLangData = {};
var setLanguage = async (lang) => {
  currentLang = lang;
  document.documentElement.dir = currentLang.rtl ? "rtl" : "ltr";
  document.documentElement.lang = currentLang.code;
  if (lang.code.startsWith(TEST_LANG_CODE)) {
    currentLangData = {};
  } else {
    try {
      currentLangData = await globImport_locales_json(`./locales/${currentLang.code}.json`);
    } catch (error) {
      console.error(`Failed to load language ${lang.code}:`, error.message);
      currentLangData = en_default;
    }
  }
  editorJotaiStore.set(editorLangCodeAtom, lang.code);
};
var getLanguage = () => currentLang;
var findPartsForData = (data, parts) => {
  for (let index = 0; index < parts.length; ++index) {
    const part = parts[index];
    if (data[part] === void 0) {
      return void 0;
    }
    data = data[part];
  }
  if (typeof data !== "string") {
    return void 0;
  }
  return data;
};
var t = (path, replacement, fallback) => {
  if (currentLang.code.startsWith(TEST_LANG_CODE)) {
    const name = replacement ? `${path}(${JSON.stringify(replacement).slice(1, -1)})` : path;
    return `\u202A[[${name}]]\u202C`;
  }
  const parts = path.split(".");
  let translation = findPartsForData(currentLangData, parts) || findPartsForData(en_default, parts) || fallback;
  if (translation === void 0) {
    const errorMessage = `Can't find translation for ${path}`;
    if (define_import_meta_env_default.PROD) {
      console.warn(errorMessage);
      return "";
    }
    throw new Error(errorMessage);
  }
  if (replacement) {
    for (const key in replacement) {
      translation = translation.replace(`{{${key}}}`, String(replacement[key]));
    }
  }
  return translation;
};
var editorLangCodeAtom = atom(defaultLang.code);
var useI18n = () => {
  const langCode = useAtomValue(editorLangCodeAtom);
  return { t, langCode };
};

// components/icons.tsx
import clsx from "clsx";
import React from "react";
import { THEME } from "@excalidraw/common";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var iconFillColor = (theme) => "var(--icon-fill-color)";
var handlerColor = (theme) => theme === THEME.LIGHT ? "#fff" : "#1e1e1e";
var createIcon = (d, opts = 512) => {
  const {
    width = 512,
    height = width,
    mirror,
    style,
    ...rest
  } = typeof opts === "number" ? { width: opts } : opts;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "aria-hidden": "true",
      focusable: "false",
      role: "img",
      viewBox: `0 0 ${width} ${height}`,
      className: clsx({ "rtl-mirror": mirror }),
      style,
      ...rest,
      children: typeof d === "string" ? /* @__PURE__ */ jsx("path", { fill: "currentColor", d }) : d
    }
  );
};
var tablerIconProps = {
  width: 24,
  height: 24,
  fill: "none",
  strokeWidth: 2,
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var modifiedTablerIconProps = {
  width: 20,
  height: 20,
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var PlusPromoIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }),
    /* @__PURE__ */ jsx("line", { x1: 12, y1: 8, x2: 12, y2: 21 }),
    /* @__PURE__ */ jsx("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }),
    /* @__PURE__ */ jsx("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })
  ] }),
  tablerIconProps
);
var LibraryIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
    /* @__PURE__ */ jsx("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
    /* @__PURE__ */ jsx("line", { x1: "3", y1: "6", x2: "3", y2: "19" }),
    /* @__PURE__ */ jsx("line", { x1: "12", y1: "6", x2: "12", y2: "19" }),
    /* @__PURE__ */ jsx("line", { x1: "21", y1: "6", x2: "21", y2: "19" })
  ] }),
  tablerIconProps
);
var PlusIcon = createIcon(
  /* @__PURE__ */ jsxs("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
    /* @__PURE__ */ jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
  ] }),
  tablerIconProps
);
var DotsIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "12", r: "1" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "19", r: "1" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "5", r: "1" })
  ] }),
  tablerIconProps
);
var DotsHorizontalIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }),
    /* @__PURE__ */ jsx("path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" })
  ] }),
  tablerIconProps
);
var PinIcon = createIcon(
  /* @__PURE__ */ jsxs("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }),
    /* @__PURE__ */ jsx("line", { x1: "12", y1: "16", x2: "12", y2: "21" }),
    /* @__PURE__ */ jsx("line", { x1: "8", y1: "4", x2: "16", y2: "4" })
  ] }),
  tablerIconProps
);
var polygonIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M12 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 8m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M5 11m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M15 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M6.5 9.5l3.5 -3" }),
    /* @__PURE__ */ jsx("path", { d: "M14 5.5l3 1.5" }),
    /* @__PURE__ */ jsx("path", { d: "M18.5 10l-2.5 7" }),
    /* @__PURE__ */ jsx("path", { d: "M13.5 17.5l-7 -5" })
  ] }),
  tablerIconProps
);
var UnlockedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ jsx(
      "mask",
      {
        id: "UnlockedIcon",
        style: { maskType: "alpha" },
        maskUnits: "userSpaceOnUse",
        x: 6,
        y: 1,
        width: 9,
        height: 9,
        children: /* @__PURE__ */ jsx(
          "path",
          {
            stroke: "none",
            d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481",
            fill: "#fff"
          }
        )
      }
    ),
    /* @__PURE__ */ jsx("g", { mask: "url(#UnlockedIcon)", children: /* @__PURE__ */ jsx(
      "path",
      {
        stroke: "none",
        d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z",
        fill: "currentColor"
      }
    ) })
  ] }),
  modifiedTablerIconProps
);
var LockedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }),
    /* @__PURE__ */ jsx("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }),
    /* @__PURE__ */ jsx("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })
  ] }),
  modifiedTablerIconProps
);
var LockedIconFilled = createIcon(
  /* @__PURE__ */ jsx("g", { fill: "currentColor", children: /* @__PURE__ */ jsx("path", { d: "M12 2a5 5 0 0 1 5 5v3a3 3 0 0 1 3 3v6a3 3 0 0 1 -3 3h-10a3 3 0 0 1 -3 -3v-6a3 3 0 0 1 3 -3v-3a5 5 0 0 1 5 -5m0 12a2 2 0 0 0 -1.995 1.85l-.005 .15a2 2 0 1 0 2 -2m0 -10a3 3 0 0 0 -3 3v3h6v-3a3 3 0 0 0 -3 -3" }) }),
  {
    width: 24,
    height: 24
  }
);
var WelcomeScreenMenuArrow = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 41, height: 94, fill: "none" }
);
var WelcomeScreenHelpArrow = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 85, height: 71, fill: "none" }
);
var WelcomeScreenTopToolbarArrow = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z",
        fill: "currentColor"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round"
      }
    )
  ] }),
  { width: 38, height: 78, fill: "none" }
);
var ExcalLogo = createIcon(
  /* @__PURE__ */ jsx("g", { fill: "currentColor", children: /* @__PURE__ */ jsx(
    "path",
    {
      d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
      fill: "currentColor"
    }
  ) }),
  { width: 40, height: 40, fill: "none" }
);
var SelectionIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }),
    /* @__PURE__ */ jsx("path", { d: "M13.5 13.5l4.5 4.5" })
  ] }),
  { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
);
var LassoIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 1.5,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M4.028 13.252c-.657 -.972 -1.028 -2.078 -1.028 -3.252c0 -3.866 4.03 -7 9 -7s9 3.134 9 7s-4.03 7 -9 7c-1.913 0 -3.686 -.464 -5.144 -1.255" }),
        /* @__PURE__ */ jsx("path", { d: "M5 15m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        /* @__PURE__ */ jsx("path", { d: "M5 17c0 1.42 .316 2.805 1 4" })
      ]
    }
  ),
  { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
);
var RectangleIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })
  ] }),
  tablerIconProps
);
var DiamondIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })
  ] }),
  tablerIconProps
);
var EllipseIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "12", r: "9" })
  ] }),
  tablerIconProps
);
var StickyNoteIconSvg = () => {
  const id = React.useId().replace(/:/g, "");
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      className: "ToolIcon__sticky-note-icon",
      width: "28",
      height: "27",
      viewBox: "0 0 28 27",
      fill: "none",
      "aria-hidden": "true",
      focusable: "false",
      role: "img",
      children: [
        /* @__PURE__ */ jsx("g", { filter: `url(#filter0_d_${id})`, children: /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.30283 2L23.9728 4.80284L21.1699 23.4728L18.328 23.0461L2.49999 20.6699L5.30283 2Z",
            fill: "#F6D773"
          }
        ) }),
        /* @__PURE__ */ jsx("g", { filter: `url(#filter1_d_${id})`, children: /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.56042 5.80286H26.4396V24.682H23.5658H7.56042V5.80286Z",
            fill: "#F6E073"
          }
        ) }),
        /* @__PURE__ */ jsxs("defs", { children: [
          /* @__PURE__ */ jsxs(
            "filter",
            {
              id: `filter0_d_${id}`,
              x: "0",
              y: "0",
              width: "25.4727",
              height: "25.4728",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                /* @__PURE__ */ jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                /* @__PURE__ */ jsx(
                  "feColorMatrix",
                  {
                    in: "SourceAlpha",
                    type: "matrix",
                    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",
                    result: "hardAlpha"
                  }
                ),
                /* @__PURE__ */ jsx("feOffset", { dx: "-0.5" }),
                /* @__PURE__ */ jsx("feGaussianBlur", { stdDeviation: "1" }),
                /* @__PURE__ */ jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
                /* @__PURE__ */ jsx(
                  "feColorMatrix",
                  {
                    type: "matrix",
                    values: "0 0 0 0 0.438796 0 0 0 0 0.366822 0 0 0 0 0.278854 0 0 0 0.6 0"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in2: "BackgroundImageFix",
                    result: "effect1_dropShadow_1915_217"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in: "SourceGraphic",
                    in2: "effect1_dropShadow_1915_217",
                    result: "shape"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxs(
            "filter",
            {
              id: `filter1_d_${id}`,
              x: "5.06042",
              y: "3.80286",
              width: "22.8792",
              height: "22.8792",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                /* @__PURE__ */ jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                /* @__PURE__ */ jsx(
                  "feColorMatrix",
                  {
                    in: "SourceAlpha",
                    type: "matrix",
                    values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",
                    result: "hardAlpha"
                  }
                ),
                /* @__PURE__ */ jsx("feOffset", { dx: "-0.5" }),
                /* @__PURE__ */ jsx("feGaussianBlur", { stdDeviation: "1" }),
                /* @__PURE__ */ jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
                /* @__PURE__ */ jsx(
                  "feColorMatrix",
                  {
                    type: "matrix",
                    values: "0 0 0 0 0.52956 0 0 0 0 0.407321 0 0 0 0 0.257918 0 0 0 0.6 0"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in2: "BackgroundImageFix",
                    result: "effect1_dropShadow_1915_217"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in: "SourceGraphic",
                    in2: "effect1_dropShadow_1915_217",
                    result: "shape"
                  }
                )
              ]
            }
          )
        ] })
      ]
    }
  );
};
var StickyNoteIcon = /* @__PURE__ */ jsx(StickyNoteIconSvg, {});
var ArrowIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
    /* @__PURE__ */ jsx("line", { x1: "15", y1: "16", x2: "19", y2: "12" }),
    /* @__PURE__ */ jsx("line", { x1: "15", y1: "8", x2: "19", y2: "12" })
  ] }),
  tablerIconProps
);
var LineIcon = createIcon(
  /* @__PURE__ */ jsx("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }),
  modifiedTablerIconProps
);
var PenModeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }),
    /* @__PURE__ */ jsx("path", { d: "M16 7h4" }),
    /* @__PURE__ */ jsx("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })
  ] }),
  tablerIconProps
);
var FreedrawIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        clipRule: "evenodd",
        d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z"
      }
    ),
    /* @__PURE__ */ jsx("path", { d: "m11.25 5.417 3.333 3.333" })
  ] }),
  modifiedTablerIconProps
);
var TextIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("line", { x1: "4", y1: "20", x2: "7", y2: "20" }),
    /* @__PURE__ */ jsx("line", { x1: "14", y1: "20", x2: "21", y2: "20" }),
    /* @__PURE__ */ jsx("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }),
    /* @__PURE__ */ jsx("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }),
    /* @__PURE__ */ jsx("polyline", { points: "5 20 11 4 13 4 20 20" })
  ] }),
  tablerIconProps
);
var TextSizeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 7v-2h13v2" }),
    /* @__PURE__ */ jsx("path", { d: "M10 5v14" }),
    /* @__PURE__ */ jsx("path", { d: "M12 19h-4" }),
    /* @__PURE__ */ jsx("path", { d: "M15 13v-1h6v1" }),
    /* @__PURE__ */ jsx("path", { d: "M18 12v7" }),
    /* @__PURE__ */ jsx("path", { d: "M17 19h2" })
  ] }),
  tablerIconProps
);
var ImageIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M12.5 6.667h.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }),
    /* @__PURE__ */ jsx("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }),
    /* @__PURE__ */ jsx("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })
  ] }),
  modifiedTablerIconProps
);
var EraserIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }),
    /* @__PURE__ */ jsx("path", { d: "M18 13.3l-6.3 -6.3" })
  ] }),
  tablerIconProps
);
var ZoomInIcon = createIcon(
  /* @__PURE__ */ jsx("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }),
  modifiedTablerIconProps
);
var ZoomOutIcon = createIcon(
  /* @__PURE__ */ jsx("path", { d: "M5 10h10", strokeWidth: "1.25" }),
  modifiedTablerIconProps
);
var ZoomResetIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M21 21l-6 -6" }),
    /* @__PURE__ */ jsx("path", { d: "M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403" }),
    /* @__PURE__ */ jsx("path", { d: "M3 4v4h4" })
  ] }),
  tablerIconProps
);
var TrashIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      strokeWidth: "1.25",
      d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5"
    }
  ),
  modifiedTablerIconProps
);
var EmbedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("polyline", { points: "12 16 18 10 12 4" }),
    /* @__PURE__ */ jsx("polyline", { points: "8 4 2 10 8 16" })
  ] }),
  modifiedTablerIconProps
);
var DuplicateIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }),
    /* @__PURE__ */ jsx(
      "path",
      {
        clipRule: "evenodd",
        d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z"
      }
    )
  ] }),
  modifiedTablerIconProps
);
var MoonIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      clipRule: "evenodd",
      d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z",
      stroke: "currentColor"
    }
  ),
  modifiedTablerIconProps
);
var SunIcon = createIcon(
  /* @__PURE__ */ jsx("g", { stroke: "currentColor", strokeLinejoin: "round", children: /* @__PURE__ */ jsx("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" }) }),
  { ...modifiedTablerIconProps, strokeWidth: 1.5 }
);
var HamburgerMenuIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("line", { x1: "4", y1: "6", x2: "20", y2: "6" }),
    /* @__PURE__ */ jsx("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
    /* @__PURE__ */ jsx("line", { x1: "4", y1: "18", x2: "20", y2: "18" })
  ] }),
  tablerIconProps
);
var ExportIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      strokeWidth: "1.25",
      d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10"
    }
  ),
  modifiedTablerIconProps
);
var HelpIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "12", r: "9" }),
    /* @__PURE__ */ jsx("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
  ] }),
  tablerIconProps
);
var HelpIconThin = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("circle", { cx: "12", cy: "12", r: "9" }),
    /* @__PURE__ */ jsx("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
  ] }),
  tablerIconProps
);
var ExternalLinkIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      strokeWidth: "1.25",
      d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5"
    }
  ),
  modifiedTablerIconProps
);
var GithubIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var DiscordIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }),
    /* @__PURE__ */ jsx("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })
  ] }),
  modifiedTablerIconProps
);
var XBrandIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }),
    /* @__PURE__ */ jsx("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })
  ] }),
  tablerIconProps
);
var checkIcon = createIcon(
  /* @__PURE__ */ jsx("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }),
  {
    width: 24,
    height: 24
  }
);
var LinkIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }),
    /* @__PURE__ */ jsx("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })
  ] }),
  modifiedTablerIconProps
);
var save = createIcon(
  "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
  { width: 448, height: 512 }
);
var saveAs = createIcon(
  "M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z",
  { width: 448, height: 512 }
);
var LoadIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var clipboard = createIcon(
  "M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z",
  { width: 384, height: 512 }
);
var palette = createIcon(
  "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"
);
var bucketFillIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z" }),
    /* @__PURE__ */ jsx("path", { d: "M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z" }),
    /* @__PURE__ */ jsx("path", { d: "M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208" })
  ] }),
  tablerIconProps
);
var slashIcon = createIcon(
  /* @__PURE__ */ jsx("g", { strokeWidth: 1.5, children: /* @__PURE__ */ jsx("path", { d: "M6 18l12 -12" }) }),
  tablerIconProps
);
var ExportImageIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M15 8h.01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }),
    /* @__PURE__ */ jsx("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }),
    /* @__PURE__ */ jsx("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }),
    /* @__PURE__ */ jsx("path", { d: "M19 16v6" }),
    /* @__PURE__ */ jsx("path", { d: "M22 19l-3 3l-3 -3" })
  ] }),
  tablerIconProps
);
var exportToFileIcon = createIcon(
  "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z",
  { width: 512, height: 512 }
);
var zoomIn = createIcon(
  "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  { width: 448, height: 512 }
);
var zoomOut = createIcon(
  "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
  { width: 448, height: 512 }
);
var done = createIcon(
  "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
);
var menu = createIcon(
  "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
);
var UndoIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var RedoIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var questionCircle = createIcon(
  "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
  { mirror: true }
);
var share = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834",
      strokeWidth: "1.5"
    }
  ),
  modifiedTablerIconProps
);
var warning = createIcon(
  "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"
);
var shareIOS = createIcon(
  "M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z",
  { width: 24, height: 24 }
);
var exportToPlus = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1" }),
    /* @__PURE__ */ jsx("path", { d: "M12 14v-11" }),
    /* @__PURE__ */ jsx("path", { d: "M9 6l3 -3l3 3" })
  ] }),
  tablerIconProps
);
var shareWindows = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        fill: "currentColor",
        d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        stroke: "currentColor",
        fill: "currentColor",
        d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z"
      }
    )
  ] }),
  { width: 64, height: 64 }
);
var resetZoom = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      stroke: "currentColor",
      strokeWidth: "40",
      fill: "currentColor",
      d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z"
    }
  ),
  { width: 1024 }
);
var arrowBarToTopJSX = /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
  /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
  /* @__PURE__ */ jsx("path", { d: "M12 10l0 10" }),
  /* @__PURE__ */ jsx("path", { d: "M12 10l4 4" }),
  /* @__PURE__ */ jsx("path", { d: "M12 10l-4 4" }),
  /* @__PURE__ */ jsx("path", { d: "M4 4l16 0" })
] });
var arrownNarrowUpJSX = /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
  /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
  /* @__PURE__ */ jsx("path", { d: "M12 5l0 14" }),
  /* @__PURE__ */ jsx("path", { d: "M16 9l-4 -4" }),
  /* @__PURE__ */ jsx("path", { d: "M8 9l4 -4" })
] });
var BringForwardIcon = createIcon(arrownNarrowUpJSX, tablerIconProps);
var SendBackwardIcon = createIcon(arrownNarrowUpJSX, {
  ...tablerIconProps,
  style: {
    transform: "rotate(180deg)"
  }
});
var BringToFrontIcon = createIcon(arrowBarToTopJSX, tablerIconProps);
var SendToBackIcon = createIcon(arrowBarToTopJSX, {
  ...tablerIconProps,
  style: {
    transform: "rotate(180deg)"
  }
});
var AlignTopIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.333 3.333h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignBottomIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.333 16.667h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignLeftIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.333 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var AlignRightIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M16.667 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var DistributeHorizontallyIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M16.667 3.333v13.334M3.333 3.333v13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var DistributeVerticallyIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.333 3.333h13.334M3.333 16.667h13.334",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var CenterVerticallyIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })
  ] }),
  modifiedTablerIconProps
);
var CenterHorizontallyIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsx("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })
  ] }),
  modifiedTablerIconProps
);
var usersIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("circle", { cx: "9", cy: "7", r: "4" }),
    /* @__PURE__ */ jsx("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }),
    /* @__PURE__ */ jsx("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
    /* @__PURE__ */ jsx("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })
  ] }),
  tablerIconProps
);
var start = createIcon(
  "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z"
);
var stop = createIcon(
  "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z"
);
var CloseIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "g",
      {
        clipPath: "url(#a)",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: /* @__PURE__ */ jsx("path", { d: "M15 5 5 15M5 5l10 10" })
      }
    ),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var clone = createIcon(
  "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z",
  { mirror: true }
);
var shield = createIcon(
  "M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z",
  { width: 24 }
);
var file = createIcon(
  "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z",
  { width: 384, height: 512 }
);
var GroupIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ jsxs(
        "g",
        {
          fill: handlerColor(theme),
          stroke: iconFillColor(theme),
          strokeWidth: "6",
          children: [
            /* @__PURE__ */ jsx("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })
          ]
        }
      )
    ] }),
    { width: 182, height: 182, mirror: true }
  )
);
var UngroupIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ jsx("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
          stroke: iconFillColor(theme),
          strokeWidth: "2"
        }
      ),
      /* @__PURE__ */ jsxs(
        "g",
        {
          fill: handlerColor(theme),
          stroke: iconFillColor(theme),
          strokeWidth: "6",
          children: [
            /* @__PURE__ */ jsx("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }),
            /* @__PURE__ */ jsx("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })
          ]
        }
      )
    ] }),
    { width: 182, height: 182, mirror: true }
  )
);
var FillZigZagIcon = createIcon(
  /* @__PURE__ */ jsx("g", { strokeWidth: 1.25, children: /* @__PURE__ */ jsx("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }),
  modifiedTablerIconProps
);
var FillHachureIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ),
    /* @__PURE__ */ jsx(
      "mask",
      {
        id: "FillHachureIcon",
        style: { maskType: "alpha" },
        maskUnits: "userSpaceOnUse",
        x: 2,
        y: 2,
        width: 16,
        height: 16,
        children: /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        )
      }
    ),
    /* @__PURE__ */ jsx("g", { mask: "url(#FillHachureIcon)", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) })
  ] }),
  modifiedTablerIconProps
);
var FillCrossHatchIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("g", { clipPath: "url(#a)", children: [
      /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
          stroke: "currentColor",
          strokeWidth: "1.25"
        }
      ),
      /* @__PURE__ */ jsx(
        "mask",
        {
          id: "FillCrossHatchIcon",
          style: { maskType: "alpha" },
          maskUnits: "userSpaceOnUse",
          x: -1,
          y: -1,
          width: 22,
          height: 22,
          children: /* @__PURE__ */ jsx(
            "path",
            {
              d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745",
              stroke: "currentColor",
              strokeWidth: "1.25",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        }
      ),
      /* @__PURE__ */ jsx("g", { mask: "url(#FillCrossHatchIcon)", children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z",
          fill: "currentColor"
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FillSolidIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
        stroke: "currentColor",
        strokeWidth: "1.25"
      }
    ) }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  { ...modifiedTablerIconProps, fill: "currentColor" }
);
var StrokeWidthBaseIcon = createIcon(
  /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
    "path",
    {
      d: "M4.167 10h11.666",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) }),
  modifiedTablerIconProps
);
var StrokeWidthBoldIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "2.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  modifiedTablerIconProps
);
var StrokeWidthExtraBoldIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "3.75",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ),
  modifiedTablerIconProps
);
var StrokeStyleSolidIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M6 10H34",
        stroke: iconFillColor(theme),
        strokeWidth: 2,
        fill: "none",
        strokeLinecap: "round"
      }
    ),
    {
      width: 40,
      height: 20
    }
  )
);
var StrokeStyleDashedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "2", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 12h2" }),
    /* @__PURE__ */ jsx("path", { d: "M17 12h2" }),
    /* @__PURE__ */ jsx("path", { d: "M11 12h2" })
  ] }),
  tablerIconProps
);
var StrokeStyleDottedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "2", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M8 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M16 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 12v.01" })
  ] }),
  tablerIconProps
);
var SloppinessArchitectIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var SloppinessArtistIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var SloppinessCartoonistIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42",
      strokeWidth: "1.25"
    }
  ),
  modifiedTablerIconProps
);
var EdgeSharpIcon = createIcon(
  /* @__PURE__ */ jsxs("svg", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }),
    /* @__PURE__ */ jsx("path", { d: "M13.3333 3.33331V3.34331" }),
    /* @__PURE__ */ jsx("path", { d: "M16.6667 3.33331V3.34331" }),
    /* @__PURE__ */ jsx("path", { d: "M16.6667 6.66669V6.67669" }),
    /* @__PURE__ */ jsx("path", { d: "M16.6667 10V10.01" }),
    /* @__PURE__ */ jsx("path", { d: "M3.33334 13.3333V13.3433" }),
    /* @__PURE__ */ jsx("path", { d: "M16.6667 13.3333V13.3433" }),
    /* @__PURE__ */ jsx("path", { d: "M3.33334 16.6667V16.6767" }),
    /* @__PURE__ */ jsx("path", { d: "M6.66666 16.6667V16.6767" }),
    /* @__PURE__ */ jsx("path", { d: "M10 16.6667V16.6767" }),
    /* @__PURE__ */ jsx("path", { d: "M13.3333 16.6667V16.6767" }),
    /* @__PURE__ */ jsx("path", { d: "M16.6667 16.6667V16.6767" })
  ] }),
  modifiedTablerIconProps
);
var EdgeRoundIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      strokeWidth: "1.5",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }),
        /* @__PURE__ */ jsx("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }),
        /* @__PURE__ */ jsx("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }),
        /* @__PURE__ */ jsx("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }),
        /* @__PURE__ */ jsx("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }),
        /* @__PURE__ */ jsx("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }),
        /* @__PURE__ */ jsx("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }),
        /* @__PURE__ */ jsx("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }),
        /* @__PURE__ */ jsx("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }),
        /* @__PURE__ */ jsx("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })
      ]
    }
  ),
  tablerIconProps
);
var ArrowheadNoneIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", opacity: 0.3, strokeWidth: 2, children: [
    /* @__PURE__ */ jsx("path", { d: "M12 12l9 0" }),
    /* @__PURE__ */ jsx("path", { d: "M3 9l6 6" }),
    /* @__PURE__ */ jsx("path", { d: "M3 15l6 -6" })
  ] }),
  tablerIconProps
);
var ArrowheadArrowIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        stroke: "currentColor",
        strokeWidth: 2,
        fill: "none",
        children: [
          /* @__PURE__ */ jsx("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }),
          /* @__PURE__ */ jsx("path", { d: "M27.5 5L34.5 10L27.5 15" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCircleIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          /* @__PURE__ */ jsx("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          /* @__PURE__ */ jsx("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCircleOutlineIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ jsx("path", { d: "M26 10L6 10" }),
          /* @__PURE__ */ jsx("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadBarIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsx("g", { transform: flip ? "translate(40, 0) scale(-1, 1)" : "", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M34 10H5.99996M34 10L34 5M34 10L34 15",
        stroke: "currentColor",
        strokeWidth: 2,
        fill: "none"
      }
    ) }),
    { width: 40, height: 20 }
  )
);
var ArrowheadTriangleIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          /* @__PURE__ */ jsx("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          /* @__PURE__ */ jsx("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadTriangleOutlineIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { d: "M6,9.5H27" }),
          /* @__PURE__ */ jsx("path", { d: "M27,5L34,10L27,14Z", fill: "none" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadDiamondIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "currentColor",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ jsx("path", { d: "M6,9.5H20" }),
          /* @__PURE__ */ jsx("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadDiamondOutlineIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [
          /* @__PURE__ */ jsx("path", { d: "M6,9.5H20" }),
          /* @__PURE__ */ jsx("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
        ]
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCrowfootIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsx(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: /* @__PURE__ */ jsx("path", { d: "M34,10 H6 M15,10 L7,5 M15,10 L7,15" })
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCrowfootOneIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsx(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: /* @__PURE__ */ jsx("path", { d: "M34,10 H6 M15,10 L15,15 L15,5" })
      }
    ),
    { width: 40, height: 20 }
  )
);
var ArrowheadCrowfootOneOrManyIcon = React.memo(
  ({ flip = false }) => createIcon(
    /* @__PURE__ */ jsx(
      "g",
      {
        stroke: "currentColor",
        fill: "none",
        transform: flip ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: /* @__PURE__ */ jsx("path", { d: "M34,10 H6 M15,10 L15,16 L15,4 M15,10 L7,5 M15,10 L7,15" })
      }
    ),
    { width: 40, height: 20 }
  )
);
var FontSizeSmallIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeMediumIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5 16.667V3.333L10 15l5-11.667v13.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeLargeIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5.833 3.333v13.334h8.334",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) }),
    /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", { id: "a", children: /* @__PURE__ */ jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
  ] }),
  modifiedTablerIconProps
);
var FontSizeExtraLargeIcon = createIcon(
  /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
    "path",
    {
      d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) }),
  modifiedTablerIconProps
);
var fontSizeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 7v-2h13v2" }),
    /* @__PURE__ */ jsx("path", { d: "M10 5v14" }),
    /* @__PURE__ */ jsx("path", { d: "M12 19h-4" }),
    /* @__PURE__ */ jsx("path", { d: "M15 13v-1h6v1" }),
    /* @__PURE__ */ jsx("path", { d: "M18 12v7" }),
    /* @__PURE__ */ jsx("path", { d: "M17 19h2" })
  ] }),
  tablerIconProps
);
var FontFamilyHeadingIcon = createIcon(
  /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs(
    "g",
    {
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx("path", { d: "M7 12h10" }),
        /* @__PURE__ */ jsx("path", { d: "M7 5v14" }),
        /* @__PURE__ */ jsx("path", { d: "M17 5v14" }),
        /* @__PURE__ */ jsx("path", { d: "M15 19h4" }),
        /* @__PURE__ */ jsx("path", { d: "M15 5h4" }),
        /* @__PURE__ */ jsx("path", { d: "M5 19h4" }),
        /* @__PURE__ */ jsx("path", { d: "M5 5h4" })
      ]
    }
  ) }),
  tablerIconProps
);
var FontFamilyNormalIcon = createIcon(
  /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
    "g",
    {
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: /* @__PURE__ */ jsx("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" })
    }
  ) }),
  modifiedTablerIconProps
);
var codeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M7 8l-4 4l4 4" }),
    /* @__PURE__ */ jsx("path", { d: "M17 8l4 4l-4 4" }),
    /* @__PURE__ */ jsx("path", { d: "M14 4l-4 16" })
  ] }),
  tablerIconProps
);
var FontFamilyCodeIcon = codeIcon;
var TextAlignLeftIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 2,
      children: [
        /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "12", x2: "12", y2: "12" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "16", x2: "16", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignCenterIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ jsx("line", { x1: "8", y1: "12", x2: "16", y2: "12" }),
        /* @__PURE__ */ jsx("line", { x1: "6", y1: "16", x2: "18", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignRightIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        /* @__PURE__ */ jsx("line", { x1: "10", y1: "12", x2: "20", y2: "12" }),
        /* @__PURE__ */ jsx("line", { x1: "8", y1: "16", x2: "20", y2: "16" })
      ]
    }
  ),
  tablerIconProps
);
var TextAlignTopIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ jsx("line", { x1: "4", y1: "4", x2: "20", y2: "4" }),
          /* @__PURE__ */ jsx("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var TextAlignBottomIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        strokeWidth: "2",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ jsx("line", { x1: "4", y1: "20", x2: "20", y2: "20" }),
          /* @__PURE__ */ jsx("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var TextAlignMiddleIcon = React.memo(
  ({ theme }) => createIcon(
    /* @__PURE__ */ jsxs(
      "g",
      {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          /* @__PURE__ */ jsx("line", { x1: "4", y1: "12", x2: "9", y2: "12" }),
          /* @__PURE__ */ jsx("line", { x1: "15", y1: "12", x2: "20", y2: "12" }),
          /* @__PURE__ */ jsx("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })
        ]
      }
    ),
    tablerIconProps
  )
);
var angleIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M21 19h-18l9 -15" }),
    /* @__PURE__ */ jsx("path", { d: "M20.615 15.171h.015" }),
    /* @__PURE__ */ jsx("path", { d: "M19.515 11.771h.015" }),
    /* @__PURE__ */ jsx("path", { d: "M17.715 8.671h.015" }),
    /* @__PURE__ */ jsx("path", { d: "M15.415 5.971h.015" })
  ] }),
  tablerIconProps
);
var publishIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z",
      fill: "currentColor"
    }
  ),
  { width: 640, height: 512 }
);
var eraser = createIcon(
  /* @__PURE__ */ jsx("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" })
);
var handIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }),
    /* @__PURE__ */ jsx("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }),
    /* @__PURE__ */ jsx("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }),
    /* @__PURE__ */ jsx("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })
  ] }),
  tablerIconProps
);
var downloadIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }),
    /* @__PURE__ */ jsx("path", { d: "M7 11l5 5l5 -5" }),
    /* @__PURE__ */ jsx("path", { d: "M12 4l0 12" })
  ] }),
  tablerIconProps
);
var copyIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }),
    /* @__PURE__ */ jsx("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })
  ] }),
  tablerIconProps
);
var cutIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
    /* @__PURE__ */ jsx("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
    /* @__PURE__ */ jsx("path", { d: "M9.15 14.85l8.85 -10.85" }),
    /* @__PURE__ */ jsx("path", { d: "M6 4l8.85 10.85" })
  ] }),
  tablerIconProps
);
var helpIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
    /* @__PURE__ */ jsx("path", { d: "M12 17l0 .01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
  ] }),
  tablerIconProps
);
var playerPlayIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M7 4v16l13 -8z" })
  ] }),
  tablerIconProps
);
var playerStopFilledIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx(
      "path",
      {
        d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z",
        strokeWidth: "0",
        fill: "currentColor"
      }
    )
  ] }),
  tablerIconProps
);
var tablerCheckIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 12l5 5l10 -10" })
  ] }),
  tablerIconProps
);
var alertTriangleIcon = createIcon(
  /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }),
    /* @__PURE__ */ jsx("path", { d: "M12 9v4" }),
    /* @__PURE__ */ jsx("path", { d: "M12 17h.01" })
  ] }),
  tablerIconProps
);
var eyeDropperIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M11 7l6 6" }),
    /* @__PURE__ */ jsx("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })
  ] }),
  tablerIconProps
);
var extraToolsIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M12 3l-4 7h8z" }),
    /* @__PURE__ */ jsx("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })
  ] }),
  tablerIconProps
);
var frameToolIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 7l16 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 17l16 0" }),
    /* @__PURE__ */ jsx("path", { d: "M7 4l0 16" }),
    /* @__PURE__ */ jsx("path", { d: "M17 4l0 16" })
  ] }),
  tablerIconProps
);
var mermaidLogoIcon = createIcon(
  /* @__PURE__ */ jsx(
    "path",
    {
      fill: "currentColor",
      d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z"
    }
  )
);
var RetryIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4" }),
    /* @__PURE__ */ jsx("path", { d: "M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" })
  ] }),
  tablerIconProps
);
var stackPushIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 10l-2 1l8 4l8 -4l-2 -1" }),
    /* @__PURE__ */ jsx("path", { d: "M4 15l8 4l8 -4" }),
    /* @__PURE__ */ jsx("path", { d: "M12 4v7" }),
    /* @__PURE__ */ jsx("path", { d: "M15 8l-3 3l-3 -3" })
  ] }),
  tablerIconProps
);
var ArrowRightIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { d: "M4.16602 10H15.8327" }),
    /* @__PURE__ */ jsx("path", { d: "M12.5 13.3333L15.8333 10" }),
    /* @__PURE__ */ jsx("path", { d: "M12.5 6.66666L15.8333 9.99999" })
  ] }),
  modifiedTablerIconProps
);
var laserPointerToolIcon = createIcon(
  /* @__PURE__ */ jsxs(
    "g",
    {
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      transform: "rotate(90 10 10)",
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            clipRule: "evenodd",
            d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })
      ]
    }
  ),
  20
);
var MagicIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z" }),
    /* @__PURE__ */ jsx("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
    /* @__PURE__ */ jsx("path", { d: "M15 6l3 3" }),
    /* @__PURE__ */ jsx("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
    /* @__PURE__ */ jsx("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
  ] }),
  tablerIconProps
);
var MagicIconThin = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z" }),
    /* @__PURE__ */ jsx("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
    /* @__PURE__ */ jsx("path", { d: "M15 6l3 3" }),
    /* @__PURE__ */ jsx("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
    /* @__PURE__ */ jsx("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
  ] }),
  tablerIconProps
);
var OpenAIIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }),
    /* @__PURE__ */ jsx("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }),
    /* @__PURE__ */ jsx("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }),
    /* @__PURE__ */ jsx("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }),
    /* @__PURE__ */ jsx("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }),
    /* @__PURE__ */ jsx("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })
  ] }),
  tablerIconProps
);
var fullscreenIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }),
    /* @__PURE__ */ jsx("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }),
    /* @__PURE__ */ jsx("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }),
    /* @__PURE__ */ jsx("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })
  ] }),
  tablerIconProps
);
var eyeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })
  ] }),
  tablerIconProps
);
var eyeClosedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }),
    /* @__PURE__ */ jsx("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }),
    /* @__PURE__ */ jsx("path", { d: "M3 3l18 18" })
  ] }),
  tablerIconProps
);
var brainIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", fill: "none", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
    /* @__PURE__ */ jsx("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
    /* @__PURE__ */ jsx("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
    /* @__PURE__ */ jsx("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
    /* @__PURE__ */ jsx("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
    /* @__PURE__ */ jsx("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
  ] }),
  tablerIconProps
);
var brainIconThin = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
    /* @__PURE__ */ jsx("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
    /* @__PURE__ */ jsx("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
    /* @__PURE__ */ jsx("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
    /* @__PURE__ */ jsx("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
    /* @__PURE__ */ jsx("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
  ] }),
  tablerIconProps
);
var searchIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }),
    /* @__PURE__ */ jsx("path", { d: "M21 21l-6 -6" })
  ] }),
  tablerIconProps
);
var historyCommandIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M20.984 12.53a9 9 0 1 0 -7.552 8.355" }),
    /* @__PURE__ */ jsx("path", { d: "M12 7v5l3 3" }),
    /* @__PURE__ */ jsx("path", { d: "M19 16l-2 3h4l-2 3" })
  ] }),
  tablerIconProps
);
var historyIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M12 8l0 4l2 2" }),
    /* @__PURE__ */ jsx("path", { d: "M3.05 11a9 9 0 1 1 .5 4m-.5 5v-5h5" })
  ] }),
  tablerIconProps
);
var microphoneIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z" }),
    /* @__PURE__ */ jsx("path", { d: "M5 10a7 7 0 0 0 14 0" }),
    /* @__PURE__ */ jsx("path", { d: "M8 21l8 0" }),
    /* @__PURE__ */ jsx("path", { d: "M12 17l0 4" })
  ] }),
  tablerIconProps
);
var microphoneMutedIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 3l18 18" }),
    /* @__PURE__ */ jsx("path", { d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1" }),
    /* @__PURE__ */ jsx("path", { d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85" }),
    /* @__PURE__ */ jsx("path", { d: "M8 21l8 0" }),
    /* @__PURE__ */ jsx("path", { d: "M12 17l0 4" })
  ] }),
  tablerIconProps
);
var boltIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11" })
  ] }),
  tablerIconProps
);
var selectAllIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z" }),
    /* @__PURE__ */ jsx("path", { d: "M12 20v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M16 20v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M8 20v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4 20v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4 16v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4 8v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M4 4v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M8 4v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M12 4v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M16 4v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 4v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 8v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 12v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 16v.01" }),
    /* @__PURE__ */ jsx("path", { d: "M20 20v.01" })
  ] }),
  tablerIconProps
);
var abacusIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 3v18" }),
    /* @__PURE__ */ jsx("path", { d: "M19 21v-18" }),
    /* @__PURE__ */ jsx("path", { d: "M5 7h14" }),
    /* @__PURE__ */ jsx("path", { d: "M5 15h14" }),
    /* @__PURE__ */ jsx("path", { d: "M8 13v4" }),
    /* @__PURE__ */ jsx("path", { d: "M11 13v4" }),
    /* @__PURE__ */ jsx("path", { d: "M16 13v4" }),
    /* @__PURE__ */ jsx("path", { d: "M14 5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M11 5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M8 5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M3 21h18" })
  ] }),
  tablerIconProps
);
var flipVertical = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 12l18 0" }),
    /* @__PURE__ */ jsx("path", { d: "M7 16l10 0l-10 5l0 -5" }),
    /* @__PURE__ */ jsx("path", { d: "M7 8l10 0l-10 -5l0 5" })
  ] }),
  tablerIconProps
);
var flipHorizontal = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M12 3l0 18" }),
    /* @__PURE__ */ jsx("path", { d: "M16 7l0 10l5 0l-5 -10" }),
    /* @__PURE__ */ jsx("path", { d: "M8 7l0 10l-5 0l5 -10" })
  ] }),
  tablerIconProps
);
var paintIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" }),
    /* @__PURE__ */ jsx("path", { d: "M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2" }),
    /* @__PURE__ */ jsx("path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" })
  ] }),
  tablerIconProps
);
var zoomAreaIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }),
    /* @__PURE__ */ jsx("path", { d: "M22 22l-3 -3" }),
    /* @__PURE__ */ jsx("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }),
    /* @__PURE__ */ jsx("path", { d: "M3 11v-1" }),
    /* @__PURE__ */ jsx("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }),
    /* @__PURE__ */ jsx("path", { d: "M10 3h1" }),
    /* @__PURE__ */ jsx("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" })
  ] }),
  tablerIconProps
);
var svgIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
    /* @__PURE__ */ jsx("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75" }),
    /* @__PURE__ */ jsx("path", { d: "M10 15l2 6l2 -6" }),
    /* @__PURE__ */ jsx("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" })
  ] }),
  tablerIconProps
);
var pngIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
    /* @__PURE__ */ jsx("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }),
    /* @__PURE__ */ jsx("path", { d: "M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" }),
    /* @__PURE__ */ jsx("path", { d: "M11 21v-6l3 6v-6" })
  ] }),
  tablerIconProps
);
var magnetIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 8l5 0" }),
    /* @__PURE__ */ jsx("path", { d: "M15 8l4 0" })
  ] }),
  tablerIconProps
);
var coffeeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1" }),
    /* @__PURE__ */ jsx("path", { d: "M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
    /* @__PURE__ */ jsx("path", { d: "M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
    /* @__PURE__ */ jsx("path", { d: "M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z" }),
    /* @__PURE__ */ jsx("path", { d: "M16.746 16.726a3 3 0 1 0 .252 -5.555" })
  ] }),
  tablerIconProps
);
var DeviceDesktopIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { stroke: "currentColor", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4" })
  ] }),
  { ...tablerIconProps, strokeWidth: 1.5 }
);
var loginIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2" }),
    /* @__PURE__ */ jsx("path", { d: "M21 12h-13l3 -3" }),
    /* @__PURE__ */ jsx("path", { d: "M11 15l-3 -3" })
  ] }),
  tablerIconProps
);
var youtubeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z" }),
    /* @__PURE__ */ jsx("path", { d: "M10 9l5 3l-5 3z" })
  ] }),
  tablerIconProps
);
var gridIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 6h18" }),
    /* @__PURE__ */ jsx("path", { d: "M3 12h18" }),
    /* @__PURE__ */ jsx("path", { d: "M3 18h18" }),
    /* @__PURE__ */ jsx("path", { d: "M6 3v18" }),
    /* @__PURE__ */ jsx("path", { d: "M12 3v18" }),
    /* @__PURE__ */ jsx("path", { d: "M18 3v18" })
  ] }),
  tablerIconProps
);
var lineEditorIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }),
    /* @__PURE__ */ jsx("path", { d: "M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }),
    /* @__PURE__ */ jsx("path", { d: "M17 5c-6.627 0 -12 5.373 -12 12" })
  ] }),
  tablerIconProps
);
var sharpArrowIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 18l12 -12" }),
    /* @__PURE__ */ jsx("path", { d: "M18 10v-4h-4" })
  ] }),
  tablerIconProps
);
var elbowArrowIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7" }),
    /* @__PURE__ */ jsx("path", { d: "M18 4l3 3l-3 3" })
  ] }),
  tablerIconProps
);
var roundArrowIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { d: "M16,12L20,9L16,6" }),
    /* @__PURE__ */ jsx("path", { d: "M6 20c0 -6.075 4.925 -11 11 -11h3" })
  ] }),
  tablerIconProps
);
var collapseDownIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 9l6 6l6 -6" })
  ] }),
  tablerIconProps
);
var collapseUpIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 15l6 -6l6 6" })
  ] }),
  tablerIconProps
);
var upIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 15l6 -6l6 6" })
  ] }),
  tablerIconProps
);
var cropIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M8 5v10a1 1 0 0 0 1 1h10" }),
    /* @__PURE__ */ jsx("path", { d: "M5 8h10a1 1 0 0 1 1 1v10" })
  ] }),
  tablerIconProps
);
var elementLinkIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M5 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M5 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M5 7l0 10" }),
    /* @__PURE__ */ jsx("path", { d: "M7 5l10 0" }),
    /* @__PURE__ */ jsx("path", { d: "M7 19l10 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 7l0 10" })
  ] }),
  tablerIconProps
);
var resizeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 11v8a1 1 0 0 0 1 1h8m-9 -14v-1a1 1 0 0 1 1 -1h1m5 0h2m5 0h1a1 1 0 0 1 1 1v1m0 5v2m0 5v1a1 1 0 0 1 -1 1h-1" }),
    /* @__PURE__ */ jsx("path", { d: "M4 12h7a1 1 0 0 1 1 1v7" })
  ] }),
  tablerIconProps
);
var adjustmentsIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.5, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M14 6m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 6l8 0" }),
    /* @__PURE__ */ jsx("path", { d: "M16 6l4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M8 12m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 12l2 0" }),
    /* @__PURE__ */ jsx("path", { d: "M10 12l10 0" }),
    /* @__PURE__ */ jsx("path", { d: "M17 18m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 18l11 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 18l1 0" })
  ] }),
  tablerIconProps
);
var strokeIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M6 10l4 -4 L6 14l8 -8 L6 18l12 -12 L10 18l8 -8 L14 18l4 -4" })
  ] }),
  tablerIconProps
);
var pencilIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" }),
    /* @__PURE__ */ jsx("path", { d: "M13.5 6.5l4 4" })
  ] }),
  tablerIconProps
);
var chevronLeftIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M11 7l-5 5l5 5" }),
    /* @__PURE__ */ jsx("path", { d: "M17 7l-5 5l5 5" })
  ] }),
  tablerIconProps
);
var sidebarRightIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.75", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z" }),
    /* @__PURE__ */ jsx("path", { d: "M15 4l0 16" })
  ] }),
  tablerIconProps
);
var messageCircleIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 20l1.3 -3.9c-2.324 -3.437 -1.426 -7.872 2.1 -10.374c3.526 -2.501 8.59 -2.296 11.845 .48c3.255 2.777 3.695 7.266 1.029 10.501c-2.666 3.235 -7.615 4.215 -11.574 2.293l-4.7 1" })
  ] }),
  tablerIconProps
);
var presentationIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.25", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M3 4l18 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 4v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-10" }),
    /* @__PURE__ */ jsx("path", { d: "M12 16l0 4" }),
    /* @__PURE__ */ jsx("path", { d: "M9 20l6 0" }),
    /* @__PURE__ */ jsx("path", { d: "M8 12l3 -3l2 2l3 -3" })
  ] }),
  tablerIconProps
);
var emptyIcon = /* @__PURE__ */ jsx("div", { style: { width: "1rem", height: "1rem" } });
var chevronRight = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("polyline", { points: "9 6 15 12 9 18" })
  ] }),
  tablerIconProps
);
var settingsIcon = createIcon(
  /* @__PURE__ */ jsxs("g", { strokeWidth: 1.25, children: [
    /* @__PURE__ */ jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
    /* @__PURE__ */ jsx("path", { d: "M14 6m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 6l8 0" }),
    /* @__PURE__ */ jsx("path", { d: "M16 6l4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M8 12m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 12l2 0" }),
    /* @__PURE__ */ jsx("path", { d: "M10 12l10 0" }),
    /* @__PURE__ */ jsx("path", { d: "M17 18m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
    /* @__PURE__ */ jsx("path", { d: "M4 18l11 0" }),
    /* @__PURE__ */ jsx("path", { d: "M19 18l1 0" })
  ] }),
  tablerIconProps
);

// components/ToolButton.tsx
import clsx2 from "clsx";
import React3, { useEffect, useRef, useState } from "react";
import { isPromiseLike } from "@excalidraw/common";

// components/Spinner.tsx
import React2 from "react";
import { jsx as jsx2 } from "react/jsx-runtime";
var Spinner = ({
  size = "1em",
  circleWidth = 8,
  synchronized = false,
  className = ""
}) => {
  const mountTime = React2.useRef(Date.now());
  const mountDelay = -(mountTime.current % 1600);
  return /* @__PURE__ */ jsx2("div", { className: `Spinner ${className}`, children: /* @__PURE__ */ jsx2(
    "svg",
    {
      viewBox: "0 0 100 100",
      style: {
        width: size,
        height: size,
        // fix for remounting causing spinner flicker
        ["--spinner-delay"]: synchronized ? `${mountDelay}ms` : 0
      },
      children: /* @__PURE__ */ jsx2(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: 50 - circleWidth / 2,
          strokeWidth: circleWidth,
          fill: "none",
          strokeMiterlimit: "10"
        }
      )
    }
  ) });
};
var Spinner_default = Spinner;

// components/ToolButton.tsx
import { jsx as jsx3, jsxs as jsxs2 } from "react/jsx-runtime";
var ToolButton = React3.forwardRef(
  ({
    size = "medium",
    visible = true,
    className = "",
    ...props
  }, ref) => {
    const { id: excalId } = useExcalidrawContainer();
    const innerRef = React3.useRef(null);
    React3.useImperativeHandle(ref, () => innerRef.current);
    const sizeCn = `ToolIcon_size_${size}`;
    const [isLoading, setIsLoading] = useState(false);
    const isMountedRef = useRef(true);
    const onClick = async (event) => {
      const ret = "onClick" in props && props.onClick?.(event);
      if (isPromiseLike(ret)) {
        try {
          setIsLoading(true);
          await ret;
        } catch (error) {
          if (!(error instanceof AbortError)) {
            throw error;
          } else {
            console.warn(error);
          }
        } finally {
          if (isMountedRef.current) {
            setIsLoading(false);
          }
        }
      }
    };
    useEffect(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    const lastPointerTypeRef = useRef(null);
    if (props.type === "button" || props.type === "icon" || props.type === "submit") {
      const type = props.type === "icon" ? "button" : props.type;
      return /* @__PURE__ */ jsxs2(
        "button",
        {
          className: clsx2(
            "ToolIcon_type_button",
            sizeCn,
            className,
            visible && !props.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
            {
              ToolIcon: !props.hidden,
              "ToolIcon--selected": props.selected,
              "ToolIcon--plain": props.type === "icon"
            }
          ),
          style: props.style,
          "data-testid": props["data-testid"],
          hidden: props.hidden,
          title: props.title,
          "aria-label": props["aria-label"],
          type,
          onClick,
          ref: innerRef,
          disabled: isLoading || props.isLoading || !!props.disabled,
          children: [
            (props.icon || props.label) && /* @__PURE__ */ jsxs2(
              "div",
              {
                className: "ToolIcon__icon",
                "aria-hidden": "true",
                "aria-disabled": !!props.disabled,
                children: [
                  props.icon || props.label,
                  props.keyBindingLabel && /* @__PURE__ */ jsx3("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel }),
                  props.isLoading && /* @__PURE__ */ jsx3(Spinner_default, {})
                ]
              }
            ),
            props.showAriaLabel && /* @__PURE__ */ jsxs2("div", { className: "ToolIcon__label", children: [
              props["aria-label"],
              " ",
              isLoading && /* @__PURE__ */ jsx3(Spinner_default, {})
            ] }),
            props.children
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxs2(
      "label",
      {
        className: clsx2("ToolIcon", className),
        title: props.title,
        onPointerDown: (event) => {
          lastPointerTypeRef.current = event.pointerType || null;
          props.onPointerDown?.({ pointerType: event.pointerType || null });
        },
        onPointerUp: () => {
          requestAnimationFrame(() => {
            lastPointerTypeRef.current = null;
          });
        },
        children: [
          /* @__PURE__ */ jsx3(
            "input",
            {
              className: `ToolIcon_type_radio ${sizeCn}`,
              type: "radio",
              name: props.name,
              "aria-label": props["aria-label"],
              "aria-keyshortcuts": props["aria-keyshortcuts"],
              "data-testid": props["data-testid"],
              id: `${excalId}-${props.id}`,
              onChange: () => {
                props.onChange?.({ pointerType: lastPointerTypeRef.current });
              },
              checked: props.checked,
              ref: innerRef
            }
          ),
          /* @__PURE__ */ jsxs2("div", { className: "ToolIcon__icon", children: [
            props.icon,
            props.keyBindingLabel && /* @__PURE__ */ jsx3("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel })
          ] })
        ]
      }
    );
  }
);
ToolButton.displayName = "ToolButton";

// actions/register.ts
var actions = [];
var register = (action) => {
  actions = actions.concat(action);
  return action;
};

// actions/actionDeleteSelected.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var deleteSelectedElements = (elements, appState, app) => {
  const framesToBeDeleted = new Set(
    getSelectedElements(
      elements.filter((el) => isFrameLikeElement(el)),
      appState
    ).map((el) => el.id)
  );
  const selectedElementIds = {};
  const elementsMap = app.scene.getNonDeletedElementsMap();
  const processedElements = /* @__PURE__ */ new Set();
  for (const frameId of framesToBeDeleted) {
    const frameChildren = getFrameChildren(elements, frameId);
    for (const el of frameChildren) {
      if (processedElements.has(el.id)) {
        continue;
      }
      if (isBoundToContainer(el)) {
        const containerElement = getContainerElement(el, elementsMap);
        if (containerElement) {
          selectedElementIds[containerElement.id] = true;
        }
      } else {
        selectedElementIds[el.id] = true;
      }
      processedElements.add(el.id);
    }
  }
  let shouldSelectEditingGroup = true;
  const nextElements = elements.map((el) => {
    if (appState.selectedElementIds[el.id]) {
      const boundElement = isBoundToContainer(el) ? getContainerElement(el, elementsMap) : null;
      if (el.frameId && framesToBeDeleted.has(el.frameId)) {
        shouldSelectEditingGroup = false;
        selectedElementIds[el.id] = true;
        return el;
      }
      if (boundElement?.frameId && framesToBeDeleted.has(boundElement?.frameId)) {
        return el;
      }
      if (el.boundElements) {
        el.boundElements.forEach((candidate) => {
          const bound = app.scene.getNonDeletedElementsMap().get(candidate.id);
          if (bound && isElbowArrow(bound)) {
            app.scene.mutateElement(bound, {
              startBinding: el.id === bound.startBinding?.elementId ? null : bound.startBinding,
              endBinding: el.id === bound.endBinding?.elementId ? null : bound.endBinding
            });
          }
        });
      }
      return newElementWith(el, { isDeleted: true });
    }
    if (el.frameId && framesToBeDeleted.has(el.frameId)) {
      shouldSelectEditingGroup = false;
      if (!isBoundToContainer(el)) {
        selectedElementIds[el.id] = true;
      }
      return newElementWith(el, { frameId: null });
    }
    if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {
      return newElementWith(el, { isDeleted: true });
    }
    return el;
  });
  let nextEditingGroupId = appState.editingGroupId;
  if (shouldSelectEditingGroup && appState.editingGroupId) {
    const elems = getElementsInGroup(
      nextElements,
      appState.editingGroupId
    ).filter((el) => !el.isDeleted);
    if (elems.length > 1) {
      if (elems[0]) {
        selectedElementIds[elems[0].id] = true;
      }
    } else {
      nextEditingGroupId = null;
      if (elems[0]) {
        selectedElementIds[elems[0].id] = true;
      }
      const lastElementInGroup = elems[0];
      if (lastElementInGroup) {
        const editingGroupIdx = lastElementInGroup.groupIds.findIndex(
          (groupId) => {
            return groupId === appState.editingGroupId;
          }
        );
        const superGroupId = lastElementInGroup.groupIds[editingGroupIdx + 1];
        if (superGroupId) {
          const elems2 = getElementsInGroup(nextElements, superGroupId).filter(
            (el) => !el.isDeleted
          );
          if (elems2.length > 1) {
            nextEditingGroupId = superGroupId;
            elems2.forEach((el) => {
              selectedElementIds[el.id] = true;
            });
          }
        }
      }
    }
  }
  return {
    elements: nextElements,
    appState: {
      ...appState,
      ...selectGroupsForSelectedElements(
        {
          selectedElementIds,
          editingGroupId: nextEditingGroupId
        },
        nextElements,
        appState,
        null
      )
    }
  };
};
var handleGroupEditingState = (appState, elements) => {
  if (appState.editingGroupId) {
    const siblingElements = getElementsInGroup(
      getNonDeletedElements(elements),
      appState.editingGroupId
    );
    if (siblingElements.length) {
      return {
        ...appState,
        selectedElementIds: { [siblingElements[0].id]: true }
      };
    }
  }
  return appState;
};
var actionDeleteSelected = register({
  name: "deleteSelectedElements",
  label: "labels.delete",
  icon: TrashIcon,
  trackEvent: { category: "element", action: "delete" },
  perform: (elements, appState, formData, app) => {
    if (appState.selectedLinearElement?.isEditing) {
      const { elementId, selectedPointsIndices } = appState.selectedLinearElement;
      const elementsMap = app.scene.getNonDeletedElementsMap();
      const linearElement = LinearElementEditor.getElement(
        elementId,
        elementsMap
      );
      if (!linearElement) {
        return false;
      }
      if (selectedPointsIndices == null) {
        return false;
      }
      if (selectedPointsIndices.length >= linearElement.points.length) {
        const nextElements2 = elements.map((el) => {
          if (el.id === linearElement.id) {
            return newElementWith(el, { isDeleted: true });
          }
          return el;
        });
        const nextAppState2 = handleGroupEditingState(appState, nextElements2);
        return {
          elements: nextElements2,
          appState: {
            ...nextAppState2,
            selectedLinearElement: null
          },
          captureUpdate: CaptureUpdateAction.IMMEDIATELY
        };
      }
      LinearElementEditor.deletePoints(
        linearElement,
        app,
        selectedPointsIndices
      );
      return {
        elements,
        appState: {
          ...appState,
          selectedLinearElement: {
            ...appState.selectedLinearElement,
            selectedPointsIndices: selectedPointsIndices?.[0] > 0 ? [selectedPointsIndices[0] - 1] : [0]
          }
        },
        captureUpdate: CaptureUpdateAction.IMMEDIATELY
      };
    }
    let { elements: nextElements, appState: nextAppState } = deleteSelectedElements(elements, appState, app);
    fixBindingsAfterDeletion(
      nextElements,
      nextElements.filter((el) => el.isDeleted)
    );
    nextAppState = handleGroupEditingState(nextAppState, nextElements);
    return {
      elements: nextElements,
      appState: {
        ...nextAppState,
        activeTool: updateActiveTool(appState, {
          type: app.state.preferredSelectionTool.type
        }),
        multiElement: null,
        newElement: null,
        activeEmbeddable: null,
        selectedLinearElement: null
      },
      captureUpdate: isSomeElementSelected(
        getNonDeletedElements(elements),
        appState
      ) ? CaptureUpdateAction.IMMEDIATELY : CaptureUpdateAction.EVENTUALLY
    };
  },
  keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const isMobile = useStylesPanelMode() === "mobile";
    return /* @__PURE__ */ jsx4(
      ToolButton,
      {
        type: "button",
        icon: TrashIcon,
        title: t("labels.delete"),
        "aria-label": t("labels.delete"),
        onClick: () => updateData(null),
        disabled: !isSomeElementSelected(getNonDeletedElements(elements), appState),
        style: {
          ...isMobile && appState.openPopup !== "compactOtherProperties" ? MOBILE_ACTION_BUTTON_BG : {}
        }
      }
    );
  }
});

// actions/actionZindex.tsx
import { KEYS as KEYS2, CODES, isDarwin as isDarwin2 } from "@excalidraw/common";
import {
  moveOneLeft,
  moveOneRight,
  moveAllLeft,
  moveAllRight
} from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction2 } from "@excalidraw/element";

// shortcut.ts
import { isDarwin } from "@excalidraw/common";
var getShortcutKey = (shortcut) => shortcut.replace(
  /\b(Opt(?:ion)?|Alt)\b/i,
  isDarwin ? t("keys.option") : t("keys.alt")
).replace(/\bShift\b/i, t("keys.shift")).replace(/\b(Enter|Return)\b/i, t("keys.enter")).replace(
  /\b(Ctrl|Cmd|Command|CtrlOrCmd)\b/gi,
  isDarwin ? t("keys.cmd") : t("keys.ctrl")
).replace(/\b(Esc(?:ape)?)\b/i, t("keys.escape")).replace(/\b(Space(?:bar)?)\b/i, t("keys.spacebar")).replace(/\b(Del(?:ete)?)\b/i, t("keys.delete"));

// actions/actionZindex.tsx
import { jsx as jsx5 } from "react/jsx-runtime";
var actionSendBackward = register({
  name: "sendBackward",
  label: "labels.sendBackward",
  keywords: ["move down", "zindex", "layer"],
  icon: SendBackwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: moveOneLeft(elements, appState, app.scene),
      appState,
      captureUpdate: CaptureUpdateAction2.IMMEDIATELY
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS2.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx5(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendBackward")} \u2014 ${getShortcutKey("CtrlOrCmd+[")}`,
      children: SendBackwardIcon
    }
  )
});
var actionBringForward = register({
  name: "bringForward",
  label: "labels.bringForward",
  keywords: ["move up", "zindex", "layer"],
  icon: BringForwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: moveOneRight(elements, appState, app.scene),
      appState,
      captureUpdate: CaptureUpdateAction2.IMMEDIATELY
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS2.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx5(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.bringForward")} \u2014 ${getShortcutKey("CtrlOrCmd+]")}`,
      children: BringForwardIcon
    }
  )
});
var actionSendToBack = register({
  name: "sendToBack",
  label: "labels.sendToBack",
  keywords: ["move down", "zindex", "layer"],
  icon: SendToBackIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllLeft(elements, appState),
      appState,
      captureUpdate: CaptureUpdateAction2.IMMEDIATELY
    };
  },
  keyTest: (event) => isDarwin2 ? event[KEYS2.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_LEFT : event[KEYS2.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx5(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendToBack")} \u2014 ${isDarwin2 ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")}`,
      children: SendToBackIcon
    }
  )
});
var actionBringToFront = register({
  name: "bringToFront",
  label: "labels.bringToFront",
  keywords: ["move up", "zindex", "layer"],
  icon: BringToFrontIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllRight(elements, appState),
      appState,
      captureUpdate: CaptureUpdateAction2.IMMEDIATELY
    };
  },
  keyTest: (event) => isDarwin2 ? event[KEYS2.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_RIGHT : event[KEYS2.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx5(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: (event) => updateData(null),
      title: `${t("labels.bringToFront")} \u2014 ${isDarwin2 ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")}`,
      children: BringToFrontIcon
    }
  )
});

// actions/actionSelectAll.ts
import { getNonDeletedElements as getNonDeletedElements2 } from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor2 } from "@excalidraw/element";
import { isLinearElement, isTextElement } from "@excalidraw/element";
import { arrayToMap, KEYS as KEYS3 } from "@excalidraw/common";
import { selectGroupsForSelectedElements as selectGroupsForSelectedElements2 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction3 } from "@excalidraw/element";
var actionSelectAll = register({
  name: "selectAll",
  label: "labels.selectAll",
  icon: selectAllIcon,
  trackEvent: { category: "canvas" },
  viewMode: false,
  perform: (elements, appState, value, app) => {
    if (appState.selectedLinearElement?.isEditing) {
      return false;
    }
    const selectedElementIds = elements.filter(
      (element) => !element.isDeleted && !(isTextElement(element) && element.containerId) && !element.locked
    ).reduce((map, element) => {
      map[element.id] = true;
      return map;
    }, {});
    return {
      appState: {
        ...appState,
        ...selectGroupsForSelectedElements2(
          {
            editingGroupId: null,
            selectedElementIds
          },
          getNonDeletedElements2(elements),
          appState,
          app
        ),
        selectedLinearElement: (
          // single linear element selected
          Object.keys(selectedElementIds).length === 1 && isLinearElement(elements[0]) ? new LinearElementEditor2(elements[0], arrayToMap(elements)) : null
        )
      },
      captureUpdate: CaptureUpdateAction3.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS3.CTRL_OR_CMD] && event.key === KEYS3.A
});

// actions/actionDuplicateSelection.tsx
import {
  DEFAULT_GRID_SIZE,
  KEYS as KEYS4,
  MOBILE_ACTION_BUTTON_BG as MOBILE_ACTION_BUTTON_BG2,
  arrayToMap as arrayToMap2
} from "@excalidraw/common";
import { getNonDeletedElements as getNonDeletedElements3 } from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor3 } from "@excalidraw/element";
import {
  getSelectedElements as getSelectedElements2,
  getSelectionStateForElements
} from "@excalidraw/element";
import { syncMovedIndices } from "@excalidraw/element";
import { duplicateElements } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction4 } from "@excalidraw/element";
import { jsx as jsx6 } from "react/jsx-runtime";
var actionDuplicateSelection = register({
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    if (appState.selectedElementsAreBeingDragged) {
      return false;
    }
    if (appState.selectedLinearElement?.isEditing) {
      try {
        const newAppState = LinearElementEditor3.duplicateSelectedPoints(
          appState,
          app.scene
        );
        return {
          elements,
          appState: newAppState,
          captureUpdate: CaptureUpdateAction4.IMMEDIATELY
        };
      } catch {
        return false;
      }
    }
    let { duplicatedElements, elementsWithDuplicates } = duplicateElements({
      type: "in-place",
      elements,
      idsOfElementsToDuplicate: arrayToMap2(
        getSelectedElements2(elements, appState, {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        })
      ),
      appState,
      randomizeSeed: true,
      overrides: ({ origElement, origIdToDuplicateId }) => {
        const duplicateFrameId = origElement.frameId && origIdToDuplicateId.get(origElement.frameId);
        return {
          x: origElement.x + DEFAULT_GRID_SIZE / 2,
          y: origElement.y + DEFAULT_GRID_SIZE / 2,
          frameId: duplicateFrameId ?? origElement.frameId
        };
      }
    });
    if (app.props.onDuplicate && elementsWithDuplicates) {
      const mappedElements = app.props.onDuplicate(
        elementsWithDuplicates,
        elements
      );
      if (mappedElements) {
        elementsWithDuplicates = mappedElements;
      }
    }
    return {
      elements: syncMovedIndices(
        elementsWithDuplicates,
        arrayToMap2(duplicatedElements)
      ),
      appState: {
        ...appState,
        ...getSelectionStateForElements(
          duplicatedElements,
          getNonDeletedElements3(elementsWithDuplicates),
          appState
        )
      },
      captureUpdate: CaptureUpdateAction4.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS4.CTRL_OR_CMD] && event.key === KEYS4.D,
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const isMobile = useStylesPanelMode() === "mobile";
    return /* @__PURE__ */ jsx6(
      ToolButton,
      {
        type: "button",
        icon: DuplicateIcon,
        title: `${t("labels.duplicateSelection")} \u2014 ${getShortcutKey(
          "CtrlOrCmd+D"
        )}`,
        "aria-label": t("labels.duplicateSelection"),
        onClick: () => updateData(null),
        disabled: !isSomeElementSelected(getNonDeletedElements3(elements), appState),
        style: {
          ...isMobile && appState.openPopup !== "compactOtherProperties" ? MOBILE_ACTION_BUTTON_BG2 : {}
        }
      }
    );
  }
});

// actions/actionProperties.tsx
import { pointFrom } from "@excalidraw/math";
import { useEffect as useEffect13, useMemo as useMemo3, useRef as useRef10, useState as useState7 } from "react";
import {
  DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
  DEFAULT_ELEMENT_BACKGROUND_PICKS as DEFAULT_ELEMENT_BACKGROUND_PICKS2,
  DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
  DEFAULT_ELEMENT_STROKE_PICKS as DEFAULT_ELEMENT_STROKE_PICKS2,
  ARROW_TYPE,
  DEFAULT_FONT_FAMILY,
  DEFAULT_FONT_SIZE,
  FONT_FAMILY as FONT_FAMILY3,
  ROUNDNESS,
  STROKE_WIDTH,
  VERTICAL_ALIGN,
  KEYS as KEYS11,
  randomInteger,
  arrayToMap as arrayToMap3,
  getFontFamilyString as getFontFamilyString2,
  getLineHeight,
  isTransparent,
  reduceToCommonValue,
  invariant,
  FONT_SIZES
} from "@excalidraw/common";
import { canBecomePolygon, getNonDeletedElements as getNonDeletedElements4 } from "@excalidraw/element";
import {
  bindBindingElement,
  calculateFixedPointForElbowArrowBinding,
  updateBoundElements
} from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor4 } from "@excalidraw/element";
import { newElementWith as newElementWith2 } from "@excalidraw/element";
import {
  getBoundTextElement,
  getContainerElement as getContainerElement2,
  redrawTextBoundingBox
} from "@excalidraw/element";
import {
  isArrowElement,
  isBoundToContainer as isBoundToContainer2,
  isElbowArrow as isElbowArrow2,
  isLinearElement as isLinearElement2,
  isLineElement,
  isTextElement as isTextElement2,
  isUsingAdaptiveRadius
} from "@excalidraw/element";
import { hasStrokeColor } from "@excalidraw/element";
import {
  updateElbowArrowPoints,
  CaptureUpdateAction as CaptureUpdateAction5,
  toggleLinePolygonState
} from "@excalidraw/element";
import { deriveStylesPanelMode } from "@excalidraw/common";

// analytics.ts
import { isDevEnv as isDevEnv2 } from "@excalidraw/common";
var ALLOWED_CATEGORIES_TO_TRACK = /* @__PURE__ */ new Set(["command_palette", "export"]);
var trackEvent = (category, action, label, value) => {
  try {
    if (typeof window === "undefined" || define_import_meta_env_default.VITE_WORKER_ID || define_import_meta_env_default.VITE_APP_ENABLE_TRACKING !== "true") {
      return;
    }
    if (!ALLOWED_CATEGORIES_TO_TRACK.has(category)) {
      return;
    }
    if (isDevEnv2()) {
      return;
    }
    if (!define_import_meta_env_default.PROD) {
      console.info("trackEvent", { category, action, label, value });
    }
    if (window.sa_event) {
      window.sa_event(action, {
        category,
        label,
        value
      });
    }
  } catch (error) {
    console.error("error during analytics", error);
  }
};

// components/RadioSelection.tsx
import clsx4 from "clsx";

// components/ButtonIcon.tsx
import clsx3 from "clsx";
import { forwardRef } from "react";
import { jsx as jsx7 } from "react/jsx-runtime";
var ButtonIcon = forwardRef(
  (props, ref) => {
    const { title, className, testId, active, standalone, icon, onClick } = props;
    return /* @__PURE__ */ jsx7(
      "button",
      {
        type: "button",
        ref,
        title,
        "data-testid": testId,
        className: clsx3(className, { standalone, active }),
        onClick,
        style: props.style,
        children: icon
      },
      title
    );
  }
);

// components/RadioSelection.tsx
import { Fragment as Fragment2, jsx as jsx8, jsxs as jsxs3 } from "react/jsx-runtime";
var RadioSelection = (props) => /* @__PURE__ */ jsx8(Fragment2, { children: props.options.map(
  (option) => props.type === "button" ? /* @__PURE__ */ jsx8(
    ButtonIcon,
    {
      icon: option.icon,
      title: option.text,
      testId: option.testId,
      active: option.active ?? props.value === option.value,
      onClick: (event) => props.onClick(option.value, event)
    },
    option.text
  ) : /* @__PURE__ */ jsxs3(
    "label",
    {
      className: clsx4({ active: props.value === option.value }),
      title: option.text,
      children: [
        /* @__PURE__ */ jsx8(
          "input",
          {
            type: "radio",
            name: props.group,
            onChange: () => props.onChange(option.value),
            checked: props.value === option.value,
            "data-testid": option.testId
          }
        ),
        option.icon
      ]
    },
    option.text
  )
) });

// components/ColorPicker/ColorPicker.tsx
import { Popover as Popover2 } from "radix-ui";
import clsx12 from "clsx";
import { useRef as useRef8, useEffect as useEffect9 } from "react";
import {
  COLOR_OUTLINE_CONTRAST_THRESHOLD as COLOR_OUTLINE_CONTRAST_THRESHOLD2,
  COLOR_PALETTE as COLOR_PALETTE2,
  isColorDark as isColorDark3,
  isWritableElement
} from "@excalidraw/common";

// components/ButtonSeparator.tsx
import { jsx as jsx9 } from "react/jsx-runtime";
var ButtonSeparator = () => /* @__PURE__ */ jsx9(
  "div",
  {
    style: {
      width: 1,
      height: "1rem",
      backgroundColor: "var(--default-border-color)",
      margin: "0 auto"
    }
  }
);

// components/EyeDropper.tsx
import { useEffect as useEffect3, useRef as useRef3 } from "react";
import { createPortal } from "react-dom";
import { EVENT as EVENT2, KEYS as KEYS5, rgbToHex } from "@excalidraw/common";

// context/ui-appState.ts
import React4 from "react";
var UIAppStateContext = React4.createContext(null);
var useUIAppState = () => React4.useContext(UIAppStateContext);

// hooks/useCreatePortalContainer.ts
import { useState as useState2, useLayoutEffect } from "react";
import { THEME as THEME2 } from "@excalidraw/common";
var useCreatePortalContainer = (opts) => {
  const [div, setDiv] = useState2(null);
  const editorInterface = useEditorInterface();
  const { theme } = useUIAppState();
  const { container: excalidrawContainer } = useExcalidrawContainer();
  useLayoutEffect(() => {
    if (div) {
      div.className = "";
      div.classList.add("excalidraw", ...opts?.className?.split(/\s+/) || []);
      div.classList.toggle(
        "excalidraw--mobile",
        editorInterface.formFactor === "phone"
      );
      div.classList.toggle("theme--dark", theme === THEME2.DARK);
    }
  }, [div, theme, editorInterface.formFactor, opts?.className]);
  useLayoutEffect(() => {
    const container = opts?.parentSelector ? excalidrawContainer?.querySelector(opts.parentSelector) : document.body;
    if (!container) {
      return;
    }
    const div2 = document.createElement("div");
    container.appendChild(div2);
    setDiv(div2);
    return () => {
      container.removeChild(div2);
    };
  }, [excalidrawContainer, opts?.parentSelector]);
  return div;
};

// hooks/useOutsideClick.ts
import { useEffect as useEffect2 } from "react";
import { EVENT } from "@excalidraw/common";
function useOutsideClick(ref, callback, isInside) {
  useEffect2(() => {
    function onOutsideClick(event) {
      const _event = event;
      if (!ref.current) {
        return;
      }
      const isInsideOverride = isInside?.(_event, ref.current);
      if (isInsideOverride === true) {
        return;
      } else if (isInsideOverride === false) {
        return callback(_event);
      }
      if (ref.current.contains(_event.target) || // target is detached from DOM (happens when the element is removed
      // on a pointerup event fired *before* this handler's pointerup is
      // dispatched)
      !document.documentElement.contains(_event.target)) {
        return;
      }
      const isClickOnRadixPortal = _event.target.closest("[data-radix-portal]") || // when radix popup is in "modal" mode, it disables pointer events on
      // the `body` element, so the target element is going to be the `html`
      // (note: this won't work if we selectively re-enable pointer events on
      // specific elements as we do with navbar or excalidraw UI elements)
      _event.target === document.documentElement && document.body.style.pointerEvents === "none";
      if (isClickOnRadixPortal) {
        return;
      }
      if (_event.target.closest("[data-prevent-outside-click]")) {
        return;
      }
      callback(_event);
    }
    document.addEventListener(EVENT.POINTER_DOWN, onOutsideClick);
    document.addEventListener(EVENT.TOUCH_START, onOutsideClick);
    return () => {
      document.removeEventListener(EVENT.POINTER_DOWN, onOutsideClick);
      document.removeEventListener(EVENT.TOUCH_START, onOutsideClick);
    };
  }, [ref, callback, isInside]);
}

// hooks/useStable.ts
import { useRef as useRef2 } from "react";
var useStable = (value) => {
  const ref = useRef2(value);
  Object.assign(ref.current, value);
  return ref.current;
};

// components/EyeDropper.tsx
import { jsx as jsx10 } from "react/jsx-runtime";
var activeEyeDropperAtom = atom(null);
var EyeDropper = ({ onCancel, onChange, onSelect, colorPickerType }) => {
  const eyeDropperContainer = useCreatePortalContainer({
    className: "excalidraw-eye-dropper-backdrop",
    parentSelector: ".excalidraw-eye-dropper-container"
  });
  const appState = useUIAppState();
  const elements = useExcalidrawElements();
  const app = useApp();
  const selectedElements = getSelectedElements(elements, appState);
  const stableProps = useStable({
    app,
    onCancel,
    onChange,
    onSelect,
    selectedElements
  });
  const { container: excalidrawContainer } = useExcalidrawContainer();
  useEffect3(() => {
    const colorPreviewDiv = ref.current;
    if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {
      return;
    }
    let isHoldingPointerDown = false;
    const ctx = app.canvas.getContext("2d");
    const getCurrentColor = ({
      clientX,
      clientY
    }) => {
      const pixel = ctx.getImageData(
        (clientX - appState.offsetLeft) * window.devicePixelRatio,
        (clientY - appState.offsetTop) * window.devicePixelRatio,
        1,
        1
      ).data;
      return rgbToHex(pixel[0], pixel[1], pixel[2]);
    };
    const mouseMoveListener = ({
      clientX,
      clientY,
      altKey
    }) => {
      colorPreviewDiv.style.top = `${clientY + 20}px`;
      colorPreviewDiv.style.left = `${clientX + 20}px`;
      const currentColor = getCurrentColor({ clientX, clientY });
      if (isHoldingPointerDown) {
        stableProps.onChange(
          colorPickerType,
          currentColor,
          stableProps.selectedElements,
          { altKey }
        );
      }
      colorPreviewDiv.style.background = currentColor;
    };
    const onCancel2 = () => {
      stableProps.onCancel();
    };
    const onSelect2 = (color, event) => {
      stableProps.onSelect(color, event);
    };
    const pointerDownListener = (event) => {
      isHoldingPointerDown = true;
      event.stopImmediatePropagation();
    };
    const pointerUpListener = (event) => {
      isHoldingPointerDown = false;
      excalidrawContainer?.focus();
      event.stopImmediatePropagation();
      event.preventDefault();
      onSelect2(getCurrentColor(event), event);
    };
    const keyDownListener = (event) => {
      if (event.key === KEYS5.ESCAPE) {
        event.preventDefault();
        event.stopImmediatePropagation();
        onCancel2();
      }
    };
    eyeDropperContainer.tabIndex = -1;
    eyeDropperContainer.focus();
    mouseMoveListener({
      clientX: stableProps.app.lastViewportPosition.x,
      clientY: stableProps.app.lastViewportPosition.y,
      altKey: false
    });
    eyeDropperContainer.addEventListener(EVENT2.KEYDOWN, keyDownListener);
    eyeDropperContainer.addEventListener(
      EVENT2.POINTER_DOWN,
      pointerDownListener
    );
    eyeDropperContainer.addEventListener(EVENT2.POINTER_UP, pointerUpListener);
    window.addEventListener("pointermove", mouseMoveListener, {
      passive: true
    });
    window.addEventListener(EVENT2.BLUR, onCancel2);
    return () => {
      isHoldingPointerDown = false;
      eyeDropperContainer.removeEventListener(EVENT2.KEYDOWN, keyDownListener);
      eyeDropperContainer.removeEventListener(
        EVENT2.POINTER_DOWN,
        pointerDownListener
      );
      eyeDropperContainer.removeEventListener(
        EVENT2.POINTER_UP,
        pointerUpListener
      );
      window.removeEventListener("pointermove", mouseMoveListener);
      window.removeEventListener(EVENT2.BLUR, onCancel2);
    };
  }, [
    stableProps,
    app.canvas,
    eyeDropperContainer,
    colorPickerType,
    excalidrawContainer,
    appState.offsetLeft,
    appState.offsetTop
  ]);
  const ref = useRef3(null);
  useOutsideClick(
    ref,
    () => {
      onCancel();
    },
    (event) => {
      if (event.target.closest(
        ".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop"
      )) {
        return true;
      }
      return false;
    }
  );
  if (!eyeDropperContainer) {
    return null;
  }
  return createPortal(
    /* @__PURE__ */ jsx10("div", { ref, className: "excalidraw-eye-dropper-preview" }),
    eyeDropperContainer
  );
};

// components/PropertiesPopover.tsx
import { Popover } from "radix-ui";
import clsx6 from "clsx";
import React6 from "react";
import { isInteractive } from "@excalidraw/common";

// components/Island.tsx
import React5 from "react";
import clsx5 from "clsx";
import { jsx as jsx11 } from "react/jsx-runtime";
var Island = React5.forwardRef(
  ({ children, padding, className, style }, ref) => /* @__PURE__ */ jsx11(
    "div",
    {
      className: clsx5("Island", className),
      style: { "--padding": padding, ...style },
      ref,
      children
    }
  )
);

// components/PropertiesPopover.tsx
import { jsx as jsx12, jsxs as jsxs4 } from "react/jsx-runtime";
var PropertiesPopover = React6.forwardRef(
  ({
    className,
    container,
    children,
    style,
    onClose,
    onKeyDown,
    onFocusOutside,
    onPointerLeave,
    onPointerDownOutside,
    preventAutoFocusOnTouch = false
  }, ref) => {
    const editorInterface = useEditorInterface();
    const isMobilePortrait = editorInterface.formFactor === "phone" && !editorInterface.isLandscape;
    return /* @__PURE__ */ jsx12(Popover.Portal, { container, children: /* @__PURE__ */ jsxs4(
      Popover.Content,
      {
        ref,
        className: clsx6("focus-visible-none", className),
        "data-prevent-outside-click": true,
        side: isMobilePortrait ? "bottom" : "right",
        align: isMobilePortrait ? "center" : "start",
        alignOffset: -16,
        sideOffset: 20,
        collisionBoundary: container ?? void 0,
        style: {
          zIndex: "var(--zIndex-ui-styles-popup)",
          marginLeft: editorInterface.formFactor === "phone" ? "0.5rem" : void 0
        },
        onPointerLeave,
        onKeyDown,
        onFocusOutside,
        onPointerDownOutside,
        onOpenAutoFocus: (e) => {
          if (preventAutoFocusOnTouch && editorInterface.isTouchScreen) {
            e.preventDefault();
          }
        },
        onCloseAutoFocus: (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (container && !isInteractive(document.activeElement)) {
            container.focus();
          }
          onClose();
        },
        children: [
          /* @__PURE__ */ jsx12(Island, { padding: 3, style, children }),
          /* @__PURE__ */ jsx12(
            Popover.Arrow,
            {
              width: 20,
              height: 10,
              style: {
                fill: "var(--popup-bg-color)",
                filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
              }
            }
          )
        ]
      }
    ) });
  }
);

// hooks/useTextEditorFocus.ts
import { useState as useState3, useCallback } from "react";
var getTextEditor = () => {
  return document.querySelector(".excalidraw-wysiwyg");
};
var saveCaretPosition = () => {
  const textEditor = getTextEditor();
  if (textEditor) {
    return {
      start: textEditor.selectionStart,
      end: textEditor.selectionEnd
    };
  }
  return null;
};
var restoreCaretPosition = (position) => {
  setTimeout(() => {
    const textEditor = getTextEditor();
    if (textEditor) {
      textEditor.focus();
      if (position) {
        textEditor.selectionStart = position.start;
        textEditor.selectionEnd = position.end;
      }
    }
  }, 0);
};
var withCaretPositionPreservation = (callback, isCompactMode, isEditingText, onPreventClose) => {
  if (isCompactMode && onPreventClose) {
    onPreventClose();
  }
  const savedPosition = isCompactMode && isEditingText ? saveCaretPosition() : null;
  callback();
  if (isCompactMode && isEditingText) {
    restoreCaretPosition(savedPosition);
  }
};
var useTextEditorFocus = () => {
  const [savedCaretPosition, setSavedCaretPosition] = useState3(null);
  const saveCaretPositionToState = useCallback(() => {
    const position = saveCaretPosition();
    setSavedCaretPosition(position);
  }, []);
  const restoreCaretPositionFromState = useCallback(() => {
    setTimeout(() => {
      const textEditor = getTextEditor();
      if (textEditor) {
        textEditor.focus();
        if (savedCaretPosition) {
          textEditor.selectionStart = savedCaretPosition.start;
          textEditor.selectionEnd = savedCaretPosition.end;
          setSavedCaretPosition(null);
        }
      }
    }, 0);
  }, [savedCaretPosition]);
  const clearSavedPosition = useCallback(() => {
    setSavedCaretPosition(null);
  }, []);
  return {
    saveCaretPosition: saveCaretPositionToState,
    restoreCaretPosition: restoreCaretPositionFromState,
    clearSavedPosition,
    hasSavedPosition: !!savedCaretPosition
  };
};
var temporarilyDisableTextEditorBlur = (duration = 100) => {
  const textEditor = getTextEditor();
  if (textEditor) {
    const originalOnBlur = textEditor.onblur;
    textEditor.onblur = null;
    setTimeout(() => {
      textEditor.onblur = originalOnBlur;
    }, duration);
  }
};

// components/ColorPicker/ColorInput.tsx
import clsx7 from "clsx";
import { useCallback as useCallback2, useEffect as useEffect4, useRef as useRef4, useState as useState4 } from "react";
import { KEYS as KEYS6, normalizeInputColor } from "@excalidraw/common";

// components/ColorPicker/colorPickerUtils.ts
import { MAX_CUSTOM_COLORS_USED_IN_CANVAS } from "@excalidraw/common";
var getColorNameAndShadeFromColor = ({
  palette: palette2,
  color
}) => {
  if (!color) {
    return null;
  }
  for (const [colorName, colorVal] of Object.entries(palette2)) {
    if (Array.isArray(colorVal)) {
      const shade = colorVal.indexOf(color);
      if (shade > -1) {
        return { colorName, shade };
      }
    } else if (colorVal === color) {
      return { colorName, shade: null };
    }
  }
  return null;
};
var colorPickerHotkeyBindings = [
  ["q", "w", "e", "r", "t"],
  ["a", "s", "d", "f", "g"],
  ["z", "x", "c", "v", "b"]
].flat();
var isCustomColor = ({
  color,
  palette: palette2
}) => {
  const paletteValues = Object.values(palette2).flat();
  return !paletteValues.includes(color);
};
var getMostUsedCustomColors = (elements, type, palette2) => {
  const elementColorTypeMap = {
    elementBackground: "backgroundColor",
    elementStroke: "strokeColor"
  };
  const colors = elements.filter((element) => {
    if (element.isDeleted) {
      return false;
    }
    const color = element[elementColorTypeMap[type]];
    return isCustomColor({ color, palette: palette2 });
  });
  const colorCountMap = /* @__PURE__ */ new Map();
  colors.forEach((element) => {
    const color = element[elementColorTypeMap[type]];
    if (colorCountMap.has(color)) {
      colorCountMap.set(color, colorCountMap.get(color) + 1);
    } else {
      colorCountMap.set(color, 1);
    }
  });
  return [...colorCountMap.entries()].sort((a, b) => b[1] - a[1]).map((c) => c[0]).slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);
};
var activeColorPickerSectionAtom = atom(null);

// components/ColorPicker/ColorInput.tsx
import { Fragment as Fragment3, jsx as jsx13, jsxs as jsxs5 } from "react/jsx-runtime";
var ColorInput = ({
  color,
  onChange,
  label,
  colorPickerType,
  placeholder
}) => {
  const editorInterface = useEditorInterface();
  const [innerValue, setInnerValue] = useState4(color);
  const [activeSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  useEffect4(() => {
    setInnerValue(color);
  }, [color]);
  const changeColor = useCallback2(
    (inputValue) => {
      const value = inputValue.toLowerCase();
      const color2 = normalizeInputColor(value);
      if (color2) {
        onChange(color2);
      }
      setInnerValue(value);
    },
    [onChange]
  );
  const inputRef = useRef4(null);
  const eyeDropperTriggerRef = useRef4(null);
  useEffect4(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeSection]);
  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);
  useEffect4(() => {
    return () => {
      setEyeDropperState(null);
    };
  }, [setEyeDropperState]);
  return /* @__PURE__ */ jsxs5("div", { className: "color-picker__input-label", children: [
    /* @__PURE__ */ jsx13("div", { className: "color-picker__input-hash", children: "#" }),
    /* @__PURE__ */ jsx13(
      "input",
      {
        ref: activeSection === "hex" ? inputRef : void 0,
        style: { border: 0, padding: 0 },
        spellCheck: false,
        className: "color-picker-input",
        "aria-label": label,
        onChange: (event) => {
          changeColor(event.target.value);
        },
        value: (innerValue || "").replace(/^#/, ""),
        onBlur: () => {
          setInnerValue(color);
        },
        tabIndex: -1,
        onFocus: () => setActiveColorPickerSection("hex"),
        onKeyDown: (event) => {
          if (event.key === KEYS6.TAB) {
            return;
          } else if (event.key === KEYS6.ESCAPE) {
            eyeDropperTriggerRef.current?.focus();
          }
          event.stopPropagation();
        },
        placeholder
      }
    ),
    editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsxs5(Fragment3, { children: [
      /* @__PURE__ */ jsx13(
        "div",
        {
          style: {
            width: "1px",
            height: "1.25rem",
            backgroundColor: "var(--default-border-color)"
          }
        }
      ),
      /* @__PURE__ */ jsx13(
        "div",
        {
          ref: eyeDropperTriggerRef,
          className: clsx7("excalidraw-eye-dropper-trigger", {
            selected: eyeDropperState
          }),
          onClick: () => setEyeDropperState(
            (s) => s ? null : {
              keepOpenOnAlt: false,
              onSelect: (color2) => onChange(color2),
              colorPickerType
            }
          ),
          title: `${t(
            "labels.eyeDropper"
          )} \u2014 ${KEYS6.I.toLocaleUpperCase()} or ${getShortcutKey("Alt")} `,
          children: eyeDropperIcon
        }
      )
    ] })
  ] });
};

// components/ColorPicker/Picker.tsx
import React7, { useEffect as useEffect8, useImperativeHandle, useState as useState5 } from "react";
import { EVENT as EVENT3 } from "@excalidraw/common";
import {
  DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX,
  DEFAULT_ELEMENT_STROKE_COLOR_INDEX,
  KEYS as KEYS8
} from "@excalidraw/common";

// components/ColorPicker/CustomColorList.tsx
import clsx8 from "clsx";
import { useEffect as useEffect5, useRef as useRef5 } from "react";

// components/ColorPicker/HotkeyLabel.tsx
import { isColorDark } from "@excalidraw/common";
import { jsxs as jsxs6 } from "react/jsx-runtime";
var HotkeyLabel = ({
  color,
  keyLabel,
  isShade = false
}) => {
  return /* @__PURE__ */ jsxs6(
    "div",
    {
      className: "color-picker__button__hotkey-label",
      style: {
        color: isColorDark(color) ? "#fff" : "#000"
      },
      children: [
        isShade && "\u21E7",
        keyLabel
      ]
    }
  );
};
var HotkeyLabel_default = HotkeyLabel;

// components/ColorPicker/CustomColorList.tsx
import { jsx as jsx14, jsxs as jsxs7 } from "react/jsx-runtime";
var CustomColorList = ({
  colors,
  color,
  onChange,
  label
}) => {
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef5(null);
  useEffect5(() => {
    if (btnRef.current) {
      btnRef.current.focus();
    }
  }, [color, activeColorPickerSection]);
  return /* @__PURE__ */ jsx14("div", { className: "color-picker-content--default", children: colors.map((c, i) => {
    return /* @__PURE__ */ jsxs7(
      "button",
      {
        ref: color === c ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx8(
          "color-picker__button color-picker__button--large has-outline",
          {
            active: color === c,
            "is-transparent": c === "transparent" || !c
          }
        ),
        onClick: () => {
          onChange(c);
          setActiveColorPickerSection("custom");
        },
        title: c,
        "aria-label": label,
        style: { "--swatch-color": c },
        children: [
          /* @__PURE__ */ jsx14("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ jsx14(HotkeyLabel_default, { color: c, keyLabel: i + 1 })
        ]
      },
      i
    );
  }) });
};

// components/ColorPicker/PickerColorList.tsx
import clsx9 from "clsx";
import { useEffect as useEffect6, useRef as useRef6 } from "react";
import { jsx as jsx15, jsxs as jsxs8 } from "react/jsx-runtime";
var PickerColorList = ({
  palette: palette2,
  color,
  onChange,
  activeShade,
  showHotKey = true
}) => {
  const colorObj = getColorNameAndShadeFromColor({
    color,
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef6(null);
  useEffect6(() => {
    if (btnRef.current && activeColorPickerSection === "baseColors") {
      btnRef.current.focus();
    }
  }, [colorObj?.colorName, activeColorPickerSection]);
  return /* @__PURE__ */ jsx15("div", { className: "color-picker-content--default", children: Object.entries(palette2).map(([key, value], index) => {
    const color2 = (Array.isArray(value) ? value[activeShade] : value) || "transparent";
    const keybinding = colorPickerHotkeyBindings[index];
    const label = t(
      `colors.${key.replace(/\d+/, "")}`,
      null,
      ""
    );
    return /* @__PURE__ */ jsxs8(
      "button",
      {
        ref: colorObj?.colorName === key ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx9(
          "color-picker__button color-picker__button--large has-outline",
          {
            active: colorObj?.colorName === key,
            "is-transparent": color2 === "transparent" || !color2
          }
        ),
        onClick: () => {
          onChange(color2);
          setActiveColorPickerSection("baseColors");
        },
        title: `${label}${color2.startsWith("#") ? ` ${color2}` : ""} \u2014 ${keybinding}`,
        "aria-label": `${label} \u2014 ${keybinding}`,
        style: color2 ? { "--swatch-color": color2 } : void 0,
        "data-testid": `color-${key}`,
        children: [
          /* @__PURE__ */ jsx15("div", { className: "color-picker__button-outline" }),
          showHotKey && /* @__PURE__ */ jsx15(HotkeyLabel_default, { color: color2, keyLabel: keybinding })
        ]
      },
      key
    );
  }) });
};
var PickerColorList_default = PickerColorList;

// components/ColorPicker/PickerHeading.tsx
import { jsx as jsx16 } from "react/jsx-runtime";
var PickerHeading = ({ children }) => /* @__PURE__ */ jsx16("div", { className: "color-picker__heading", children });
var PickerHeading_default = PickerHeading;

// components/ColorPicker/ShadeList.tsx
import clsx10 from "clsx";
import { useEffect as useEffect7, useRef as useRef7 } from "react";
import { jsx as jsx17, jsxs as jsxs9 } from "react/jsx-runtime";
var ShadeList = ({
  color,
  onChange,
  palette: palette2,
  showHotKey
}) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: color || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef7(null);
  useEffect7(() => {
    if (btnRef.current && activeColorPickerSection === "shades") {
      btnRef.current.focus();
    }
  }, [colorObj, activeColorPickerSection]);
  if (colorObj) {
    const { colorName, shade } = colorObj;
    const shades = palette2[colorName];
    if (Array.isArray(shades)) {
      return /* @__PURE__ */ jsx17("div", { className: "color-picker-content--default shades", children: shades.map((color2, i) => /* @__PURE__ */ jsxs9(
        "button",
        {
          ref: i === shade && activeColorPickerSection === "shades" ? btnRef : void 0,
          tabIndex: -1,
          type: "button",
          className: clsx10(
            "color-picker__button color-picker__button--large has-outline",
            { active: i === shade }
          ),
          "aria-label": "Shade",
          title: `${colorName} - ${i + 1}`,
          style: color2 ? { "--swatch-color": color2 } : void 0,
          onClick: () => {
            onChange(color2);
            setActiveColorPickerSection("shades");
          },
          children: [
            /* @__PURE__ */ jsx17("div", { className: "color-picker__button-outline" }),
            showHotKey && /* @__PURE__ */ jsx17(HotkeyLabel_default, { color: color2, keyLabel: i + 1, isShade: true })
          ]
        },
        i
      )) });
    }
  }
  return /* @__PURE__ */ jsxs9(
    "div",
    {
      className: "color-picker-content--default",
      style: { position: "relative" },
      tabIndex: -1,
      children: [
        /* @__PURE__ */ jsx17(
          "button",
          {
            type: "button",
            tabIndex: -1,
            className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible"
          }
        ),
        /* @__PURE__ */ jsx17(
          "div",
          {
            tabIndex: -1,
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              textAlign: "center",
              fontSize: "0.75rem"
            },
            children: t("colorPicker.noShades")
          }
        )
      ]
    }
  );
};

// components/ColorPicker/keyboardNavHandlers.ts
import { COLORS_PER_ROW, COLOR_PALETTE, KEYS as KEYS7 } from "@excalidraw/common";
var arrowHandler = (eventKey, currentIndex, length) => {
  const rows = Math.ceil(length / COLORS_PER_ROW);
  currentIndex = currentIndex ?? -1;
  switch (eventKey) {
    case "ArrowLeft": {
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? length - 1 : prevIndex;
    }
    case "ArrowRight": {
      return (currentIndex + 1) % length;
    }
    case "ArrowDown": {
      const nextIndex = currentIndex + COLORS_PER_ROW;
      return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;
    }
    case "ArrowUp": {
      const prevIndex = currentIndex - COLORS_PER_ROW;
      const newIndex = prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;
      return newIndex >= length ? void 0 : newIndex;
    }
  }
};
var hotkeyHandler = ({
  e,
  colorObj,
  onChange,
  palette: palette2,
  customColors,
  setActiveColorPickerSection,
  activeShade
}) => {
  if (colorObj?.shade != null) {
    if (["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e.code) && e.shiftKey) {
      const newShade = Number(e.code.slice(-1)) - 1;
      onChange(palette2[colorObj.colorName][newShade]);
      setActiveColorPickerSection("shades");
      return true;
    }
  }
  if (["1", "2", "3", "4", "5"].includes(e.key)) {
    const c = customColors[Number(e.key) - 1];
    if (c) {
      onChange(customColors[Number(e.key) - 1]);
      setActiveColorPickerSection("custom");
      return true;
    }
  }
  if (colorPickerHotkeyBindings.includes(e.key)) {
    const index = colorPickerHotkeyBindings.indexOf(e.key);
    const paletteKey = Object.keys(palette2)[index];
    const paletteValue = palette2[paletteKey];
    const r = Array.isArray(paletteValue) ? paletteValue[activeShade] : paletteValue;
    onChange(r);
    setActiveColorPickerSection("baseColors");
    return true;
  }
  return false;
};
var colorPickerKeyNavHandler = ({
  event,
  activeColorPickerSection,
  palette: palette2,
  color,
  onChange,
  customColors,
  setActiveColorPickerSection,
  updateData,
  activeShade,
  onEyeDropperToggle,
  onEscape
}) => {
  if (event[KEYS7.CTRL_OR_CMD]) {
    return false;
  }
  if (event.key === KEYS7.ESCAPE) {
    onEscape(event);
    return true;
  }
  if (event.key === KEYS7.ALT) {
    onEyeDropperToggle(true);
    return true;
  }
  if (event.key === KEYS7.I) {
    onEyeDropperToggle();
    return true;
  }
  const colorObj = getColorNameAndShadeFromColor({ color, palette: palette2 });
  if (event.key === KEYS7.TAB) {
    const sectionsMap = {
      custom: !!customColors.length,
      baseColors: true,
      shades: colorObj?.shade != null,
      hex: true
    };
    const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {
      if (value) {
        acc.push(key);
      }
      return acc;
    }, []);
    const activeSectionIndex = sections.indexOf(activeColorPickerSection);
    const indexOffset = event.shiftKey ? -1 : 1;
    const nextSectionIndex = activeSectionIndex + indexOffset > sections.length - 1 ? 0 : activeSectionIndex + indexOffset < 0 ? sections.length - 1 : activeSectionIndex + indexOffset;
    const nextSection = sections[nextSectionIndex];
    if (nextSection) {
      setActiveColorPickerSection(nextSection);
    }
    if (nextSection === "custom") {
      onChange(customColors[0]);
    } else if (nextSection === "baseColors") {
      const baseColorName = Object.entries(palette2).find(([name, shades]) => {
        if (Array.isArray(shades)) {
          return shades.includes(color);
        } else if (shades === color) {
          return name;
        }
        return null;
      });
      if (!baseColorName) {
        onChange(COLOR_PALETTE.black);
      }
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  if (hotkeyHandler({
    e: event,
    colorObj,
    onChange,
    palette: palette2,
    customColors,
    setActiveColorPickerSection,
    activeShade
  })) {
    return true;
  }
  if (activeColorPickerSection === "shades") {
    if (colorObj) {
      const { shade } = colorObj;
      const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);
      if (newShade !== void 0) {
        onChange(palette2[colorObj.colorName][newShade]);
        return true;
      }
    }
  }
  if (activeColorPickerSection === "baseColors") {
    if (colorObj) {
      const { colorName } = colorObj;
      const colorNames = Object.keys(palette2);
      const indexOfColorName = colorNames.indexOf(colorName);
      const newColorIndex = arrowHandler(
        event.key,
        indexOfColorName,
        colorNames.length
      );
      if (newColorIndex !== void 0) {
        const newColorName = colorNames[newColorIndex];
        const newColorNameValue = palette2[newColorName];
        onChange(
          Array.isArray(newColorNameValue) ? newColorNameValue[activeShade] : newColorNameValue
        );
        return true;
      }
    }
  }
  if (activeColorPickerSection === "custom") {
    const indexOfColor = color != null ? customColors.indexOf(color) : 0;
    const newColorIndex = arrowHandler(
      event.key,
      indexOfColor,
      customColors.length
    );
    if (newColorIndex !== void 0) {
      const newColor = customColors[newColorIndex];
      onChange(newColor);
      return true;
    }
  }
  return false;
};

// components/ColorPicker/Picker.tsx
import { jsx as jsx18, jsxs as jsxs10 } from "react/jsx-runtime";
var Picker = React7.forwardRef(
  ({
    color,
    onChange,
    type,
    elements,
    palette: palette2,
    updateData,
    children,
    showTitle,
    onEyeDropperToggle,
    onEscape,
    showHotKey = true
  }, ref) => {
    const title = showTitle ? type === "elementStroke" ? t("labels.stroke") : type === "elementBackground" ? t("labels.background") : null : null;
    const [customColors] = React7.useState(() => {
      if (type === "canvasBackground") {
        return [];
      }
      return getMostUsedCustomColors(elements, type, palette2);
    });
    const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
      activeColorPickerSectionAtom
    );
    const colorObj = getColorNameAndShadeFromColor({
      color,
      palette: palette2
    });
    useEffect8(() => {
      if (!activeColorPickerSection) {
        const isCustom = !!color && isCustomColor({ color, palette: palette2 });
        const isCustomButNotInList = isCustom && !customColors.includes(color);
        setActiveColorPickerSection(
          isCustomButNotInList ? null : isCustom ? "custom" : colorObj?.shade != null ? "shades" : "baseColors"
        );
      }
    }, [
      activeColorPickerSection,
      color,
      palette2,
      setActiveColorPickerSection,
      colorObj,
      customColors
    ]);
    const [activeShade, setActiveShade] = useState5(
      colorObj?.shade ?? (type === "elementBackground" ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX : DEFAULT_ELEMENT_STROKE_COLOR_INDEX)
    );
    useEffect8(() => {
      if (colorObj?.shade != null) {
        setActiveShade(colorObj.shade);
      }
      const keyup = (event) => {
        if (event.key === KEYS8.ALT) {
          onEyeDropperToggle(false);
        }
      };
      document.addEventListener(EVENT3.KEYUP, keyup, { capture: true });
      return () => {
        document.removeEventListener(EVENT3.KEYUP, keyup, { capture: true });
      };
    }, [colorObj, onEyeDropperToggle]);
    const pickerRef = React7.useRef(null);
    useImperativeHandle(ref, () => pickerRef.current);
    useEffect8(() => {
      pickerRef?.current?.focus();
    }, []);
    return /* @__PURE__ */ jsx18("div", { role: "dialog", "aria-modal": "true", "aria-label": t("labels.colorPicker"), children: /* @__PURE__ */ jsxs10(
      "div",
      {
        ref: pickerRef,
        onKeyDown: (event) => {
          const handled = colorPickerKeyNavHandler({
            event,
            activeColorPickerSection,
            palette: palette2,
            color,
            onChange,
            onEyeDropperToggle,
            customColors,
            setActiveColorPickerSection,
            updateData,
            activeShade,
            onEscape
          });
          if (handled) {
            event.preventDefault();
            event.stopPropagation();
          }
        },
        className: "color-picker-content properties-content",
        tabIndex: -1,
        children: [
          title && /* @__PURE__ */ jsx18("div", { className: "color-picker__title", children: title }),
          !!customColors.length && /* @__PURE__ */ jsxs10("div", { children: [
            /* @__PURE__ */ jsx18(PickerHeading_default, { children: t("colorPicker.mostUsedCustomColors") }),
            /* @__PURE__ */ jsx18(
              CustomColorList,
              {
                colors: customColors,
                color,
                label: t("colorPicker.mostUsedCustomColors"),
                onChange
              }
            )
          ] }),
          /* @__PURE__ */ jsxs10("div", { children: [
            /* @__PURE__ */ jsx18(PickerHeading_default, { children: t("colorPicker.colors") }),
            /* @__PURE__ */ jsx18(
              PickerColorList_default,
              {
                color,
                palette: palette2,
                onChange,
                activeShade,
                showHotKey
              }
            )
          ] }),
          /* @__PURE__ */ jsxs10("div", { children: [
            /* @__PURE__ */ jsx18(PickerHeading_default, { children: t("colorPicker.shades") }),
            /* @__PURE__ */ jsx18(
              ShadeList,
              {
                color,
                onChange,
                palette: palette2,
                showHotKey
              }
            )
          ] }),
          children
        ]
      }
    ) });
  }
);

// components/ColorPicker/TopPicks.tsx
import clsx11 from "clsx";
import {
  COLOR_OUTLINE_CONTRAST_THRESHOLD,
  DEFAULT_CANVAS_BACKGROUND_PICKS,
  DEFAULT_ELEMENT_BACKGROUND_PICKS,
  DEFAULT_ELEMENT_STROKE_PICKS,
  isColorDark as isColorDark2
} from "@excalidraw/common";
import { jsx as jsx19 } from "react/jsx-runtime";
var TopPicks = ({
  onChange,
  type,
  activeColor,
  topPicks
}) => {
  let colors;
  if (type === "elementStroke") {
    colors = DEFAULT_ELEMENT_STROKE_PICKS;
  }
  if (type === "elementBackground") {
    colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;
  }
  if (type === "canvasBackground") {
    colors = DEFAULT_CANVAS_BACKGROUND_PICKS;
  }
  if (topPicks) {
    colors = topPicks;
  }
  if (!colors) {
    console.error("Invalid type for TopPicks");
    return null;
  }
  return /* @__PURE__ */ jsx19("div", { className: "color-picker__top-picks", children: colors.map((color) => /* @__PURE__ */ jsx19(
    "button",
    {
      className: clsx11("color-picker__button", {
        active: color === activeColor,
        "is-transparent": color === "transparent" || !color,
        "has-outline": !isColorDark2(
          color,
          COLOR_OUTLINE_CONTRAST_THRESHOLD
        )
      }),
      style: { "--swatch-color": color },
      type: "button",
      title: color,
      onClick: () => onChange(color),
      "data-testid": `color-top-pick-${color}`,
      children: /* @__PURE__ */ jsx19("div", { className: "color-picker__button-outline" })
    },
    color
  )) });
};

// components/ColorPicker/ColorPicker.tsx
import { jsx as jsx20, jsxs as jsxs11 } from "react/jsx-runtime";
var ColorPickerPopupContent = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE2,
  updateData,
  getOpenPopup,
  appState
}) => {
  const { container } = useExcalidrawContainer();
  const stylesPanelMode = useStylesPanelMode();
  const isCompactMode = stylesPanelMode !== "full";
  const isMobileMode = stylesPanelMode === "mobile";
  const [, setActiveColorPickerSection] = useAtom(activeColorPickerSectionAtom);
  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);
  const colorInputJSX = /* @__PURE__ */ jsxs11("div", { children: [
    /* @__PURE__ */ jsx20(PickerHeading_default, { children: t("colorPicker.hexCode") }),
    /* @__PURE__ */ jsx20(
      ColorInput,
      {
        color: color || "",
        label,
        onChange: (color2) => {
          onChange(color2);
        },
        colorPickerType: type,
        placeholder: t("colorPicker.color")
      }
    )
  ] });
  const colorPickerContentRef = useRef8(null);
  const focusPickerContent = () => {
    colorPickerContentRef.current?.focus();
  };
  return /* @__PURE__ */ jsx20(
    PropertiesPopover,
    {
      container,
      style: { maxWidth: "13rem" },
      preventAutoFocusOnTouch: !!appState.editingTextElement,
      onFocusOutside: (event) => {
        if (!isWritableElement(event.target)) {
          focusPickerContent();
        }
        event.preventDefault();
      },
      onPointerDownOutside: (event) => {
        if (eyeDropperState) {
          event.preventDefault();
        }
      },
      onClose: () => {
        if (getOpenPopup() === type) {
          updateData({ openPopup: null });
        }
        setActiveColorPickerSection(null);
        if (appState.editingTextElement) {
          setTimeout(() => {
            const textEditor = document.querySelector(
              ".excalidraw-wysiwyg"
            );
            if (textEditor) {
              textEditor.focus();
            }
          }, 0);
        }
      },
      children: palette2 ? /* @__PURE__ */ jsx20(
        Picker,
        {
          ref: colorPickerContentRef,
          palette: palette2,
          color,
          onChange: (changedColor) => {
            const savedSelection = appState.editingTextElement ? saveCaretPosition() : null;
            onChange(changedColor);
            if (appState.editingTextElement && savedSelection) {
              restoreCaretPosition(savedSelection);
            }
          },
          onEyeDropperToggle: (force) => {
            setEyeDropperState((state) => {
              if (force) {
                state = state || {
                  keepOpenOnAlt: true,
                  onSelect: onChange,
                  colorPickerType: type
                };
                state.keepOpenOnAlt = true;
                return state;
              }
              return force === false || state ? null : {
                keepOpenOnAlt: false,
                onSelect: onChange,
                colorPickerType: type
              };
            });
          },
          onEscape: (event) => {
            if (eyeDropperState) {
              setEyeDropperState(null);
            } else {
              updateData({ openPopup: null });
            }
          },
          type,
          elements,
          updateData,
          showTitle: isCompactMode,
          showHotKey: !isMobileMode,
          children: colorInputJSX
        }
      ) : colorInputJSX
    }
  );
};
var ColorPickerTrigger = ({
  label,
  color,
  type,
  mode = "background",
  onToggle,
  editingTextElement
}) => {
  const stylesPanelMode = useStylesPanelMode();
  const isCompactMode = stylesPanelMode !== "full";
  const isMobileMode = stylesPanelMode === "mobile";
  const handleClick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (editingTextElement) {
      temporarilyDisableTextEditorBlur();
    }
    onToggle();
  };
  return /* @__PURE__ */ jsxs11(
    Popover2.Trigger,
    {
      type: "button",
      className: clsx12("color-picker__button active-color properties-trigger", {
        "is-transparent": !color || color === "transparent",
        "has-outline": !color || !isColorDark3(color, COLOR_OUTLINE_CONTRAST_THRESHOLD2),
        "compact-sizing": isCompactMode,
        "mobile-border": isMobileMode
      }),
      "aria-label": label,
      style: color ? { "--swatch-color": color } : void 0,
      title: type === "elementStroke" ? t("labels.showStroke") : t("labels.showBackground"),
      "data-openpopup": type,
      onClick: handleClick,
      children: [
        /* @__PURE__ */ jsx20("div", { className: "color-picker__button-outline", children: !color && slashIcon }),
        isCompactMode && color && mode === "stroke" && /* @__PURE__ */ jsx20("div", { className: "color-picker__button-background", children: /* @__PURE__ */ jsx20(
          "span",
          {
            style: {
              color: color && isColorDark3(color, COLOR_OUTLINE_CONTRAST_THRESHOLD2) ? "#fff" : "#111"
            },
            children: strokeIcon
          }
        ) })
      ]
    }
  );
};
var ColorPicker = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE2,
  topPicks,
  updateData,
  appState
}) => {
  const openRef = useRef8(appState.openPopup);
  useEffect9(() => {
    openRef.current = appState.openPopup;
  }, [appState.openPopup]);
  const stylesPanelMode = useStylesPanelMode();
  const isCompactMode = stylesPanelMode !== "full";
  return /* @__PURE__ */ jsx20("div", { children: /* @__PURE__ */ jsxs11(
    "div",
    {
      role: "dialog",
      "aria-modal": "true",
      className: clsx12("color-picker-container", {
        "color-picker-container--no-top-picks": isCompactMode
      }),
      children: [
        !isCompactMode && /* @__PURE__ */ jsx20(
          TopPicks,
          {
            activeColor: color,
            onChange,
            type,
            topPicks
          }
        ),
        !isCompactMode && /* @__PURE__ */ jsx20(ButtonSeparator, {}),
        /* @__PURE__ */ jsxs11(
          Popover2.Root,
          {
            open: appState.openPopup === type,
            onOpenChange: (open) => {
              if (open) {
                updateData({ openPopup: type });
              }
            },
            children: [
              /* @__PURE__ */ jsx20(
                ColorPickerTrigger,
                {
                  color,
                  label,
                  type,
                  mode: type === "elementStroke" ? "stroke" : "background",
                  editingTextElement: !!appState.editingTextElement,
                  onToggle: () => {
                    if (appState.openPopup === type) {
                      updateData({ openPopup: null });
                    } else if (appState.openPopup) {
                      updateData({ openPopup: type });
                    } else {
                      updateData({ openPopup: type });
                    }
                  }
                }
              ),
              appState.openPopup === type && /* @__PURE__ */ jsx20(
                ColorPickerPopupContent,
                {
                  type,
                  color,
                  onChange,
                  label,
                  elements,
                  palette: palette2,
                  updateData,
                  getOpenPopup: () => openRef.current,
                  appState
                }
              )
            ]
          }
        )
      ]
    }
  ) });
};

// components/FontPicker/FontPicker.tsx
import { Popover as Popover4 } from "radix-ui";
import clsx15 from "clsx";
import React11, { useCallback as useCallback4, useMemo as useMemo2 } from "react";
import { FONT_FAMILY as FONT_FAMILY2 } from "@excalidraw/common";

// components/FontPicker/FontPickerList.tsx
import React10, {
  useMemo,
  useState as useState6,
  useRef as useRef9,
  useEffect as useEffect10,
  useCallback as useCallback3
} from "react";
import {
  arrayToList,
  debounce,
  FONT_FAMILY,
  getFontFamilyString
} from "@excalidraw/common";

// components/QuickSearch.tsx
import clsx13 from "clsx";
import React8 from "react";
import { jsx as jsx21, jsxs as jsxs12 } from "react/jsx-runtime";
var QuickSearch = React8.forwardRef(
  ({ className, placeholder, onChange }, ref) => {
    return /* @__PURE__ */ jsxs12("div", { className: clsx13("QuickSearch__wrapper", className), children: [
      searchIcon,
      /* @__PURE__ */ jsx21(
        "input",
        {
          ref,
          className: "QuickSearch__input",
          type: "text",
          placeholder,
          onChange: (e) => onChange(e.target.value.trim().toLowerCase())
        }
      )
    ] });
  }
);

// components/ScrollableList.tsx
import clsx14 from "clsx";
import { Children } from "react";
import { jsx as jsx22 } from "react/jsx-runtime";
var ScrollableList = ({
  className,
  placeholder,
  children
}) => {
  const isEmpty = !Children.count(children);
  return /* @__PURE__ */ jsx22("div", { className: clsx14("ScrollableList__wrapper", className), role: "menu", children: isEmpty ? /* @__PURE__ */ jsx22("div", { className: "empty", children: placeholder }) : children });
};

// components/dropdownMenu/DropdownMenuGroup.tsx
import { jsx as jsx23, jsxs as jsxs13 } from "react/jsx-runtime";
var MenuGroup = ({
  children,
  className = "",
  style,
  title
}) => {
  return /* @__PURE__ */ jsxs13("div", { className: `dropdown-menu-group ${className}`, style, children: [
    title && /* @__PURE__ */ jsx23("p", { className: "dropdown-menu-group-title", children: title }),
    children
  ] });
};
var DropdownMenuGroup_default = MenuGroup;
MenuGroup.displayName = "DropdownMenuGroup";

// components/dropdownMenu/DropdownMenuItem.tsx
import { THEME as THEME3 } from "@excalidraw/common";
import { DropdownMenu as DropdownMenuPrimitive } from "radix-ui";

// components/dropdownMenu/common.ts
import React9, { useContext } from "react";
import { composeEventHandlers } from "@excalidraw/common";
var DropdownMenuContentPropsContext = React9.createContext({});
var getDropdownMenuItemClassName = (className = "", selected = false, hovered = false) => {
  return `dropdown-menu-item dropdown-menu-item-base ${className} ${selected ? "dropdown-menu-item--selected" : ""} ${hovered ? "dropdown-menu-item--hovered" : ""}`.trim();
};
var useHandleDropdownMenuItemSelect = (onSelect) => {
  const DropdownMenuContentProps = useContext(DropdownMenuContentPropsContext);
  return composeEventHandlers(onSelect, (event) => {
    DropdownMenuContentProps.onSelect?.(event);
  });
};

// components/Ellipsify.tsx
import { jsx as jsx24 } from "react/jsx-runtime";
var Ellipsify = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx24(
    "span",
    {
      ...rest,
      style: {
        textOverflow: "ellipsis",
        overflow: "hidden",
        whiteSpace: "nowrap",
        ...rest.style
      },
      children
    }
  );
};

// components/dropdownMenu/DropdownMenuItemContent.tsx
import { Fragment as Fragment4, jsx as jsx25, jsxs as jsxs14 } from "react/jsx-runtime";
var MenuItemContent = ({
  textStyle,
  icon,
  shortcut,
  children,
  badge
}) => {
  const editorInterface = useEditorInterface();
  return /* @__PURE__ */ jsxs14(Fragment4, { children: [
    icon && /* @__PURE__ */ jsx25("div", { className: "dropdown-menu-item__icon", children: icon }),
    /* @__PURE__ */ jsx25("div", { style: textStyle, className: "dropdown-menu-item__text", children: /* @__PURE__ */ jsx25(Ellipsify, { children }) }),
    badge && /* @__PURE__ */ jsx25("div", { className: "dropdown-menu-item__badge", children: badge }),
    shortcut && editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsx25("div", { className: "dropdown-menu-item__shortcut", children: shortcut })
  ] });
};
var DropdownMenuItemContent_default = MenuItemContent;

// components/dropdownMenu/DropdownMenuItem.tsx
import { jsx as jsx26 } from "react/jsx-runtime";
var DropdownMenuItem = ({
  icon,
  badge,
  value,
  children,
  shortcut,
  className,
  selected,
  onSelect,
  ...rest
}) => {
  const handleSelect = useHandleDropdownMenuItemSelect(onSelect);
  return /* @__PURE__ */ jsx26(
    DropdownMenuPrimitive.Item,
    {
      className: "radix-menu-item",
      onSelect: handleSelect,
      asChild: true,
      children: /* @__PURE__ */ jsx26(
        "button",
        {
          ...rest,
          value,
          className: getDropdownMenuItemClassName(className, selected),
          title: rest.title ?? rest["aria-label"],
          children: /* @__PURE__ */ jsx26(DropdownMenuItemContent_default, { icon, shortcut, badge, children })
        }
      )
    }
  );
};
DropdownMenuItem.displayName = "DropdownMenuItem";
var DropDownMenuItemBadgeType = {
  GREEN: "green",
  RED: "red",
  BLUE: "blue"
};
var DropDownMenuItemBadge = ({
  type = DropDownMenuItemBadgeType.BLUE,
  children
}) => {
  const { theme } = useExcalidrawAppState();
  const style = {
    display: "inline-flex",
    marginLeft: "auto",
    padding: "2px 4px",
    borderRadius: 6,
    fontSize: 9,
    fontFamily: "Cascadia, monospace",
    border: theme === THEME3.LIGHT ? "1.5px solid white" : "none"
  };
  switch (type) {
    case DropDownMenuItemBadgeType.GREEN:
      Object.assign(style, {
        backgroundColor: "var(--background-color-badge)",
        color: "var(--color-badge)"
      });
      break;
    case DropDownMenuItemBadgeType.RED:
      Object.assign(style, {
        backgroundColor: "pink",
        color: "darkred"
      });
      break;
    case DropDownMenuItemBadgeType.BLUE:
    default:
      Object.assign(style, {
        background: "var(--color-promo)",
        color: "var(--color-surface-lowest)"
      });
  }
  return /* @__PURE__ */ jsx26("div", { className: "DropDownMenuItemBadge", style, children });
};
DropDownMenuItemBadge.displayName = "DropdownMenuItemBadge";
DropdownMenuItem.Badge = DropDownMenuItemBadge;
var DropdownMenuItem_default = DropdownMenuItem;

// components/FontPicker/keyboardNavHandlers.ts
import { KEYS as KEYS9 } from "@excalidraw/common";
var fontPickerKeyHandler = ({
  event,
  inputRef,
  hoveredFont,
  filteredFonts,
  onClose,
  onSelect,
  onHover
}) => {
  if (!event[KEYS9.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS9.F) {
    inputRef.current?.focus();
    return true;
  }
  if (event.key === KEYS9.ESCAPE) {
    onClose();
    return true;
  }
  if (event.key === KEYS9.ENTER) {
    if (hoveredFont?.value) {
      onSelect(hoveredFont.value);
    }
    return true;
  }
  if (event.key === KEYS9.ARROW_DOWN) {
    if (hoveredFont?.next) {
      onHover(hoveredFont.next.value);
    } else if (filteredFonts[0]?.value) {
      onHover(filteredFonts[0].value);
    }
    return true;
  }
  if (event.key === KEYS9.ARROW_UP) {
    if (hoveredFont?.prev) {
      onHover(hoveredFont.prev.value);
    } else if (filteredFonts[filteredFonts.length - 1]?.value) {
      onHover(filteredFonts[filteredFonts.length - 1].value);
    }
    return true;
  }
};

// components/FontPicker/FontPickerList.tsx
import { jsx as jsx27, jsxs as jsxs15 } from "react/jsx-runtime";
var getFontFamilyIcon = (fontFamily) => {
  switch (fontFamily) {
    case FONT_FAMILY.Excalifont:
    case FONT_FAMILY.Virgil:
      return FreedrawIcon;
    case FONT_FAMILY.Nunito:
    case FONT_FAMILY.Helvetica:
    case FONT_FAMILY.Arial:
      return FontFamilyNormalIcon;
    case FONT_FAMILY["Lilita One"]:
      return FontFamilyHeadingIcon;
    case FONT_FAMILY["Comic Shanns"]:
    case FONT_FAMILY.Cascadia:
      return FontFamilyCodeIcon;
    default:
      return FontFamilyNormalIcon;
  }
};
var FontPickerList = React10.memo(
  ({
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onOpen,
    onClose
  }) => {
    const { container } = useExcalidrawContainer();
    const app = useApp();
    const { fonts } = app;
    const { showDeprecatedFonts } = useAppProps();
    const stylesPanelMode = useStylesPanelMode();
    const [searchTerm, setSearchTerm] = useState6("");
    const inputRef = useRef9(null);
    const allFonts = useMemo(
      () => Array.from(Fonts.registered.entries()).filter(
        ([_, { metadata }]) => !metadata.private && !metadata.fallback
      ).map(([familyId, { metadata, fontFaces }]) => {
        const fontDescriptor = {
          value: familyId,
          icon: getFontFamilyIcon(familyId),
          text: fontFaces[0]?.fontFace?.family ?? "Unknown"
        };
        if (metadata.deprecated) {
          Object.assign(fontDescriptor, {
            deprecated: metadata.deprecated,
            badge: {
              type: DropDownMenuItemBadgeType.RED,
              placeholder: t("fontList.badge.old")
            }
          });
        }
        return fontDescriptor;
      }).sort(
        (a, b) => a.text.toLowerCase() > b.text.toLowerCase() ? 1 : -1
      ),
      []
    );
    const sceneFamilies = useMemo(
      () => new Set(fonts.getSceneFamilies()),
      // cache per selected font family, so hover re-render won't mess it up
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [selectedFontFamily]
    );
    const sceneFonts = useMemo(
      () => allFonts.filter((font) => sceneFamilies.has(font.value)),
      // always show all the fonts in the scene, even those that were deprecated
      [allFonts, sceneFamilies]
    );
    const availableFonts = useMemo(
      () => allFonts.filter(
        (font) => !sceneFamilies.has(font.value) && (showDeprecatedFonts || !font.deprecated)
        // skip deprecated fonts
      ),
      [allFonts, sceneFamilies, showDeprecatedFonts]
    );
    const filteredFonts = useMemo(
      () => arrayToList(
        [...sceneFonts, ...availableFonts].filter(
          (font) => font.text?.toLowerCase().includes(searchTerm)
        )
      ),
      [sceneFonts, availableFonts, searchTerm]
    );
    const hoveredFont = useMemo(() => {
      let font;
      if (hoveredFontFamily) {
        font = filteredFonts.find((font2) => font2.value === hoveredFontFamily);
      } else if (selectedFontFamily) {
        font = filteredFonts.find((font2) => font2.value === selectedFontFamily);
      }
      if (!font && searchTerm) {
        if (filteredFonts[0]?.value) {
          onHover(filteredFonts[0].value);
        } else {
          onLeave();
        }
      }
      return font;
    }, [
      hoveredFontFamily,
      selectedFontFamily,
      searchTerm,
      filteredFonts,
      onHover,
      onLeave
    ]);
    const wrappedOnSelect = useCallback3(
      (fontFamily) => {
        let savedSelection = null;
        if (app.state.editingTextElement) {
          const textEditor = document.querySelector(
            ".excalidraw-wysiwyg"
          );
          if (textEditor) {
            savedSelection = {
              start: textEditor.selectionStart,
              end: textEditor.selectionEnd
            };
          }
        }
        onSelect(fontFamily);
        if (app.state.editingTextElement && savedSelection) {
          setTimeout(() => {
            const textEditor = document.querySelector(
              ".excalidraw-wysiwyg"
            );
            if (textEditor && savedSelection) {
              textEditor.focus();
              textEditor.selectionStart = savedSelection.start;
              textEditor.selectionEnd = savedSelection.end;
            }
          }, 0);
        }
      },
      [onSelect, app.state.editingTextElement]
    );
    const onKeyDown = useCallback3(
      (event) => {
        const handled = fontPickerKeyHandler({
          event,
          inputRef,
          hoveredFont,
          filteredFonts,
          onSelect: wrappedOnSelect,
          onHover,
          onClose
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [hoveredFont, filteredFonts, wrappedOnSelect, onHover, onClose]
    );
    useEffect10(() => {
      onOpen();
      return () => {
        onClose();
      };
    }, []);
    const sceneFilteredFonts = useMemo(
      () => filteredFonts.filter((font) => sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const availableFilteredFonts = useMemo(
      () => filteredFonts.filter((font) => !sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const FontPickerListItem = ({
      font,
      order
    }) => {
      const ref = useRef9(null);
      const isHovered = font.value === hoveredFont?.value;
      const isSelected = font.value === selectedFontFamily;
      useEffect10(() => {
        if (!isHovered) {
          return;
        }
        if (order === 0) {
          ref.current?.scrollIntoView?.({ block: "end" });
        } else {
          ref.current?.scrollIntoView?.({ block: "nearest" });
        }
      }, [isHovered, order]);
      return /* @__PURE__ */ jsx27(
        "button",
        {
          ref,
          type: "button",
          value: font.value,
          className: getDropdownMenuItemClassName("", isSelected, isHovered),
          title: font.text,
          tabIndex: isSelected ? 0 : -1,
          onClick: (e) => {
            wrappedOnSelect(Number(e.currentTarget.value));
          },
          onMouseMove: () => {
            if (hoveredFont?.value !== font.value) {
              onHover(font.value);
            }
          },
          children: /* @__PURE__ */ jsx27(
            DropdownMenuItemContent_default,
            {
              icon: font.icon,
              badge: font.badge && /* @__PURE__ */ jsx27(DropDownMenuItemBadge, { type: font.badge.type, children: font.badge.placeholder }),
              textStyle: {
                fontFamily: getFontFamilyString({ fontFamily: font.value })
              },
              children: font.text
            }
          )
        }
      );
    };
    const groups = [];
    if (sceneFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ jsx27(DropdownMenuGroup_default, { title: t("fontList.sceneFonts"), children: sceneFilteredFonts.map((font, index) => /* @__PURE__ */ jsx27(FontPickerListItem, { font, order: index }, font.value)) }, "group_1")
      );
    }
    if (availableFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ jsx27(DropdownMenuGroup_default, { title: t("fontList.availableFonts"), children: availableFilteredFonts.map((font, index) => /* @__PURE__ */ jsx27(
          FontPickerListItem,
          {
            font,
            order: index + sceneFilteredFonts.length
          },
          font.value
        )) }, "group_2")
      );
    }
    return /* @__PURE__ */ jsxs15(
      PropertiesPopover,
      {
        className: "properties-content",
        container,
        style: { width: "15rem" },
        onClose: () => {
          onClose();
          if (app.state.editingTextElement) {
            setTimeout(() => {
              const textEditor = document.querySelector(
                ".excalidraw-wysiwyg"
              );
              if (textEditor) {
                textEditor.focus();
              }
            }, 0);
          }
        },
        onPointerLeave: onLeave,
        onKeyDown,
        preventAutoFocusOnTouch: !!app.state.editingTextElement,
        children: [
          stylesPanelMode === "full" && /* @__PURE__ */ jsx27(
            QuickSearch,
            {
              ref: inputRef,
              placeholder: t("quickSearch.placeholder"),
              onChange: debounce(setSearchTerm, 20)
            }
          ),
          /* @__PURE__ */ jsx27(
            ScrollableList,
            {
              className: "dropdown-menu fonts manual-hover",
              placeholder: t("fontList.empty"),
              children: groups.length ? groups : null
            }
          )
        ]
      }
    );
  },
  (prev, next) => prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// components/FontPicker/FontPickerTrigger.tsx
import { Popover as Popover3 } from "radix-ui";
import { MOBILE_ACTION_BUTTON_BG as MOBILE_ACTION_BUTTON_BG3 } from "@excalidraw/common";
import { jsx as jsx28 } from "react/jsx-runtime";
var FontPickerTrigger = ({
  selectedFontFamily,
  isOpened = false,
  compactMode = false
}) => {
  const setAppState = useExcalidrawSetAppState();
  const compactStyle = compactMode ? {
    ...MOBILE_ACTION_BUTTON_BG3,
    width: "2rem",
    height: "2rem"
  } : {};
  return /* @__PURE__ */ jsx28(Popover3.Trigger, { asChild: true, children: /* @__PURE__ */ jsx28("div", { "data-openpopup": "fontFamily", className: "properties-trigger", children: /* @__PURE__ */ jsx28(
    ButtonIcon,
    {
      standalone: true,
      icon: TextIcon,
      title: t("labels.showFonts"),
      className: "properties-trigger",
      testId: "font-family-show-fonts",
      active: isOpened,
      onClick: () => {
        setAppState((appState) => ({
          openPopup: appState.openPopup === "fontFamily" ? null : appState.openPopup
        }));
      },
      style: {
        border: "none",
        ...compactStyle
      }
    }
  ) }) });
};

// components/FontPicker/FontPicker.tsx
import { jsx as jsx29, jsxs as jsxs16 } from "react/jsx-runtime";
var DEFAULT_FONTS = [
  {
    value: FONT_FAMILY2.Arial,
    icon: FontFamilyNormalIcon,
    text: t("labels.arial"),
    testId: "font-family-arial"
  },
  {
    value: FONT_FAMILY2.Excalifont,
    icon: FreedrawIcon,
    text: t("labels.handDrawn"),
    testId: "font-family-hand-drawn"
  },
  {
    value: FONT_FAMILY2.Nunito,
    icon: FontFamilyNormalIcon,
    text: t("labels.normal"),
    testId: "font-family-normal"
  },
  {
    value: FONT_FAMILY2["Comic Shanns"],
    icon: FontFamilyCodeIcon,
    text: t("labels.code"),
    testId: "font-family-code"
  }
];
var defaultFontFamilies = new Set(DEFAULT_FONTS.map((x) => x.value));
var FontPicker = React11.memo(
  ({
    isOpened,
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onPopupChange,
    compactMode = false
  }) => {
    const defaultFonts = useMemo2(() => DEFAULT_FONTS, []);
    const onSelectCallback = useCallback4(
      (value) => {
        if (value) {
          onSelect(value);
        }
      },
      [onSelect]
    );
    return /* @__PURE__ */ jsxs16(
      "div",
      {
        role: "dialog",
        "aria-modal": "true",
        className: clsx15("FontPicker__container", {
          "FontPicker__container--compact": compactMode
        }),
        children: [
          !compactMode && /* @__PURE__ */ jsx29("div", { className: "buttonList", children: /* @__PURE__ */ jsx29(
            RadioSelection,
            {
              type: "button",
              options: defaultFonts,
              value: selectedFontFamily,
              onClick: onSelectCallback
            }
          ) }),
          !compactMode && /* @__PURE__ */ jsx29(ButtonSeparator, {}),
          /* @__PURE__ */ jsxs16(Popover4.Root, { open: isOpened, onOpenChange: onPopupChange, children: [
            /* @__PURE__ */ jsx29(
              FontPickerTrigger,
              {
                selectedFontFamily,
                isOpened,
                compactMode
              }
            ),
            isOpened && /* @__PURE__ */ jsx29(
              FontPickerList,
              {
                selectedFontFamily,
                hoveredFontFamily,
                onSelect: onSelectCallback,
                onHover,
                onLeave,
                onOpen: () => onPopupChange(true),
                onClose: () => onPopupChange(false)
              }
            )
          ] })
        ]
      }
    );
  },
  (prev, next) => prev.isOpened === next.isOpened && prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// components/IconPicker.tsx
import { Popover as Popover5 } from "radix-ui";
import clsx16 from "clsx";
import React12, { useEffect as useEffect11 } from "react";
import { isArrowKey, KEYS as KEYS10 } from "@excalidraw/common";

// components/InlineIcon.tsx
import { jsx as jsx30 } from "react/jsx-runtime";
var InlineIcon = ({
  className,
  icon,
  size = "1em"
}) => {
  return /* @__PURE__ */ jsx30(
    "span",
    {
      className,
      style: {
        width: size,
        height: "100%",
        margin: "0 0.5ex 0 0.5ex",
        display: "inline-flex",
        lineHeight: 0,
        verticalAlign: "middle",
        flex: "0 0 auto"
      },
      children: icon
    }
  );
};

// components/Stats/Collapsible.tsx
import { Fragment as Fragment5, jsx as jsx31, jsxs as jsxs17 } from "react/jsx-runtime";
var Collapsible = ({
  label,
  open,
  openTrigger,
  children,
  className,
  showCollapsedIcon = true
}) => {
  return /* @__PURE__ */ jsxs17(Fragment5, { children: [
    /* @__PURE__ */ jsxs17(
      "div",
      {
        style: {
          cursor: "pointer",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        className,
        onClick: openTrigger,
        children: [
          label,
          showCollapsedIcon && /* @__PURE__ */ jsx31(InlineIcon, { icon: open ? collapseUpIcon : collapseDownIcon })
        ]
      }
    ),
    open && /* @__PURE__ */ jsx31("div", { style: { display: "flex", flexDirection: "column" }, children })
  ] });
};
var Collapsible_default = Collapsible;

// components/IconPicker.tsx
import { jsx as jsx32, jsxs as jsxs18 } from "react/jsx-runtime";
var moreOptionsAtom = atom(false);
function Picker2({
  options,
  value,
  label,
  onChange,
  onClose,
  numberOfOptionsToAlwaysShow = options.length
}) {
  const editorInterface = useEditorInterface();
  const { container } = useExcalidrawContainer();
  const handleKeyDown = (event) => {
    const pressedOption = options.find(
      (option) => option.keyBinding === event.key.toLowerCase()
    );
    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {
      onChange(pressedOption.value);
      event.preventDefault();
    } else if (event.key === KEYS10.TAB) {
      const index = options.findIndex((option) => option.value === value);
      const nextIndex = event.shiftKey ? (options.length + index - 1) % options.length : (index + 1) % options.length;
      onChange(options[nextIndex].value);
    } else if (isArrowKey(event.key)) {
      const isRTL2 = getLanguage().rtl;
      const index = options.findIndex((option) => option.value === value);
      if (index !== -1) {
        const length = options.length;
        let nextIndex = index;
        switch (event.key) {
          case (isRTL2 ? KEYS10.ARROW_LEFT : KEYS10.ARROW_RIGHT):
            nextIndex = (index + 1) % length;
            break;
          case (isRTL2 ? KEYS10.ARROW_RIGHT : KEYS10.ARROW_LEFT):
            nextIndex = (length + index - 1) % length;
            break;
          case KEYS10.ARROW_DOWN: {
            nextIndex = (index + (numberOfOptionsToAlwaysShow ?? 1)) % length;
            break;
          }
          case KEYS10.ARROW_UP: {
            nextIndex = (length + index - (numberOfOptionsToAlwaysShow ?? 1)) % length;
            break;
          }
        }
        onChange(options[nextIndex].value);
      }
      event.preventDefault();
    } else if (event.key === KEYS10.ESCAPE || event.key === KEYS10.ENTER) {
      event.preventDefault();
      onClose();
    }
    event.nativeEvent.stopImmediatePropagation();
    event.stopPropagation();
  };
  const [showMoreOptions, setShowMoreOptions] = useAtom(moreOptionsAtom);
  const alwaysVisibleOptions = React12.useMemo(
    () => options.slice(0, numberOfOptionsToAlwaysShow),
    [options, numberOfOptionsToAlwaysShow]
  );
  const moreOptions = React12.useMemo(
    () => options.slice(numberOfOptionsToAlwaysShow),
    [options, numberOfOptionsToAlwaysShow]
  );
  useEffect11(() => {
    if (!alwaysVisibleOptions.some((option) => option.value === value)) {
      setShowMoreOptions(true);
    }
  }, [value, alwaysVisibleOptions, setShowMoreOptions]);
  const renderOptions = (options2) => {
    return /* @__PURE__ */ jsx32("div", { className: "picker-content", children: options2.map((option, i) => /* @__PURE__ */ jsxs18(
      "button",
      {
        type: "button",
        className: clsx16("picker-option", {
          active: value === option.value
        }),
        onClick: (event) => {
          onChange(option.value);
        },
        title: `${option.text} ${option.keyBinding && `\u2014 ${option.keyBinding.toUpperCase()}`}`,
        "aria-label": option.text || "none",
        "aria-keyshortcuts": option.keyBinding || void 0,
        ref: (ref) => {
          if (value === option.value) {
            setTimeout(() => {
              ref?.focus();
            }, 0);
          }
        },
        children: [
          option.icon,
          option.keyBinding && /* @__PURE__ */ jsx32("span", { className: "picker-keybinding", children: option.keyBinding })
        ]
      },
      option.text
    )) });
  };
  const isMobile = editorInterface.formFactor === "phone";
  return /* @__PURE__ */ jsx32(
    Popover5.Content,
    {
      side: isMobile ? "right" : "bottom",
      align: "start",
      sideOffset: isMobile ? 8 : 12,
      style: { zIndex: "var(--zIndex-ui-styles-popup)" },
      onKeyDown: handleKeyDown,
      collisionBoundary: container ?? void 0,
      children: /* @__PURE__ */ jsxs18(
        "div",
        {
          className: `picker`,
          role: "dialog",
          "aria-modal": "true",
          "aria-label": label,
          children: [
            renderOptions(alwaysVisibleOptions),
            moreOptions.length > 0 && /* @__PURE__ */ jsx32(
              Collapsible_default,
              {
                label: t("labels.more_options"),
                open: showMoreOptions,
                openTrigger: () => {
                  setShowMoreOptions((value2) => !value2);
                },
                className: "picker-collapsible",
                children: renderOptions(moreOptions)
              }
            )
          ]
        }
      )
    }
  );
}
function IconPicker({
  value,
  label,
  options,
  onChange,
  group = "",
  numberOfOptionsToAlwaysShow
}) {
  const [isActive, setActive] = React12.useState(false);
  const rPickerButton = React12.useRef(null);
  return /* @__PURE__ */ jsx32("div", { children: /* @__PURE__ */ jsxs18(Popover5.Root, { open: isActive, onOpenChange: (open) => setActive(open), children: [
    /* @__PURE__ */ jsx32(
      Popover5.Trigger,
      {
        name: group,
        type: "button",
        "aria-label": label,
        onClick: () => setActive(!isActive),
        ref: rPickerButton,
        className: isActive ? "active" : "",
        children: options.find((option) => option.value === value)?.icon
      }
    ),
    isActive && /* @__PURE__ */ jsx32(
      Picker2,
      {
        options,
        value,
        label,
        onChange,
        onClose: () => {
          setActive(false);
        },
        numberOfOptionsToAlwaysShow
      }
    )
  ] }) });
}

// components/Range.tsx
import React13, { useEffect as useEffect12 } from "react";
import { jsx as jsx33, jsxs as jsxs19 } from "react/jsx-runtime";
var Range = ({ updateData, app, testId }) => {
  const rangeRef = React13.useRef(null);
  const valueRef = React13.useRef(null);
  const selectedElements = app.scene.getSelectedElements(app.state);
  let hasCommonOpacity = true;
  const firstElement = selectedElements.at(0);
  const leastCommonOpacity = selectedElements.reduce((acc, element) => {
    if (acc != null && acc !== element.opacity) {
      hasCommonOpacity = false;
    }
    if (acc == null || acc > element.opacity) {
      return element.opacity;
    }
    return acc;
  }, firstElement?.opacity ?? null);
  const value = leastCommonOpacity ?? app.state.currentItemOpacity;
  useEffect12(() => {
    if (rangeRef.current && valueRef.current) {
      const rangeElement = rangeRef.current;
      const valueElement = valueRef.current;
      const inputWidth = rangeElement.offsetWidth;
      const thumbWidth = 15;
      const position = value / 100 * (inputWidth - thumbWidth) + thumbWidth / 2;
      valueElement.style.left = `${position}px`;
      rangeElement.style.background = `linear-gradient(to right, var(--color-slider-track) 0%, var(--color-slider-track) ${value}%, var(--button-bg) ${value}%, var(--button-bg) 100%)`;
    }
  }, [value]);
  return /* @__PURE__ */ jsxs19("label", { className: "control-label", children: [
    t("labels.opacity"),
    /* @__PURE__ */ jsxs19("div", { className: "range-wrapper", children: [
      /* @__PURE__ */ jsx33(
        "input",
        {
          style: {
            ["--color-slider-track"]: hasCommonOpacity ? void 0 : "var(--button-bg)"
          },
          ref: rangeRef,
          type: "range",
          min: "0",
          max: "100",
          step: "10",
          onChange: (event) => {
            updateData(+event.target.value);
          },
          value,
          className: "range-input",
          "data-testid": testId
        }
      ),
      /* @__PURE__ */ jsx33("div", { className: "value-bubble", ref: valueRef, children: value !== 0 ? value : null }),
      /* @__PURE__ */ jsx33("div", { className: "zero-label", children: "0" })
    ] })
  ] });
};

// actions/actionProperties.tsx
import { Fragment as Fragment6, jsx as jsx34, jsxs as jsxs20 } from "react/jsx-runtime";
var FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;
var isStickyNoteElement = (el) => el.type === "rectangle" && el.customData?.isStickyNote === true;
var areOnlyStickyNotesSelected = (elements, appState) => {
  const selected = getSelectedElements(elements, appState);
  return selected.length > 0 && selected.every(isStickyNoteElement);
};
var getStylesPanelInfo = (app) => {
  const stylesPanelMode = deriveStylesPanelMode(app.editorInterface);
  return {
    stylesPanelMode,
    isCompact: stylesPanelMode !== "full",
    isMobile: stylesPanelMode === "mobile"
  };
};
var changeProperty = (elements, appState, callback, includeBoundText = false, applyToContainerWhenSingleBoundText = false) => {
  let selectedElements = getSelectedElements(elements, appState, {
    includeBoundTextElement: includeBoundText
  });
  if (applyToContainerWhenSingleBoundText && includeBoundText && selectedElements.length === 1 && isTextElement2(selectedElements[0]) && selectedElements[0].containerId) {
    const elementsMap = arrayToMap3(elements);
    const container = getContainerElement2(selectedElements[0], elementsMap);
    if (container) {
      selectedElements = [container];
    }
  }
  const selectedElementIds = arrayToMap3(selectedElements);
  return elements.map((element) => {
    if (selectedElementIds.get(element.id) || element.id === appState.editingTextElement?.id) {
      return callback(element);
    }
    return element;
  });
};
var getFormValue = function(elements, app, getAttribute, isRelevantElement, defaultValue) {
  const editingTextElement = app.state.editingTextElement;
  const nonDeletedElements = getNonDeletedElements4(elements);
  let ret = null;
  if (editingTextElement) {
    ret = getAttribute(editingTextElement);
  }
  if (!ret) {
    const hasSelection = isSomeElementSelected(nonDeletedElements, app.state);
    if (hasSelection) {
      const selectedElements = app.scene.getSelectedElements(app.state);
      const targetElements = isRelevantElement === true ? selectedElements : selectedElements.filter((el) => isRelevantElement(el));
      ret = reduceToCommonValue(targetElements, getAttribute) ?? (typeof defaultValue === "function" ? defaultValue(true) : defaultValue);
    } else {
      ret = typeof defaultValue === "function" ? defaultValue(false) : defaultValue;
    }
  }
  return ret;
};
var offsetElementAfterFontResize = (prevElement, nextElement, scene) => {
  if (isBoundToContainer2(nextElement) || !nextElement.autoResize) {
    return nextElement;
  }
  return scene.mutateElement(nextElement, {
    x: prevElement.textAlign === "left" ? prevElement.x : prevElement.x + (prevElement.width - nextElement.width) / (prevElement.textAlign === "center" ? 2 : 1),
    // centering vertically is non-standard, but for Excalidraw I think
    // it makes sense
    y: prevElement.y + (prevElement.height - nextElement.height) / 2
  });
};
var changeFontSize = (elements, appState, app, getNewFontSize, fallbackValue) => {
  const newFontSizes = /* @__PURE__ */ new Set();
  const updatedElements = changeProperty(
    elements,
    appState,
    (oldElement) => {
      if (isTextElement2(oldElement)) {
        const newFontSize = getNewFontSize(oldElement);
        newFontSizes.add(newFontSize);
        let newElement5 = newElementWith2(oldElement, {
          fontSize: newFontSize
        });
        redrawTextBoundingBox(
          newElement5,
          app.scene.getContainerElement(oldElement),
          app.scene
        );
        newElement5 = offsetElementAfterFontResize(
          oldElement,
          newElement5,
          app.scene
        );
        return newElement5;
      }
      return oldElement;
    },
    true
  );
  getSelectedElements(elements, appState, {
    includeBoundTextElement: true
  }).forEach((element) => {
    if (isTextElement2(element)) {
      updateBoundElements(element, app.scene);
    }
  });
  return {
    elements: updatedElements,
    appState: {
      ...appState,
      // update state only if we've set all select text elements to
      // the same font size
      currentItemFontSize: newFontSizes.size === 1 ? [...newFontSizes][0] : fallbackValue ?? appState.currentItemFontSize
    },
    captureUpdate: CaptureUpdateAction5.IMMEDIATELY
  };
};
var actionChangeStrokeColor = register({
  name: "changeStrokeColor",
  label: "labels.stroke",
  trackEvent: false,
  perform: (elements, appState, value) => {
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      ...value?.currentItemStrokeColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => {
            if (isTextElement2(el) && el.containerId) {
              return el;
            }
            return hasStrokeColor(el.type) ? newElementWith2(el, {
              strokeColor: value.currentItemStrokeColor
            }) : el;
          },
          true,
          true
        )
      },
      appState: {
        ...appState,
        ...onlyStickies ? {} : value
      },
      captureUpdate: !!value?.currentItemStrokeColor ? CaptureUpdateAction5.IMMEDIATELY : CaptureUpdateAction5.EVENTUALLY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => {
    const { stylesPanelMode } = getStylesPanelInfo(app);
    return /* @__PURE__ */ jsxs20(Fragment6, { children: [
      stylesPanelMode === "full" && /* @__PURE__ */ jsx34("h3", { "aria-hidden": "true", children: t("labels.stroke") }),
      /* @__PURE__ */ jsx34(
        ColorPicker,
        {
          topPicks: DEFAULT_ELEMENT_STROKE_PICKS2,
          palette: DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
          type: "elementStroke",
          label: t("labels.stroke"),
          color: getFormValue(
            elements,
            app,
            (element) => element.strokeColor,
            true,
            (hasSelection) => !hasSelection ? appState.currentItemStrokeColor : null
          ),
          onChange: (color) => updateData({ currentItemStrokeColor: color }),
          elements,
          appState,
          updateData
        }
      )
    ] });
  }
});
var actionChangeBackgroundColor = register({
  name: "changeBackgroundColor",
  label: "labels.changeBackground",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    if (!value?.currentItemBackgroundColor) {
      return {
        appState: {
          ...appState,
          ...value
        },
        captureUpdate: CaptureUpdateAction5.EVENTUALLY
      };
    }
    let nextElements;
    const selectedElements = app.scene.getSelectedElements(appState);
    const shouldEnablePolygon = !isTransparent(value.currentItemBackgroundColor) && selectedElements.every(
      (el) => isLineElement(el) && canBecomePolygon(el.points)
    );
    if (shouldEnablePolygon) {
      const selectedElementsMap = arrayToMap3(selectedElements);
      nextElements = elements.map((el) => {
        if (selectedElementsMap.has(el.id) && isLineElement(el)) {
          return newElementWith2(el, {
            backgroundColor: value.currentItemBackgroundColor,
            ...toggleLinePolygonState(el, true)
          });
        }
        return el;
      });
    } else {
      nextElements = changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          backgroundColor: value.currentItemBackgroundColor
        }),
        true,
        true
      );
    }
    const elementsAppliedTo = selectedElements.length === 1 && isTextElement2(selectedElements[0]) && selectedElements[0].containerId ? (() => {
      const container = getContainerElement2(
        selectedElements[0],
        arrayToMap3(elements)
      );
      return container ? [container] : selectedElements;
    })() : selectedElements;
    const hasStickyNote = elementsAppliedTo.some(
      (el) => el.type === "rectangle" && el.customData?.isStickyNote === true
    );
    return {
      elements: nextElements,
      appState: {
        ...appState,
        ...value,
        ...hasStickyNote && value.currentItemBackgroundColor ? { lastStickyNoteBackgroundColor: value.currentItemBackgroundColor } : {}
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => {
    const { stylesPanelMode } = getStylesPanelInfo(app);
    return /* @__PURE__ */ jsxs20(Fragment6, { children: [
      stylesPanelMode === "full" && /* @__PURE__ */ jsx34("h3", { "aria-hidden": "true", children: t("labels.background") }),
      /* @__PURE__ */ jsx34(
        ColorPicker,
        {
          topPicks: DEFAULT_ELEMENT_BACKGROUND_PICKS2,
          palette: DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
          type: "elementBackground",
          label: t("labels.background"),
          color: getFormValue(
            elements,
            app,
            (element) => element.backgroundColor,
            true,
            (hasSelection) => !hasSelection ? appState.currentItemBackgroundColor : null
          ),
          onChange: (color) => updateData({ currentItemBackgroundColor: color }),
          elements,
          appState,
          updateData
        }
      )
    ] });
  }
});
var actionChangeFillStyle = register({
  name: "changeFillStyle",
  label: "labels.fill",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    trackEvent(
      "element",
      "changeFillStyle",
      `${value} (${app.editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
    );
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          fillStyle: value
        }),
        true,
        true
      ),
      appState: {
        ...appState,
        ...onlyStickies ? {} : { currentItemFillStyle: value }
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const selectedElements = getSelectedElements(elements, appState);
    const allElementsZigZag = selectedElements.length > 0 && selectedElements.every((el) => el.fillStyle === "zigzag");
    return /* @__PURE__ */ jsxs20("fieldset", { children: [
      /* @__PURE__ */ jsx34("legend", { children: t("labels.fill") }),
      /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
        RadioSelection,
        {
          type: "button",
          options: [
            {
              value: "hachure",
              text: `${allElementsZigZag ? t("labels.zigzag") : t("labels.hachure")} (${getShortcutKey("Alt-Click")})`,
              icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,
              active: allElementsZigZag ? true : void 0,
              testId: `fill-hachure`
            },
            {
              value: "cross-hatch",
              text: t("labels.crossHatch"),
              icon: FillCrossHatchIcon,
              testId: `fill-cross-hatch`
            },
            {
              value: "solid",
              text: t("labels.solid"),
              icon: FillSolidIcon,
              testId: `fill-solid`
            }
          ],
          value: getFormValue(
            elements,
            app,
            (element) => element.fillStyle,
            (element) => element.hasOwnProperty("fillStyle"),
            (hasSelection) => hasSelection ? null : appState.currentItemFillStyle
          ),
          onClick: (value, event) => {
            const nextValue = event.altKey && value === "hachure" && selectedElements.every((el) => el.fillStyle === "hachure") ? "zigzag" : value;
            updateData(nextValue);
          }
        }
      ) })
    ] });
  }
});
var actionChangeStrokeWidth = register({
  name: "changeStrokeWidth",
  label: "labels.strokeWidth",
  trackEvent: false,
  perform: (elements, appState, value) => {
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          strokeWidth: value
        }),
        true,
        true
      ),
      appState: {
        ...appState,
        ...onlyStickies ? {} : { currentItemStrokeWidth: value }
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => /* @__PURE__ */ jsxs20("fieldset", { children: [
    /* @__PURE__ */ jsx34("legend", { children: t("labels.strokeWidth") }),
    /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
      RadioSelection,
      {
        group: "stroke-width",
        options: [
          {
            value: STROKE_WIDTH.thin,
            text: t("labels.thin"),
            icon: StrokeWidthBaseIcon,
            testId: "strokeWidth-thin"
          },
          {
            value: STROKE_WIDTH.bold,
            text: t("labels.bold"),
            icon: StrokeWidthBoldIcon,
            testId: "strokeWidth-bold"
          },
          {
            value: STROKE_WIDTH.extraBold,
            text: t("labels.extraBold"),
            icon: StrokeWidthExtraBoldIcon,
            testId: "strokeWidth-extraBold"
          }
        ],
        value: getFormValue(
          elements,
          app,
          (element) => element.strokeWidth,
          (element) => element.hasOwnProperty("strokeWidth"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeWidth
        ),
        onChange: (value) => updateData(value)
      }
    ) })
  ] })
});
var actionChangeSloppiness = register({
  name: "changeSloppiness",
  label: "labels.sloppiness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          seed: randomInteger(),
          roughness: value
        }),
        true,
        true
      ),
      appState: {
        ...appState,
        ...onlyStickies ? {} : { currentItemRoughness: value }
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => /* @__PURE__ */ jsxs20("fieldset", { children: [
    /* @__PURE__ */ jsx34("legend", { children: t("labels.sloppiness") }),
    /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
      RadioSelection,
      {
        group: "sloppiness",
        options: [
          {
            value: 0,
            text: t("labels.architect"),
            icon: SloppinessArchitectIcon
          },
          {
            value: 1,
            text: t("labels.artist"),
            icon: SloppinessArtistIcon
          },
          {
            value: 2,
            text: t("labels.cartoonist"),
            icon: SloppinessCartoonistIcon
          }
        ],
        value: getFormValue(
          elements,
          app,
          (element) => element.roughness,
          (element) => element.hasOwnProperty("roughness"),
          (hasSelection) => hasSelection ? null : appState.currentItemRoughness
        ),
        onChange: (value) => updateData(value)
      }
    ) })
  ] })
});
var actionChangeStrokeStyle = register({
  name: "changeStrokeStyle",
  label: "labels.strokeStyle",
  trackEvent: false,
  perform: (elements, appState, value) => {
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          strokeStyle: value
        }),
        true,
        true
      ),
      appState: {
        ...appState,
        ...onlyStickies ? {} : { currentItemStrokeStyle: value }
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => /* @__PURE__ */ jsxs20("fieldset", { children: [
    /* @__PURE__ */ jsx34("legend", { children: t("labels.strokeStyle") }),
    /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
      RadioSelection,
      {
        group: "strokeStyle",
        options: [
          {
            value: "solid",
            text: t("labels.strokeStyle_solid"),
            icon: StrokeWidthBaseIcon
          },
          {
            value: "dashed",
            text: t("labels.strokeStyle_dashed"),
            icon: StrokeStyleDashedIcon
          },
          {
            value: "dotted",
            text: t("labels.strokeStyle_dotted"),
            icon: StrokeStyleDottedIcon
          }
        ],
        value: getFormValue(
          elements,
          app,
          (element) => element.strokeStyle,
          (element) => element.hasOwnProperty("strokeStyle"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeStyle
        ),
        onChange: (value) => updateData(value)
      }
    ) })
  ] })
});
var actionChangeOpacity = register({
  name: "changeOpacity",
  label: "labels.opacity",
  trackEvent: false,
  perform: (elements, appState, value) => {
    const onlyStickies = areOnlyStickyNotesSelected(elements, appState);
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith2(el, {
          opacity: value
        }),
        true,
        true
      ),
      appState: {
        ...appState,
        ...onlyStickies ? {} : { currentItemOpacity: value }
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ app, updateData }) => /* @__PURE__ */ jsx34(Range, { updateData, app, testId: "opacity" })
});
var actionChangeFontSize = register(
  {
    name: "changeFontSize",
    label: "labels.fontSize",
    trackEvent: false,
    perform: (elements, appState, value, app) => {
      return changeFontSize(
        elements,
        appState,
        app,
        () => {
          invariant(value, "actionChangeFontSize: Expected a font size value");
          return value;
        },
        value
      );
    },
    PanelComponent: ({ elements, appState, updateData, app, data }) => {
      const { isCompact } = getStylesPanelInfo(app);
      return /* @__PURE__ */ jsxs20("fieldset", { children: [
        /* @__PURE__ */ jsx34("legend", { children: t("labels.fontSize") }),
        /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
          RadioSelection,
          {
            group: "font-size",
            options: [
              {
                value: FONT_SIZES.sm,
                text: t("labels.small"),
                icon: FontSizeSmallIcon,
                testId: "fontSize-small"
              },
              {
                value: FONT_SIZES.md,
                text: t("labels.medium"),
                icon: FontSizeMediumIcon,
                testId: "fontSize-medium"
              },
              {
                value: FONT_SIZES.lg,
                text: t("labels.large"),
                icon: FontSizeLargeIcon,
                testId: "fontSize-large"
              },
              {
                value: FONT_SIZES.xl,
                text: t("labels.veryLarge"),
                icon: FontSizeExtraLargeIcon,
                testId: "fontSize-veryLarge"
              }
            ],
            value: getFormValue(
              elements,
              app,
              (element) => {
                if (isTextElement2(element)) {
                  return element.fontSize;
                }
                const boundTextElement = getBoundTextElement(
                  element,
                  app.scene.getNonDeletedElementsMap()
                );
                if (boundTextElement) {
                  return boundTextElement.fontSize;
                }
                return null;
              },
              (element) => isTextElement2(element) || getBoundTextElement(
                element,
                app.scene.getNonDeletedElementsMap()
              ) !== null,
              (hasSelection) => hasSelection ? null : appState.currentItemFontSize || DEFAULT_FONT_SIZE
            ),
            onChange: (value) => {
              withCaretPositionPreservation(
                () => updateData(value),
                isCompact,
                !!appState.editingTextElement,
                data?.onPreventClose
              );
            }
          }
        ) })
      ] });
    }
  }
);
var actionDecreaseFontSize = register({
  name: "decreaseFontSize",
  label: "labels.decreaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(
        // get previous value before relative increase (doesn't work fully
        // due to rounding and float precision issues)
        1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP) * element.fontSize
      )
    );
  },
  keyTest: (event) => {
    return event[KEYS11.CTRL_OR_CMD] && event.shiftKey && // KEYS.COMMA needed for MacOS
    (event.key === KEYS11.CHEVRON_LEFT || event.key === KEYS11.COMMA);
  }
});
var actionIncreaseFontSize = register({
  name: "increaseFontSize",
  label: "labels.increaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP))
    );
  },
  keyTest: (event) => {
    return event[KEYS11.CTRL_OR_CMD] && event.shiftKey && // KEYS.PERIOD needed for MacOS
    (event.key === KEYS11.CHEVRON_RIGHT || event.key === KEYS11.PERIOD);
  }
});
var actionChangeFontFamily = register({
  name: "changeFontFamily",
  label: "labels.fontFamily",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    const { cachedElements, resetAll, resetContainers, ...nextAppState } = value;
    if (resetAll) {
      const nextElements = changeProperty(
        elements,
        appState,
        (element) => {
          const cachedElement = cachedElements?.get(element.id);
          if (cachedElement) {
            const newElement5 = newElementWith2(element, {
              ...cachedElement
            });
            return newElement5;
          }
          return element;
        },
        true
      );
      return {
        elements: nextElements,
        appState: {
          ...appState,
          ...nextAppState
        },
        captureUpdate: CaptureUpdateAction5.NEVER
      };
    }
    invariant(value, "actionChangeFontFamily: value must be defined");
    const { currentItemFontFamily, currentHoveredFontFamily } = value;
    let nextCaptureUpdateAction = CaptureUpdateAction5.EVENTUALLY;
    let nextFontFamily;
    let skipOnHoverRender = false;
    if (currentItemFontFamily) {
      nextFontFamily = currentItemFontFamily;
      nextCaptureUpdateAction = CaptureUpdateAction5.IMMEDIATELY;
    } else if (currentHoveredFontFamily) {
      nextFontFamily = currentHoveredFontFamily;
      nextCaptureUpdateAction = CaptureUpdateAction5.EVENTUALLY;
      const selectedTextElements = getSelectedElements(elements, appState, {
        includeBoundTextElement: true
      }).filter((element) => isTextElement2(element));
      if (selectedTextElements.length > 200) {
        skipOnHoverRender = true;
      } else {
        let i = 0;
        let textLengthAccumulator = 0;
        while (i < selectedTextElements.length && textLengthAccumulator < 5e3) {
          const textElement = selectedTextElements[i];
          textLengthAccumulator += textElement?.originalText.length || 0;
          i++;
        }
        if (textLengthAccumulator > 5e3) {
          skipOnHoverRender = true;
        }
      }
    }
    const result = {
      appState: {
        ...appState,
        ...nextAppState
      },
      captureUpdate: nextCaptureUpdateAction
    };
    if (nextFontFamily && !skipOnHoverRender) {
      const elementContainerMapping = /* @__PURE__ */ new Map();
      let uniqueChars = /* @__PURE__ */ new Set();
      let skipFontFaceCheck = false;
      const fontsCache = Array.from(Fonts.loadedFontsCache.values());
      const fontFamily = Object.entries(FONT_FAMILY3).find(
        ([_, value2]) => value2 === nextFontFamily
      )?.[0];
      if (currentHoveredFontFamily && fontFamily && fontsCache.some((sig) => sig.startsWith(fontFamily))) {
        skipFontFaceCheck = true;
      }
      Object.assign(result, {
        elements: changeProperty(
          elements,
          appState,
          (oldElement) => {
            if (isTextElement2(oldElement) && (oldElement.fontFamily !== nextFontFamily || currentItemFontFamily)) {
              const newElement5 = newElementWith2(
                oldElement,
                {
                  fontFamily: nextFontFamily,
                  lineHeight: getLineHeight(nextFontFamily)
                }
              );
              const cachedContainer = cachedElements?.get(oldElement.containerId || "") || {};
              const container = app.scene.getContainerElement(oldElement);
              if (resetContainers && container && cachedContainer) {
                app.scene.mutateElement(container, { ...cachedContainer });
              }
              if (!skipFontFaceCheck) {
                uniqueChars = /* @__PURE__ */ new Set([
                  ...uniqueChars,
                  ...Array.from(newElement5.originalText)
                ]);
              }
              elementContainerMapping.set(newElement5, container);
              return newElement5;
            }
            return oldElement;
          },
          true
        )
      });
      const fontString = `10px ${getFontFamilyString2({
        fontFamily: nextFontFamily
      })}`;
      const chars = Array.from(uniqueChars.values()).join();
      if (skipFontFaceCheck || window.document.fonts.check(fontString, chars)) {
        for (const [element, container] of elementContainerMapping) {
          redrawTextBoundingBox(element, container, app.scene);
        }
      } else {
        window.document.fonts.load(fontString, chars).then((fontFaces) => {
          for (const [element, container] of elementContainerMapping) {
            const latestElement = app.scene.getElement(element.id);
            const latestContainer = container ? app.scene.getElement(container.id) : null;
            if (latestElement) {
              redrawTextBoundingBox(
                latestElement,
                latestContainer,
                app.scene
              );
            }
          }
          app.fonts.onLoaded(fontFaces);
        });
      }
    }
    return result;
  },
  PanelComponent: ({ elements, appState, app, updateData }) => {
    const cachedElementsRef = useRef10(/* @__PURE__ */ new Map());
    const prevSelectedFontFamilyRef = useRef10(null);
    const [batchedData, setBatchedData] = useState7({});
    const isUnmounted = useRef10(true);
    const { stylesPanelMode, isCompact } = getStylesPanelInfo(app);
    const selectedFontFamily = useMemo3(() => {
      const getFontFamily = (elementsArray, elementsMap) => getFormValue(
        elementsArray,
        app,
        (element) => {
          if (isTextElement2(element)) {
            return element.fontFamily;
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            return boundTextElement.fontFamily;
          }
          return null;
        },
        (element) => isTextElement2(element) || getBoundTextElement(element, elementsMap) !== null,
        (hasSelection) => hasSelection ? null : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY
      );
      if (batchedData.openPopup === "fontFamily" && appState.openPopup === "fontFamily") {
        return getFontFamily(
          Array.from(cachedElementsRef.current?.values() ?? []),
          cachedElementsRef.current
        );
      }
      if (!batchedData.openPopup && appState.openPopup !== "fontFamily") {
        return getFontFamily(elements, app.scene.getNonDeletedElementsMap());
      }
      return prevSelectedFontFamilyRef.current;
    }, [batchedData.openPopup, appState, elements, app]);
    useEffect13(() => {
      prevSelectedFontFamilyRef.current = selectedFontFamily;
    }, [selectedFontFamily]);
    useEffect13(() => {
      if (Object.keys(batchedData).length) {
        updateData(batchedData);
        setBatchedData({});
      }
    }, [batchedData]);
    useEffect13(() => {
      isUnmounted.current = false;
      return () => {
        isUnmounted.current = true;
      };
    }, []);
    return /* @__PURE__ */ jsxs20(Fragment6, { children: [
      stylesPanelMode === "full" && /* @__PURE__ */ jsx34("legend", { children: t("labels.fontFamily") }),
      /* @__PURE__ */ jsx34(
        FontPicker,
        {
          isOpened: appState.openPopup === "fontFamily",
          selectedFontFamily,
          hoveredFontFamily: appState.currentHoveredFontFamily,
          compactMode: stylesPanelMode !== "full",
          onSelect: (fontFamily) => {
            withCaretPositionPreservation(
              () => {
                setBatchedData({
                  openPopup: null,
                  currentHoveredFontFamily: null,
                  currentItemFontFamily: fontFamily
                });
                cachedElementsRef.current.clear();
              },
              isCompact,
              !!appState.editingTextElement
            );
          },
          onHover: (fontFamily) => {
            setBatchedData({
              currentHoveredFontFamily: fontFamily,
              cachedElements: new Map(cachedElementsRef.current),
              resetContainers: true
            });
          },
          onLeave: () => {
            setBatchedData({
              currentHoveredFontFamily: null,
              cachedElements: new Map(cachedElementsRef.current),
              resetAll: true
            });
          },
          onPopupChange: (open) => {
            if (open) {
              cachedElementsRef.current.clear();
              const { editingTextElement } = appState;
              if (editingTextElement?.type === "text") {
                const latesteditingTextElement = app.scene.getElement(
                  editingTextElement.id
                );
                cachedElementsRef.current.set(
                  editingTextElement.id,
                  newElementWith2(
                    latesteditingTextElement || editingTextElement,
                    {},
                    true
                  )
                );
              } else {
                const selectedElements = getSelectedElements(
                  elements,
                  appState,
                  {
                    includeBoundTextElement: true
                  }
                );
                for (const element of selectedElements) {
                  cachedElementsRef.current.set(
                    element.id,
                    newElementWith2(element, {}, true)
                  );
                }
              }
              setBatchedData({
                ...batchedData,
                openPopup: "fontFamily"
              });
            } else {
              const fontFamilyData = {
                currentHoveredFontFamily: null,
                cachedElements: new Map(cachedElementsRef.current),
                resetAll: true
              };
              setBatchedData({
                ...fontFamilyData
              });
              cachedElementsRef.current.clear();
              if (isCompact && appState.editingTextElement) {
                restoreCaretPosition(null);
              }
            }
          }
        }
      )
    ] });
  }
});
var actionChangeTextAlign = register({
  name: "changeTextAlign",
  label: "Change text alignment",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement2(oldElement)) {
            const newElement5 = newElementWith2(
              oldElement,
              { textAlign: value }
            );
            redrawTextBoundingBox(
              newElement5,
              app.scene.getContainerElement(oldElement),
              app.scene
            );
            return newElement5;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState,
        currentItemTextAlign: value
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => {
    const elementsMap = app.scene.getNonDeletedElementsMap();
    const { isCompact } = getStylesPanelInfo(app);
    return /* @__PURE__ */ jsxs20("fieldset", { children: [
      /* @__PURE__ */ jsx34("legend", { children: t("labels.textAlign") }),
      /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
        RadioSelection,
        {
          group: "text-align",
          options: [
            {
              value: "left",
              text: t("labels.left"),
              icon: TextAlignLeftIcon,
              testId: "align-left"
            },
            {
              value: "center",
              text: t("labels.center"),
              icon: TextAlignCenterIcon,
              testId: "align-horizontal-center"
            },
            {
              value: "right",
              text: t("labels.right"),
              icon: TextAlignRightIcon,
              testId: "align-right"
            }
          ],
          value: getFormValue(
            elements,
            app,
            (element) => {
              if (isTextElement2(element)) {
                return element.textAlign;
              }
              const boundTextElement = getBoundTextElement(
                element,
                elementsMap
              );
              if (boundTextElement) {
                return boundTextElement.textAlign;
              }
              return null;
            },
            (element) => isTextElement2(element) || getBoundTextElement(element, elementsMap) !== null,
            (hasSelection) => hasSelection ? null : appState.currentItemTextAlign
          ),
          onChange: (value) => {
            withCaretPositionPreservation(
              () => updateData(value),
              isCompact,
              !!appState.editingTextElement,
              data?.onPreventClose
            );
          }
        }
      ) })
    ] });
  }
});
var actionChangeVerticalAlign = register({
  name: "changeVerticalAlign",
  label: "Change vertical alignment",
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement2(oldElement)) {
            const newElement5 = newElementWith2(
              oldElement,
              { verticalAlign: value }
            );
            redrawTextBoundingBox(
              newElement5,
              app.scene.getContainerElement(oldElement),
              app.scene
            );
            return newElement5;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, data }) => {
    const { isCompact } = getStylesPanelInfo(app);
    return /* @__PURE__ */ jsx34("fieldset", { children: /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
      RadioSelection,
      {
        group: "text-align",
        options: [
          {
            value: VERTICAL_ALIGN.TOP,
            text: t("labels.alignTop"),
            icon: /* @__PURE__ */ jsx34(TextAlignTopIcon, { theme: appState.theme }),
            testId: "align-top"
          },
          {
            value: VERTICAL_ALIGN.MIDDLE,
            text: t("labels.centerVertically"),
            icon: /* @__PURE__ */ jsx34(TextAlignMiddleIcon, { theme: appState.theme }),
            testId: "align-middle"
          },
          {
            value: VERTICAL_ALIGN.BOTTOM,
            text: t("labels.alignBottom"),
            icon: /* @__PURE__ */ jsx34(TextAlignBottomIcon, { theme: appState.theme }),
            testId: "align-bottom"
          }
        ],
        value: getFormValue(
          elements,
          app,
          (element) => {
            if (isTextElement2(element) && element.containerId) {
              return element.verticalAlign;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.verticalAlign;
            }
            return null;
          },
          (element) => isTextElement2(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : VERTICAL_ALIGN.MIDDLE
        ),
        onChange: (value) => {
          withCaretPositionPreservation(
            () => updateData(value),
            isCompact,
            !!appState.editingTextElement,
            data?.onPreventClose
          );
        }
      }
    ) }) });
  }
});
var actionChangeRoundness = register({
  name: "changeRoundness",
  label: "Change edge roundness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => {
          if (isElbowArrow2(el)) {
            return el;
          }
          return newElementWith2(el, {
            roundness: value === "round" ? {
              type: isUsingAdaptiveRadius(el.type) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
            } : null
          });
        },
        true,
        true
      ),
      appState: {
        ...appState,
        currentItemRoundness: value
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app, renderAction }) => {
    const targetElements = getTargetElements(
      getNonDeletedElements4(elements),
      appState
    );
    const hasLegacyRoundness = targetElements.some(
      (el) => el.roundness?.type === ROUNDNESS.LEGACY
    );
    return /* @__PURE__ */ jsxs20("fieldset", { children: [
      /* @__PURE__ */ jsx34("legend", { children: t("labels.edges") }),
      /* @__PURE__ */ jsxs20("div", { className: "buttonList", children: [
        /* @__PURE__ */ jsx34(
          RadioSelection,
          {
            group: "edges",
            options: [
              {
                value: "sharp",
                text: t("labels.sharp"),
                icon: EdgeSharpIcon
              },
              {
                value: "round",
                text: t("labels.round"),
                icon: EdgeRoundIcon
              }
            ],
            value: getFormValue(
              elements,
              app,
              (element) => hasLegacyRoundness ? null : element.roundness ? "round" : "sharp",
              (element) => !isArrowElement(element) && element.hasOwnProperty("roundness"),
              (hasSelection) => hasSelection ? null : appState.currentItemRoundness
            ),
            onChange: (value) => updateData(value)
          }
        ),
        renderAction("togglePolygon")
      ] })
    ] });
  }
});
var getArrowheadOptions = (flip) => {
  return [
    {
      value: null,
      text: t("labels.arrowhead_none"),
      keyBinding: "q",
      icon: ArrowheadNoneIcon
    },
    {
      value: "arrow",
      text: t("labels.arrowhead_arrow"),
      keyBinding: "w",
      icon: /* @__PURE__ */ jsx34(ArrowheadArrowIcon, { flip })
    },
    {
      value: "triangle",
      text: t("labels.arrowhead_triangle"),
      icon: /* @__PURE__ */ jsx34(ArrowheadTriangleIcon, { flip }),
      keyBinding: "e"
    },
    {
      value: "triangle_outline",
      text: t("labels.arrowhead_triangle_outline"),
      icon: /* @__PURE__ */ jsx34(ArrowheadTriangleOutlineIcon, { flip }),
      keyBinding: "r"
    },
    {
      value: "circle",
      text: t("labels.arrowhead_circle"),
      keyBinding: "a",
      icon: /* @__PURE__ */ jsx34(ArrowheadCircleIcon, { flip })
    },
    {
      value: "circle_outline",
      text: t("labels.arrowhead_circle_outline"),
      keyBinding: "s",
      icon: /* @__PURE__ */ jsx34(ArrowheadCircleOutlineIcon, { flip })
    },
    {
      value: "diamond",
      text: t("labels.arrowhead_diamond"),
      icon: /* @__PURE__ */ jsx34(ArrowheadDiamondIcon, { flip }),
      keyBinding: "d"
    },
    {
      value: "diamond_outline",
      text: t("labels.arrowhead_diamond_outline"),
      icon: /* @__PURE__ */ jsx34(ArrowheadDiamondOutlineIcon, { flip }),
      keyBinding: "f"
    },
    {
      value: "bar",
      text: t("labels.arrowhead_bar"),
      keyBinding: "z",
      icon: /* @__PURE__ */ jsx34(ArrowheadBarIcon, { flip })
    },
    {
      value: "crowfoot_one",
      text: t("labels.arrowhead_crowfoot_one"),
      icon: /* @__PURE__ */ jsx34(ArrowheadCrowfootOneIcon, { flip }),
      keyBinding: "x"
    },
    {
      value: "crowfoot_many",
      text: t("labels.arrowhead_crowfoot_many"),
      icon: /* @__PURE__ */ jsx34(ArrowheadCrowfootIcon, { flip }),
      keyBinding: "c"
    },
    {
      value: "crowfoot_one_or_many",
      text: t("labels.arrowhead_crowfoot_one_or_many"),
      icon: /* @__PURE__ */ jsx34(ArrowheadCrowfootOneOrManyIcon, { flip }),
      keyBinding: "v"
    }
  ];
};
var actionChangeArrowhead = register({
  name: "changeArrowhead",
  label: "Change arrowheads",
  trackEvent: false,
  perform: (elements, appState, value) => {
    invariant(value, "actionChangeArrowhead: value must be defined");
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isLinearElement2(el)) {
          const { position, type } = value;
          if (position === "start") {
            const element = newElementWith2(el, {
              startArrowhead: type
            });
            return element;
          } else if (position === "end") {
            const element = newElementWith2(el, {
              endArrowhead: type
            });
            return element;
          }
        }
        return el;
      }),
      appState: {
        ...appState,
        [value.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: value.type
      },
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const isRTL2 = getLanguage().rtl;
    return /* @__PURE__ */ jsxs20("fieldset", { children: [
      /* @__PURE__ */ jsx34("legend", { children: t("labels.arrowheads") }),
      /* @__PURE__ */ jsxs20("div", { className: "iconSelectList buttonList", children: [
        /* @__PURE__ */ jsx34(
          IconPicker,
          {
            label: "arrowhead_start",
            options: getArrowheadOptions(!isRTL2),
            value: getFormValue(
              elements,
              app,
              (element) => isLinearElement2(element) && canHaveArrowheads(element.type) ? element.startArrowhead : appState.currentItemStartArrowhead,
              true,
              (hasSelection) => hasSelection ? null : appState.currentItemStartArrowhead
            ),
            onChange: (value) => updateData({ position: "start", type: value }),
            numberOfOptionsToAlwaysShow: 4
          }
        ),
        /* @__PURE__ */ jsx34(
          IconPicker,
          {
            label: "arrowhead_end",
            group: "arrowheads",
            options: getArrowheadOptions(!!isRTL2),
            value: getFormValue(
              elements,
              app,
              (element) => isLinearElement2(element) && canHaveArrowheads(element.type) ? element.endArrowhead : appState.currentItemEndArrowhead,
              true,
              (hasSelection) => hasSelection ? null : appState.currentItemEndArrowhead
            ),
            onChange: (value) => updateData({ position: "end", type: value }),
            numberOfOptionsToAlwaysShow: 4
          }
        )
      ] })
    ] });
  }
});
var actionChangeArrowProperties = register({
  name: "changeArrowProperties",
  label: "Change arrow properties",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return false;
  },
  PanelComponent: ({ elements, appState, updateData, app, renderAction }) => {
    return /* @__PURE__ */ jsxs20("div", { className: "selected-shape-actions", children: [
      renderAction("changeArrowhead"),
      renderAction("changeArrowType")
    ] });
  }
});
var actionChangeArrowType = register({
  name: "changeArrowType",
  label: "Change arrow types",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    const newElements = changeProperty(elements, appState, (el) => {
      if (!isArrowElement(el)) {
        return el;
      }
      const elementsMap = app.scene.getNonDeletedElementsMap();
      const startPoint = LinearElementEditor4.getPointAtIndexGlobalCoordinates(
        el,
        0,
        elementsMap
      );
      const endPoint = LinearElementEditor4.getPointAtIndexGlobalCoordinates(
        el,
        -1,
        elementsMap
      );
      let newElement5 = newElementWith2(el, {
        x: value === ARROW_TYPE.elbow ? startPoint[0] : el.x,
        y: value === ARROW_TYPE.elbow ? startPoint[1] : el.y,
        roundness: value === ARROW_TYPE.round ? {
          type: ROUNDNESS.PROPORTIONAL_RADIUS
        } : null,
        elbowed: value === ARROW_TYPE.elbow,
        angle: value === ARROW_TYPE.elbow ? 0 : el.angle,
        points: value === ARROW_TYPE.elbow || el.elbowed ? [
          LinearElementEditor4.pointFromAbsoluteCoords(
            {
              ...el,
              x: startPoint[0],
              y: startPoint[1],
              angle: 0
            },
            startPoint,
            elementsMap
          ),
          LinearElementEditor4.pointFromAbsoluteCoords(
            {
              ...el,
              x: startPoint[0],
              y: startPoint[1],
              angle: 0
            },
            endPoint,
            elementsMap
          )
        ] : el.points
      });
      if (isElbowArrow2(newElement5)) {
        newElement5.fixedSegments = null;
        const elementsMap2 = app.scene.getNonDeletedElementsMap();
        app.dismissLinearEditor();
        const startGlobalPoint = LinearElementEditor4.getPointAtIndexGlobalCoordinates(
          newElement5,
          0,
          elementsMap2
        );
        const endGlobalPoint = LinearElementEditor4.getPointAtIndexGlobalCoordinates(
          newElement5,
          -1,
          elementsMap2
        );
        const startElement = newElement5.startBinding && elementsMap2.get(
          newElement5.startBinding.elementId
        );
        const endElement = newElement5.endBinding && elementsMap2.get(
          newElement5.endBinding.elementId
        );
        const startBinding = startElement && newElement5.startBinding ? {
          // @ts-ignore TS cannot discern check above
          ...newElement5.startBinding,
          ...calculateFixedPointForElbowArrowBinding(
            newElement5,
            startElement,
            "start",
            elementsMap2
          )
        } : null;
        const endBinding = endElement && newElement5.endBinding ? {
          // @ts-ignore TS cannot discern check above
          ...newElement5.endBinding,
          ...calculateFixedPointForElbowArrowBinding(
            newElement5,
            endElement,
            "end",
            elementsMap2
          )
        } : null;
        newElement5 = {
          ...newElement5,
          startBinding,
          endBinding,
          ...updateElbowArrowPoints(newElement5, elementsMap2, {
            points: [startGlobalPoint, endGlobalPoint].map(
              (p) => pointFrom(p[0] - newElement5.x, p[1] - newElement5.y)
            ),
            startBinding,
            endBinding,
            fixedSegments: null
          })
        };
      } else {
        const elementsMap2 = app.scene.getNonDeletedElementsMap();
        if (newElement5.startBinding) {
          const startElement = elementsMap2.get(
            newElement5.startBinding.elementId
          );
          if (startElement) {
            bindBindingElement(
              newElement5,
              startElement,
              appState.bindMode === "inside" ? "inside" : "orbit",
              "start",
              app.scene
            );
          }
        }
        if (newElement5.endBinding) {
          const endElement = elementsMap2.get(
            newElement5.endBinding.elementId
          );
          if (endElement) {
            bindBindingElement(
              newElement5,
              endElement,
              appState.bindMode === "inside" ? "inside" : "orbit",
              "end",
              app.scene
            );
          }
        }
      }
      return newElement5;
    });
    const newState = {
      ...appState,
      currentItemArrowType: value
    };
    const selectedId = appState.selectedLinearElement?.elementId;
    if (selectedId) {
      const selected = newElements.find((el) => el.id === selectedId);
      if (selected) {
        newState.selectedLinearElement = new LinearElementEditor4(
          selected,
          arrayToMap3(elements)
        );
      }
    }
    return {
      elements: newElements,
      appState: newState,
      captureUpdate: CaptureUpdateAction5.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    return /* @__PURE__ */ jsxs20("fieldset", { children: [
      /* @__PURE__ */ jsx34("legend", { children: t("labels.arrowtypes") }),
      /* @__PURE__ */ jsx34("div", { className: "buttonList", children: /* @__PURE__ */ jsx34(
        RadioSelection,
        {
          group: "arrowtypes",
          options: [
            {
              value: ARROW_TYPE.sharp,
              text: t("labels.arrowtype_sharp"),
              icon: sharpArrowIcon,
              testId: "sharp-arrow"
            },
            {
              value: ARROW_TYPE.round,
              text: t("labels.arrowtype_round"),
              icon: roundArrowIcon,
              testId: "round-arrow"
            },
            {
              value: ARROW_TYPE.elbow,
              text: t("labels.arrowtype_elbowed"),
              icon: elbowArrowIcon,
              testId: "elbow-arrow"
            }
          ],
          value: getFormValue(
            elements,
            app,
            (element) => {
              if (isArrowElement(element)) {
                return element.elbowed ? ARROW_TYPE.elbow : element.roundness ? ARROW_TYPE.round : ARROW_TYPE.sharp;
              }
              return null;
            },
            (element) => isArrowElement(element),
            (hasSelection) => hasSelection ? null : appState.currentItemArrowType
          ),
          onChange: (value) => updateData(value)
        }
      ) })
    ] });
  }
});

// actions/actionCanvas.tsx
import { clamp, roundToStep } from "@excalidraw/math";
import {
  DEFAULT_CANVAS_BACKGROUND_PICKS as DEFAULT_CANVAS_BACKGROUND_PICKS2,
  CURSOR_TYPE as CURSOR_TYPE2,
  MAX_ZOOM,
  MIN_ZOOM,
  THEME as THEME5,
  ZOOM_STEP,
  updateActiveTool as updateActiveTool2,
  CODES as CODES2,
  KEYS as KEYS12
} from "@excalidraw/common";
import { getNonDeletedElements as getNonDeletedElements5 } from "@excalidraw/element";
import { newElementWith as newElementWith3 } from "@excalidraw/element";
import { getCommonBounds } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction6 } from "@excalidraw/element";

// components/Tooltip.tsx
import { useEffect as useEffect14 } from "react";
import { jsx as jsx35 } from "react/jsx-runtime";
var getTooltipDiv = () => {
  const existingDiv = document.querySelector(
    ".excalidraw-tooltip"
  );
  if (existingDiv) {
    return existingDiv;
  }
  const div = document.createElement("div");
  document.body.appendChild(div);
  div.classList.add("excalidraw-tooltip");
  return div;
};
var updateTooltipPosition = (tooltip, item, position = "bottom") => {
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const margin = 5;
  let left = item.left + item.width / 2 - tooltipRect.width / 2;
  if (left < 0) {
    left = margin;
  } else if (left + tooltipRect.width >= viewportWidth) {
    left = viewportWidth - tooltipRect.width - margin;
  }
  let top;
  if (position === "bottom") {
    top = item.top + item.height + margin;
    if (top + tooltipRect.height >= viewportHeight) {
      top = item.top - tooltipRect.height - margin;
    }
  } else {
    top = item.top - tooltipRect.height - margin;
    if (top < 0) {
      top = item.top + item.height + margin;
    }
  }
  Object.assign(tooltip.style, {
    top: `${top}px`,
    left: `${left}px`
  });
};
var updateTooltip = (item, tooltip, label, long) => {
  tooltip.classList.add("excalidraw-tooltip--visible");
  tooltip.style.minWidth = long ? "50ch" : "10ch";
  tooltip.style.maxWidth = long ? "50ch" : "15ch";
  tooltip.textContent = label;
  const itemRect = item.getBoundingClientRect();
  updateTooltipPosition(tooltip, itemRect);
};
var Tooltip = ({
  children,
  label,
  long = false,
  style,
  disabled
}) => {
  useEffect14(() => {
    return () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }, []);
  if (disabled) {
    return null;
  }
  return /* @__PURE__ */ jsx35(
    "div",
    {
      className: "excalidraw-tooltip-wrapper",
      onPointerEnter: (event) => updateTooltip(
        event.currentTarget,
        getTooltipDiv(),
        label,
        long
      ),
      onPointerLeave: () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible"),
      style,
      children
    }
  );
};

// cursor.ts
import { CURSOR_TYPE, MIME_TYPES, THEME as THEME4 } from "@excalidraw/common";
var laserPointerCursorSVG_tag = `<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">`;
var laserPointerCursorBackgroundSVG = `<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>`;
var laserPointerCursorIconSVG = `<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>`;
var laserPointerCursorDataURL_lightMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `${laserPointerCursorSVG_tag}${laserPointerCursorIconSVG}</svg>`
)}`;
var laserPointerCursorDataURL_darkMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
  `${laserPointerCursorSVG_tag}${laserPointerCursorBackgroundSVG}${laserPointerCursorIconSVG}</svg>`
)}`;
var resetCursor = (interactiveCanvas) => {
  if (interactiveCanvas) {
    interactiveCanvas.style.cursor = "";
  }
};
var setCursor = (interactiveCanvas, cursor) => {
  if (interactiveCanvas) {
    interactiveCanvas.style.cursor = cursor;
  }
};
var eraserCanvasCache;
var previewDataURL;
var setEraserCursor = (interactiveCanvas, theme) => {
  const cursorImageSizePx = 20;
  const drawCanvas = () => {
    const isDarkTheme = theme === THEME4.DARK;
    eraserCanvasCache = document.createElement("canvas");
    eraserCanvasCache.theme = theme;
    eraserCanvasCache.height = cursorImageSizePx;
    eraserCanvasCache.width = cursorImageSizePx;
    const context = eraserCanvasCache.getContext("2d");
    context.lineWidth = 1;
    context.beginPath();
    context.arc(
      eraserCanvasCache.width / 2,
      eraserCanvasCache.height / 2,
      5,
      0,
      2 * Math.PI
    );
    context.fillStyle = isDarkTheme ? "#000" : "#fff";
    context.fill();
    context.strokeStyle = isDarkTheme ? "#fff" : "#000";
    context.stroke();
    previewDataURL = eraserCanvasCache.toDataURL(MIME_TYPES.svg);
  };
  if (!eraserCanvasCache || eraserCanvasCache.theme !== theme) {
    drawCanvas();
  }
  setCursor(
    interactiveCanvas,
    `url(${previewDataURL}) ${cursorImageSizePx / 2} ${cursorImageSizePx / 2}, auto`
  );
};
var setCursorForShape = (interactiveCanvas, appState) => {
  if (!interactiveCanvas) {
    return;
  }
  if (appState.activeTool.type === "selection") {
    resetCursor(interactiveCanvas);
  } else if (isHandToolActive(appState)) {
    interactiveCanvas.style.cursor = CURSOR_TYPE.GRAB;
  } else if (isEraserActive(appState)) {
    setEraserCursor(interactiveCanvas, appState.theme);
  } else if (appState.activeTool.type === "laser") {
    const url = appState.theme === THEME4.LIGHT ? laserPointerCursorDataURL_lightMode : laserPointerCursorDataURL_darkMode;
    interactiveCanvas.style.cursor = `url(${url}), auto`;
  } else if (!["image", "custom"].includes(appState.activeTool.type)) {
    interactiveCanvas.style.cursor = CURSOR_TYPE.CROSSHAIR;
  } else if (appState.activeTool.type !== "image") {
    interactiveCanvas.style.cursor = CURSOR_TYPE.AUTO;
  }
};

// scene/zoom.ts
var getStateForZoom = ({
  viewportX,
  viewportY,
  nextZoom
}, appState) => {
  const appLayerX = viewportX - appState.offsetLeft;
  const appLayerY = viewportY - appState.offsetTop;
  const currentZoom = appState.zoom.value;
  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);
  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);
  return {
    scrollX: baseScrollX + zoomOffsetScrollX,
    scrollY: baseScrollY + zoomOffsetScrollY,
    zoom: {
      value: nextZoom
    }
  };
};

// actions/actionCanvas.tsx
import { jsx as jsx36, jsxs as jsxs21 } from "react/jsx-runtime";
var actionChangeViewBackgroundColor = register({
  name: "changeViewBackgroundColor",
  label: "labels.canvasBackground",
  trackEvent: false,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.changeViewBackgroundColor && !appState.viewModeEnabled;
  },
  perform: (_, appState, value) => {
    return {
      appState: { ...appState, ...value },
      captureUpdate: !!value?.viewBackgroundColor ? CaptureUpdateAction6.IMMEDIATELY : CaptureUpdateAction6.EVENTUALLY
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps, data }) => {
    return /* @__PURE__ */ jsx36(
      ColorPicker,
      {
        palette: null,
        topPicks: DEFAULT_CANVAS_BACKGROUND_PICKS2,
        label: t("labels.canvasBackground"),
        type: "canvasBackground",
        color: appState.viewBackgroundColor,
        onChange: (color) => updateData({ viewBackgroundColor: color }),
        "data-testid": "canvas-background-picker",
        elements,
        appState,
        updateData
      }
    );
  }
});
var actionClearCanvas = register({
  name: "clearCanvas",
  label: "labels.clearCanvas",
  icon: TrashIcon,
  trackEvent: { category: "canvas" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.clearCanvas && !appState.viewModeEnabled && appState.openDialog?.name !== "elementLinkSelector";
  },
  perform: (elements, appState, _, app) => {
    app.imageCache.clear();
    return {
      elements: elements.map(
        (element) => newElementWith3(element, { isDeleted: true })
      ),
      appState: {
        ...getDefaultAppState(),
        files: {},
        theme: appState.theme,
        penMode: appState.penMode,
        penDetected: appState.penDetected,
        exportBackground: appState.exportBackground,
        exportEmbedScene: appState.exportEmbedScene,
        gridSize: appState.gridSize,
        gridStep: appState.gridStep,
        gridModeEnabled: appState.gridModeEnabled,
        stats: appState.stats,
        pasteDialog: appState.pasteDialog,
        activeTool: appState.activeTool.type === "image" ? {
          ...appState.activeTool,
          type: app.state.preferredSelectionTool.type
        } : appState.activeTool
      },
      captureUpdate: CaptureUpdateAction6.IMMEDIATELY
    };
  }
});
var actionZoomIn = register({
  name: "zoomIn",
  label: "buttons.zoomIn",
  viewMode: true,
  icon: ZoomInIcon,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      captureUpdate: CaptureUpdateAction6.EVENTUALLY
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx36(
    ToolButton,
    {
      type: "button",
      className: "zoom-in-button zoom-button",
      icon: ZoomInIcon,
      title: `${t("buttons.zoomIn")} \u2014 ${getShortcutKey("CtrlOrCmd++")}`,
      "aria-label": t("buttons.zoomIn"),
      disabled: appState.zoom.value >= MAX_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES2.EQUAL || event.code === CODES2.NUM_ADD) && (event[KEYS12.CTRL_OR_CMD] || event.shiftKey)
});
var actionZoomOut = register({
  name: "zoomOut",
  label: "buttons.zoomOut",
  icon: ZoomOutIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      captureUpdate: CaptureUpdateAction6.EVENTUALLY
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx36(
    ToolButton,
    {
      type: "button",
      className: "zoom-out-button zoom-button",
      icon: ZoomOutIcon,
      title: `${t("buttons.zoomOut")} \u2014 ${getShortcutKey("CtrlOrCmd+-")}`,
      "aria-label": t("buttons.zoomOut"),
      disabled: appState.zoom.value <= MIN_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES2.MINUS || event.code === CODES2.NUM_SUBTRACT) && (event[KEYS12.CTRL_OR_CMD] || event.shiftKey)
});
var actionResetZoom = register({
  name: "resetZoom",
  label: "buttons.resetZoom",
  icon: ZoomResetIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(1)
          },
          appState
        ),
        userToFollow: null
      },
      captureUpdate: CaptureUpdateAction6.EVENTUALLY
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx36(Tooltip, { label: t("buttons.resetZoom"), style: { height: "100%" }, children: /* @__PURE__ */ jsxs21(
    ToolButton,
    {
      type: "button",
      className: "reset-zoom-button zoom-button",
      title: t("buttons.resetZoom"),
      "aria-label": t("buttons.resetZoom"),
      onClick: () => {
        updateData(null);
      },
      children: [
        (appState.zoom.value * 100).toFixed(0),
        "%"
      ]
    }
  ) }),
  keyTest: (event) => (event.code === CODES2.ZERO || event.code === CODES2.NUM_ZERO) && (event[KEYS12.CTRL_OR_CMD] || event.shiftKey)
});
var zoomValueToFitBoundsOnViewport = (bounds, viewportDimensions, viewportZoomFactor = 1) => {
  const [x1, y1, x2, y2] = bounds;
  const commonBoundsWidth = x2 - x1;
  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;
  const commonBoundsHeight = y2 - y1;
  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;
  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);
  const adjustedZoomValue = smallestZoomValue * clamp(viewportZoomFactor, 0.1, 1);
  return Math.min(adjustedZoomValue, 1);
};
var zoomToFitBounds = ({
  bounds,
  appState,
  canvasOffsets,
  fitToViewport = false,
  viewportZoomFactor = 1,
  minZoom = -Infinity,
  maxZoom = Infinity
}) => {
  viewportZoomFactor = clamp(viewportZoomFactor, MIN_ZOOM, MAX_ZOOM);
  const [x1, y1, x2, y2] = bounds;
  const centerX = (x1 + x2) / 2;
  const centerY = (y1 + y2) / 2;
  const canvasOffsetLeft = canvasOffsets?.left ?? 0;
  const canvasOffsetTop = canvasOffsets?.top ?? 0;
  const canvasOffsetRight = canvasOffsets?.right ?? 0;
  const canvasOffsetBottom = canvasOffsets?.bottom ?? 0;
  const effectiveCanvasWidth = appState.width - canvasOffsetLeft - canvasOffsetRight;
  const effectiveCanvasHeight = appState.height - canvasOffsetTop - canvasOffsetBottom;
  let adjustedZoomValue;
  if (fitToViewport) {
    const commonBoundsWidth = x2 - x1;
    const commonBoundsHeight = y2 - y1;
    adjustedZoomValue = Math.min(
      effectiveCanvasWidth / commonBoundsWidth,
      effectiveCanvasHeight / commonBoundsHeight
    ) * viewportZoomFactor;
  } else {
    adjustedZoomValue = zoomValueToFitBoundsOnViewport(
      bounds,
      {
        width: effectiveCanvasWidth,
        height: effectiveCanvasHeight
      },
      viewportZoomFactor
    );
  }
  const newZoomValue = getNormalizedZoom(
    clamp(roundToStep(adjustedZoomValue, ZOOM_STEP, "floor"), minZoom, maxZoom)
  );
  const centerScroll = centerScrollOn({
    scenePoint: { x: centerX, y: centerY },
    viewportDimensions: {
      width: appState.width,
      height: appState.height
    },
    offsets: canvasOffsets,
    zoom: { value: newZoomValue }
  });
  return {
    appState: {
      ...appState,
      scrollX: centerScroll.scrollX,
      scrollY: centerScroll.scrollY,
      zoom: { value: newZoomValue }
    },
    captureUpdate: CaptureUpdateAction6.EVENTUALLY
  };
};
var zoomToFit = ({
  canvasOffsets,
  targetElements,
  appState,
  fitToViewport,
  viewportZoomFactor,
  minZoom,
  maxZoom
}) => {
  const commonBounds = getCommonBounds(getNonDeletedElements5(targetElements));
  return zoomToFitBounds({
    canvasOffsets,
    bounds: commonBounds,
    appState,
    fitToViewport,
    viewportZoomFactor,
    minZoom,
    maxZoom
  });
};
var actionZoomToFitSelectionInViewport = register({
  name: "zoomToFitSelectionInViewport",
  label: "labels.zoomToFitViewport",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: false,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE shift-2 should have been assigned actionZoomToFitSelection.
  // TBD on how proceed
  keyTest: (event) => event.code === CODES2.TWO && event.shiftKey && !event.altKey && !event[KEYS12.CTRL_OR_CMD]
});
var actionZoomToFitSelection = register({
  name: "zoomToFitSelection",
  label: "helpDialog.zoomToSelection",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: true,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE this action should use shift-2 per figma, alas
  keyTest: (event) => event.code === CODES2.THREE && event.shiftKey && !event.altKey && !event[KEYS12.CTRL_OR_CMD]
});
var actionZoomToFit = register({
  name: "zoomToFit",
  label: "helpDialog.zoomToFit",
  icon: zoomAreaIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => zoomToFit({
    targetElements: elements,
    appState: {
      ...appState,
      userToFollow: null
    },
    fitToViewport: false,
    canvasOffsets: app.getEditorUIOffsets()
  }),
  keyTest: (event) => event.code === CODES2.ONE && event.shiftKey && !event.altKey && !event[KEYS12.CTRL_OR_CMD]
});
var actionToggleTheme = register({
  name: "toggleTheme",
  label: (_, appState) => {
    return appState.theme === THEME5.DARK ? "buttons.lightMode" : "buttons.darkMode";
  },
  keywords: ["toggle", "dark", "light", "mode", "theme"],
  icon: (appState, elements) => appState.theme === THEME5.LIGHT ? MoonIcon : SunIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_, appState, value) => {
    return {
      appState: {
        ...appState,
        theme: value || (appState.theme === THEME5.LIGHT ? THEME5.DARK : THEME5.LIGHT)
      },
      captureUpdate: CaptureUpdateAction6.EVENTUALLY
    };
  },
  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES2.D,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.toggleTheme;
  }
});
var actionToggleEraserTool = register({
  name: "toggleEraserTool",
  label: "toolBar.eraser",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (isEraserActive(appState)) {
      activeTool = updateActiveTool2(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: app.state.preferredSelectionTool.type
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool2(appState, {
        type: "eraser",
        lastActiveToolBeforeEraser: appState.activeTool
      });
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      captureUpdate: CaptureUpdateAction6.IMMEDIATELY
    };
  },
  keyTest: (event) => event.key === KEYS12.E
});
var actionToggleLassoTool = register({
  name: "toggleLassoTool",
  label: "toolBar.lasso",
  icon: LassoIcon,
  trackEvent: { category: "toolbar" },
  predicate: (elements, appState, props, app) => {
    return app.state.preferredSelectionTool.type !== "lasso";
  },
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (appState.activeTool.type !== "lasso") {
      activeTool = updateActiveTool2(appState, {
        type: "lasso",
        fromSelection: false
      });
      setCursor(app.interactiveCanvas, CURSOR_TYPE2.CROSSHAIR);
    } else {
      activeTool = updateActiveTool2(appState, {
        type: "selection"
      });
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      captureUpdate: CaptureUpdateAction6.NEVER
    };
  }
});
var actionToggleHandTool = register({
  name: "toggleHandTool",
  label: "toolBar.hand",
  trackEvent: { category: "toolbar" },
  icon: handIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (isHandToolActive(appState)) {
      activeTool = updateActiveTool2(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool2(appState, {
        type: "hand",
        lastActiveToolBeforeEraser: appState.activeTool
      });
      setCursor(app.interactiveCanvas, CURSOR_TYPE2.GRAB);
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      captureUpdate: CaptureUpdateAction6.IMMEDIATELY
    };
  },
  keyTest: (event) => !event.altKey && !event[KEYS12.CTRL_OR_CMD] && event.key === KEYS12.H
});

// actions/actionEmbeddable.ts
import { updateActiveTool as updateActiveTool3 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction7 } from "@excalidraw/element";
var actionSetEmbeddableAsActiveTool = register({
  name: "setEmbeddableAsActiveTool",
  trackEvent: { category: "toolbar" },
  target: "Tool",
  label: "toolBar.embeddable",
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool3(appState, {
      type: "embeddable"
    });
    setCursorForShape(app.canvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool3(appState, {
          type: "embeddable"
        })
      },
      captureUpdate: CaptureUpdateAction7.EVENTUALLY
    };
  }
});

// actions/actionFinalize.tsx
import { pointFrom as pointFrom2 } from "@excalidraw/math";
import { bindOrUnbindBindingElement } from "@excalidraw/element/binding";
import {
  isValidPolygon,
  LinearElementEditor as LinearElementEditor5,
  newElementWith as newElementWith4
} from "@excalidraw/element";
import {
  isBindingElement,
  isFreeDrawElement,
  isLinearElement as isLinearElement3,
  isLineElement as isLineElement2
} from "@excalidraw/element";
import {
  DEFAULT_ELEMENT_PROPS,
  DEFAULT_TEXT_ALIGN,
  KEYS as KEYS13,
  arrayToMap as arrayToMap4,
  invariant as invariant2,
  shouldRotateWithDiscreteAngle,
  updateActiveTool as updateActiveTool4
} from "@excalidraw/common";
import { isPathALoop } from "@excalidraw/element";
import { isInvisiblySmallElement } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction8 } from "@excalidraw/element";
import { jsx as jsx37 } from "react/jsx-runtime";
var actionFinalize = register({
  name: "finalize",
  label: "",
  trackEvent: false,
  perform: (elements, appState, data, app) => {
    let newElements = elements;
    const { interactiveCanvas, focusContainer, scene } = app;
    const elementsMap = scene.getNonDeletedElementsMap();
    if (data && appState.selectedLinearElement) {
      const { event, sceneCoords } = data;
      const element2 = LinearElementEditor5.getElement(
        appState.selectedLinearElement.elementId,
        elementsMap
      );
      invariant2(
        element2,
        "Arrow element should exist if selectedLinearElement is set"
      );
      invariant2(
        sceneCoords,
        "sceneCoords should be defined if actionFinalize is called with event"
      );
      const linearElementEditor = LinearElementEditor5.handlePointerUp(
        event,
        appState.selectedLinearElement,
        appState,
        app.scene
      );
      if (isBindingElement(element2) && !appState.selectedLinearElement.segmentMidPointHoveredCoords) {
        const newArrow = !!appState.newElement;
        const selectedPointsIndices = newArrow || !appState.selectedLinearElement.selectedPointsIndices ? [element2.points.length - 1] : appState.selectedLinearElement.selectedPointsIndices;
        const draggedPoints = selectedPointsIndices.reduce((map, index) => {
          map.set(index, {
            point: LinearElementEditor5.pointFromAbsoluteCoords(
              element2,
              pointFrom2(
                sceneCoords.x - linearElementEditor.pointerOffset.x,
                sceneCoords.y - linearElementEditor.pointerOffset.y
              ),
              elementsMap
            )
          });
          return map;
        }, /* @__PURE__ */ new Map()) ?? /* @__PURE__ */ new Map();
        bindOrUnbindBindingElement(
          element2,
          draggedPoints,
          sceneCoords.x - linearElementEditor.pointerOffset.x,
          sceneCoords.y - linearElementEditor.pointerOffset.y,
          scene,
          appState,
          {
            newArrow,
            altKey: event.altKey,
            angleLocked: shouldRotateWithDiscreteAngle(event)
          }
        );
      } else if (isLineElement2(element2)) {
        if (appState.selectedLinearElement?.isEditing && !appState.newElement && !isValidPolygon(element2.points)) {
          scene.mutateElement(element2, {
            polygon: false
          });
        }
      }
      if (linearElementEditor !== appState.selectedLinearElement) {
        if (element2 && isInvisiblySmallElement(element2)) {
          newElements = newElements.map((el) => {
            if (el.id === element2.id) {
              return newElementWith4(el, {
                isDeleted: true
              });
            }
            return el;
          });
        }
        const activeToolLocked = appState.activeTool?.locked;
        return {
          elements: element2.points.length < 2 || isInvisiblySmallElement(element2) ? elements.map((el) => {
            if (el.id === element2.id) {
              return newElementWith4(el, { isDeleted: true });
            }
            return el;
          }) : newElements,
          appState: {
            ...appState,
            cursorButton: "up",
            selectedLinearElement: activeToolLocked ? null : {
              ...linearElementEditor,
              selectedPointsIndices: null,
              isEditing: false,
              initialState: {
                ...linearElementEditor.initialState,
                lastClickedPoint: -1
              },
              pointerOffset: { x: 0, y: 0 }
            },
            selectionElement: null,
            suggestedBinding: null,
            newElement: null,
            multiElement: null
          },
          captureUpdate: CaptureUpdateAction8.IMMEDIATELY
        };
      }
    }
    if (window.document.activeElement instanceof HTMLElement) {
      focusContainer();
    }
    let element = null;
    if (appState.multiElement) {
      element = appState.multiElement;
    } else if (appState.newElement?.type === "freedraw" || isBindingElement(appState.newElement)) {
      element = appState.newElement;
    } else if (Object.keys(appState.selectedElementIds).length === 1) {
      const candidate = elementsMap.get(
        Object.keys(appState.selectedElementIds)[0]
      );
      if (candidate) {
        element = candidate;
      }
    }
    if (element) {
      if (appState.selectedLinearElement && appState.multiElement && element.type !== "freedraw" && appState.lastPointerDownWith !== "touch") {
        const { points } = element;
        const { lastCommittedPoint } = appState.selectedLinearElement;
        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {
          scene.mutateElement(element, {
            points: element.points.slice(0, -1)
          });
        }
      }
      if (element && isInvisiblySmallElement(element)) {
        newElements = newElements.map((el) => {
          if (el.id === element?.id) {
            return newElementWith4(el, { isDeleted: true });
          }
          return el;
        });
      }
      if (isLinearElement3(element) || isFreeDrawElement(element)) {
        const isLoop = isPathALoop(element.points, appState.zoom.value);
        if (isLoop && (isLineElement2(element) || isFreeDrawElement(element))) {
          const linePoints = element.points;
          const firstPoint = linePoints[0];
          const points = linePoints.map(
            (p, index) => index === linePoints.length - 1 ? pointFrom2(firstPoint[0], firstPoint[1]) : p
          );
          if (isLineElement2(element)) {
            scene.mutateElement(element, {
              points,
              polygon: true
            });
          } else {
            scene.mutateElement(element, {
              points
            });
          }
        }
        if (isLineElement2(element) && !isValidPolygon(element.points)) {
          scene.mutateElement(element, {
            polygon: false
          });
        }
      }
    }
    if (!appState.activeTool.locked && appState.activeTool.type !== "freedraw" || !element) {
      resetCursor(interactiveCanvas);
    }
    let activeTool;
    if (appState.activeTool.type === "eraser") {
      activeTool = updateActiveTool4(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: app.state.preferredSelectionTool.type
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool4(appState, {
        type: app.state.preferredSelectionTool.type
      });
    }
    const resetStickyNoteStyles = appState.activeTool.type === "StickyNote" && activeTool.type === app.state.preferredSelectionTool.type;
    let selectedLinearElement = element && isLinearElement3(element) ? new LinearElementEditor5(element, arrayToMap4(newElements)) : appState.selectedLinearElement;
    selectedLinearElement = selectedLinearElement ? {
      ...selectedLinearElement,
      isEditing: appState.newElement ? false : selectedLinearElement.isEditing,
      initialState: {
        ...selectedLinearElement.initialState,
        lastClickedPoint: -1,
        origin: null
      }
    } : selectedLinearElement;
    return {
      elements: newElements,
      appState: {
        ...appState,
        cursorButton: "up",
        activeTool: (appState.activeTool.locked || appState.activeTool.type === "freedraw") && element ? appState.activeTool : activeTool,
        activeEmbeddable: null,
        newElement: null,
        selectionElement: null,
        multiElement: null,
        editingTextElement: null,
        startBoundElement: null,
        suggestedBinding: null,
        selectedElementIds: element && !appState.activeTool.locked && appState.activeTool.type !== "freedraw" ? {
          ...appState.selectedElementIds,
          [element.id]: true
        } : appState.selectedElementIds,
        selectedLinearElement,
        ...resetStickyNoteStyles ? {
          currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS.backgroundColor,
          currentItemFillStyle: DEFAULT_ELEMENT_PROPS.fillStyle,
          currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS.strokeWidth,
          currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS.strokeStyle,
          currentItemRoughness: DEFAULT_ELEMENT_PROPS.roughness,
          currentItemTextAlign: DEFAULT_TEXT_ALIGN
        } : {}
      },
      // TODO: #7348 we should not capture everything, but if we don't, it leads to incosistencies -> revisit
      captureUpdate: CaptureUpdateAction8.IMMEDIATELY
    };
  },
  keyTest: (event, appState) => event.key === KEYS13.ESCAPE && (appState.selectedLinearElement?.isEditing || !appState.newElement && appState.multiElement === null) || (event.key === KEYS13.ESCAPE || event.key === KEYS13.ENTER) && appState.multiElement !== null,
  PanelComponent: ({ appState, updateData, data }) => /* @__PURE__ */ jsx37(
    ToolButton,
    {
      type: "button",
      icon: done,
      title: t("buttons.done"),
      "aria-label": t("buttons.done"),
      onClick: updateData,
      visible: appState.multiElement != null,
      size: data?.size || "medium",
      style: { pointerEvents: "all" }
    }
  )
});

// actions/actionExport.tsx
import {
  KEYS as KEYS15,
  DEFAULT_EXPORT_PADDING as DEFAULT_EXPORT_PADDING2,
  EXPORT_SCALES,
  THEME as THEME7
} from "@excalidraw/common";
import { getNonDeletedElements as getNonDeletedElements7 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction9 } from "@excalidraw/element";

// components/CheckboxItem.tsx
import clsx17 from "clsx";
import { jsx as jsx38, jsxs as jsxs22 } from "react/jsx-runtime";
var CheckboxItem = ({ children, checked, onChange, className }) => {
  return /* @__PURE__ */ jsxs22(
    "div",
    {
      className: clsx17("Checkbox", className, { "is-checked": checked }),
      onClick: (event) => {
        onChange(!checked, event);
        event.currentTarget.querySelector(
          ".Checkbox-box"
        ).focus();
      },
      children: [
        /* @__PURE__ */ jsx38(
          "button",
          {
            type: "button",
            className: "Checkbox-box",
            role: "checkbox",
            "aria-checked": checked,
            children: checkIcon
          }
        ),
        /* @__PURE__ */ jsx38("div", { className: "Checkbox-label", children })
      ]
    }
  );
};

// components/DarkModeToggle.tsx
import { THEME as THEME6 } from "@excalidraw/common";
import { jsx as jsx39 } from "react/jsx-runtime";
var DarkModeToggle = (props) => {
  const title = props.title || (props.value === THEME6.DARK ? t("buttons.lightMode") : t("buttons.darkMode"));
  return /* @__PURE__ */ jsx39(
    ToolButton,
    {
      type: "icon",
      icon: props.value === THEME6.LIGHT ? ICONS.MOON : ICONS.SUN,
      title,
      "aria-label": title,
      onClick: () => props.onChange(props.value === THEME6.DARK ? THEME6.LIGHT : THEME6.DARK),
      "data-testid": "toggle-dark-mode"
    }
  );
};
var ICONS = {
  SUN: /* @__PURE__ */ jsx39("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx39(
    "path",
    {
      fill: "currentColor",
      d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
    }
  ) }),
  MOON: /* @__PURE__ */ jsx39("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx39(
    "path",
    {
      fill: "currentColor",
      d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
    }
  ) })
};

// components/ProjectName.tsx
import { useState as useState8 } from "react";
import { focusNearestParent, KEYS as KEYS14 } from "@excalidraw/common";
import { jsx as jsx40, jsxs as jsxs23 } from "react/jsx-runtime";
var ProjectName = (props) => {
  const { id } = useExcalidrawContainer();
  const [fileName, setFileName] = useState8(props.value);
  const handleBlur = (event) => {
    if (!props.ignoreFocus) {
      focusNearestParent(event.target);
    }
    const value = event.target.value;
    if (value !== props.value) {
      props.onChange(value);
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === KEYS14.ENTER) {
      event.preventDefault();
      if (event.nativeEvent.isComposing || event.keyCode === 229) {
        return;
      }
      event.currentTarget.blur();
    }
  };
  return /* @__PURE__ */ jsxs23("div", { className: "ProjectName", children: [
    /* @__PURE__ */ jsx40("label", { className: "ProjectName-label", htmlFor: "filename", children: `${props.label}:` }),
    /* @__PURE__ */ jsx40(
      "input",
      {
        type: "text",
        className: "TextInput",
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        id: `${id}-filename`,
        value: fileName,
        onChange: (event) => setFileName(event.target.value)
      }
    )
  ] });
};

// data/index.ts
import {
  DEFAULT_EXPORT_PADDING,
  DEFAULT_FILENAME,
  IMAGE_MIME_TYPES,
  isFirefox,
  MIME_TYPES as MIME_TYPES3,
  cloneJSON,
  SVG_DOCUMENT_PREAMBLE
} from "@excalidraw/common";
import { getNonDeletedElements as getNonDeletedElements6 } from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement3 } from "@excalidraw/element";
import { getElementsOverlappingFrame } from "@excalidraw/element";

// clipboard.ts
import {
  ALLOWED_PASTE_MIME_TYPES,
  EXPORT_DATA_TYPES,
  MIME_TYPES as MIME_TYPES2,
  arrayToMap as arrayToMap5,
  isMemberOf,
  isPromiseLike as isPromiseLike2,
  EVENT as EVENT4
} from "@excalidraw/common";
import { mutateElement } from "@excalidraw/element";
import { deepCopyElement } from "@excalidraw/element";
import {
  isFrameLikeElement as isFrameLikeElement2,
  isInitializedImageElement
} from "@excalidraw/element";
import { getContainingFrame } from "@excalidraw/element";

// charts.ts
import { pointFrom as pointFrom3 } from "@excalidraw/math";
import {
  COLOR_PALETTE as COLOR_PALETTE3,
  DEFAULT_CHART_COLOR_INDEX,
  getAllColorsSpecificShade,
  DEFAULT_FONT_FAMILY as DEFAULT_FONT_FAMILY2,
  DEFAULT_FONT_SIZE as DEFAULT_FONT_SIZE2,
  VERTICAL_ALIGN as VERTICAL_ALIGN2,
  randomId,
  isDevEnv as isDevEnv3,
  FONT_SIZES as FONT_SIZES2
} from "@excalidraw/common";
import {
  newTextElement,
  newLinearElement,
  newElement
} from "@excalidraw/element";
var BAR_WIDTH = 32;
var BAR_GAP = 12;
var BAR_HEIGHT = 256;
var GRID_OPACITY = 50;
var NOT_SPREADSHEET = "NOT_SPREADSHEET";
var VALID_SPREADSHEET = "VALID_SPREADSHEET";
var tryParseNumber = (s) => {
  const match = /^([-+]?)[$]?([-+]?)([\d.,]+)[%]?$/.exec(s);
  if (!match) {
    return null;
  }
  return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, ""));
};
var isNumericColumn = (lines, columnIndex) => lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);
var tryParseCells = (cells) => {
  const numCols = cells[0].length;
  if (numCols > 2) {
    return { type: NOT_SPREADSHEET, reason: "More than 2 columns" };
  }
  if (numCols === 1) {
    if (!isNumericColumn(cells, 0)) {
      return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
    }
    const hasHeader2 = tryParseNumber(cells[0][0]) === null;
    const values = (hasHeader2 ? cells.slice(1) : cells).map(
      (line) => tryParseNumber(line[0])
    );
    if (values.length < 2) {
      return { type: NOT_SPREADSHEET, reason: "Less than two rows" };
    }
    return {
      type: VALID_SPREADSHEET,
      spreadsheet: {
        title: hasHeader2 ? cells[0][0] : null,
        labels: null,
        values
      }
    };
  }
  const labelColumnNumeric = isNumericColumn(cells, 0);
  const valueColumnNumeric = isNumericColumn(cells, 1);
  if (!labelColumnNumeric && !valueColumnNumeric) {
    return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
  }
  const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric ? [0, 1] : [1, 0];
  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;
  const rows = hasHeader ? cells.slice(1) : cells;
  if (rows.length < 2) {
    return { type: NOT_SPREADSHEET, reason: "Less than 2 rows" };
  }
  return {
    type: VALID_SPREADSHEET,
    spreadsheet: {
      title: hasHeader ? cells[0][valueColumnIndex] : null,
      labels: rows.map((row) => row[labelColumnIndex]),
      values: rows.map((row) => tryParseNumber(row[valueColumnIndex]))
    }
  };
};
var transposeCells = (cells) => {
  const nextCells = [];
  for (let col = 0; col < cells[0].length; col++) {
    const nextCellRow = [];
    for (let row = 0; row < cells.length; row++) {
      nextCellRow.push(cells[row][col]);
    }
    nextCells.push(nextCellRow);
  }
  return nextCells;
};
var tryParseSpreadsheet = (text) => {
  let lines = text.trim().split("\n").map((line) => line.trim().split("	"));
  if (lines.length && lines[0].length !== 2) {
    lines = text.trim().split("\n").map((line) => line.trim().split(","));
  }
  if (lines.length === 0) {
    return { type: NOT_SPREADSHEET, reason: "No values" };
  }
  const numColsFirstLine = lines[0].length;
  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);
  if (!isSpreadsheet) {
    return {
      type: NOT_SPREADSHEET,
      reason: "All rows don't have same number of columns"
    };
  }
  const result = tryParseCells(lines);
  if (result.type !== VALID_SPREADSHEET) {
    const transposedResults = tryParseCells(transposeCells(lines));
    if (transposedResults.type === VALID_SPREADSHEET) {
      return transposedResults;
    }
  }
  return result;
};
var bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);
var commonProps = {
  fillStyle: "hachure",
  fontFamily: DEFAULT_FONT_FAMILY2,
  fontSize: DEFAULT_FONT_SIZE2,
  opacity: 100,
  roughness: 1,
  strokeColor: COLOR_PALETTE3.black,
  roundness: null,
  strokeStyle: "solid",
  strokeWidth: 1,
  verticalAlign: VERTICAL_ALIGN2.MIDDLE,
  locked: false
};
var getChartDimensions = (spreadsheet) => {
  const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;
  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;
  return { chartWidth, chartHeight };
};
var chartXLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
  return spreadsheet.labels?.map((label, index) => {
    return newTextElement({
      groupIds: [groupId],
      backgroundColor,
      ...commonProps,
      text: label.length > 8 ? `${label.slice(0, 5)}...` : label,
      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,
      y: y + BAR_GAP / 2,
      width: BAR_WIDTH,
      angle: 5.87,
      fontSize: FONT_SIZES2.sm,
      textAlign: "center",
      verticalAlign: "top"
    });
  }) || [];
};
var chartYLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
  const minYLabel = newTextElement({
    groupIds: [groupId],
    backgroundColor,
    ...commonProps,
    x: x - BAR_GAP,
    y: y - BAR_GAP,
    text: "0",
    textAlign: "right"
  });
  const maxYLabel = newTextElement({
    groupIds: [groupId],
    backgroundColor,
    ...commonProps,
    x: x - BAR_GAP,
    y: y - BAR_HEIGHT - minYLabel.height / 2,
    text: Math.max(...spreadsheet.values).toLocaleString(),
    textAlign: "right"
  });
  return [minYLabel, maxYLabel];
};
var chartLines = (spreadsheet, x, y, groupId, backgroundColor) => {
  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
  const xLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x,
    y,
    width: chartWidth,
    points: [pointFrom3(0, 0), pointFrom3(chartWidth, 0)]
  });
  const yLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x,
    y,
    height: chartHeight,
    points: [pointFrom3(0, 0), pointFrom3(0, -chartHeight)]
  });
  const maxLine = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x,
    y: y - BAR_HEIGHT - BAR_GAP,
    strokeStyle: "dotted",
    width: chartWidth,
    opacity: GRID_OPACITY,
    points: [pointFrom3(0, 0), pointFrom3(chartWidth, 0)]
  });
  return [xLine, yLine, maxLine];
};
var chartBaseElements = (spreadsheet, x, y, groupId, backgroundColor, debug) => {
  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
  const title = spreadsheet.title ? newTextElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    text: spreadsheet.title,
    x: x + chartWidth / 2,
    y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE2,
    roundness: null,
    textAlign: "center"
  }) : null;
  const debugRect = debug ? newElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "rectangle",
    x,
    y: y - chartHeight,
    width: chartWidth,
    height: chartHeight,
    strokeColor: COLOR_PALETTE3.black,
    fillStyle: "solid",
    opacity: 6
  }) : null;
  return [
    ...debugRect ? [debugRect] : [],
    ...title ? [title] : [],
    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),
    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),
    ...chartLines(spreadsheet, x, y, groupId, backgroundColor)
  ];
};
var chartTypeBar = (spreadsheet, x, y) => {
  const max = Math.max(...spreadsheet.values);
  const groupId = randomId();
  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
  const bars = spreadsheet.values.map((value, index) => {
    const barHeight = value / max * BAR_HEIGHT;
    return newElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      type: "rectangle",
      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,
      y: y - barHeight - BAR_GAP,
      width: BAR_WIDTH,
      height: barHeight
    });
  });
  return [
    ...bars,
    ...chartBaseElements(
      spreadsheet,
      x,
      y,
      groupId,
      backgroundColor,
      isDevEnv3()
    )
  ];
};
var chartTypeLine = (spreadsheet, x, y) => {
  const max = Math.max(...spreadsheet.values);
  const groupId = randomId();
  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
  let index = 0;
  const points = [];
  for (const value of spreadsheet.values) {
    const cx = index * (BAR_WIDTH + BAR_GAP);
    const cy = -(value / max) * BAR_HEIGHT;
    points.push([cx, cy]);
    index++;
  }
  const maxX = Math.max(...points.map((element) => element[0]));
  const maxY = Math.max(...points.map((element) => element[1]));
  const minX = Math.min(...points.map((element) => element[0]));
  const minY = Math.min(...points.map((element) => element[1]));
  const line = newLinearElement({
    backgroundColor,
    groupIds: [groupId],
    ...commonProps,
    type: "line",
    x: x + BAR_GAP + BAR_WIDTH / 2,
    y: y - BAR_GAP,
    height: maxY - minY,
    width: maxX - minX,
    strokeWidth: 2,
    points
  });
  const dots = spreadsheet.values.map((value, index2) => {
    const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;
    return newElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      fillStyle: "solid",
      strokeWidth: 2,
      type: "ellipse",
      x: x + cx + BAR_WIDTH / 2,
      y: y + cy - BAR_GAP * 2,
      width: BAR_GAP,
      height: BAR_GAP
    });
  });
  const lines = spreadsheet.values.map((value, index2) => {
    const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
    const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;
    return newLinearElement({
      backgroundColor,
      groupIds: [groupId],
      ...commonProps,
      type: "line",
      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,
      y: y - cy,
      height: cy,
      strokeStyle: "dotted",
      opacity: GRID_OPACITY,
      points: [pointFrom3(0, 0), pointFrom3(0, cy)]
    });
  });
  return [
    ...chartBaseElements(
      spreadsheet,
      x,
      y,
      groupId,
      backgroundColor,
      isDevEnv3()
    ),
    line,
    ...lines,
    ...dots
  ];
};
var renderSpreadsheet = (chartType, spreadsheet, x, y) => {
  if (chartType === "line") {
    return chartTypeLine(spreadsheet, x, y);
  }
  return chartTypeBar(spreadsheet, x, y);
};

// clipboard.ts
var probablySupportsClipboardReadText = "clipboard" in navigator && "readText" in navigator.clipboard;
var probablySupportsClipboardWriteText = "clipboard" in navigator && "writeText" in navigator.clipboard;
var probablySupportsClipboardBlob = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype;
var clipboardContainsElements = (contents) => {
  if ([
    EXPORT_DATA_TYPES.excalidraw,
    EXPORT_DATA_TYPES.excalidrawClipboard,
    EXPORT_DATA_TYPES.excalidrawClipboardWithAPI
  ].includes(contents?.type) && Array.isArray(contents.elements)) {
    return true;
  }
  return false;
};
var createPasteEvent = ({
  types,
  files
}) => {
  if (!types && !files) {
    console.warn("createPasteEvent: no types or files provided");
  }
  const event = new ClipboardEvent(EVENT4.PASTE, {
    clipboardData: new DataTransfer()
  });
  if (types) {
    for (const [type, value] of Object.entries(types)) {
      if (typeof value !== "string") {
        files = files || [];
        files.push(value);
        continue;
      }
      try {
        event.clipboardData?.items.add(value, type);
        if (event.clipboardData?.getData(type) !== value) {
          throw new Error(`Failed to set "${type}" as clipboardData item`);
        }
      } catch (error) {
        throw new Error(error.message);
      }
    }
  }
  if (files) {
    let idx = -1;
    for (const file2 of files) {
      idx++;
      try {
        event.clipboardData?.items.add(file2);
        if (event.clipboardData?.files[idx] !== file2) {
          throw new Error(
            `Failed to set file "${file2.name}" as clipboardData item`
          );
        }
      } catch (error) {
        throw new Error(error.message);
      }
    }
  }
  return event;
};
var serializeAsClipboardJSON = ({
  elements,
  files
}) => {
  const elementsMap = arrayToMap5(elements);
  const framesToCopy = new Set(
    elements.filter((element) => isFrameLikeElement2(element))
  );
  let foundFile = false;
  const _files = elements.reduce((acc, element) => {
    if (isInitializedImageElement(element)) {
      foundFile = true;
      if (files && files[element.fileId]) {
        acc[element.fileId] = files[element.fileId];
      }
    }
    return acc;
  }, {});
  if (foundFile && !files) {
    console.warn(
      "copyToClipboard: attempting to file element(s) without providing associated `files` object."
    );
  }
  const contents = {
    type: EXPORT_DATA_TYPES.excalidrawClipboard,
    elements: elements.map((element) => {
      if (getContainingFrame(element, elementsMap) && !framesToCopy.has(getContainingFrame(element, elementsMap))) {
        const copiedElement = deepCopyElement(element);
        mutateElement(copiedElement, elementsMap, {
          frameId: null
        });
        return copiedElement;
      }
      return element;
    }),
    files: files ? _files : void 0
  };
  return JSON.stringify(contents);
};
var copyToClipboard = async (elements, files, clipboardEvent) => {
  const json = serializeAsClipboardJSON({ elements, files });
  await copyTextToSystemClipboard(
    {
      [MIME_TYPES2.excalidrawClipboard]: json,
      [MIME_TYPES2.text]: json
    },
    clipboardEvent
  );
};
var parsePotentialSpreadsheet = (text) => {
  const result = tryParseSpreadsheet(text);
  if (result.type === VALID_SPREADSHEET) {
    return { spreadsheet: result.spreadsheet };
  }
  return null;
};
function parseHTMLTree(el) {
  let result = [];
  for (const node of el.childNodes) {
    if (node.nodeType === 3) {
      const text = node.textContent?.trim();
      if (text) {
        result.push({ type: "text", value: text });
      }
    } else if (node instanceof HTMLImageElement) {
      const url = node.getAttribute("src");
      if (url && url.startsWith("http")) {
        result.push({ type: "imageUrl", value: url });
      }
    } else {
      result = result.concat(parseHTMLTree(node));
    }
  }
  return result;
}
var maybeParseHTMLDataItem = (dataItem) => {
  const html = dataItem.value;
  try {
    const doc = new DOMParser().parseFromString(html, MIME_TYPES2.html);
    const content = parseHTMLTree(doc.body);
    if (content.length) {
      return { type: "mixedContent", value: content };
    }
  } catch (error) {
    console.error(`error in parseHTMLFromPaste: ${error.message}`);
  }
  return null;
};
var readSystemClipboard = async () => {
  const types = {};
  let clipboardItems;
  try {
    clipboardItems = await navigator.clipboard?.read();
  } catch (error) {
    try {
      if (navigator.clipboard?.readText) {
        console.warn(
          `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`
        );
        const readText = await navigator.clipboard?.readText();
        if (readText) {
          return { [MIME_TYPES2.text]: readText };
        }
      }
    } catch (error2) {
      if (navigator.clipboard?.read) {
        console.warn(
          `navigator.clipboard.readText() failed (${error2.message}). Failling back to navigator.clipboard.read()`
        );
      } else {
        if (error2.name === "DataError") {
          console.warn(
            `navigator.clipboard.read() error, clipboard is probably empty: ${error2.message}`
          );
          return types;
        }
        throw error2;
      }
    }
    throw error;
  }
  for (const item of clipboardItems) {
    for (const type of item.types) {
      if (!isMemberOf(ALLOWED_PASTE_MIME_TYPES, type)) {
        continue;
      }
      try {
        if (type === MIME_TYPES2.text || type === MIME_TYPES2.html) {
          types[type] = await (await item.getType(type)).text();
        } else if (isSupportedImageFileType(type)) {
          const imageBlob = await item.getType(type);
          const file2 = createFile(imageBlob, type, void 0);
          types[type] = file2;
        } else {
          throw new ExcalidrawError(`Unsupported clipboard type: ${type}`);
        }
      } catch (error) {
        console.warn(
          error instanceof ExcalidrawError ? error.message : `Cannot retrieve ${type} from clipboardItem: ${error.message}`
        );
      }
    }
  }
  if (Object.keys(types).length === 0) {
    console.warn("No clipboard data found from clipboard.read().");
    return types;
  }
  return types;
};
var parseClipboardEventTextData = async (dataList, isPlainPaste = false) => {
  try {
    const htmlItem = dataList.findByType(MIME_TYPES2.html);
    const mixedContent = !isPlainPaste && htmlItem && maybeParseHTMLDataItem(htmlItem);
    if (mixedContent) {
      if (mixedContent.value.every((item) => item.type === "text")) {
        return {
          type: "text",
          value: dataList.getData(MIME_TYPES2.text) ?? mixedContent.value.map((item) => item.value).join("\n").trim()
        };
      }
      return mixedContent;
    }
    return {
      type: "text",
      value: (dataList.getData(MIME_TYPES2.text) || "").trim()
    };
  } catch {
    return { type: "text", value: "" };
  }
};
var findDataTransferItemType = function(type) {
  return this.find(
    (item) => item.type === type
  ) || null;
};
var getDataTransferItemData = function(type) {
  const item = this.find(
    (item2) => item2.type === type
  );
  return item?.value ?? null;
};
var getDataTransferFiles = function() {
  return this.filter(
    (item) => item.kind === "file"
  );
};
var parseDataTransferEventMimeTypes = (event) => {
  let items = void 0;
  if (isClipboardEvent(event)) {
    items = event.clipboardData?.items;
  } else {
    items = event.dataTransfer?.items;
  }
  const types = /* @__PURE__ */ new Set();
  for (const item of Array.from(items || [])) {
    if (!types.has(item.type)) {
      types.add(item.type);
    }
  }
  return types;
};
var parseDataTransferEvent = async (event) => {
  let items = void 0;
  if (isClipboardEvent(event)) {
    items = event.clipboardData?.items;
  } else {
    items = event.dataTransfer?.items;
  }
  const dataItems = (await Promise.all(
    Array.from(items || []).map(
      async (item) => {
        if (item.kind === "file") {
          let file2 = item.getAsFile();
          if (file2) {
            const fileHandle = await getFileHandle(item);
            file2 = await normalizeFile(file2);
            return {
              type: file2.type,
              kind: "file",
              file: file2,
              fileHandle
            };
          }
        } else if (item.kind === "string") {
          const { type } = item;
          let value;
          if ("clipboardData" in event && event.clipboardData) {
            value = event.clipboardData?.getData(type);
          } else {
            value = await new Promise((resolve) => {
              item.getAsString((str) => resolve(str));
            });
          }
          return { type, kind: "string", value };
        }
        return null;
      }
    )
  )).filter((data) => data != null);
  return Object.assign(dataItems, {
    findByType: findDataTransferItemType,
    getData: getDataTransferItemData,
    getFiles: getDataTransferFiles
  });
};
var parseClipboard = async (dataList, isPlainPaste = false) => {
  const parsedEventData = await parseClipboardEventTextData(
    dataList,
    isPlainPaste
  );
  if (parsedEventData.type === "mixedContent") {
    return {
      mixedContent: parsedEventData.value
    };
  }
  try {
    const spreadsheetResult = !isPlainPaste && parsePotentialSpreadsheet(parsedEventData.value);
    if (spreadsheetResult) {
      return spreadsheetResult;
    }
  } catch (error) {
    console.error(error);
  }
  try {
    const systemClipboardData = JSON.parse(parsedEventData.value);
    const programmaticAPI = systemClipboardData.type === EXPORT_DATA_TYPES.excalidrawClipboardWithAPI;
    if (clipboardContainsElements(systemClipboardData)) {
      return {
        elements: systemClipboardData.elements,
        files: systemClipboardData.files,
        text: isPlainPaste ? JSON.stringify(systemClipboardData.elements, null, 2) : void 0,
        programmaticAPI
      };
    }
  } catch {
  }
  return { text: parsedEventData.value };
};
var copyBlobToClipboardAsPng = async (blob) => {
  try {
    await navigator.clipboard.write([
      new ClipboardItem({
        [MIME_TYPES2.png]: blob
      })
    ]);
  } catch (error) {
    if (isPromiseLike2(blob)) {
      await navigator.clipboard.write([
        new ClipboardItem({
          [MIME_TYPES2.png]: await blob
        })
      ]);
    } else {
      throw error;
    }
  }
};
var copyTextToSystemClipboard = async (text, clipboardEvent) => {
  text = text || "";
  const entries = Object.entries(
    typeof text === "string" ? { [MIME_TYPES2.text]: text } : text
  );
  try {
    if (clipboardEvent) {
      for (const [mimeType, value] of entries) {
        clipboardEvent.clipboardData?.setData(mimeType, value);
        if (clipboardEvent.clipboardData?.getData(mimeType) !== value) {
          throw new Error("Failed to setData on clipboardEvent");
        }
      }
      return;
    }
  } catch (error) {
    console.error(error);
  }
  const plainTextEntry = entries.find(
    ([mimeType]) => mimeType === MIME_TYPES2.text
  );
  if (probablySupportsClipboardWriteText && plainTextEntry) {
    try {
      await navigator.clipboard.writeText(plainTextEntry[1]);
      return;
    } catch (error) {
      console.error(error);
    }
  }
  if (plainTextEntry && !copyTextViaExecCommand(plainTextEntry[1])) {
    throw new Error("Error copying to clipboard.");
  }
};
var copyTextViaExecCommand = (text) => {
  if (!text) {
    text = " ";
  }
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const textarea = document.createElement("textarea");
  textarea.style.border = "0";
  textarea.style.padding = "0";
  textarea.style.margin = "0";
  textarea.style.position = "absolute";
  textarea.style[isRTL2 ? "right" : "left"] = "-9999px";
  const yPosition = window.pageYOffset || document.documentElement.scrollTop;
  textarea.style.top = `${yPosition}px`;
  textarea.style.fontSize = "12pt";
  textarea.setAttribute("readonly", "");
  textarea.value = text;
  document.body.appendChild(textarea);
  let success = false;
  try {
    textarea.select();
    textarea.setSelectionRange(0, textarea.value.length);
    success = document.execCommand("copy");
  } catch (error) {
    console.error(error);
  }
  textarea.remove();
  return success;
};
var isClipboardEvent = (event) => {
  return event.type === EVENT4.PASTE || event.type === EVENT4.COPY || event.type === EVENT4.CUT;
};

// data/index.ts
var prepareElementsForExport = (elements, { selectedElementIds }, exportSelectionOnly) => {
  elements = getNonDeletedElements6(elements);
  const isExportingSelection = exportSelectionOnly && isSomeElementSelected(elements, { selectedElementIds });
  let exportingFrame = null;
  let exportedElements = isExportingSelection ? getSelectedElements(
    elements,
    { selectedElementIds },
    {
      includeBoundTextElement: true
    }
  ) : elements;
  if (isExportingSelection) {
    if (exportedElements.length === 1 && isFrameLikeElement3(exportedElements[0])) {
      exportingFrame = exportedElements[0];
      exportedElements = getElementsOverlappingFrame(elements, exportingFrame);
    } else if (exportedElements.length > 1) {
      exportedElements = getSelectedElements(
        elements,
        { selectedElementIds },
        {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        }
      );
    }
  }
  return {
    exportingFrame,
    exportedElements: cloneJSON(exportedElements)
  };
};
var exportCanvas = async (type, elements, appState, files, {
  exportBackground,
  exportPadding = DEFAULT_EXPORT_PADDING,
  viewBackgroundColor,
  name = appState.name || DEFAULT_FILENAME,
  fileHandle = null,
  exportingFrame = null
}) => {
  if (elements.length === 0) {
    throw new Error(t("alerts.cannotExportEmptyCanvas"));
  }
  if (type === "svg" || type === "clipboard-svg") {
    const svgPromise = exportToSvg(
      elements,
      {
        exportBackground,
        exportWithDarkMode: appState.exportWithDarkMode,
        viewBackgroundColor,
        exportPadding,
        exportScale: appState.exportScale,
        exportEmbedScene: appState.exportEmbedScene && type === "svg"
      },
      files,
      { exportingFrame }
    );
    if (type === "svg") {
      return fileSave(
        svgPromise.then((svg) => {
          return new Blob([SVG_DOCUMENT_PREAMBLE + svg.outerHTML], {
            type: MIME_TYPES3.svg
          });
        }),
        {
          description: "Export to SVG",
          name,
          extension: appState.exportEmbedScene ? "excalidraw.svg" : "svg",
          mimeTypes: [IMAGE_MIME_TYPES.svg],
          fileHandle
        }
      );
    } else if (type === "clipboard-svg") {
      const svg = await svgPromise.then((svg2) => svg2.outerHTML);
      try {
        await copyTextToSystemClipboard(svg);
      } catch (e) {
        throw new Error(t("errors.copyToSystemClipboardFailed"));
      }
      return;
    }
  }
  const tempCanvas = exportToCanvas(elements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    exportPadding,
    exportingFrame
  });
  if (type === "png") {
    let blob = canvasToBlob(tempCanvas);
    if (appState.exportEmbedScene) {
      blob = blob.then(
        (blob2) => import("./data/image-5NYQCMPO.js").then(
          ({ encodePngMetadata: encodePngMetadata2 }) => encodePngMetadata2({
            blob: blob2,
            metadata: serializeAsJSON(elements, appState, files, "local")
          })
        )
      );
    }
    return fileSave(blob, {
      description: "Export to PNG",
      name,
      extension: appState.exportEmbedScene ? "excalidraw.png" : "png",
      mimeTypes: [IMAGE_MIME_TYPES.png],
      fileHandle
    });
  } else if (type === "clipboard") {
    try {
      const blob = canvasToBlob(tempCanvas);
      await copyBlobToClipboardAsPng(blob);
    } catch (error) {
      console.warn(error);
      if (error.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw new Error(t("canvasError.canvasTooBig"));
      }
      if (isFirefox && error.name === "TypeError") {
        throw new Error(
          `${t("alerts.couldNotCopyToClipboard")}

${t(
            "hints.firefox_clipboard_write"
          )}`
        );
      } else {
        throw new Error(t("alerts.couldNotCopyToClipboard"));
      }
    }
  } else {
    throw new Error("Unsupported export type");
  }
};

// data/resave.ts
var resaveAsImageWithScene = async (elements, appState, files, name) => {
  const { exportBackground, viewBackgroundColor, fileHandle } = appState;
  const fileHandleType = getFileHandleType(fileHandle);
  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {
    throw new Error(
      "fileHandle should exist and should be of type svg or png when resaving"
    );
  }
  appState = {
    ...appState,
    exportEmbedScene: true
  };
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elements,
    appState,
    false
  );
  await exportCanvas(fileHandleType, exportedElements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    name,
    fileHandle,
    exportingFrame
  });
  return { fileHandle };
};

// actions/actionExport.tsx
import { Fragment as Fragment7, jsx as jsx41, jsxs as jsxs24 } from "react/jsx-runtime";
var actionChangeProjectName = register({
  name: "changeProjectName",
  label: "labels.fileTitle",
  trackEvent: false,
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, name: value },
      captureUpdate: CaptureUpdateAction9.EVENTUALLY
    };
  },
  PanelComponent: ({ appState, updateData, appProps, data, app }) => /* @__PURE__ */ jsx41(
    ProjectName,
    {
      label: t("labels.fileTitle"),
      value: app.getName(),
      onChange: (name) => updateData(name),
      ignoreFocus: data?.ignoreFocus ?? false
    }
  )
});
var actionChangeExportScale = register({
  name: "changeExportScale",
  label: "imageExportDialog.scale",
  trackEvent: { category: "export", action: "scale" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportScale: value },
      captureUpdate: CaptureUpdateAction9.EVENTUALLY
    };
  },
  PanelComponent: ({ elements: allElements, appState, updateData }) => {
    const elements = getNonDeletedElements7(allElements);
    const exportSelected = isSomeElementSelected(elements, appState);
    const exportedElements = exportSelected ? getSelectedElements(elements, appState) : elements;
    return /* @__PURE__ */ jsx41(Fragment7, { children: EXPORT_SCALES.map((s) => {
      const [width, height] = getExportSize(
        exportedElements,
        DEFAULT_EXPORT_PADDING2,
        s
      );
      const scaleButtonTitle = `${t(
        "imageExportDialog.label.scale"
      )} ${s}x (${width}x${height})`;
      return /* @__PURE__ */ jsx41(
        ToolButton,
        {
          size: "small",
          type: "radio",
          icon: `${s}x`,
          name: "export-canvas-scale",
          title: scaleButtonTitle,
          "aria-label": scaleButtonTitle,
          id: "export-canvas-scale",
          checked: s === appState.exportScale,
          onChange: () => updateData(s)
        },
        s
      );
    }) });
  }
});
var actionChangeExportBackground = register({
  name: "changeExportBackground",
  label: "imageExportDialog.label.withBackground",
  trackEvent: { category: "export", action: "toggleBackground" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportBackground: value },
      captureUpdate: CaptureUpdateAction9.EVENTUALLY
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx41(
    CheckboxItem,
    {
      checked: appState.exportBackground,
      onChange: (checked) => updateData(checked),
      children: t("imageExportDialog.label.withBackground")
    }
  )
});
var actionChangeExportEmbedScene = register({
  name: "changeExportEmbedScene",
  label: "imageExportDialog.tooltip.embedScene",
  trackEvent: { category: "export", action: "embedScene" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportEmbedScene: value },
      captureUpdate: CaptureUpdateAction9.EVENTUALLY
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsxs24(
    CheckboxItem,
    {
      checked: appState.exportEmbedScene,
      onChange: (checked) => updateData(checked),
      children: [
        t("imageExportDialog.label.embedScene"),
        /* @__PURE__ */ jsx41(Tooltip, { label: t("imageExportDialog.tooltip.embedScene"), long: true, children: /* @__PURE__ */ jsx41("div", { className: "excalidraw-tooltip-icon", children: questionCircle }) })
      ]
    }
  )
});
var actionSaveToActiveFile = register({
  name: "saveToActiveFile",
  label: "buttons.save",
  icon: ExportIcon,
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.saveToActiveFile && !!appState.fileHandle && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, value, app) => {
    const fileHandleExists = !!appState.fileHandle;
    try {
      const { fileHandle } = isImageFileHandle(appState.fileHandle) ? await resaveAsImageWithScene(
        elements,
        appState,
        app.files,
        app.getName()
      ) : await saveAsJSON(elements, appState, app.files, app.getName());
      return {
        captureUpdate: CaptureUpdateAction9.EVENTUALLY,
        appState: {
          ...appState,
          fileHandle,
          toast: fileHandleExists ? {
            message: fileHandle?.name ? t("toast.fileSavedToFilename").replace(
              "{filename}",
              `"${fileHandle.name}"`
            ) : t("toast.fileSaved")
          } : null
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { captureUpdate: CaptureUpdateAction9.EVENTUALLY };
    }
  },
  keyTest: (event) => event.key === KEYS15.S && event[KEYS15.CTRL_OR_CMD] && !event.shiftKey
});
var actionSaveFileToDisk = register({
  name: "saveFileToDisk",
  label: "exportDialog.disk_title",
  icon: ExportIcon,
  viewMode: true,
  trackEvent: { category: "export" },
  perform: async (elements, appState, value, app) => {
    try {
      const { fileHandle } = await saveAsJSON(
        elements,
        {
          ...appState,
          fileHandle: null
        },
        app.files,
        app.getName()
      );
      return {
        captureUpdate: CaptureUpdateAction9.EVENTUALLY,
        appState: {
          ...appState,
          openDialog: null,
          fileHandle,
          toast: { message: t("toast.fileSaved") }
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { captureUpdate: CaptureUpdateAction9.EVENTUALLY };
    }
  },
  keyTest: (event) => event.key === KEYS15.S && event.shiftKey && event[KEYS15.CTRL_OR_CMD],
  PanelComponent: ({ updateData }) => /* @__PURE__ */ jsx41(
    ToolButton,
    {
      type: "button",
      icon: saveAs,
      title: t("buttons.saveAs"),
      "aria-label": t("buttons.saveAs"),
      showAriaLabel: useEditorInterface().formFactor === "phone",
      hidden: !nativeFileSystemSupported,
      onClick: () => updateData(null),
      "data-testid": "save-as-button"
    }
  )
});
var actionLoadScene = register({
  name: "loadScene",
  label: "buttons.load",
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, _, app) => {
    try {
      const {
        elements: loadedElements,
        appState: loadedAppState,
        files
      } = await loadFromJSON(appState, elements);
      return {
        elements: loadedElements,
        appState: loadedAppState,
        files,
        captureUpdate: CaptureUpdateAction9.IMMEDIATELY
      };
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return false;
      }
      return {
        elements,
        appState: { ...appState, errorMessage: error.message },
        files: app.files,
        captureUpdate: CaptureUpdateAction9.EVENTUALLY
      };
    }
  },
  keyTest: (event) => event[KEYS15.CTRL_OR_CMD] && event.key === KEYS15.O
});
var actionExportWithDarkMode = register({
  name: "exportWithDarkMode",
  label: "imageExportDialog.label.darkMode",
  trackEvent: { category: "export", action: "toggleTheme" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportWithDarkMode: value },
      captureUpdate: CaptureUpdateAction9.EVENTUALLY
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx41(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "-45px",
        marginBottom: "10px"
      },
      children: /* @__PURE__ */ jsx41(
        DarkModeToggle,
        {
          value: appState.exportWithDarkMode ? THEME7.DARK : THEME7.LIGHT,
          onChange: (theme) => {
            updateData(theme === THEME7.DARK);
          },
          title: t("imageExportDialog.label.darkMode")
        }
      )
    }
  )
});

// actions/actionStyles.ts
import {
  DEFAULT_FONT_SIZE as DEFAULT_FONT_SIZE3,
  DEFAULT_FONT_FAMILY as DEFAULT_FONT_FAMILY3,
  DEFAULT_TEXT_ALIGN as DEFAULT_TEXT_ALIGN2,
  CODES as CODES3,
  KEYS as KEYS16,
  getLineHeight as getLineHeight2
} from "@excalidraw/common";
import { newElementWith as newElementWith5 } from "@excalidraw/element";
import {
  hasBoundTextElement,
  canApplyRoundnessTypeToElement,
  getDefaultRoundnessTypeForElement,
  isFrameLikeElement as isFrameLikeElement4,
  isArrowElement as isArrowElement2,
  isExcalidrawElement,
  isTextElement as isTextElement3
} from "@excalidraw/element";
import {
  getBoundTextElement as getBoundTextElement2,
  redrawTextBoundingBox as redrawTextBoundingBox2
} from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction10 } from "@excalidraw/element";
var copiedStyles = "{}";
var actionCopyStyles = register({
  name: "copyStyles",
  label: "labels.copyStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = [];
    const element = elements.find((el) => appState.selectedElementIds[el.id]);
    elementsCopied.push(element);
    if (element && hasBoundTextElement(element)) {
      const boundTextElement = getBoundTextElement2(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      elementsCopied.push(boundTextElement);
    }
    if (element) {
      copiedStyles = JSON.stringify(elementsCopied);
    }
    return {
      appState: {
        ...appState,
        toast: { message: t("toast.copyStyles") }
      },
      captureUpdate: CaptureUpdateAction10.EVENTUALLY
    };
  },
  keyTest: (event) => event[KEYS16.CTRL_OR_CMD] && event.altKey && event.code === CODES3.C
});
var actionPasteStyles = register({
  name: "pasteStyles",
  label: "labels.pasteStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = JSON.parse(copiedStyles);
    const pastedElement = elementsCopied[0];
    const boundTextElement = elementsCopied[1];
    if (!isExcalidrawElement(pastedElement)) {
      return { elements, captureUpdate: CaptureUpdateAction10.EVENTUALLY };
    }
    const selectedElements = getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    const selectedElementIds = selectedElements.map((element) => element.id);
    return {
      elements: elements.map((element) => {
        if (selectedElementIds.includes(element.id)) {
          let elementStylesToCopyFrom = pastedElement;
          if (isTextElement3(element) && element.containerId) {
            elementStylesToCopyFrom = boundTextElement;
          }
          if (!elementStylesToCopyFrom) {
            return element;
          }
          let newElement5 = newElementWith5(element, {
            backgroundColor: elementStylesToCopyFrom?.backgroundColor,
            strokeWidth: elementStylesToCopyFrom?.strokeWidth,
            strokeColor: elementStylesToCopyFrom?.strokeColor,
            strokeStyle: elementStylesToCopyFrom?.strokeStyle,
            fillStyle: elementStylesToCopyFrom?.fillStyle,
            opacity: elementStylesToCopyFrom?.opacity,
            roughness: elementStylesToCopyFrom?.roughness,
            roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(
              elementStylesToCopyFrom.roundness.type,
              element
            ) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null
          });
          if (isTextElement3(newElement5)) {
            const fontSize = elementStylesToCopyFrom.fontSize || DEFAULT_FONT_SIZE3;
            const fontFamily = elementStylesToCopyFrom.fontFamily || DEFAULT_FONT_FAMILY3;
            newElement5 = newElementWith5(newElement5, {
              fontSize,
              fontFamily,
              textAlign: elementStylesToCopyFrom.textAlign || DEFAULT_TEXT_ALIGN2,
              lineHeight: elementStylesToCopyFrom.lineHeight || getLineHeight2(fontFamily)
            });
            let container = null;
            if (newElement5.containerId) {
              container = selectedElements.find(
                (element2) => isTextElement3(newElement5) && element2.id === newElement5.containerId
              ) || null;
            }
            redrawTextBoundingBox2(newElement5, container, app.scene);
          }
          if (newElement5.type === "arrow" && isArrowElement2(elementStylesToCopyFrom)) {
            newElement5 = newElementWith5(newElement5, {
              startArrowhead: elementStylesToCopyFrom.startArrowhead,
              endArrowhead: elementStylesToCopyFrom.endArrowhead
            });
          }
          if (isFrameLikeElement4(element)) {
            newElement5 = newElementWith5(newElement5, {
              roundness: null,
              backgroundColor: "transparent"
            });
          }
          return newElement5;
        }
        return element;
      }),
      captureUpdate: CaptureUpdateAction10.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS16.CTRL_OR_CMD] && event.altKey && event.code === CODES3.V
});

// actions/actionMenu.tsx
import { KEYS as KEYS17 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction11 } from "@excalidraw/element";
var actionShortcuts = register({
  name: "toggleShortcuts",
  label: "welcomeScreen.defaults.helpHint",
  icon: HelpIconThin,
  viewMode: true,
  trackEvent: { category: "menu", action: "toggleHelpDialog" },
  perform: (_elements, appState, _, { focusContainer }) => {
    if (appState.openDialog?.name === "help") {
      focusContainer();
    }
    return {
      appState: {
        ...appState,
        openDialog: appState.openDialog?.name === "help" ? null : {
          name: "help"
        },
        openMenu: null,
        openPopup: null
      },
      captureUpdate: CaptureUpdateAction11.EVENTUALLY
    };
  },
  keyTest: (event) => event.key === KEYS17.QUESTION_MARK
});

// actions/actionGroup.tsx
import { getNonDeletedElements as getNonDeletedElements8 } from "@excalidraw/element";
import { newElementWith as newElementWith6 } from "@excalidraw/element";
import { isBoundToContainer as isBoundToContainer3 } from "@excalidraw/element";
import {
  frameAndChildrenSelectedTogether,
  getElementsInResizingFrame,
  getFrameLikeElements,
  getRootElements,
  groupByFrameLikes,
  removeElementsFromFrame,
  replaceAllElementsInFrame
} from "@excalidraw/element";
import { KEYS as KEYS18, randomId as randomId2, arrayToMap as arrayToMap6 } from "@excalidraw/common";
import {
  getSelectedGroupIds,
  selectGroup,
  selectGroupsForSelectedElements as selectGroupsForSelectedElements3,
  getElementsInGroup as getElementsInGroup2,
  addToGroup,
  removeFromSelectedGroups,
  isElementInGroup
} from "@excalidraw/element";
import { syncMovedIndices as syncMovedIndices2 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction12 } from "@excalidraw/element";
import { jsx as jsx42 } from "react/jsx-runtime";
var allElementsInSameGroup = (elements) => {
  if (elements.length >= 2) {
    const groupIds = elements[0].groupIds;
    for (const groupId of groupIds) {
      if (elements.reduce(
        (acc, element) => acc && isElementInGroup(element, groupId),
        true
      )) {
        return true;
      }
    }
  }
  return false;
};
var enableActionGroup = (elements, appState, app) => {
  const selectedElements = app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: true
  });
  return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements) && !frameAndChildrenSelectedTogether(selectedElements);
};
var actionGroup = register({
  name: "group",
  label: "labels.group",
  icon: (appState) => /* @__PURE__ */ jsx42(GroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = getRootElements(
      app.scene.getSelectedElements({
        selectedElementIds: appState.selectedElementIds,
        includeBoundTextElement: true
      })
    );
    if (selectedElements.length < 2) {
      return {
        appState,
        elements,
        captureUpdate: CaptureUpdateAction12.EVENTUALLY
      };
    }
    const selectedGroupIds = getSelectedGroupIds(appState);
    if (selectedGroupIds.length === 1) {
      const selectedGroupId = selectedGroupIds[0];
      const elementIdsInGroup = new Set(
        getElementsInGroup2(elements, selectedGroupId).map(
          (element) => element.id
        )
      );
      const selectedElementIds = new Set(
        selectedElements.map((element) => element.id)
      );
      const combinedSet = /* @__PURE__ */ new Set([
        ...Array.from(elementIdsInGroup),
        ...Array.from(selectedElementIds)
      ]);
      if (combinedSet.size === elementIdsInGroup.size) {
        return {
          appState,
          elements,
          captureUpdate: CaptureUpdateAction12.EVENTUALLY
        };
      }
    }
    let nextElements = [...elements];
    const groupingElementsFromDifferentFrames = new Set(selectedElements.map((element) => element.frameId)).size > 1;
    if (groupingElementsFromDifferentFrames) {
      const frameElementsMap = groupByFrameLikes(selectedElements);
      frameElementsMap.forEach((elementsInFrame, frameId) => {
        removeElementsFromFrame(
          elementsInFrame,
          app.scene.getNonDeletedElementsMap()
        );
      });
    }
    const newGroupId = randomId2();
    const selectElementIds = arrayToMap6(selectedElements);
    nextElements = nextElements.map((element) => {
      if (!selectElementIds.get(element.id)) {
        return element;
      }
      return newElementWith6(element, {
        groupIds: addToGroup(
          element.groupIds,
          newGroupId,
          appState.editingGroupId
        )
      });
    });
    const elementsInGroup = getElementsInGroup2(nextElements, newGroupId);
    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];
    const lastGroupElementIndex = nextElements.lastIndexOf(
      lastElementInGroup
    );
    const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);
    const elementsBeforeGroup = nextElements.slice(0, lastGroupElementIndex).filter(
      (updatedElement) => !isElementInGroup(updatedElement, newGroupId)
    );
    const reorderedElements = syncMovedIndices2(
      [...elementsBeforeGroup, ...elementsInGroup, ...elementsAfterGroup],
      arrayToMap6(elementsInGroup)
    );
    return {
      appState: {
        ...appState,
        ...selectGroup(
          newGroupId,
          { ...appState, selectedGroupIds: {} },
          getNonDeletedElements8(nextElements)
        )
      },
      elements: reorderedElements,
      captureUpdate: CaptureUpdateAction12.IMMEDIATELY
    };
  },
  predicate: (elements, appState, _, app) => enableActionGroup(elements, appState, app),
  keyTest: (event) => !event.shiftKey && event[KEYS18.CTRL_OR_CMD] && event.key === KEYS18.G,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx42(
    ToolButton,
    {
      hidden: !enableActionGroup(elements, appState, app),
      type: "button",
      icon: /* @__PURE__ */ jsx42(GroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.group")} \u2014 ${getShortcutKey("CtrlOrCmd+G")}`,
      "aria-label": t("labels.group"),
      visible: isSomeElementSelected(getNonDeletedElements8(elements), appState)
    }
  )
});
var actionUngroup = register({
  name: "ungroup",
  label: "labels.ungroup",
  icon: (appState) => /* @__PURE__ */ jsx42(UngroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const groupIds = getSelectedGroupIds(appState);
    const elementsMap = arrayToMap6(elements);
    if (groupIds.length === 0) {
      return {
        appState,
        elements,
        captureUpdate: CaptureUpdateAction12.EVENTUALLY
      };
    }
    let nextElements = [...elements];
    const boundTextElementIds = [];
    nextElements = nextElements.map((element) => {
      if (isBoundToContainer3(element)) {
        boundTextElementIds.push(element.id);
      }
      const nextGroupIds = removeFromSelectedGroups(
        element.groupIds,
        appState.selectedGroupIds
      );
      if (nextGroupIds.length === element.groupIds.length) {
        return element;
      }
      return newElementWith6(element, {
        groupIds: nextGroupIds
      });
    });
    const updateAppState = selectGroupsForSelectedElements3(
      appState,
      getNonDeletedElements8(nextElements),
      appState,
      null
    );
    const selectedElements = app.scene.getSelectedElements(appState);
    const selectedElementFrameIds = new Set(
      selectedElements.filter((element) => element.frameId).map((element) => element.frameId)
    );
    const targetFrames = getFrameLikeElements(elements).filter(
      (frame) => selectedElementFrameIds.has(frame.id)
    );
    targetFrames.forEach((frame) => {
      if (frame) {
        nextElements = replaceAllElementsInFrame(
          nextElements,
          getElementsInResizingFrame(
            nextElements,
            frame,
            appState,
            elementsMap
          ),
          frame,
          app
        );
      }
    });
    updateAppState.selectedElementIds = Object.entries(
      updateAppState.selectedElementIds
    ).reduce(
      (acc, [id, selected]) => {
        if (selected && !boundTextElementIds.includes(id)) {
          acc[id] = true;
        }
        return acc;
      },
      {}
    );
    return {
      appState: { ...appState, ...updateAppState },
      elements: nextElements,
      captureUpdate: CaptureUpdateAction12.IMMEDIATELY
    };
  },
  keyTest: (event) => event.shiftKey && event[KEYS18.CTRL_OR_CMD] && event.key === KEYS18.G.toUpperCase(),
  predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx42(
    ToolButton,
    {
      type: "button",
      hidden: getSelectedGroupIds(appState).length === 0,
      icon: /* @__PURE__ */ jsx42(UngroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.ungroup")} \u2014 ${getShortcutKey("CtrlOrCmd+Shift+G")}`,
      "aria-label": t("labels.ungroup"),
      visible: isSomeElementSelected(getNonDeletedElements8(elements), appState)
    }
  )
});

// actions/actionNavigate.tsx
import clsx19 from "clsx";
import { CaptureUpdateAction as CaptureUpdateAction13 } from "@excalidraw/element";
import { invariant as invariant3 } from "@excalidraw/common";

// clients.ts
import {
  COLOR_CHARCOAL_BLACK,
  COLOR_VOICE_CALL,
  COLOR_WHITE,
  THEME as THEME8,
  UserIdleState
} from "@excalidraw/common";

// renderer/roundRect.ts
var roundRect = (context, x, y, width, height, radius, strokeColor) => {
  context.beginPath();
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(
    x + width,
    y + height,
    x + width - radius,
    y + height
  );
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
  context.closePath();
  context.fill();
  if (strokeColor) {
    context.strokeStyle = strokeColor;
  }
  context.stroke();
};

// clients.ts
function hashToInteger(id) {
  let hash = 0;
  if (id.length === 0) {
    return hash;
  }
  for (let i = 0; i < id.length; i++) {
    const char = id.charCodeAt(i);
    hash = (hash << 5) - hash + char;
  }
  return hash;
}
var getClientColor = (socketId, collaborator) => {
  const hash = Math.abs(hashToInteger(collaborator?.id || socketId));
  const hue = hash % 37 * 10;
  const saturation = 100;
  const lightness = 83;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};
var getNameInitial = (name) => {
  const firstCodePoint = name?.trim()?.codePointAt(0);
  return (firstCodePoint ? String.fromCodePoint(firstCodePoint) : "?").toUpperCase();
};
var renderRemoteCursors = ({
  context,
  renderConfig,
  appState,
  normalizedWidth,
  normalizedHeight
}) => {
  for (const [socketId, pointer] of renderConfig.remotePointerViewportCoords) {
    let { x, y } = pointer;
    const collaborator = appState.collaborators.get(socketId);
    x -= appState.offsetLeft;
    y -= appState.offsetTop;
    const width = 11;
    const height = 14;
    const isOutOfBounds = x < 0 || x > normalizedWidth - width || y < 0 || y > normalizedHeight - height;
    x = Math.max(x, 0);
    x = Math.min(x, normalizedWidth - width);
    y = Math.max(y, 0);
    y = Math.min(y, normalizedHeight - height);
    const background = getClientColor(socketId, collaborator);
    context.save();
    context.strokeStyle = background;
    context.fillStyle = background;
    const userState = renderConfig.remotePointerUserStates.get(socketId);
    const isInactive = isOutOfBounds || userState === UserIdleState.IDLE || userState === UserIdleState.AWAY;
    if (isInactive) {
      context.globalAlpha = 0.3;
    }
    if (renderConfig.remotePointerButton.get(socketId) === "down") {
      context.beginPath();
      context.arc(x, y, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 3;
      context.strokeStyle = "#ffffff88";
      context.stroke();
      context.closePath();
      context.beginPath();
      context.arc(x, y, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 1;
      context.strokeStyle = background;
      context.stroke();
      context.closePath();
    }
    const IS_SPEAKING_COLOR = appState.theme === THEME8.DARK ? "#2f6330" : COLOR_VOICE_CALL;
    const isSpeaking = collaborator?.isSpeaking;
    if (isSpeaking) {
      context.fillStyle = IS_SPEAKING_COLOR;
      context.strokeStyle = IS_SPEAKING_COLOR;
      context.lineWidth = 10;
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x + 0, y + 14);
      context.lineTo(x + 4, y + 9);
      context.lineTo(x + 11, y + 8);
      context.closePath();
      context.stroke();
      context.fill();
    }
    context.fillStyle = COLOR_WHITE;
    context.strokeStyle = COLOR_WHITE;
    context.lineWidth = 6;
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x + 0, y + 14);
    context.lineTo(x + 4, y + 9);
    context.lineTo(x + 11, y + 8);
    context.closePath();
    context.stroke();
    context.fill();
    context.fillStyle = background;
    context.strokeStyle = background;
    context.lineWidth = 2;
    context.lineJoin = "round";
    context.beginPath();
    if (isInactive) {
      context.moveTo(x - 1, y - 1);
      context.lineTo(x - 1, y + 15);
      context.lineTo(x + 5, y + 10);
      context.lineTo(x + 12, y + 9);
      context.closePath();
      context.fill();
    } else {
      context.moveTo(x, y);
      context.lineTo(x + 0, y + 14);
      context.lineTo(x + 4, y + 9);
      context.lineTo(x + 11, y + 8);
      context.closePath();
      context.fill();
      context.stroke();
    }
    const username = renderConfig.remotePointerUsernames.get(socketId) || "";
    if (!isOutOfBounds && username) {
      context.font = "600 12px sans-serif";
      const offsetX = (isSpeaking ? x + 0 : x) + width / 2;
      const offsetY = (isSpeaking ? y + 0 : y) + height + 2;
      const paddingHorizontal = 5;
      const paddingVertical = 3;
      const measure = context.measureText(username);
      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;
      const finalHeight = Math.max(measureHeight, 12);
      const boxX = offsetX - 1;
      const boxY = offsetY - 1;
      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;
      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;
      if (context.roundRect) {
        context.beginPath();
        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
        context.fillStyle = background;
        context.fill();
        context.strokeStyle = COLOR_WHITE;
        context.stroke();
        if (isSpeaking) {
          context.beginPath();
          context.roundRect(boxX - 2, boxY - 2, boxWidth + 4, boxHeight + 4, 8);
          context.strokeStyle = IS_SPEAKING_COLOR;
          context.stroke();
        }
      } else {
        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, COLOR_WHITE);
      }
      context.fillStyle = COLOR_CHARCOAL_BLACK;
      context.fillText(
        username,
        offsetX + paddingHorizontal + 1,
        offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2
      );
      if (isSpeaking) {
        context.fillStyle = IS_SPEAKING_COLOR;
        const barheight = 8;
        const margin = 8;
        const gap = 5;
        context.fillRect(
          boxX + boxWidth + margin,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
        context.fillRect(
          boxX + boxWidth + margin + gap,
          boxY + (boxHeight / 2 - barheight * 2 / 2),
          2,
          barheight * 2
        );
        context.fillRect(
          boxX + boxWidth + margin + gap * 2,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
      }
    }
    context.restore();
    context.closePath();
  }
};

// components/Avatar.tsx
import clsx18 from "clsx";
import { useState as useState9 } from "react";
import { jsx as jsx43 } from "react/jsx-runtime";
var Avatar = ({
  color,
  onClick,
  name,
  src,
  className
}) => {
  const shortName = getNameInitial(name);
  const [error, setError] = useState9(false);
  const loadImg = !error && src;
  const style = loadImg ? void 0 : { background: color };
  return /* @__PURE__ */ jsx43("div", { className: clsx18("Avatar", className), style, onClick, children: loadImg ? /* @__PURE__ */ jsx43(
    "img",
    {
      className: "Avatar-img",
      src,
      alt: shortName,
      referrerPolicy: "no-referrer",
      onError: () => setError(true)
    }
  ) : shortName });
};

// actions/actionNavigate.tsx
import { jsx as jsx44, jsxs as jsxs25 } from "react/jsx-runtime";
var actionGoToCollaborator = register({
  name: "goToCollaborator",
  label: "Go to a collaborator",
  viewMode: true,
  trackEvent: { category: "collab" },
  perform: (_elements, appState, collaborator) => {
    invariant3(
      collaborator,
      "actionGoToCollaborator: collaborator should be defined when actionGoToCollaborator is called"
    );
    if (!collaborator.socketId || appState.userToFollow?.socketId === collaborator.socketId || collaborator.isCurrentUser) {
      return {
        appState: {
          ...appState,
          userToFollow: null
        },
        captureUpdate: CaptureUpdateAction13.EVENTUALLY
      };
    }
    return {
      appState: {
        ...appState,
        userToFollow: {
          socketId: collaborator.socketId,
          username: collaborator.username || ""
        },
        // Close mobile menu
        openMenu: appState.openMenu === "canvas" ? null : appState.openMenu
      },
      captureUpdate: CaptureUpdateAction13.EVENTUALLY
    };
  },
  PanelComponent: ({ updateData, data, appState }) => {
    const { socketId, collaborator, withName, isBeingFollowed } = data;
    const background = getClientColor(socketId, collaborator);
    const statusClassNames = clsx19({
      "is-followed": isBeingFollowed,
      "is-current-user": collaborator.isCurrentUser === true,
      "is-speaking": collaborator.isSpeaking,
      "is-in-call": collaborator.isInCall,
      "is-muted": collaborator.isMuted
    });
    const statusIconJSX = collaborator.isInCall ? collaborator.isSpeaking ? /* @__PURE__ */ jsxs25(
      "div",
      {
        className: "UserList__collaborator-status-icon-speaking-indicator",
        title: t("userList.hint.isSpeaking"),
        children: [
          /* @__PURE__ */ jsx44("div", {}),
          /* @__PURE__ */ jsx44("div", {}),
          /* @__PURE__ */ jsx44("div", {})
        ]
      }
    ) : collaborator.isMuted ? /* @__PURE__ */ jsx44(
      "div",
      {
        className: "UserList__collaborator-status-icon-microphone-muted",
        title: t("userList.hint.micMuted"),
        children: microphoneMutedIcon
      }
    ) : /* @__PURE__ */ jsx44("div", { title: t("userList.hint.inCall"), children: microphoneIcon }) : null;
    return withName ? /* @__PURE__ */ jsxs25(
      "div",
      {
        className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${statusClassNames}`,
        style: { [`--avatar-size`]: "1.5rem" },
        onClick: () => updateData(collaborator),
        children: [
          /* @__PURE__ */ jsx44(
            Avatar,
            {
              color: background,
              onClick: () => {
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          /* @__PURE__ */ jsx44("div", { className: "UserList__collaborator-name", children: collaborator.username }),
          /* @__PURE__ */ jsxs25("div", { className: "UserList__collaborator-status-icons", "aria-hidden": true, children: [
            isBeingFollowed && /* @__PURE__ */ jsx44(
              "div",
              {
                className: "UserList__collaborator-status-icon-is-followed",
                title: t("userList.hint.followStatus"),
                children: eyeIcon
              }
            ),
            statusIconJSX
          ] })
        ]
      }
    ) : /* @__PURE__ */ jsxs25(
      "div",
      {
        className: `UserList__collaborator UserList__collaborator--avatar-only ${statusClassNames}`,
        children: [
          /* @__PURE__ */ jsx44(
            Avatar,
            {
              color: background,
              onClick: () => {
                updateData(collaborator);
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          statusIconJSX && /* @__PURE__ */ jsx44("div", { className: "UserList__collaborator-status-icon", children: statusIconJSX })
        ]
      }
    );
  }
});

// actions/actionAddToLibrary.ts
import { LIBRARY_DISABLED_TYPES, randomId as randomId3 } from "@excalidraw/common";
import { deepCopyElement as deepCopyElement2 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction14 } from "@excalidraw/element";
var actionAddToLibrary = register({
  name: "addToLibrary",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    for (const type of LIBRARY_DISABLED_TYPES) {
      if (selectedElements.some((element) => element.type === type)) {
        return {
          captureUpdate: CaptureUpdateAction14.EVENTUALLY,
          appState: {
            ...appState,
            errorMessage: t(`errors.libraryElementTypeError.${type}`)
          }
        };
      }
    }
    return app.library.getLatestLibrary().then((items) => {
      return app.library.setLibrary([
        {
          id: randomId3(),
          status: "unpublished",
          elements: selectedElements.map(deepCopyElement2),
          created: Date.now()
        },
        ...items
      ]);
    }).then(() => {
      return {
        captureUpdate: CaptureUpdateAction14.EVENTUALLY,
        appState: {
          ...appState,
          toast: { message: t("toast.addedToLibrary") }
        }
      };
    }).catch((error) => {
      return {
        captureUpdate: CaptureUpdateAction14.EVENTUALLY,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    });
  },
  label: "labels.addToLibrary"
});

// actions/actionAlign.tsx
import { getNonDeletedElements as getNonDeletedElements9 } from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement5 } from "@excalidraw/element";
import { updateFrameMembershipOfSelectedElements } from "@excalidraw/element";
import { KEYS as KEYS19, arrayToMap as arrayToMap7 } from "@excalidraw/common";
import { alignElements } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction15 } from "@excalidraw/element";
import { getSelectedElementsByGroup } from "@excalidraw/element";
import { jsx as jsx45 } from "react/jsx-runtime";
var alignActionsPredicate = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return getSelectedElementsByGroup(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    appState
  ).length > 1 && // TODO enable aligning frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement5(el));
};
var alignSelectedElements = (elements, appState, app, alignment) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const updatedElements = alignElements(
    selectedElements,
    alignment,
    app.scene,
    appState
  );
  const updatedElementsMap = arrayToMap7(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var actionAlignTop = register({
  name: "alignTop",
  label: "labels.alignTop",
  icon: AlignTopIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "y"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS19.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS19.ARROW_UP,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: AlignTopIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignTop")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Up"
      )}`,
      "aria-label": t("labels.alignTop"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});
var actionAlignBottom = register({
  name: "alignBottom",
  label: "labels.alignBottom",
  icon: AlignBottomIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "y"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS19.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS19.ARROW_DOWN,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: AlignBottomIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignBottom")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Down"
      )}`,
      "aria-label": t("labels.alignBottom"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});
var actionAlignLeft = register({
  name: "alignLeft",
  label: "labels.alignLeft",
  icon: AlignLeftIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "x"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS19.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS19.ARROW_LEFT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: AlignLeftIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignLeft")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Left"
      )}`,
      "aria-label": t("labels.alignLeft"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});
var actionAlignRight = register({
  name: "alignRight",
  label: "labels.alignRight",
  icon: AlignRightIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "x"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  keyTest: (event) => event[KEYS19.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS19.ARROW_RIGHT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: AlignRightIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignRight")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Right"
      )}`,
      "aria-label": t("labels.alignRight"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});
var actionAlignVerticallyCentered = register({
  name: "alignVerticallyCentered",
  label: "labels.centerVertically",
  icon: CenterVerticallyIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "y"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: CenterVerticallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerVertically"),
      "aria-label": t("labels.centerVertically"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});
var actionAlignHorizontallyCentered = register({
  name: "alignHorizontallyCentered",
  label: "labels.centerHorizontally",
  icon: CenterHorizontallyIcon,
  trackEvent: { category: "element" },
  predicate: (elements, appState, appProps, app) => alignActionsPredicate(appState, app),
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "x"
      }),
      captureUpdate: CaptureUpdateAction15.IMMEDIATELY
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(appState, app),
      type: "button",
      icon: CenterHorizontallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerHorizontally"),
      "aria-label": t("labels.centerHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements9(elements), appState)
    }
  )
});

// actions/actionDistribute.tsx
import { getNonDeletedElements as getNonDeletedElements10 } from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement6 } from "@excalidraw/element";
import { CODES as CODES4, KEYS as KEYS20, arrayToMap as arrayToMap8 } from "@excalidraw/common";
import { updateFrameMembershipOfSelectedElements as updateFrameMembershipOfSelectedElements2 } from "@excalidraw/element";
import { distributeElements } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction16 } from "@excalidraw/element";
import { getSelectedElementsByGroup as getSelectedElementsByGroup2 } from "@excalidraw/element";
import { jsx as jsx46 } from "react/jsx-runtime";
var enableActionGroup2 = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return getSelectedElementsByGroup2(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    appState
  ).length > 2 && // TODO enable distributing frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement6(el));
};
var distributeSelectedElements = (elements, appState, app, distribution) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const updatedElements = distributeElements(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    distribution,
    appState,
    app.scene
  );
  const updatedElementsMap = arrayToMap8(updatedElements);
  return updateFrameMembershipOfSelectedElements2(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var distributeHorizontally = register({
  name: "distributeHorizontally",
  label: "labels.distributeHorizontally",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "x"
      }),
      captureUpdate: CaptureUpdateAction16.IMMEDIATELY
    };
  },
  keyTest: (event) => !event[KEYS20.CTRL_OR_CMD] && event.altKey && event.code === CODES4.H,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx46(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeHorizontallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeHorizontally")} \u2014 ${getShortcutKey(
        "Alt+H"
      )}`,
      "aria-label": t("labels.distributeHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements10(elements), appState)
    }
  )
});
var distributeVertically = register({
  name: "distributeVertically",
  label: "labels.distributeVertically",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "y"
      }),
      captureUpdate: CaptureUpdateAction16.IMMEDIATELY
    };
  },
  keyTest: (event) => !event[KEYS20.CTRL_OR_CMD] && event.altKey && event.code === CODES4.V,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx46(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeVerticallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeVertically")} \u2014 ${getShortcutKey("Alt+V")}`,
      "aria-label": t("labels.distributeVertically"),
      visible: isSomeElementSelected(getNonDeletedElements10(elements), appState)
    }
  )
});

// actions/actionFlip.ts
import { getNonDeletedElements as getNonDeletedElements11 } from "@excalidraw/element";
import { bindOrUnbindBindingElements } from "@excalidraw/element";
import { getCommonBoundingBox } from "@excalidraw/element";
import { newElementWith as newElementWith7 } from "@excalidraw/element";
import { deepCopyElement as deepCopyElement3 } from "@excalidraw/element";
import { resizeMultipleElements } from "@excalidraw/element";
import { isArrowElement as isArrowElement3, isElbowArrow as isElbowArrow3 } from "@excalidraw/element";
import { updateFrameMembershipOfSelectedElements as updateFrameMembershipOfSelectedElements3 } from "@excalidraw/element";
import { CODES as CODES5, KEYS as KEYS21, arrayToMap as arrayToMap9 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction17 } from "@excalidraw/element";
var actionFlipHorizontal = register({
  name: "flipHorizontal",
  label: "labels.flipHorizontal",
  icon: flipHorizontal,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements3(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "horizontal",
          app
        ),
        appState,
        app
      ),
      appState,
      captureUpdate: CaptureUpdateAction17.IMMEDIATELY
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES5.H
});
var actionFlipVertical = register({
  name: "flipVertical",
  label: "labels.flipVertical",
  icon: flipVertical,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements3(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "vertical",
          app
        ),
        appState,
        app
      ),
      appState,
      captureUpdate: CaptureUpdateAction17.IMMEDIATELY
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES5.V && !event[KEYS21.CTRL_OR_CMD]
});
var flipSelectedElements = (elements, elementsMap, appState, flipDirection, app) => {
  const selectedElements = getSelectedElements(
    getNonDeletedElements11(elements),
    appState,
    {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    }
  );
  const updatedElements = flipElements(
    selectedElements,
    elementsMap,
    flipDirection,
    app
  );
  const updatedElementsMap = arrayToMap9(updatedElements);
  return elements.map(
    (element) => updatedElementsMap.get(element.id) || element
  );
};
var flipElements = (selectedElements, elementsMap, flipDirection, app) => {
  if (selectedElements.every(
    (element) => isArrowElement3(element) && (element.startBinding || element.endBinding)
  )) {
    return selectedElements.map((element) => {
      const _element = element;
      return newElementWith7(_element, {
        startArrowhead: _element.endArrowhead,
        endArrowhead: _element.startArrowhead
      });
    });
  }
  const { midX, midY } = getCommonBoundingBox(selectedElements);
  resizeMultipleElements(
    selectedElements,
    elementsMap,
    "nw",
    app.scene,
    new Map(
      Array.from(elementsMap.values()).map((element) => [
        element.id,
        deepCopyElement3(element)
      ])
    ),
    {
      flipByX: flipDirection === "horizontal",
      flipByY: flipDirection === "vertical",
      shouldResizeFromCenter: true,
      shouldMaintainAspectRatio: true
    }
  );
  bindOrUnbindBindingElements(
    selectedElements.filter(isArrowElement3),
    app.scene,
    app.state
  );
  const { elbowArrows, otherElements } = selectedElements.reduce(
    (acc, element) => isElbowArrow3(element) ? { ...acc, elbowArrows: acc.elbowArrows.concat(element) } : { ...acc, otherElements: acc.otherElements.concat(element) },
    { elbowArrows: [], otherElements: [] }
  );
  const { midX: newMidX, midY: newMidY } = getCommonBoundingBox(selectedElements);
  const [diffX, diffY] = [midX - newMidX, midY - newMidY];
  otherElements.forEach(
    (element) => app.scene.mutateElement(element, {
      x: element.x + diffX,
      y: element.y + diffY
    })
  );
  elbowArrows.forEach(
    (element) => app.scene.mutateElement(element, {
      x: element.x + diffX,
      y: element.y + diffY
    })
  );
  return selectedElements;
};

// actions/actionClipboard.tsx
import { isTextElement as isTextElement4 } from "@excalidraw/element";
import { getTextFromElements } from "@excalidraw/element";
import { CODES as CODES6, KEYS as KEYS22, isFirefox as isFirefox2 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction18 } from "@excalidraw/element";
var actionCopy = register({
  name: "copy",
  label: "labels.copy",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, event, app) => {
    const elementsToCopy = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    try {
      await copyToClipboard(elementsToCopy, app.files, event);
    } catch (error) {
      return {
        captureUpdate: CaptureUpdateAction18.EVENTUALLY,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    }
    return {
      captureUpdate: CaptureUpdateAction18.EVENTUALLY
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionPaste = register({
  name: "paste",
  label: "labels.paste",
  trackEvent: { category: "element" },
  perform: async (elements, appState, data, app) => {
    let types;
    try {
      types = await readSystemClipboard();
    } catch (error) {
      if (error.name === "AbortError" || error.name === "NotAllowedError") {
        return false;
      }
      console.error(`actionPaste ${error.name}: ${error.message}`);
      if (isFirefox2) {
        return {
          captureUpdate: CaptureUpdateAction18.EVENTUALLY,
          appState: {
            ...appState,
            errorMessage: t("hints.firefox_clipboard_write")
          }
        };
      }
      return {
        captureUpdate: CaptureUpdateAction18.EVENTUALLY,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnRead")
        }
      };
    }
    try {
      app.pasteFromClipboard(createPasteEvent({ types }));
    } catch (error) {
      console.error(error);
      return {
        captureUpdate: CaptureUpdateAction18.EVENTUALLY,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnParse")
        }
      };
    }
    return {
      captureUpdate: CaptureUpdateAction18.EVENTUALLY
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionCut = register({
  name: "cut",
  label: "labels.cut",
  icon: cutIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, event, app) => {
    actionCopy.perform(elements, appState, event, app);
    return actionDeleteSelected.perform(elements, appState, null, app);
  },
  keyTest: (event) => event[KEYS22.CTRL_OR_CMD] && event.key === KEYS22.X
});
var actionCopyAsSvg = register({
  name: "copyAsSvg",
  label: "labels.copyAsSvg",
  icon: svgIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    }
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas(
        "clipboard-svg",
        exportedElements,
        appState,
        app.files,
        {
          ...appState,
          exportingFrame,
          name: app.getName()
        }
      );
      const selectedElements = app.scene.getSelectedElements({
        selectedElementIds: appState.selectedElementIds,
        includeBoundTextElement: true,
        includeElementsInFrames: true
      });
      return {
        appState: {
          toast: {
            message: t("toast.copyToClipboardAsSvg", {
              exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
              exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
            })
          }
        },
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          errorMessage: error.message
        },
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardWriteText && elements.length > 0;
  },
  keywords: ["svg", "clipboard", "copy"]
});
var actionCopyAsPng = register({
  name: "copyAsPng",
  label: "labels.copyAsPng",
  icon: pngIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    }
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas("clipboard", exportedElements, appState, app.files, {
        ...appState,
        exportingFrame,
        name: app.getName()
      });
      return {
        appState: {
          ...appState,
          toast: {
            message: t("toast.copyToClipboardAsPng", {
              exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
              exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
            })
          }
        },
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        captureUpdate: CaptureUpdateAction18.EVENTUALLY
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardBlob && elements.length > 0;
  },
  keyTest: (event) => event.code === CODES6.C && event.altKey && event.shiftKey,
  keywords: ["png", "clipboard", "copy"]
});
var copyText = register({
  name: "copyText",
  label: "labels.copyText",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    try {
      copyTextToSystemClipboard(getTextFromElements(selectedElements));
    } catch (e) {
      throw new Error(t("errors.copyToSystemClipboardFailed"));
    }
    return {
      captureUpdate: CaptureUpdateAction18.EVENTUALLY
    };
  },
  predicate: (elements, appState, _, app) => {
    return probablySupportsClipboardWriteText && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    }).some(isTextElement4);
  },
  keywords: ["text", "clipboard", "copy"]
});

// actions/actionToggleGridMode.tsx
import { CODES as CODES7, KEYS as KEYS23 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction19 } from "@excalidraw/element";
var actionToggleGridMode = register({
  name: "gridMode",
  icon: gridIcon,
  keywords: ["snap"],
  label: "labels.toggleGrid",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        gridModeEnabled: !this.checked(appState),
        objectsSnapModeEnabled: false
      },
      captureUpdate: CaptureUpdateAction19.EVENTUALLY
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS23.CTRL_OR_CMD] && event.code === CODES7.QUOTE
});

// actions/actionToggleZenMode.tsx
import { CODES as CODES8, KEYS as KEYS24 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction20 } from "@excalidraw/element";
var actionToggleZenMode = register({
  name: "zenMode",
  label: "buttons.zenMode",
  icon: coffeeIcon,
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.zenModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        zenModeEnabled: !this.checked(appState)
      },
      captureUpdate: CaptureUpdateAction20.EVENTUALLY
    };
  },
  checked: (appState) => appState.zenModeEnabled,
  predicate: (elements, appState, appProps, app) => {
    return app.editorInterface.formFactor !== "phone" && typeof appProps.zenModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS24.CTRL_OR_CMD] && event.altKey && event.code === CODES8.Z
});

// actions/actionToggleObjectsSnapMode.tsx
import { CODES as CODES9, KEYS as KEYS25 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction21 } from "@excalidraw/element";
var actionToggleObjectsSnapMode = register({
  name: "objectsSnapMode",
  label: "buttons.objectsSnapMode",
  icon: magnetIcon,
  viewMode: false,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.objectsSnapModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        objectsSnapModeEnabled: !this.checked(appState),
        gridModeEnabled: false
      },
      captureUpdate: CaptureUpdateAction21.EVENTUALLY
    };
  },
  checked: (appState) => appState.objectsSnapModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.objectsSnapModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS25.CTRL_OR_CMD] && event.altKey && event.code === CODES9.S
});

// actions/actionToggleStats.tsx
import { CODES as CODES10, KEYS as KEYS26 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction22 } from "@excalidraw/element";
var actionToggleStats = register({
  name: "stats",
  label: "stats.fullTitle",
  icon: abacusIcon,
  viewMode: true,
  trackEvent: { category: "menu" },
  keywords: ["edit", "attributes", "customize"],
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        stats: { ...appState.stats, open: !this.checked(appState) }
      },
      captureUpdate: CaptureUpdateAction22.EVENTUALLY
    };
  },
  checked: (appState) => appState.stats.open,
  keyTest: (event) => !event[KEYS26.CTRL_OR_CMD] && event.altKey && event.code === CODES10.SLASH
});

// actions/actionBoundText.tsx
import {
  BOUND_TEXT_PADDING,
  ROUNDNESS as ROUNDNESS2,
  TEXT_ALIGN,
  VERTICAL_ALIGN as VERTICAL_ALIGN3,
  arrayToMap as arrayToMap10,
  getFontString
} from "@excalidraw/common";
import {
  getOriginalContainerHeightFromCache,
  isBoundToContainer as isBoundToContainer4,
  resetOriginalContainerCache,
  updateOriginalContainerCache
} from "@excalidraw/element";
import {
  computeBoundTextPosition,
  computeContainerDimensionForBoundText,
  getBoundTextElement as getBoundTextElement3,
  redrawTextBoundingBox as redrawTextBoundingBox3
} from "@excalidraw/element";
import {
  hasBoundTextElement as hasBoundTextElement2,
  isArrowElement as isArrowElement4,
  isTextBindableContainer,
  isTextElement as isTextElement5,
  isUsingAdaptiveRadius as isUsingAdaptiveRadius2
} from "@excalidraw/element";
import { measureText } from "@excalidraw/element";
import { syncMovedIndices as syncMovedIndices3 } from "@excalidraw/element";
import { newElement as newElement2 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction23 } from "@excalidraw/element";
var actionUnbindText = register({
  name: "unbindText",
  label: "labels.unbindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.some((element) => hasBoundTextElement2(element));
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const elementsMap = app.scene.getNonDeletedElementsMap();
    selectedElements.forEach((element) => {
      const boundTextElement = getBoundTextElement3(element, elementsMap);
      if (boundTextElement) {
        const { width, height } = measureText(
          boundTextElement.originalText,
          getFontString(boundTextElement),
          boundTextElement.lineHeight
        );
        const originalContainerHeight = getOriginalContainerHeightFromCache(
          element.id
        );
        resetOriginalContainerCache(element.id);
        const { x, y } = computeBoundTextPosition(
          element,
          boundTextElement,
          elementsMap
        );
        app.scene.mutateElement(boundTextElement, {
          containerId: null,
          width,
          height,
          text: boundTextElement.originalText,
          x,
          y
        });
        app.scene.mutateElement(element, {
          boundElements: element.boundElements?.filter(
            (ele) => ele.id !== boundTextElement.id
          ),
          height: originalContainerHeight ? originalContainerHeight : element.height
        });
      }
    });
    return {
      elements,
      appState,
      captureUpdate: CaptureUpdateAction23.IMMEDIATELY
    };
  }
});
var actionBindText = register({
  name: "bindText",
  label: "labels.bindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.length === 2) {
      const textElement = isTextElement5(selectedElements[0]) || isTextElement5(selectedElements[1]);
      let bindingContainer;
      if (isTextBindableContainer(selectedElements[0])) {
        bindingContainer = selectedElements[0];
      } else if (isTextBindableContainer(selectedElements[1])) {
        bindingContainer = selectedElements[1];
      }
      if (textElement && bindingContainer && getBoundTextElement3(
        bindingContainer,
        app.scene.getNonDeletedElementsMap()
      ) === null) {
        return true;
      }
    }
    return false;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let textElement;
    let container;
    if (isTextElement5(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {
      textElement = selectedElements[0];
      container = selectedElements[1];
    } else {
      textElement = selectedElements[1];
      container = selectedElements[0];
    }
    app.scene.mutateElement(textElement, {
      containerId: container.id,
      verticalAlign: VERTICAL_ALIGN3.MIDDLE,
      textAlign: TEXT_ALIGN.CENTER,
      autoResize: true,
      angle: isArrowElement4(container) ? 0 : container?.angle ?? 0
    });
    app.scene.mutateElement(container, {
      boundElements: (container.boundElements || []).concat({
        type: "text",
        id: textElement.id
      })
    });
    const originalContainerHeight = container.height;
    redrawTextBoundingBox3(textElement, container, app.scene);
    updateOriginalContainerCache(container.id, originalContainerHeight);
    return {
      elements: pushTextAboveContainer(elements, container, textElement),
      appState: { ...appState, selectedElementIds: { [container.id]: true } },
      captureUpdate: CaptureUpdateAction23.IMMEDIATELY
    };
  }
});
var pushTextAboveContainer = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 1);
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex + 1, 0, textElement);
  syncMovedIndices3(updatedElements, arrayToMap10([container, textElement]));
  return updatedElements;
};
var pushContainerBelowText = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex, 1);
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 0, container);
  syncMovedIndices3(updatedElements, arrayToMap10([container, textElement]));
  return updatedElements;
};
var actionWrapTextInContainer = register({
  name: "wrapTextInContainer",
  label: "labels.createContainerFromText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const someTextElements = selectedElements.some(
      (el) => isTextElement5(el) && !isBoundToContainer4(el)
    );
    return selectedElements.length > 0 && someTextElements;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let updatedElements = elements.slice();
    const containerIds = {};
    for (const textElement of selectedElements) {
      if (isTextElement5(textElement) && !isBoundToContainer4(textElement)) {
        const container = newElement2({
          type: "rectangle",
          backgroundColor: appState.currentItemBackgroundColor,
          boundElements: [
            ...textElement.boundElements || [],
            { id: textElement.id, type: "text" }
          ],
          angle: textElement.angle,
          fillStyle: appState.currentItemFillStyle,
          strokeColor: appState.currentItemStrokeColor,
          roughness: appState.currentItemRoughness,
          strokeWidth: appState.currentItemStrokeWidth,
          strokeStyle: appState.currentItemStrokeStyle,
          roundness: appState.currentItemRoundness === "round" ? {
            type: isUsingAdaptiveRadius2("rectangle") ? ROUNDNESS2.ADAPTIVE_RADIUS : ROUNDNESS2.PROPORTIONAL_RADIUS
          } : null,
          opacity: 100,
          locked: false,
          x: textElement.x - BOUND_TEXT_PADDING,
          y: textElement.y - BOUND_TEXT_PADDING,
          width: computeContainerDimensionForBoundText(
            textElement.width,
            "rectangle"
          ),
          height: computeContainerDimensionForBoundText(
            textElement.height,
            "rectangle"
          ),
          groupIds: textElement.groupIds,
          frameId: textElement.frameId
        });
        if (textElement.boundElements?.length) {
          const linearElementIds = textElement.boundElements.filter((ele) => ele.type === "arrow").map((el) => el.id);
          const linearElements = updatedElements.filter(
            (ele) => linearElementIds.includes(ele.id)
          );
          linearElements.forEach((ele) => {
            let startBinding = ele.startBinding;
            let endBinding = ele.endBinding;
            if (startBinding?.elementId === textElement.id) {
              startBinding = {
                ...startBinding,
                elementId: container.id
              };
            }
            if (endBinding?.elementId === textElement.id) {
              endBinding = { ...endBinding, elementId: container.id };
            }
            if (startBinding || endBinding) {
              app.scene.mutateElement(ele, {
                startBinding,
                endBinding
              });
            }
          });
        }
        app.scene.mutateElement(textElement, {
          containerId: container.id,
          verticalAlign: VERTICAL_ALIGN3.MIDDLE,
          boundElements: null,
          textAlign: TEXT_ALIGN.CENTER,
          autoResize: true
        });
        redrawTextBoundingBox3(textElement, container, app.scene);
        updatedElements = pushContainerBelowText(
          [...updatedElements, container],
          container,
          textElement
        );
        containerIds[container.id] = true;
      }
    }
    return {
      elements: updatedElements,
      appState: {
        ...appState,
        selectedElementIds: containerIds
      },
      captureUpdate: CaptureUpdateAction23.IMMEDIATELY
    };
  }
});

// actions/actionLink.tsx
import { isEmbeddableElement as isEmbeddableElement2 } from "@excalidraw/element";
import { KEYS as KEYS28 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction24 } from "@excalidraw/element";

// components/hyperlink/Hyperlink.tsx
import { pointFrom as pointFrom4 } from "@excalidraw/math";
import clsx20 from "clsx";
import {
  useCallback as useCallback5,
  useEffect as useEffect15,
  useLayoutEffect as useLayoutEffect2,
  useRef as useRef11,
  useState as useState10
} from "react";
import { EVENT as EVENT5, HYPERLINK_TOOLTIP_DELAY, KEYS as KEYS27 } from "@excalidraw/common";
import { getElementAbsoluteCoords } from "@excalidraw/element";
import { hitElementBoundingBox } from "@excalidraw/element";
import { isElementLink } from "@excalidraw/element";
import { getEmbedLink, embeddableURLValidator } from "@excalidraw/element";
import {
  sceneCoordsToViewportCoords,
  viewportCoordsToSceneCoords,
  wrapEvent,
  isLocalLink,
  normalizeLink
} from "@excalidraw/common";
import { isEmbeddableElement } from "@excalidraw/element";
import { jsx as jsx47, jsxs as jsxs26 } from "react/jsx-runtime";
var POPUP_WIDTH = 380;
var POPUP_HEIGHT = 42;
var POPUP_PADDING = 5;
var SPACE_BOTTOM = 85;
var AUTO_HIDE_TIMEOUT = 500;
var IS_HYPERLINK_TOOLTIP_VISIBLE = false;
var embeddableLinkCache = /* @__PURE__ */ new Map();
var Hyperlink = ({
  element,
  scene,
  setAppState,
  onLinkOpen,
  setToast,
  updateEmbedValidationStatus
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const appState = useExcalidrawAppState();
  const appProps = useAppProps();
  const editorInterface = useEditorInterface();
  const linkVal = element.link || "";
  const [inputVal, setInputVal] = useState10(linkVal);
  const inputRef = useRef11(null);
  const isEditing = appState.showHyperlinkPopup === "editor";
  const handleSubmit = useCallback5(() => {
    if (!inputRef.current) {
      return;
    }
    const link = normalizeLink(inputRef.current.value) || null;
    if (!element.link && link) {
      trackEvent("hyperlink", "create");
    }
    if (isEmbeddableElement(element)) {
      if (appState.activeEmbeddable?.element === element) {
        setAppState({ activeEmbeddable: null });
      }
      if (!link) {
        scene.mutateElement(element, {
          link: null
        });
        updateEmbedValidationStatus(element, false);
        return;
      }
      if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {
        if (link) {
          setToast({ message: t("toast.unableToEmbed"), closable: true });
        }
        element.link && embeddableLinkCache.set(element.id, element.link);
        scene.mutateElement(element, {
          link
        });
        updateEmbedValidationStatus(element, false);
      } else {
        const { width, height } = element;
        const embedLink = getEmbedLink(link);
        if (embedLink?.error instanceof URIError) {
          setToast({
            message: t("toast.unrecognizedLinkFormat"),
            closable: true
          });
        }
        const ar = embedLink ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h : 1;
        const hasLinkChanged = embeddableLinkCache.get(element.id) !== element.link;
        scene.mutateElement(element, {
          ...hasLinkChanged ? {
            width: embedLink?.type === "video" ? width > height ? width : height * ar : width,
            height: embedLink?.type === "video" ? width > height ? width / ar : height : height
          } : {},
          link
        });
        updateEmbedValidationStatus(element, true);
        if (embeddableLinkCache.has(element.id)) {
          embeddableLinkCache.delete(element.id);
        }
      }
    } else {
      scene.mutateElement(element, { link });
    }
  }, [
    element,
    scene,
    setToast,
    appProps.validateEmbeddable,
    appState.activeEmbeddable,
    setAppState,
    updateEmbedValidationStatus
  ]);
  useLayoutEffect2(() => {
    return () => {
      handleSubmit();
    };
  }, [handleSubmit]);
  useEffect15(() => {
    if (isEditing && inputRef?.current && !(editorInterface.formFactor === "phone" || editorInterface.isTouchScreen)) {
      inputRef.current.select();
    }
  }, [isEditing, editorInterface.formFactor, editorInterface.isTouchScreen]);
  useEffect15(() => {
    let timeoutId = null;
    const handlePointerMove = (event) => {
      if (isEditing) {
        return;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      const shouldHide = shouldHideLinkPopup(
        element,
        elementsMap,
        appState,
        pointFrom4(event.clientX, event.clientY)
      );
      if (shouldHide) {
        timeoutId = window.setTimeout(() => {
          setAppState({ showHyperlinkPopup: false });
        }, AUTO_HIDE_TIMEOUT);
      }
    };
    window.addEventListener(EVENT5.POINTER_MOVE, handlePointerMove, false);
    return () => {
      window.removeEventListener(EVENT5.POINTER_MOVE, handlePointerMove, false);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [appState, element, isEditing, setAppState, elementsMap]);
  const handleRemove = useCallback5(() => {
    trackEvent("hyperlink", "delete");
    scene.mutateElement(element, { link: null });
    setAppState({ showHyperlinkPopup: false });
  }, [setAppState, element, scene]);
  const onEdit = () => {
    trackEvent("hyperlink", "edit", "popup-ui");
    setAppState({ showHyperlinkPopup: "editor" });
  };
  const { x, y } = getCoordsForPopover(element, appState, elementsMap);
  if (appState.contextMenu || appState.selectedElementsAreBeingDragged || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ jsxs26(
    "div",
    {
      className: "excalidraw-hyperlinkContainer",
      style: {
        top: `${y}px`,
        left: `${x}px`,
        width: POPUP_WIDTH,
        padding: POPUP_PADDING
      },
      children: [
        isEditing ? /* @__PURE__ */ jsx47(
          "input",
          {
            className: clsx20("excalidraw-hyperlinkContainer-input"),
            placeholder: t("labels.link.hint"),
            ref: inputRef,
            value: inputVal,
            onChange: (event) => setInputVal(event.target.value),
            autoFocus: true,
            onKeyDown: (event) => {
              event.stopPropagation();
              if (event[KEYS27.CTRL_OR_CMD] && event.key === KEYS27.K) {
                event.preventDefault();
              }
              if (event.key === KEYS27.ENTER || event.key === KEYS27.ESCAPE) {
                handleSubmit();
                setAppState({ showHyperlinkPopup: "info" });
              }
            }
          }
        ) : element.link ? /* @__PURE__ */ jsx47(
          "a",
          {
            href: normalizeLink(element.link || ""),
            className: "excalidraw-hyperlinkContainer-link",
            target: isLocalLink(element.link) ? "_self" : "_blank",
            onClick: (event) => {
              if (element.link && onLinkOpen) {
                const customEvent = wrapEvent(
                  EVENT5.EXCALIDRAW_LINK,
                  event.nativeEvent
                );
                onLinkOpen(
                  {
                    ...element,
                    link: normalizeLink(element.link)
                  },
                  customEvent
                );
                if (customEvent.defaultPrevented) {
                  event.preventDefault();
                }
              }
            },
            rel: "noopener noreferrer",
            children: element.link
          }
        ) : /* @__PURE__ */ jsx47("div", { className: "excalidraw-hyperlinkContainer-link", children: t("labels.link.empty") }),
        /* @__PURE__ */ jsxs26("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [
          !isEditing && /* @__PURE__ */ jsx47(
            ToolButton,
            {
              type: "button",
              title: t("buttons.edit"),
              "aria-label": t("buttons.edit"),
              label: t("buttons.edit"),
              onClick: onEdit,
              className: "excalidraw-hyperlinkContainer--edit",
              icon: FreedrawIcon
            }
          ),
          /* @__PURE__ */ jsx47(
            ToolButton,
            {
              type: "button",
              title: t("labels.linkToElement"),
              "aria-label": t("labels.linkToElement"),
              label: t("labels.linkToElement"),
              onClick: () => {
                setAppState({
                  openDialog: {
                    name: "elementLinkSelector",
                    sourceElementId: element.id
                  }
                });
              },
              icon: elementLinkIcon
            }
          ),
          linkVal && !isEmbeddableElement(element) && /* @__PURE__ */ jsx47(
            ToolButton,
            {
              type: "button",
              title: t("buttons.remove"),
              "aria-label": t("buttons.remove"),
              label: t("buttons.remove"),
              onClick: handleRemove,
              className: "excalidraw-hyperlinkContainer--remove",
              icon: TrashIcon
            }
          )
        ] })
      ]
    }
  );
};
var getCoordsForPopover = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width / 2, sceneY: y1 },
    appState
  );
  const x = viewportX - appState.offsetLeft - POPUP_WIDTH / 2;
  const y = viewportY - appState.offsetTop - SPACE_BOTTOM;
  return { x, y };
};
var getContextMenuLabel = (elements, appState) => {
  const selectedElements = getSelectedElements(elements, appState);
  const label = isEmbeddableElement(selectedElements[0]) ? "labels.link.editEmbed" : selectedElements[0]?.link ? "labels.link.edit" : "labels.link.create";
  return label;
};
var HYPERLINK_TOOLTIP_TIMEOUT_ID = null;
var showHyperlinkTooltip = (element, appState, elementsMap) => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(
    () => renderTooltip(element, appState, elementsMap),
    HYPERLINK_TOOLTIP_DELAY
  );
};
var renderTooltip = (element, appState, elementsMap) => {
  if (!element.link) {
    return;
  }
  const tooltipDiv = getTooltipDiv();
  tooltipDiv.classList.add("excalidraw-tooltip--visible");
  tooltipDiv.style.maxWidth = "20rem";
  tooltipDiv.textContent = isElementLink(element.link) ? t("labels.link.goToElement") : element.link;
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
    [x1, y1, x2, y2],
    element.angle,
    appState
  );
  const linkViewportCoords = sceneCoordsToViewportCoords(
    { sceneX: linkX, sceneY: linkY },
    appState
  );
  updateTooltipPosition(
    tooltipDiv,
    {
      left: linkViewportCoords.x,
      top: linkViewportCoords.y,
      width: linkWidth,
      height: linkHeight
    },
    "top"
  );
  trackEvent("hyperlink", "tooltip", "link-icon");
  IS_HYPERLINK_TOOLTIP_VISIBLE = true;
};
var hideHyperlinkToolip = () => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  if (IS_HYPERLINK_TOOLTIP_VISIBLE) {
    IS_HYPERLINK_TOOLTIP_VISIBLE = false;
    getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }
};
var shouldHideLinkPopup = (element, elementsMap, appState, [clientX, clientY]) => {
  const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
    { clientX, clientY },
    appState
  );
  const threshold = 15 / appState.zoom.value;
  if (hitElementBoundingBox(pointFrom4(sceneX, sceneY), element, elementsMap)) {
    return false;
  }
  const [x1, y1, x2] = getElementAbsoluteCoords(element, elementsMap);
  if (sceneX >= x1 && sceneX <= x2 && sceneY >= y1 - SPACE_BOTTOM && sceneY <= y1) {
    return false;
  }
  const { x: popoverX, y: popoverY } = getCoordsForPopover(
    element,
    appState,
    elementsMap
  );
  if (clientX >= popoverX - threshold && clientX <= popoverX + POPUP_WIDTH + POPUP_PADDING * 2 + threshold && clientY >= popoverY - threshold && clientY <= popoverY + threshold + POPUP_PADDING * 2 + POPUP_HEIGHT) {
    return false;
  }
  return true;
};

// actions/actionLink.tsx
import { jsx as jsx48 } from "react/jsx-runtime";
var actionLink = register({
  name: "hyperlink",
  label: (elements, appState) => getContextMenuLabel(elements, appState),
  icon: LinkIcon,
  perform: (elements, appState) => {
    if (appState.showHyperlinkPopup === "editor") {
      return false;
    }
    return {
      elements,
      appState: {
        ...appState,
        showHyperlinkPopup: "editor",
        openMenu: null
      },
      captureUpdate: CaptureUpdateAction24.IMMEDIATELY
    };
  },
  trackEvent: { category: "hyperlink", action: "click" },
  keyTest: (event) => event[KEYS28.CTRL_OR_CMD] && event.key === KEYS28.K,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1;
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    return /* @__PURE__ */ jsx48(
      ToolButton,
      {
        type: "button",
        icon: LinkIcon,
        "aria-label": t(getContextMenuLabel(elements, appState)),
        title: `${isEmbeddableElement2(elements[0]) ? t("labels.link.labelEmbed") : t("labels.link.label")} - ${getShortcutKey("CtrlOrCmd+K")}`,
        onClick: () => updateData(null),
        selected: selectedElements.length === 1 && !!selectedElements[0].link
      }
    );
  }
});

// actions/actionElementLock.ts
import { KEYS as KEYS29, arrayToMap as arrayToMap11, randomId as randomId4 } from "@excalidraw/common";
import {
  elementsAreInSameGroup,
  newElementWith as newElementWith8,
  selectGroupsFromGivenElements
} from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction25 } from "@excalidraw/element";
var shouldLock = (elements) => elements.every((el) => !el.locked);
var actionToggleElementLock = register({
  name: "toggleElementLock",
  label: (elements, appState, app) => {
    const selected = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    });
    return shouldLock(selected) ? "labels.elementLock.lock" : "labels.elementLock.unlock";
  },
  icon: (appState, elements) => {
    const selectedElements = getSelectedElements(elements, appState);
    return shouldLock(selectedElements) ? LockedIcon : UnlockedIcon;
  },
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.length > 0 && !selectedElements.some((element) => element.locked && element.frameId);
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    if (!selectedElements.length) {
      return false;
    }
    const nextLockState = shouldLock(selectedElements);
    const selectedElementsMap = arrayToMap11(selectedElements);
    const isAGroup = selectedElements.length > 1 && elementsAreInSameGroup(selectedElements);
    const isASingleUnit = selectedElements.length === 1 || isAGroup;
    const newGroupId = isASingleUnit ? null : randomId4();
    let nextLockedMultiSelections = { ...appState.lockedMultiSelections };
    if (nextLockState) {
      nextLockedMultiSelections = {
        ...appState.lockedMultiSelections,
        ...newGroupId ? { [newGroupId]: true } : {}
      };
    } else if (isAGroup) {
      const groupId = selectedElements[0].groupIds.at(-1);
      delete nextLockedMultiSelections[groupId];
    }
    const nextElements = elements.map((element) => {
      if (!selectedElementsMap.has(element.id)) {
        return element;
      }
      let nextGroupIds = element.groupIds;
      if (nextLockState) {
        if (newGroupId) {
          nextGroupIds = [...nextGroupIds, newGroupId];
        }
      } else {
        nextGroupIds = nextGroupIds.filter(
          (groupId) => !appState.lockedMultiSelections[groupId]
        );
      }
      return newElementWith8(element, {
        locked: nextLockState,
        // do not recreate the array unncessarily
        groupIds: nextGroupIds.length !== element.groupIds.length ? nextGroupIds : element.groupIds
      });
    });
    const nextElementsMap = arrayToMap11(nextElements);
    const nextSelectedElementIds = nextLockState ? {} : Object.fromEntries(selectedElements.map((el) => [el.id, true]));
    const unlockedSelectedElements = selectedElements.map(
      (el) => nextElementsMap.get(el.id) || el
    );
    const nextSelectedGroupIds = nextLockState ? {} : selectGroupsFromGivenElements(unlockedSelectedElements, appState);
    const activeLockedId = nextLockState ? newGroupId ? newGroupId : isAGroup ? selectedElements[0].groupIds.at(-1) : selectedElements[0].id : null;
    return {
      elements: nextElements,
      appState: {
        ...appState,
        selectedElementIds: nextSelectedElementIds,
        selectedGroupIds: nextSelectedGroupIds,
        selectedLinearElement: nextLockState ? null : appState.selectedLinearElement,
        lockedMultiSelections: nextLockedMultiSelections,
        activeLockedId
      },
      captureUpdate: CaptureUpdateAction25.IMMEDIATELY
    };
  },
  keyTest: (event, appState, elements, app) => {
    return event.key.toLocaleLowerCase() === KEYS29.L && event[KEYS29.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    }).length > 0;
  }
});
var actionUnlockAllElements = register({
  name: "unlockAllElements",
  trackEvent: { category: "canvas" },
  viewMode: false,
  icon: UnlockedIcon,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 0 && elements.some((element) => element.locked);
  },
  perform: (elements, appState) => {
    const lockedElements = elements.filter((el) => el.locked);
    const nextElements = elements.map((element) => {
      if (element.locked) {
        const nextGroupIds = element.groupIds.filter(
          (gid) => !appState.lockedMultiSelections[gid]
        );
        return newElementWith8(element, {
          locked: false,
          groupIds: (
            // do not recreate the array unncessarily
            element.groupIds.length !== nextGroupIds.length ? nextGroupIds : element.groupIds
          )
        });
      }
      return element;
    });
    const nextElementsMap = arrayToMap11(nextElements);
    const unlockedElements = lockedElements.map(
      (el) => nextElementsMap.get(el.id) || el
    );
    return {
      elements: nextElements,
      appState: {
        ...appState,
        selectedElementIds: Object.fromEntries(
          lockedElements.map((el) => [el.id, true])
        ),
        selectedGroupIds: selectGroupsFromGivenElements(
          unlockedElements,
          appState
        ),
        lockedMultiSelections: {},
        activeLockedId: null
      },
      captureUpdate: CaptureUpdateAction25.IMMEDIATELY
    };
  },
  label: "labels.elementLock.unlockAll"
});

// actions/actionLinearEditor.tsx
import {
  isElbowArrow as isElbowArrow7,
  isLinearElement as isLinearElement8,
  isLineElement as isLineElement4
} from "@excalidraw/element";
import { arrayToMap as arrayToMap20, invariant as invariant14 } from "@excalidraw/common";
import {
  toggleLinePolygonState as toggleLinePolygonState3,
  CaptureUpdateAction as CaptureUpdateAction29
} from "@excalidraw/element";

// components/CommandPalette/CommandPalette.tsx
import clsx35 from "clsx";
import fuzzy from "fuzzy";
import { useEffect as useEffect26, useRef as useRef23, useMemo as useMemo7, useState as useState24 } from "react";
import {
  DEFAULT_SIDEBAR as DEFAULT_SIDEBAR2,
  EVENT as EVENT9,
  KEYS as KEYS37,
  capitalizeString as capitalizeString2,
  isWritableElement as isWritableElement3
} from "@excalidraw/common";

// actions/actionToggleShapeSwitch.tsx
import { CaptureUpdateAction as CaptureUpdateAction26 } from "@excalidraw/element";

// components/ConvertElementTypePopup.tsx
import { useEffect as useEffect16, useMemo as useMemo4, useRef as useRef12, useState as useState11 } from "react";
import {
  getLinearElementSubType,
  updateElbowArrowPoints as updateElbowArrowPoints2
} from "@excalidraw/element";
import { pointFrom as pointFrom5, pointRotateRads } from "@excalidraw/math";
import {
  hasBoundTextElement as hasBoundTextElement3,
  isArrowBoundToElement,
  isArrowElement as isArrowElement5,
  isElbowArrow as isElbowArrow4,
  isLinearElement as isLinearElement4,
  isUsingAdaptiveRadius as isUsingAdaptiveRadius3
} from "@excalidraw/element";
import {
  getCommonBoundingBox as getCommonBoundingBox2,
  getElementAbsoluteCoords as getElementAbsoluteCoords2
} from "@excalidraw/element";
import {
  getBoundTextElement as getBoundTextElement4,
  getBoundTextMaxHeight,
  getBoundTextMaxWidth,
  redrawTextBoundingBox as redrawTextBoundingBox4
} from "@excalidraw/element";
import { wrapText } from "@excalidraw/element";
import {
  assertNever,
  CLASSES,
  getFontString as getFontString2,
  isProdEnv,
  mapFind,
  reduceToCommonValue as reduceToCommonValue2,
  updateActiveTool as updateActiveTool5
} from "@excalidraw/common";
import { measureText as measureText2 } from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor6 } from "@excalidraw/element";
import {
  newArrowElement,
  newElement as newElement3,
  newLinearElement as newLinearElement2
} from "@excalidraw/element";
import { ShapeCache } from "@excalidraw/element";
import { updateBindings } from "@excalidraw/element";
import { jsx as jsx49 } from "react/jsx-runtime";
var GAP_HORIZONTAL = 8;
var GAP_VERTICAL = 10;
var GENERIC_TYPES = ["rectangle", "diamond", "ellipse"];
var LINEAR_TYPES = [
  "line",
  "sharpArrow",
  "curvedArrow",
  "elbowArrow"
];
var CONVERTIBLE_GENERIC_TYPES = new Set(
  GENERIC_TYPES
);
var CONVERTIBLE_LINEAR_TYPES = new Set(
  LINEAR_TYPES
);
var isConvertibleGenericType = (elementType) => CONVERTIBLE_GENERIC_TYPES.has(elementType);
var isConvertibleLinearType = (elementType) => elementType === "arrow" || CONVERTIBLE_LINEAR_TYPES.has(elementType);
var convertElementTypePopupAtom = atom(null);
var FONT_SIZE_CONVERSION_CACHE = /* @__PURE__ */ new Map();
var LINEAR_ELEMENT_CONVERSION_CACHE = /* @__PURE__ */ new Map();
var ConvertElementTypePopup = ({ app }) => {
  const selectedElements = app.scene.getSelectedElements(app.state);
  const elementsCategoryRef = useRef12(null);
  useEffect16(() => {
    if (selectedElements.length === 0) {
      app.updateEditorAtom(convertElementTypePopupAtom, null);
      return;
    }
    const conversionType = getConversionTypeFromElements(selectedElements);
    if (conversionType && !elementsCategoryRef.current) {
      elementsCategoryRef.current = conversionType;
    } else if (elementsCategoryRef.current && !conversionType || elementsCategoryRef.current && conversionType !== elementsCategoryRef.current) {
      app.updateEditorAtom(convertElementTypePopupAtom, null);
      elementsCategoryRef.current = null;
    }
  }, [selectedElements, app]);
  useEffect16(() => {
    return () => {
      FONT_SIZE_CONVERSION_CACHE.clear();
      LINEAR_ELEMENT_CONVERSION_CACHE.clear();
    };
  }, []);
  return /* @__PURE__ */ jsx49(Panel, { app, elements: selectedElements });
};
var Panel = ({
  app,
  elements
}) => {
  const conversionType = getConversionTypeFromElements(elements);
  const genericElements = useMemo4(() => {
    return conversionType === "generic" ? filterGenericConvetibleElements(elements) : [];
  }, [conversionType, elements]);
  const linearElements = useMemo4(() => {
    return conversionType === "linear" ? filterLinearConvertibleElements(elements) : [];
  }, [conversionType, elements]);
  const sameType = conversionType === "generic" ? genericElements.every(
    (element) => element.type === genericElements[0].type
  ) : conversionType === "linear" ? linearElements.every(
    (element) => getLinearElementSubType(element) === getLinearElementSubType(linearElements[0])
  ) : false;
  const [panelPosition, setPanelPosition] = useState11({ x: 0, y: 0 });
  const positionRef = useRef12("");
  const panelRef = useRef12(null);
  useEffect16(() => {
    const elements2 = [...genericElements, ...linearElements].sort(
      (a, b) => a.id.localeCompare(b.id)
    );
    const newPositionRef = `
      ${app.state.scrollX}${app.state.scrollY}${app.state.offsetTop}${app.state.offsetLeft}${app.state.zoom.value}${elements2.map((el) => el.id).join(",")}`;
    if (newPositionRef === positionRef.current) {
      return;
    }
    positionRef.current = newPositionRef;
    let bottomLeft;
    if (elements2.length === 1) {
      const [x1, , , y2, cx, cy] = getElementAbsoluteCoords2(
        elements2[0],
        app.scene.getNonDeletedElementsMap()
      );
      bottomLeft = pointRotateRads(
        pointFrom5(x1, y2),
        pointFrom5(cx, cy),
        elements2[0].angle
      );
    } else {
      const { minX, maxY } = getCommonBoundingBox2(elements2);
      bottomLeft = pointFrom5(minX, maxY);
    }
    const { x, y } = sceneCoordsToViewportCoords2(
      { sceneX: bottomLeft[0], sceneY: bottomLeft[1] },
      app.state
    );
    setPanelPosition({ x, y });
  }, [genericElements, linearElements, app.scene, app.state]);
  useEffect16(() => {
    for (const linearElement of linearElements) {
      const cacheKey = toCacheKey(
        linearElement.id,
        getConvertibleType(linearElement)
      );
      if (!LINEAR_ELEMENT_CONVERSION_CACHE.has(cacheKey)) {
        LINEAR_ELEMENT_CONVERSION_CACHE.set(cacheKey, linearElement);
      }
    }
  }, [linearElements]);
  useEffect16(() => {
    for (const element of genericElements) {
      if (!FONT_SIZE_CONVERSION_CACHE.has(element.id)) {
        const boundText = getBoundTextElement4(
          element,
          app.scene.getNonDeletedElementsMap()
        );
        if (boundText) {
          FONT_SIZE_CONVERSION_CACHE.set(element.id, {
            fontSize: boundText.fontSize
          });
        }
      }
    }
  }, [genericElements, app.scene]);
  const SHAPES2 = conversionType === "linear" ? [
    ["line", LineIcon],
    ["sharpArrow", sharpArrowIcon],
    ["curvedArrow", roundArrowIcon],
    ["elbowArrow", elbowArrowIcon]
  ] : conversionType === "generic" ? [
    ["rectangle", RectangleIcon],
    ["diamond", DiamondIcon],
    ["ellipse", EllipseIcon]
  ] : [];
  return /* @__PURE__ */ jsx49(
    "div",
    {
      ref: panelRef,
      tabIndex: -1,
      style: {
        position: "absolute",
        top: `${panelPosition.y + (GAP_VERTICAL + 8) * app.state.zoom.value - app.state.offsetTop}px`,
        left: `${panelPosition.x - app.state.offsetLeft - GAP_HORIZONTAL}px`,
        zIndex: 2
      },
      className: CLASSES.CONVERT_ELEMENT_TYPE_POPUP,
      children: SHAPES2.map(([type, icon]) => {
        const isSelected = sameType && (conversionType === "generic" && genericElements[0].type === type || conversionType === "linear" && getLinearElementSubType(linearElements[0]) === type);
        return /* @__PURE__ */ jsx49(
          ToolButton,
          {
            className: "Shape",
            type: "radio",
            icon,
            checked: isSelected,
            name: "convertElementType-option",
            title: type,
            keyBindingLabel: "",
            "aria-label": type,
            "data-testid": `toolbar-${type}`,
            onChange: () => {
              if (app.state.activeTool.type !== type) {
                trackEvent("convertElementType", type, "ui");
              }
              convertElementTypes(app, {
                conversionType,
                nextType: type
              });
              panelRef.current?.focus();
            }
          },
          `${elements[0].id}${elements[0].version}_${type}`
        );
      })
    }
  );
};
var adjustBoundTextSize = (container, boundText, scene) => {
  const maxWidth = getBoundTextMaxWidth(container, boundText);
  const maxHeight = getBoundTextMaxHeight(container, boundText);
  const wrappedText = wrapText(
    boundText.text,
    getFontString2(boundText),
    maxWidth
  );
  let metrics = measureText2(
    wrappedText,
    getFontString2(boundText),
    boundText.lineHeight
  );
  let nextFontSize = boundText.fontSize;
  while ((metrics.width > maxWidth || metrics.height > maxHeight) && nextFontSize > 0) {
    nextFontSize -= 1;
    const _updatedTextElement = {
      ...boundText,
      fontSize: nextFontSize
    };
    metrics = measureText2(
      boundText.text,
      getFontString2(_updatedTextElement),
      boundText.lineHeight
    );
  }
  mutateElement2(boundText, scene.getNonDeletedElementsMap(), {
    fontSize: nextFontSize,
    width: metrics.width,
    height: metrics.height
  });
  redrawTextBoundingBox4(boundText, container, scene);
};
var convertElementTypes = (app, {
  conversionType,
  nextType,
  direction = "right"
}) => {
  if (!conversionType) {
    return false;
  }
  const selectedElements = app.scene.getSelectedElements(app.state);
  const selectedElementIds = selectedElements.reduce(
    (acc, element) => ({ ...acc, [element.id]: true }),
    {}
  );
  const advancement = direction === "right" ? 1 : -1;
  if (conversionType === "generic") {
    const convertibleGenericElements = filterGenericConvetibleElements(selectedElements);
    const sameType = convertibleGenericElements.every(
      (element) => element.type === convertibleGenericElements[0].type
    );
    const index = sameType ? GENERIC_TYPES.indexOf(convertibleGenericElements[0].type) : -1;
    nextType = nextType ?? GENERIC_TYPES[(index + GENERIC_TYPES.length + advancement) % GENERIC_TYPES.length];
    if (nextType && isConvertibleGenericType(nextType)) {
      const convertedElements = {};
      for (const element of convertibleGenericElements) {
        const convertedElement = convertElementType(element, nextType, app);
        convertedElements[convertedElement.id] = convertedElement;
      }
      const nextElements = [];
      for (const element of app.scene.getElementsIncludingDeleted()) {
        if (convertedElements[element.id]) {
          nextElements.push(convertedElements[element.id]);
        } else {
          nextElements.push(element);
        }
      }
      app.scene.replaceAllElements(nextElements);
      for (const element of Object.values(convertedElements)) {
        const boundText = getBoundTextElement4(
          element,
          app.scene.getNonDeletedElementsMap()
        );
        if (boundText) {
          if (FONT_SIZE_CONVERSION_CACHE.get(element.id)) {
            mutateElement2(boundText, app.scene.getNonDeletedElementsMap(), {
              fontSize: FONT_SIZE_CONVERSION_CACHE.get(element.id)?.fontSize ?? boundText.fontSize
            });
          }
          adjustBoundTextSize(
            element,
            boundText,
            app.scene
          );
        }
      }
      app.setState((prevState) => {
        return {
          selectedElementIds,
          activeTool: updateActiveTool5(prevState, {
            type: "selection"
          })
        };
      });
    }
  }
  if (conversionType === "linear") {
    const convertibleLinearElements = filterLinearConvertibleElements(
      selectedElements
    );
    if (!nextType) {
      const commonSubType = reduceToCommonValue2(
        convertibleLinearElements,
        getLinearElementSubType
      );
      const index = commonSubType ? LINEAR_TYPES.indexOf(commonSubType) : -1;
      nextType = LINEAR_TYPES[(index + LINEAR_TYPES.length + advancement) % LINEAR_TYPES.length];
    }
    if (isConvertibleLinearType(nextType)) {
      const convertedElements = [];
      const nextElementsMap = app.scene.getElementsMapIncludingDeleted();
      for (const element of convertibleLinearElements) {
        const cachedElement = LINEAR_ELEMENT_CONVERSION_CACHE.get(
          toCacheKey(element.id, nextType)
        );
        if (cachedElement && getLinearElementSubType(cachedElement) === nextType) {
          nextElementsMap.set(cachedElement.id, cachedElement);
          convertedElements.push(cachedElement);
        } else {
          const converted = convertElementType(element, nextType, app);
          nextElementsMap.set(converted.id, converted);
          convertedElements.push(converted);
        }
      }
      app.scene.replaceAllElements(nextElementsMap);
      for (const element of convertedElements) {
        if (isLinearElement4(element)) {
          if (isElbowArrow4(element)) {
            const nextPoints = convertLineToElbow(element);
            if (nextPoints.length < 2) {
              continue;
            }
            const fixedSegments = [];
            for (let i = 1; i < nextPoints.length - 2; i++) {
              fixedSegments.push({
                start: nextPoints[i],
                end: nextPoints[i + 1],
                index: i + 1
              });
            }
            const updates = updateElbowArrowPoints2(
              element,
              app.scene.getNonDeletedElementsMap(),
              {
                points: nextPoints,
                fixedSegments
              }
            );
            mutateElement2(element, app.scene.getNonDeletedElementsMap(), {
              ...updates,
              endArrowhead: "arrow"
            });
          } else {
            const similarCachedLinearElement = mapFind(
              ["line", "sharpArrow", "curvedArrow"],
              (type) => LINEAR_ELEMENT_CONVERSION_CACHE.get(
                toCacheKey(element.id, type)
              )
            );
            if (similarCachedLinearElement) {
              const points = similarCachedLinearElement.points;
              app.scene.mutateElement(element, {
                points
              });
            }
          }
        }
      }
    }
    const convertedSelectedLinearElements = filterLinearConvertibleElements(
      app.scene.getSelectedElements(app.state)
    );
    app.setState((prevState) => ({
      selectedElementIds,
      selectedLinearElement: convertedSelectedLinearElements.length === 1 ? new LinearElementEditor6(
        convertedSelectedLinearElements[0],
        app.scene.getNonDeletedElementsMap()
      ) : null,
      activeTool: updateActiveTool5(prevState, {
        type: "selection"
      })
    }));
  }
  return true;
};
var getConversionTypeFromElements = (elements) => {
  if (elements.length === 0) {
    return null;
  }
  let canBeLinear = false;
  for (const element of elements) {
    if (isConvertibleGenericType(element.type)) {
      return "generic";
    }
    if (isEligibleLinearElement(element)) {
      canBeLinear = true;
    }
  }
  if (canBeLinear) {
    return "linear";
  }
  return null;
};
var isEligibleLinearElement = (element) => {
  return isLinearElement4(element) && (!isArrowElement5(element) || !isArrowBoundToElement(element) && !hasBoundTextElement3(element));
};
var toCacheKey = (elementId, convertitleType) => {
  return `${elementId}:${convertitleType}`;
};
var filterGenericConvetibleElements = (elements) => elements.filter((element) => isConvertibleGenericType(element.type));
var filterLinearConvertibleElements = (elements) => elements.filter(
  (element) => isEligibleLinearElement(element)
);
var THRESHOLD = 20;
var isVert = (a, b) => a[0] === b[0];
var isHorz = (a, b) => a[1] === b[1];
var dist = (a, b) => isVert(a, b) ? Math.abs(a[1] - b[1]) : Math.abs(a[0] - b[0]);
var convertLineToElbow = (line) => {
  const ortho = [line.points[0]];
  const src = sanitizePoints(line.points);
  for (let i = 1; i < src.length; ++i) {
    const start2 = ortho[ortho.length - 1];
    const end = [...src[i]];
    if (Math.abs(end[0] - start2[0]) < THRESHOLD) {
      end[0] = start2[0];
    } else if (Math.abs(end[1] - start2[1]) < THRESHOLD) {
      end[1] = start2[1];
    }
    if (isVert(start2, end) || isHorz(start2, end)) {
      ortho.push(end);
    } else {
      ortho.push(pointFrom5(start2[0], end[1]));
      ortho.push(end);
    }
  }
  const trimmed = [ortho[0]];
  for (let i = 1; i < ortho.length - 1; ++i) {
    if (!(isVert(ortho[i - 1], ortho[i]) && isVert(ortho[i], ortho[i + 1]) || isHorz(ortho[i - 1], ortho[i]) && isHorz(ortho[i], ortho[i + 1]))) {
      trimmed.push(ortho[i]);
    }
  }
  trimmed.push(ortho[ortho.length - 1]);
  const clean = [trimmed[0]];
  for (let i = 1; i < trimmed.length - 1; ++i) {
    const a = clean[clean.length - 1];
    const b = trimmed[i];
    const c = trimmed[i + 1];
    const v1 = isVert(a, b);
    const v2 = isVert(b, c);
    if (v1 !== v2) {
      const d1 = dist(a, b);
      const d2 = dist(b, c);
      if (d1 < THRESHOLD || d2 < THRESHOLD) {
        if (d2 < d1) {
          if (v1) {
            c[0] = a[0];
          } else {
            c[1] = a[1];
          }
        } else {
          if (v2) {
            for (let k = clean.length - 1; k >= 0 && clean[k][0] === a[0]; --k) {
              clean[k][0] = b[0];
            }
          } else {
            for (let k = clean.length - 1; k >= 0 && clean[k][1] === a[1]; --k) {
              clean[k][1] = b[1];
            }
          }
        }
        continue;
      }
    }
    clean.push(b);
  }
  clean.push(trimmed[trimmed.length - 1]);
  return clean;
};
var sanitizePoints = (points) => {
  if (points.length === 0) {
    return [];
  }
  const sanitized = [points[0]];
  for (let i = 1; i < points.length; i++) {
    const [x1, y1] = sanitized[sanitized.length - 1];
    const [x2, y2] = points[i];
    if (x1 !== x2 || y1 !== y2) {
      sanitized.push(points[i]);
    }
  }
  return sanitized;
};
var convertElementType = (element, targetType, app) => {
  if (!isValidConversion(element.type, targetType)) {
    if (!isProdEnv()) {
      throw Error(`Invalid conversion from ${element.type} to ${targetType}.`);
    }
    return element;
  }
  if (element.type === targetType) {
    return element;
  }
  ShapeCache.delete(element);
  if (isConvertibleGenericType(targetType)) {
    const nextElement = bumpVersion(
      newElement3({
        ...element,
        type: targetType,
        roundness: targetType === "diamond" && element.roundness ? {
          type: isUsingAdaptiveRadius3(targetType) ? ROUNDNESS3.ADAPTIVE_RADIUS : ROUNDNESS3.PROPORTIONAL_RADIUS
        } : element.roundness
      })
    );
    updateBindings(nextElement, app.scene, app.state);
    return nextElement;
  }
  if (isConvertibleLinearType(targetType)) {
    switch (targetType) {
      case "line": {
        return bumpVersion(
          newLinearElement2({
            ...element,
            type: "line"
          })
        );
      }
      case "sharpArrow": {
        return bumpVersion(
          newArrowElement({
            ...element,
            type: "arrow",
            elbowed: false,
            roundness: null,
            startArrowhead: app.state.currentItemStartArrowhead,
            endArrowhead: app.state.currentItemEndArrowhead
          })
        );
      }
      case "curvedArrow": {
        return bumpVersion(
          newArrowElement({
            ...element,
            type: "arrow",
            elbowed: false,
            roundness: {
              type: ROUNDNESS3.PROPORTIONAL_RADIUS
            },
            startArrowhead: app.state.currentItemStartArrowhead,
            endArrowhead: app.state.currentItemEndArrowhead
          })
        );
      }
      case "elbowArrow": {
        return bumpVersion(
          newArrowElement({
            ...element,
            type: "arrow",
            elbowed: true,
            fixedSegments: null,
            roundness: null
          })
        );
      }
    }
  }
  assertNever(targetType, `unhandled conversion type: ${targetType}`);
  return element;
};
var isValidConversion = (startType, targetType) => {
  if (isConvertibleGenericType(startType) && isConvertibleGenericType(targetType)) {
    return true;
  }
  if (isConvertibleLinearType(startType) && isConvertibleLinearType(targetType)) {
    return true;
  }
  return false;
};
var getConvertibleType = (element) => {
  if (isLinearElement4(element)) {
    return getLinearElementSubType(element);
  }
  return element.type;
};
var ConvertElementTypePopup_default = ConvertElementTypePopup;

// actions/actionToggleShapeSwitch.tsx
var actionToggleShapeSwitch = register({
  name: "toggleShapeSwitch",
  label: "labels.shapeSwitch",
  icon: () => null,
  viewMode: true,
  trackEvent: {
    category: "shape_switch",
    action: "toggle"
  },
  keywords: ["change", "switch", "swap"],
  perform(elements, appState, _, app) {
    editorJotaiStore.set(convertElementTypePopupAtom, {
      type: "panel"
    });
    return {
      captureUpdate: CaptureUpdateAction26.NEVER
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (elements, appState, props) => getConversionTypeFromElements(elements) !== null
});

// actions/actionElementLink.ts
import {
  canCreateLinkFromElements,
  defaultGetElementLinkFromSelection,
  getLinkIdAndTypeFromSelection
} from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction27 } from "@excalidraw/element";
var actionCopyElementLink = register({
  name: "copyElementLink",
  label: "labels.copyElementLink",
  icon: copyIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    try {
      if (window.location) {
        const idAndType = getLinkIdAndTypeFromSelection(
          selectedElements,
          appState
        );
        if (idAndType) {
          await copyTextToSystemClipboard(
            app.props.generateLinkForSelection ? app.props.generateLinkForSelection(idAndType.id, idAndType.type) : defaultGetElementLinkFromSelection(
              idAndType.id,
              idAndType.type
            )
          );
          return {
            appState: {
              toast: {
                message: t("toast.elementLinkCopied"),
                closable: true
              }
            },
            captureUpdate: CaptureUpdateAction27.EVENTUALLY
          };
        }
        return {
          appState,
          elements,
          app,
          captureUpdate: CaptureUpdateAction27.EVENTUALLY
        };
      }
    } catch (error) {
      console.error(error);
    }
    return {
      appState,
      elements,
      app,
      captureUpdate: CaptureUpdateAction27.EVENTUALLY
    };
  },
  predicate: (elements, appState) => canCreateLinkFromElements(getSelectedElements(elements, appState))
});
var actionLinkToElement = register({
  name: "linkToElement",
  label: "labels.linkToElement",
  icon: elementLinkIcon,
  perform: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    if (selectedElements.length !== 1 || !canCreateLinkFromElements(selectedElements)) {
      return {
        elements,
        appState,
        app,
        captureUpdate: CaptureUpdateAction27.EVENTUALLY
      };
    }
    return {
      appState: {
        ...appState,
        openDialog: {
          name: "elementLinkSelector",
          sourceElementId: getSelectedElements(elements, appState)[0].id
        }
      },
      captureUpdate: CaptureUpdateAction27.IMMEDIATELY
    };
  },
  predicate: (elements, appState, appProps, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return appState.openDialog?.name !== "elementLinkSelector" && selectedElements.length === 1 && canCreateLinkFromElements(selectedElements);
  },
  trackEvent: false
});

// actions/shortcuts.ts
import { isDarwin as isDarwin3 } from "@excalidraw/common";
var shortcutMap = {
  toggleTheme: [getShortcutKey("Shift+Alt+D")],
  saveScene: [getShortcutKey("CtrlOrCmd+S")],
  loadScene: [getShortcutKey("CtrlOrCmd+O")],
  clearCanvas: [getShortcutKey("CtrlOrCmd+Delete")],
  imageExport: [getShortcutKey("CtrlOrCmd+Shift+E")],
  commandPalette: [
    getShortcutKey("CtrlOrCmd+/"),
    getShortcutKey("CtrlOrCmd+Shift+P")
  ],
  cut: [getShortcutKey("CtrlOrCmd+X")],
  copy: [getShortcutKey("CtrlOrCmd+C")],
  paste: [getShortcutKey("CtrlOrCmd+V")],
  copyStyles: [getShortcutKey("CtrlOrCmd+Alt+C")],
  pasteStyles: [getShortcutKey("CtrlOrCmd+Alt+V")],
  selectAll: [getShortcutKey("CtrlOrCmd+A")],
  deleteSelectedElements: [getShortcutKey("Delete")],
  duplicateSelection: [
    getShortcutKey("CtrlOrCmd+D"),
    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
  ],
  sendBackward: [getShortcutKey("CtrlOrCmd+[")],
  bringForward: [getShortcutKey("CtrlOrCmd+]")],
  sendToBack: [
    isDarwin3 ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
  ],
  bringToFront: [
    isDarwin3 ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
  ],
  copyAsPng: [getShortcutKey("Shift+Alt+C")],
  group: [getShortcutKey("CtrlOrCmd+G")],
  ungroup: [getShortcutKey("CtrlOrCmd+Shift+G")],
  gridMode: [getShortcutKey("CtrlOrCmd+'")],
  zenMode: [getShortcutKey("Alt+Z")],
  objectsSnapMode: [getShortcutKey("Alt+S")],
  stats: [getShortcutKey("Alt+/")],
  addToLibrary: [],
  flipHorizontal: [getShortcutKey("Shift+H")],
  flipVertical: [getShortcutKey("Shift+V")],
  viewMode: [getShortcutKey("Alt+R")],
  hyperlink: [getShortcutKey("CtrlOrCmd+K")],
  toggleElementLock: [getShortcutKey("CtrlOrCmd+Shift+L")],
  resetZoom: [getShortcutKey("CtrlOrCmd+0")],
  zoomOut: [getShortcutKey("CtrlOrCmd+-")],
  zoomIn: [getShortcutKey("CtrlOrCmd++")],
  zoomToFitSelection: [getShortcutKey("Shift+3")],
  zoomToFit: [getShortcutKey("Shift+1")],
  zoomToFitSelectionInViewport: [getShortcutKey("Shift+2")],
  toggleEraserTool: [getShortcutKey("E")],
  toggleHandTool: [getShortcutKey("H")],
  setFrameAsActiveTool: [getShortcutKey("F")],
  saveFileToDisk: [getShortcutKey("CtrlOrCmd+S")],
  saveToActiveFile: [getShortcutKey("CtrlOrCmd+S")],
  toggleShortcuts: [getShortcutKey("?")],
  searchMenu: [getShortcutKey("CtrlOrCmd+F")],
  wrapSelectionInFrame: [],
  toolLock: [getShortcutKey("Q")]
};
var getShortcutFromShortcutName = (name, idx = 0) => {
  const shortcuts = shortcutMap[name];
  return shortcuts && shortcuts.length > 0 ? shortcuts[idx] || shortcuts[0] : "";
};

// deburr.ts
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = `[${rsComboRange}]`;
var reComboMark = RegExp(rsCombo, "g");
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  // normaly Ae/ae
  "\xC6": "E",
  "\xE6": "e",
  // normally Th/th
  "\xDE": "T",
  "\xFE": "t",
  // normally ss
  "\xDF": "s",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  // normally IJ/ij
  "\u0132": "I",
  "\u0133": "i",
  // normally OE/oe
  "\u0152": "E",
  "\u0153": "e",
  // normally "'n"
  "\u0149": "n",
  "\u017F": "s"
};
var deburr = (str) => {
  return str.replace(reLatin, (key) => {
    return deburredLetters[key] || key;
  }).replace(reComboMark, "");
};

// components/Dialog.tsx
import clsx33 from "clsx";
import { useEffect as useEffect25, useState as useState22 } from "react";
import { KEYS as KEYS33, queryFocusableElements } from "@excalidraw/common";

// hooks/useCallbackRefState.ts
import { useCallback as useCallback6, useState as useState12 } from "react";
var useCallbackRefState = () => {
  const [refValue, setRefValue] = useState12(null);
  const refCallback = useCallback6((value) => setRefValue(value), []);
  return [refValue, refCallback];
};

// components/LibraryMenu.tsx
import {
  useState as useState21,
  useCallback as useCallback13,
  useMemo as useMemo6,
  useEffect as useEffect24,
  memo as memo3,
  useRef as useRef19
} from "react";
import {
  LIBRARY_DISABLED_TYPES as LIBRARY_DISABLED_TYPES2,
  randomId as randomId5,
  isShallowEqual,
  KEYS as KEYS31,
  isWritableElement as isWritableElement2,
  addEventListener,
  EVENT as EVENT8,
  CLASSES as CLASSES4
} from "@excalidraw/common";

// data/library.ts
import { useEffect as useEffect18, useRef as useRef13 } from "react";
import {
  URL_HASH_KEYS,
  URL_QUERY_KEYS,
  APP_NAME,
  EVENT as EVENT6,
  DEFAULT_SIDEBAR,
  LIBRARY_SIDEBAR_TAB,
  arrayToMap as arrayToMap12,
  cloneJSON as cloneJSON2,
  preventUnload,
  promiseTry,
  resolvablePromise,
  toValidURL,
  Queue,
  Emitter
} from "@excalidraw/common";
import { hashElementsVersion, hashString } from "@excalidraw/element";
import { getCommonBoundingBox as getCommonBoundingBox3 } from "@excalidraw/element";

// ../utils/src/export.ts
import { MIME_TYPES as MIME_TYPES4 } from "@excalidraw/common";
var exportToCanvas2 = ({
  elements,
  appState,
  files,
  maxWidthOrHeight,
  getDimensions,
  exportPadding,
  exportingFrame
}) => {
  const restoredElements = restoreElements(elements, null, {
    deleteInvisibleElements: true
  });
  const restoredAppState = restoreAppState(appState, null);
  const { exportBackground, viewBackgroundColor } = restoredAppState;
  return exportToCanvas(
    restoredElements,
    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },
    files || {},
    { exportBackground, exportPadding, viewBackgroundColor, exportingFrame },
    (width, height) => {
      const canvas = document.createElement("canvas");
      if (maxWidthOrHeight) {
        if (typeof getDimensions === "function") {
          console.warn(
            "`getDimensions()` is ignored when `maxWidthOrHeight` is supplied."
          );
        }
        const max = Math.max(width, height);
        const scale = maxWidthOrHeight < max ? maxWidthOrHeight / max : appState?.exportScale ?? 1;
        canvas.width = width * scale;
        canvas.height = height * scale;
        return {
          canvas,
          scale
        };
      }
      const ret = getDimensions?.(width, height) || { width, height };
      canvas.width = ret.width;
      canvas.height = ret.height;
      return {
        canvas,
        scale: ret.scale ?? 1
      };
    }
  );
};
var exportToBlob = async (opts) => {
  let { mimeType = MIME_TYPES4.png, quality } = opts;
  if (mimeType === MIME_TYPES4.png && typeof quality === "number") {
    console.warn(`"quality" will be ignored for "${MIME_TYPES4.png}" mimeType`);
  }
  if (mimeType === "image/jpg") {
    mimeType = MIME_TYPES4.jpg;
  }
  if (mimeType === MIME_TYPES4.jpg && !opts.appState?.exportBackground) {
    console.warn(
      `Defaulting "exportBackground" to "true" for "${MIME_TYPES4.jpg}" mimeType`
    );
    opts = {
      ...opts,
      appState: { ...opts.appState, exportBackground: true }
    };
  }
  const canvas = await exportToCanvas2(opts);
  quality = quality ? quality : /image\/jpe?g/.test(mimeType) ? 0.92 : 0.8;
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      async (blob) => {
        if (!blob) {
          return reject(new Error("couldn't export to blob"));
        }
        if (blob && mimeType === MIME_TYPES4.png && opts.appState?.exportEmbedScene) {
          blob = await encodePngMetadata({
            blob,
            metadata: serializeAsJSON(
              // NOTE as long as we're using the Scene hack, we need to ensure
              // we pass the original, uncloned elements when serializing
              // so that we keep ids stable
              opts.elements,
              opts.appState,
              opts.files || {},
              "local"
            )
          });
        }
        resolve(blob);
      },
      mimeType,
      quality
    );
  });
};
var exportToSvg2 = async ({
  elements,
  appState = getDefaultAppState(),
  files = {},
  exportPadding,
  renderEmbeddables,
  exportingFrame,
  skipInliningFonts,
  reuseImages
}) => {
  const restoredElements = restoreElements(elements, null, {
    deleteInvisibleElements: true
  });
  const restoredAppState = restoreAppState(appState, null);
  const exportAppState = {
    ...restoredAppState,
    exportPadding
  };
  return exportToSvg(restoredElements, exportAppState, files, {
    exportingFrame,
    renderEmbeddables,
    skipInliningFonts,
    reuseImages
  });
};
var exportToClipboard = async (opts) => {
  if (opts.type === "svg") {
    const svg = await exportToSvg2(opts);
    await copyTextToSystemClipboard(svg.outerHTML);
  } else if (opts.type === "png") {
    await copyBlobToClipboardAsPng(exportToBlob(opts));
  } else if (opts.type === "json") {
    await copyToClipboard(opts.elements, opts.files);
  } else {
    throw new Error("Invalid export type");
  }
};

// hooks/useLibraryItemSvg.ts
import { useEffect as useEffect17, useState as useState13 } from "react";
import { COLOR_PALETTE as COLOR_PALETTE4 } from "@excalidraw/common";
var libraryItemSvgsCache = atom(/* @__PURE__ */ new Map());
var exportLibraryItemToSvg = async (elements) => {
  return await exportToSvg2({
    elements,
    appState: {
      exportBackground: false,
      viewBackgroundColor: COLOR_PALETTE4.white
    },
    files: null,
    renderEmbeddables: false,
    skipInliningFonts: true
  });
};
var useLibraryItemSvg = (id, elements, svgCache, ref) => {
  const [svg, setSvg] = useState13();
  useEffect17(() => {
    if (elements) {
      if (id) {
        const cachedSvg = svgCache.get(id);
        if (cachedSvg) {
          setSvg(cachedSvg);
        } else {
          (async () => {
            const exportedSvg = await exportLibraryItemToSvg(elements);
            exportedSvg.querySelector(".style-fonts")?.remove();
            if (exportedSvg) {
              svgCache.set(id, exportedSvg);
              setSvg(exportedSvg);
            }
          })();
        }
      } else {
        (async () => {
          const exportedSvg = await exportLibraryItemToSvg(elements);
          setSvg(exportedSvg);
        })();
      }
    }
  }, [id, elements, svgCache, setSvg]);
  useEffect17(() => {
    const node = ref.current;
    if (!node) {
      return;
    }
    if (svg) {
      node.innerHTML = svg.outerHTML;
    }
    return () => {
      node.innerHTML = "";
    };
  }, [svg, ref]);
  return svg;
};
var useLibraryCache = () => {
  const [svgCache] = useAtom(libraryItemSvgsCache);
  const clearLibraryCache = () => svgCache.clear();
  const deleteItemsFromLibraryCache = (items) => {
    items.forEach((item) => svgCache.delete(item));
  };
  return {
    clearLibraryCache,
    deleteItemsFromLibraryCache,
    svgCache
  };
};

// data/library.ts
var ALLOWED_LIBRARY_URLS = [
  "excalidraw.com",
  // when installing from github PRs
  "raw.githubusercontent.com/excalidraw/excalidraw-libraries"
];
var onLibraryUpdateEmitter = new Emitter();
var libraryItemsAtom = atom({ status: "loaded", isInitialized: false, libraryItems: [] });
var cloneLibraryItems = (libraryItems) => cloneJSON2(libraryItems);
var isUniqueItem = (existingLibraryItems, targetLibraryItem) => {
  return !existingLibraryItems.find((libraryItem) => {
    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {
      return false;
    }
    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {
      return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;
    });
  });
};
var mergeLibraryItems = (localItems, otherItems) => {
  const newItems = [];
  for (const item of otherItems) {
    if (isUniqueItem(localItems, item)) {
      newItems.push(item);
    }
  }
  return [...newItems, ...localItems];
};
var createLibraryUpdate = (prevLibraryItems, nextLibraryItems) => {
  const nextItemsMap = arrayToMap12(nextLibraryItems);
  const update = {
    deletedItems: /* @__PURE__ */ new Map(),
    addedItems: /* @__PURE__ */ new Map(),
    updatedItems: /* @__PURE__ */ new Map()
  };
  for (const item of prevLibraryItems) {
    if (!nextItemsMap.has(item.id)) {
      update.deletedItems.set(item.id, item);
    }
  }
  const prevItemsMap = arrayToMap12(prevLibraryItems);
  for (const item of nextLibraryItems) {
    const prevItem = prevItemsMap.get(item.id);
    if (!prevItem) {
      update.addedItems.set(item.id, item);
    } else if (getLibraryItemHash(prevItem) !== getLibraryItemHash(item)) {
      update.updatedItems.set(item.id, item);
    }
  }
  return update;
};
var Library = class {
  constructor(app) {
    /** latest libraryItems */
    __publicField(this, "currLibraryItems", []);
    /** snapshot of library items since last onLibraryChange call */
    __publicField(this, "prevLibraryItems", cloneLibraryItems(this.currLibraryItems));
    __publicField(this, "app");
    __publicField(this, "updateQueue", []);
    __publicField(this, "getLastUpdateTask", () => {
      return this.updateQueue[this.updateQueue.length - 1];
    });
    __publicField(this, "notifyListeners", () => {
      if (this.updateQueue.length > 0) {
        editorJotaiStore.set(libraryItemsAtom, (s) => ({
          status: "loading",
          libraryItems: this.currLibraryItems,
          isInitialized: s.isInitialized
        }));
      } else {
        editorJotaiStore.set(libraryItemsAtom, {
          status: "loaded",
          libraryItems: this.currLibraryItems,
          isInitialized: true
        });
        try {
          const prevLibraryItems = this.prevLibraryItems;
          this.prevLibraryItems = cloneLibraryItems(this.currLibraryItems);
          const nextLibraryItems = cloneLibraryItems(this.currLibraryItems);
          this.app.props.onLibraryChange?.(nextLibraryItems);
          onLibraryUpdateEmitter.trigger(
            createLibraryUpdate(prevLibraryItems, nextLibraryItems),
            nextLibraryItems
          );
        } catch (error) {
          console.error(error);
        }
      }
    });
    /** call on excalidraw instance unmount */
    __publicField(this, "destroy", () => {
      this.updateQueue = [];
      this.currLibraryItems = [];
      editorJotaiStore.set(libraryItemSvgsCache, /* @__PURE__ */ new Map());
    });
    __publicField(this, "resetLibrary", () => {
      return this.setLibrary([]);
    });
    /**
     * @returns latest cloned libraryItems. Awaits all in-progress updates first.
     */
    __publicField(this, "getLatestLibrary", () => {
      return new Promise(async (resolve) => {
        try {
          const libraryItems = await (this.getLastUpdateTask() || this.currLibraryItems);
          if (this.updateQueue.length > 0) {
            resolve(this.getLatestLibrary());
          } else {
            resolve(cloneLibraryItems(libraryItems));
          }
        } catch (error) {
          return resolve(this.currLibraryItems);
        }
      });
    });
    // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with
    // a slight overhead (always restoring library items). For internal use
    // where merging isn't needed, use `library.setLibrary()` directly.
    __publicField(this, "updateLibrary", async ({
      libraryItems,
      prompt = false,
      merge = false,
      openLibraryMenu = false,
      defaultStatus = "unpublished"
    }) => {
      if (openLibraryMenu) {
        this.app.setState({
          openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB }
        });
      }
      return this.setLibrary(() => {
        return new Promise(async (resolve, reject) => {
          try {
            const source = await (typeof libraryItems === "function" && !(libraryItems instanceof Blob) ? libraryItems(this.currLibraryItems) : libraryItems);
            let nextItems;
            if (source instanceof Blob) {
              nextItems = await loadLibraryFromBlob(source, defaultStatus);
            } else {
              nextItems = restoreLibraryItems(source, defaultStatus);
            }
            if (!prompt || window.confirm(
              t("alerts.confirmAddLibrary", {
                numShapes: nextItems.length
              })
            )) {
              if (prompt) {
                this.app.focusContainer();
              }
              if (merge) {
                resolve(mergeLibraryItems(this.currLibraryItems, nextItems));
              } else {
                resolve(nextItems);
              }
            } else {
              reject(new AbortError());
            }
          } catch (error) {
            reject(error);
          }
        });
      });
    });
    __publicField(this, "setLibrary", (libraryItems) => {
      const task = new Promise(async (resolve, reject) => {
        try {
          await this.getLastUpdateTask();
          if (typeof libraryItems === "function") {
            libraryItems = libraryItems(this.currLibraryItems);
          }
          this.currLibraryItems = cloneLibraryItems(await libraryItems);
          resolve(this.currLibraryItems);
        } catch (error) {
          reject(error);
        }
      }).catch((error) => {
        if (error.name === "AbortError") {
          console.warn("Library update aborted by user");
          return this.currLibraryItems;
        }
        throw error;
      }).finally(() => {
        this.updateQueue = this.updateQueue.filter((_task) => _task !== task);
        this.notifyListeners();
      });
      this.updateQueue.push(task);
      this.notifyListeners();
      return task;
    });
    this.app = app;
  }
};
var library_default = Library;
var distributeLibraryItemsOnSquareGrid = (libraryItems) => {
  const PADDING = 50;
  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));
  const resElements = [];
  const getMaxHeightPerRow = (row2) => {
    const maxHeight = libraryItems.slice(row2 * ITEMS_PER_ROW, row2 * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {
      const { height } = getCommonBoundingBox3(item.elements);
      return Math.max(acc, height);
    }, 0);
    return maxHeight;
  };
  const getMaxWidthPerCol = (targetCol) => {
    let index2 = 0;
    let currCol = 0;
    let maxWidth = 0;
    for (const item of libraryItems) {
      if (index2 % ITEMS_PER_ROW === 0) {
        currCol = 0;
      }
      if (currCol === targetCol) {
        const { width } = getCommonBoundingBox3(item.elements);
        maxWidth = Math.max(maxWidth, width);
      }
      index2++;
      currCol++;
    }
    return maxWidth;
  };
  let colOffsetX = 0;
  let rowOffsetY = 0;
  let maxHeightCurrRow = 0;
  let maxWidthCurrCol = 0;
  let index = 0;
  let col = 0;
  let row = 0;
  for (const item of libraryItems) {
    if (index && index % ITEMS_PER_ROW === 0) {
      rowOffsetY += maxHeightCurrRow + PADDING;
      colOffsetX = 0;
      col = 0;
      row++;
    }
    if (col === 0) {
      maxHeightCurrRow = getMaxHeightPerRow(row);
    }
    maxWidthCurrCol = getMaxWidthPerCol(col);
    const { minX, minY, width, height } = getCommonBoundingBox3(item.elements);
    const offsetCenterX = (maxWidthCurrCol - width) / 2;
    const offsetCenterY = (maxHeightCurrRow - height) / 2;
    resElements.push(
      ...item.elements.map((element) => ({
        ...element,
        x: element.x + // offset for column
        colOffsetX + // offset to center in given square grid
        offsetCenterX - // subtract minX so that given item starts at 0 coord
        minX,
        y: element.y + // offset for row
        rowOffsetY + // offset to center in given square grid
        offsetCenterY - // subtract minY so that given item starts at 0 coord
        minY
      }))
    );
    colOffsetX += maxWidthCurrCol + PADDING;
    index++;
    col++;
  }
  return resElements;
};
var validateLibraryUrl = (libraryUrl, validator = ALLOWED_LIBRARY_URLS) => {
  if (typeof validator === "function" ? validator(libraryUrl) : validator.some((allowedUrlDef) => {
    const allowedUrl = new URL(
      `https://${allowedUrlDef.replace(/^https?:\/\//, "")}`
    );
    const { hostname, pathname } = new URL(libraryUrl);
    return new RegExp(`(^|\\.)${allowedUrl.hostname}$`).test(hostname) && new RegExp(
      `^${allowedUrl.pathname.replace(/\/+$/, "")}(/+|$)`
    ).test(pathname);
  })) {
    return true;
  }
  throw new Error(`Invalid or disallowed library URL: "${libraryUrl}"`);
};
var parseLibraryTokensFromUrl = () => {
  const libraryUrl = (
    // current
    new URLSearchParams(window.location.hash.slice(1)).get(
      URL_HASH_KEYS.addLibrary
    ) || // legacy, kept for compat reasons
    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary)
  );
  const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
  return libraryUrl ? { libraryUrl, idToken } : null;
};
var _AdapterTransaction = class _AdapterTransaction {
  constructor(adapter) {
    // ------------------
    __publicField(this, "adapter");
    this.adapter = adapter;
  }
  static async getLibraryItems(adapter, source, _queue = true) {
    const task = () => new Promise(async (resolve, reject) => {
      try {
        const data = await adapter.load({ source });
        resolve(restoreLibraryItems(data?.libraryItems || [], "published"));
      } catch (error) {
        reject(error);
      }
    });
    if (_queue) {
      return _AdapterTransaction.queue.push(task);
    }
    return task();
  }
  getLibraryItems(source) {
    return _AdapterTransaction.getLibraryItems(this.adapter, source, false);
  }
};
__publicField(_AdapterTransaction, "queue", new Queue());
__publicField(_AdapterTransaction, "run", async (adapter, fn) => {
  const transaction = new _AdapterTransaction(adapter);
  return _AdapterTransaction.queue.push(() => fn(transaction));
});
var AdapterTransaction = _AdapterTransaction;
var lastSavedLibraryItemsHash = 0;
var librarySaveCounter = 0;
var getLibraryItemHash = (item) => {
  return `${item.id}:${item.name || ""}:${hashElementsVersion(item.elements)}`;
};
var getLibraryItemsHash = (items) => {
  return hashString(
    items.map((item) => getLibraryItemHash(item)).sort().join()
  );
};
var persistLibraryUpdate = async (adapter, update) => {
  try {
    librarySaveCounter++;
    return await AdapterTransaction.run(adapter, async (transaction) => {
      const nextLibraryItemsMap = arrayToMap12(
        await transaction.getLibraryItems("save")
      );
      for (const [id] of update.deletedItems) {
        nextLibraryItemsMap.delete(id);
      }
      const addedItems = [];
      for (const [id, item] of update.addedItems) {
        if (nextLibraryItemsMap.has(id)) {
          nextLibraryItemsMap.set(id, item);
        } else {
          addedItems.push(item);
        }
      }
      if (update.updatedItems) {
        for (const [id, item] of update.updatedItems) {
          nextLibraryItemsMap.set(id, item);
        }
      }
      const nextLibraryItems = addedItems.concat(
        Array.from(nextLibraryItemsMap.values())
      );
      const version = getLibraryItemsHash(nextLibraryItems);
      if (version !== lastSavedLibraryItemsHash) {
        await adapter.save({ libraryItems: nextLibraryItems });
      }
      lastSavedLibraryItemsHash = version;
      return nextLibraryItems;
    });
  } finally {
    librarySaveCounter--;
  }
};
var useHandleLibrary = (opts) => {
  const { excalidrawAPI } = opts;
  const optsRef = useRef13(opts);
  optsRef.current = opts;
  const isLibraryLoadedRef = useRef13(false);
  useEffect18(() => {
    if (!excalidrawAPI) {
      return;
    }
    isLibraryLoadedRef.current = false;
    const importLibraryFromURL = async ({
      libraryUrl,
      idToken
    }) => {
      const libraryPromise = new Promise(async (resolve, reject) => {
        try {
          libraryUrl = decodeURIComponent(libraryUrl);
          libraryUrl = toValidURL(libraryUrl);
          validateLibraryUrl(libraryUrl, optsRef.current.validateLibraryUrl);
          const request = await fetch(libraryUrl);
          const blob = await request.blob();
          resolve(blob);
        } catch (error) {
          reject(error);
        }
      });
      const shouldPrompt = idToken !== excalidrawAPI.id;
      await (shouldPrompt && document.hidden ? new Promise((resolve) => {
        window.addEventListener("focus", () => resolve(), {
          once: true
        });
      }) : null);
      try {
        await excalidrawAPI.updateLibrary({
          libraryItems: libraryPromise,
          prompt: shouldPrompt,
          merge: true,
          defaultStatus: "published",
          openLibraryMenu: true
        });
      } catch (error) {
        excalidrawAPI.updateScene({
          appState: {
            errorMessage: error.message
          }
        });
        throw error;
      } finally {
        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {
          const hash = new URLSearchParams(window.location.hash.slice(1));
          hash.delete(URL_HASH_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);
        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {
          const query = new URLSearchParams(window.location.search);
          query.delete(URL_QUERY_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);
        }
      }
    };
    const onHashChange = (event) => {
      event.preventDefault();
      const libraryUrlTokens2 = parseLibraryTokensFromUrl();
      if (libraryUrlTokens2) {
        event.stopImmediatePropagation();
        window.history.replaceState({}, "", event.oldURL);
        importLibraryFromURL(libraryUrlTokens2);
      }
    };
    const libraryUrlTokens = parseLibraryTokensFromUrl();
    if (libraryUrlTokens) {
      importLibraryFromURL(libraryUrlTokens);
    }
    if ("getInitialLibraryItems" in optsRef.current && optsRef.current.getInitialLibraryItems) {
      console.warn(
        "useHandleLibrar `opts.getInitialLibraryItems` is deprecated. Use `opts.adapter` instead."
      );
      Promise.resolve(optsRef.current.getInitialLibraryItems()).then((libraryItems) => {
        excalidrawAPI.updateLibrary({
          libraryItems,
          // merge with current library items because we may have already
          // populated it (e.g. by installing 3rd party library which can
          // happen before the DB data is loaded)
          merge: true
        });
      }).catch((error) => {
        console.error(
          `UseHandeLibrary getInitialLibraryItems failed: ${error?.message}`
        );
      });
    }
    if ("adapter" in optsRef.current && optsRef.current.adapter) {
      const adapter = optsRef.current.adapter;
      const migrationAdapter = optsRef.current.migrationAdapter;
      const initDataPromise = resolvablePromise();
      if (migrationAdapter) {
        initDataPromise.resolve(
          promiseTry(migrationAdapter.load).then(async (libraryData) => {
            let restoredData = null;
            try {
              if (!libraryData) {
                return AdapterTransaction.getLibraryItems(adapter, "load");
              }
              restoredData = restoreLibraryItems(
                libraryData.libraryItems || [],
                "published"
              );
              const nextItems = await persistLibraryUpdate(
                adapter,
                createLibraryUpdate([], restoredData)
              );
              try {
                await migrationAdapter.clear();
              } catch (error) {
                console.error(
                  `couldn't delete legacy library data: ${error.message}`
                );
              }
              return nextItems;
            } catch (error) {
              console.error(
                `couldn't migrate legacy library data: ${error.message}`
              );
              return restoredData;
            }
          }).catch((error) => {
            console.error(`error during library migration: ${error.message}`);
            return AdapterTransaction.getLibraryItems(adapter, "load");
          })
        );
      } else {
        initDataPromise.resolve(
          promiseTry(AdapterTransaction.getLibraryItems, adapter, "load")
        );
      }
      excalidrawAPI.updateLibrary({
        libraryItems: initDataPromise.then((libraryItems) => {
          const _libraryItems = libraryItems || [];
          lastSavedLibraryItemsHash = getLibraryItemsHash(_libraryItems);
          return _libraryItems;
        }),
        // merge with current library items because we may have already
        // populated it (e.g. by installing 3rd party library which can
        // happen before the DB data is loaded)
        merge: true
      }).finally(() => {
        isLibraryLoadedRef.current = true;
      });
    }
    window.addEventListener(EVENT6.HASHCHANGE, onHashChange);
    return () => {
      window.removeEventListener(EVENT6.HASHCHANGE, onHashChange);
    };
  }, [
    // important this useEffect only depends on excalidrawAPI so it only reruns
    // on editor remounts (the excalidrawAPI changes)
    excalidrawAPI
  ]);
  useEffect18(
    () => {
      const unsubOnLibraryUpdate = onLibraryUpdateEmitter.on(
        async (update, nextLibraryItems) => {
          const isLoaded = isLibraryLoadedRef.current;
          const adapter = "adapter" in optsRef.current && optsRef.current.adapter || null;
          try {
            if (adapter) {
              if (
                // if nextLibraryItems hash identical to previously saved hash,
                // exit early, even if actual upstream state ends up being
                // different (e.g. has more data than we have locally), as it'd
                // be low-impact scenario.
                lastSavedLibraryItemsHash !== getLibraryItemsHash(nextLibraryItems)
              ) {
                await persistLibraryUpdate(adapter, update);
              }
            }
          } catch (error) {
            console.error(
              `couldn't persist library update: ${error.message}`,
              update
            );
            if (isLoaded && optsRef.current.excalidrawAPI) {
              optsRef.current.excalidrawAPI.updateScene({
                appState: {
                  errorMessage: t("errors.saveLibraryError")
                }
              });
            }
          }
        }
      );
      const onUnload = (event) => {
        if (librarySaveCounter) {
          preventUnload(event);
        }
      };
      window.addEventListener(EVENT6.BEFORE_UNLOAD, onUnload);
      return () => {
        window.removeEventListener(EVENT6.BEFORE_UNLOAD, onUnload);
        unsubOnLibraryUpdate();
        lastSavedLibraryItemsHash = 0;
        librarySaveCounter = 0;
      };
    },
    [
      // this effect must not have any deps so it doesn't rerun
    ]
  );
};

// components/LibraryMenuControlButtons.tsx
import clsx21 from "clsx";

// components/LibraryMenuBrowseButton.tsx
import { VERSIONS } from "@excalidraw/common";
import { jsx as jsx50 } from "react/jsx-runtime";
var LibraryMenuBrowseButton = ({
  theme,
  id,
  libraryReturnUrl
}) => {
  const referrer = libraryReturnUrl || window.location.origin + window.location.pathname;
  return /* @__PURE__ */ jsx50(
    "a",
    {
      className: "library-menu-browse-button",
      href: `${define_import_meta_env_default.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${VERSIONS.excalidrawLibrary}`,
      target: "_excalidraw_libraries",
      children: t("labels.libraries")
    }
  );
};
var LibraryMenuBrowseButton_default = LibraryMenuBrowseButton;

// components/LibraryMenuControlButtons.tsx
import { jsx as jsx51, jsxs as jsxs27 } from "react/jsx-runtime";
var LibraryMenuControlButtons = ({
  libraryReturnUrl,
  theme,
  id,
  style,
  children,
  className
}) => {
  return /* @__PURE__ */ jsxs27(
    "div",
    {
      className: clsx21("library-menu-control-buttons", className),
      style,
      children: [
        /* @__PURE__ */ jsx51(
          LibraryMenuBrowseButton_default,
          {
            id,
            libraryReturnUrl,
            theme
          }
        ),
        children
      ]
    }
  );
};

// components/LibraryMenuItems.tsx
import {
  useCallback as useCallback12,
  useEffect as useEffect23,
  useMemo as useMemo5,
  useRef as useRef18,
  useState as useState20
} from "react";
import { MIME_TYPES as MIME_TYPES6, arrayToMap as arrayToMap13, nextAnimationFrame } from "@excalidraw/common";
import { duplicateElements as duplicateElements2 } from "@excalidraw/element";
import clsx31 from "clsx";

// hooks/useScrollPosition.ts
import throttle from "lodash.throttle";
import { useEffect as useEffect19 } from "react";
var scrollPositionAtom = atom(0);
var useScrollPosition = (elementRef) => {
  const [scrollPosition, setScrollPosition] = useAtom(scrollPositionAtom);
  useEffect19(() => {
    const { current: element } = elementRef;
    if (!element) {
      return;
    }
    const handleScroll = throttle(() => {
      const { scrollTop } = element;
      setScrollPosition(scrollTop);
    }, 200);
    element.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      element.removeEventListener("scroll", handleScroll);
    };
  }, [elementRef, setScrollPosition]);
  return scrollPosition;
};

// components/LibraryMenuHeaderContent.tsx
import clsx27 from "clsx";
import { useCallback as useCallback10, useState as useState16 } from "react";
import { muteFSAbortError } from "@excalidraw/common";

// components/ConfirmDialog.tsx
import { flushSync } from "react-dom";

// components/DialogActionButton.tsx
import clsx22 from "clsx";
import { jsx as jsx52, jsxs as jsxs28 } from "react/jsx-runtime";
var DialogActionButton = ({
  label,
  onClick,
  className,
  children,
  actionType,
  type = "button",
  isLoading,
  ...rest
}) => {
  const cs = actionType ? `Dialog__action-button--${actionType}` : "";
  return /* @__PURE__ */ jsxs28(
    "button",
    {
      className: clsx22("Dialog__action-button", cs, className),
      type,
      "aria-label": label,
      onClick,
      ...rest,
      children: [
        children && /* @__PURE__ */ jsx52("div", { style: isLoading ? { visibility: "hidden" } : {}, children }),
        /* @__PURE__ */ jsx52("div", { style: isLoading ? { visibility: "hidden" } : {}, children: label }),
        isLoading && /* @__PURE__ */ jsx52("div", { style: { position: "absolute", inset: 0 }, children: /* @__PURE__ */ jsx52(Spinner_default, {}) })
      ]
    }
  );
};
var DialogActionButton_default = DialogActionButton;

// components/ConfirmDialog.tsx
import { jsx as jsx53, jsxs as jsxs29 } from "react/jsx-runtime";
var ConfirmDialog = (props) => {
  const {
    onConfirm,
    onCancel,
    children,
    confirmText = t("buttons.confirm"),
    cancelText = t("buttons.cancel"),
    className = "",
    ...rest
  } = props;
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom);
  const { container } = useExcalidrawContainer();
  return /* @__PURE__ */ jsxs29(
    Dialog,
    {
      onCloseRequest: onCancel,
      size: "small",
      ...rest,
      className: `confirm-dialog ${className}`,
      children: [
        children,
        /* @__PURE__ */ jsxs29("div", { className: "confirm-dialog-buttons", children: [
          /* @__PURE__ */ jsx53(
            DialogActionButton_default,
            {
              label: cancelText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                flushSync(() => {
                  onCancel();
                });
                container?.focus();
              }
            }
          ),
          /* @__PURE__ */ jsx53(
            DialogActionButton_default,
            {
              label: confirmText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                flushSync(() => {
                  onConfirm();
                });
                container?.focus();
              },
              actionType: "danger"
            }
          )
        ] })
      ]
    }
  );
};
var ConfirmDialog_default = ConfirmDialog;

// components/PublishLibrary.tsx
import { useCallback as useCallback7, useEffect as useEffect20, useRef as useRef14, useState as useState14 } from "react";
import {
  EDITOR_LS_KEYS,
  EXPORT_DATA_TYPES as EXPORT_DATA_TYPES2,
  MIME_TYPES as MIME_TYPES5,
  VERSIONS as VERSIONS2,
  chunk,
  getExportSource
} from "@excalidraw/common";

// data/EditorLocalStorage.ts
var EditorLocalStorage = class {
  static has(key) {
    try {
      return !!window.localStorage.getItem(key);
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return false;
    }
  }
  static get(key) {
    try {
      const value = window.localStorage.getItem(key);
      if (value) {
        return JSON.parse(value);
      }
      return null;
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return null;
    }
  }
};
__publicField(EditorLocalStorage, "set", (key, value) => {
  try {
    window.localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (error) {
    console.warn(`localStorage.setItem error: ${error.message}`);
    return false;
  }
});
__publicField(EditorLocalStorage, "delete", (name) => {
  try {
    window.localStorage.removeItem(name);
  } catch (error) {
    console.warn(`localStorage.removeItem error: ${error.message}`);
  }
});

// components/Trans.tsx
import React17 from "react";
var SPLIT_REGEX = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g;
var KEY_REGEXP = /{{([\w-]+)}}/;
var TAG_START_REGEXP = /<([\w-]+)>/;
var TAG_END_REGEXP = /<\/([\w-]+)>/;
var getTransChildren = (format, props) => {
  const stack = [
    {
      name: "",
      children: []
    }
  ];
  format.split(SPLIT_REGEX).filter(Boolean).forEach((match) => {
    const tagStartMatch = match.match(TAG_START_REGEXP);
    const tagEndMatch = match.match(TAG_END_REGEXP);
    const keyMatch = match.match(KEY_REGEXP);
    if (tagStartMatch !== null) {
      const name = tagStartMatch[1];
      if (props.hasOwnProperty(name)) {
        stack.push({
          name,
          children: []
        });
      } else {
        console.warn(
          `Trans: missed to pass in prop ${name} for interpolating ${format}`
        );
      }
    } else if (tagEndMatch !== null) {
      const name = tagEndMatch[1];
      if (name === stack[stack.length - 1].name) {
        const item = stack.pop();
        const itemChildren = React17.createElement(
          React17.Fragment,
          {},
          ...item.children
        );
        const fn = props[item.name];
        if (typeof fn === "function") {
          stack[stack.length - 1].children.push(fn(itemChildren));
        }
      } else {
        console.warn(
          `Trans: unexpected end tag ${match} for interpolating ${format}`
        );
      }
    } else if (keyMatch !== null) {
      const name = keyMatch[1];
      if (props.hasOwnProperty(name)) {
        stack[stack.length - 1].children.push(props[name]);
      } else {
        console.warn(
          `Trans: key ${name} not in props for interpolating ${format}`
        );
      }
    } else {
      stack[stack.length - 1].children.push(match);
    }
  });
  if (stack.length !== 1) {
    console.warn(`Trans: stack not empty for interpolating ${format}`);
  }
  return stack[0].children;
};
var Trans = ({
  i18nKey,
  children,
  ...props
}) => {
  const { t: t2 } = useI18n();
  return React17.createElement(
    React17.Fragment,
    {},
    ...getTransChildren(t2(i18nKey), props)
  );
};
var Trans_default = Trans;

// components/PublishLibrary.tsx
import { jsx as jsx54, jsxs as jsxs30 } from "react/jsx-runtime";
var generatePreviewImage = async (libraryItems) => {
  const MAX_ITEMS_PER_ROW = 6;
  const BOX_SIZE = 128;
  const BOX_PADDING = Math.round(BOX_SIZE / 16);
  const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);
  const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);
  const canvas = document.createElement("canvas");
  canvas.width = rows[0].length * BOX_SIZE + (rows[0].length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  canvas.height = rows.length * BOX_SIZE + (rows.length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  for (const [index, item] of libraryItems.entries()) {
    const itemCanvas = await exportToCanvas2({
      elements: item.elements,
      files: null,
      maxWidthOrHeight: BOX_SIZE
    });
    const { width, height } = itemCanvas;
    const rowOffset = Math.floor(index / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);
    const colOffset = index % MAX_ITEMS_PER_ROW * (BOX_SIZE + BOX_PADDING * 2);
    ctx.drawImage(
      itemCanvas,
      colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,
      rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING
    );
    ctx.lineWidth = BORDER_WIDTH;
    ctx.strokeStyle = "#ced4da";
    ctx.strokeRect(
      colOffset + BOX_PADDING / 2,
      rowOffset + BOX_PADDING / 2,
      BOX_SIZE + BOX_PADDING,
      BOX_SIZE + BOX_PADDING
    );
  }
  return await resizeImageFile(
    new File([await canvasToBlob(canvas)], "preview", { type: MIME_TYPES5.png }),
    {
      outputType: MIME_TYPES5.jpg,
      maxWidthOrHeight: 5e3
    }
  );
};
var SingleLibraryItem = ({
  libItem,
  appState,
  index,
  onChange,
  onRemove
}) => {
  const svgRef = useRef14(null);
  const inputRef = useRef14(null);
  useEffect20(() => {
    const node = svgRef.current;
    if (!node) {
      return;
    }
    (async () => {
      const svg = await exportToSvg2({
        elements: libItem.elements,
        appState: {
          ...appState,
          viewBackgroundColor: "#fff",
          exportBackground: true
        },
        files: null,
        skipInliningFonts: true
      });
      node.innerHTML = svg.outerHTML;
    })();
  }, [libItem.elements, appState]);
  return /* @__PURE__ */ jsxs30("div", { className: "single-library-item", children: [
    libItem.status === "published" && /* @__PURE__ */ jsx54("span", { className: "single-library-item-status", children: t("labels.statusPublished") }),
    /* @__PURE__ */ jsx54("div", { ref: svgRef, className: "single-library-item__svg" }),
    /* @__PURE__ */ jsx54(
      ToolButton,
      {
        "aria-label": t("buttons.remove"),
        type: "button",
        icon: CloseIcon,
        className: "single-library-item--remove",
        onClick: onRemove.bind(null, libItem.id),
        title: t("buttons.remove")
      }
    ),
    /* @__PURE__ */ jsxs30(
      "div",
      {
        style: {
          display: "flex",
          margin: "0.8rem 0",
          width: "100%",
          fontSize: "14px",
          fontWeight: 500,
          flexDirection: "column"
        },
        children: [
          /* @__PURE__ */ jsxs30(
            "label",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                flexDirection: "column"
              },
              children: [
                /* @__PURE__ */ jsxs30("div", { style: { padding: "0.5em 0" }, children: [
                  /* @__PURE__ */ jsx54("span", { style: { fontWeight: 500, color: "#868e96" }, children: t("publishDialog.itemName") }),
                  /* @__PURE__ */ jsx54("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ jsx54(
                  "input",
                  {
                    type: "text",
                    ref: inputRef,
                    style: { width: "80%", padding: "0.2rem" },
                    defaultValue: libItem.name,
                    placeholder: "Item name",
                    onChange: (event) => {
                      onChange(event.target.value, index);
                    }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsx54("span", { className: "error", children: libItem.error })
        ]
      }
    )
  ] });
};
var PublishLibrary = ({
  onClose,
  libraryItems,
  appState,
  onSuccess,
  onError,
  updateItemsInStorage,
  onRemove
}) => {
  const [libraryData, setLibraryData] = useState14({
    authorName: "",
    githubHandle: "",
    name: "",
    description: "",
    twitterHandle: "",
    website: ""
  });
  const [isSubmitting, setIsSubmitting] = useState14(false);
  useEffect20(() => {
    const data = EditorLocalStorage.get(
      EDITOR_LS_KEYS.PUBLISH_LIBRARY
    );
    if (data) {
      setLibraryData(data);
    }
  }, []);
  const [clonedLibItems, setClonedLibItems] = useState14(
    libraryItems.slice()
  );
  useEffect20(() => {
    setClonedLibItems(libraryItems.slice());
  }, [libraryItems]);
  const onInputChange = (event) => {
    setLibraryData({
      ...libraryData,
      [event.target.name]: event.target.value
    });
  };
  const onSubmit = async (event) => {
    event.preventDefault();
    setIsSubmitting(true);
    const erroredLibItems = [];
    let isError = false;
    clonedLibItems.forEach((libItem) => {
      let error = "";
      if (!libItem.name) {
        error = t("publishDialog.errors.required");
        isError = true;
      }
      erroredLibItems.push({ ...libItem, error });
    });
    if (isError) {
      setClonedLibItems(erroredLibItems);
      setIsSubmitting(false);
      return;
    }
    const previewImage = await generatePreviewImage(clonedLibItems);
    const libContent = {
      type: EXPORT_DATA_TYPES2.excalidrawLibrary,
      version: VERSIONS2.excalidrawLibrary,
      source: getExportSource(),
      libraryItems: clonedLibItems
    };
    const content = JSON.stringify(libContent, null, 2);
    const lib = new Blob([content], { type: "application/json" });
    const formData = new FormData();
    formData.append("excalidrawLib", lib);
    formData.append("previewImage", previewImage);
    formData.append("previewImageType", previewImage.type);
    formData.append("title", libraryData.name);
    formData.append("authorName", libraryData.authorName);
    formData.append("githubHandle", libraryData.githubHandle);
    formData.append("name", libraryData.name);
    formData.append("description", libraryData.description);
    formData.append("twitterHandle", libraryData.twitterHandle);
    formData.append("website", libraryData.website);
    fetch(`${define_import_meta_env_default.VITE_APP_LIBRARY_BACKEND}/submit`, {
      method: "post",
      body: formData
    }).then(
      (response) => {
        if (response.ok) {
          return response.json().then(({ url }) => {
            EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);
            onSuccess({
              url,
              authorName: libraryData.authorName,
              items: clonedLibItems
            });
          });
        }
        return response.json().catch(() => {
          throw new Error(response.statusText || "something went wrong");
        }).then((error) => {
          throw new Error(
            error.message || response.statusText || "something went wrong"
          );
        });
      },
      (err) => {
        console.error(err);
        onError(err);
        setIsSubmitting(false);
      }
    ).catch((err) => {
      console.error(err);
      onError(err);
      setIsSubmitting(false);
    });
  };
  const renderLibraryItems = () => {
    const items = [];
    clonedLibItems.forEach((libItem, index) => {
      items.push(
        /* @__PURE__ */ jsx54("div", { className: "single-library-item-wrapper", children: /* @__PURE__ */ jsx54(
          SingleLibraryItem,
          {
            libItem,
            appState,
            index,
            onChange: (val, index2) => {
              const items2 = clonedLibItems.slice();
              items2[index2].name = val;
              setClonedLibItems(items2);
            },
            onRemove
          }
        ) }, index)
      );
    });
    return /* @__PURE__ */ jsx54("div", { className: "selected-library-items", children: items });
  };
  const onDialogClose = useCallback7(() => {
    updateItemsInStorage(clonedLibItems);
    EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);
    onClose();
  }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);
  const shouldRenderForm = !!libraryItems.length;
  const containsPublishedItems = libraryItems.some(
    (item) => item.status === "published"
  );
  return /* @__PURE__ */ jsx54(
    Dialog,
    {
      onCloseRequest: onDialogClose,
      title: t("publishDialog.title"),
      className: "publish-library",
      children: shouldRenderForm ? /* @__PURE__ */ jsxs30("form", { onSubmit, children: [
        /* @__PURE__ */ jsx54("div", { className: "publish-library-note", children: /* @__PURE__ */ jsx54(
          Trans_default,
          {
            i18nKey: "publishDialog.noteDescription",
            link: (el) => /* @__PURE__ */ jsx54(
              "a",
              {
                href: "https://libraries.excalidraw.com",
                target: "_blank",
                rel: "noopener",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsx54("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx54(
          Trans_default,
          {
            i18nKey: "publishDialog.noteGuidelines",
            link: (el) => /* @__PURE__ */ jsx54(
              "a",
              {
                href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsx54("div", { className: "publish-library-note", children: t("publishDialog.noteItems") }),
        containsPublishedItems && /* @__PURE__ */ jsx54("span", { className: "publish-library-note publish-library-warning", children: t("publishDialog.republishWarning") }),
        renderLibraryItems(),
        /* @__PURE__ */ jsxs30("div", { className: "publish-library__fields", children: [
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx54("span", { children: t("publishDialog.libraryName") }),
              /* @__PURE__ */ jsx54("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx54(
              "input",
              {
                type: "text",
                name: "name",
                required: true,
                value: libraryData.name,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryName")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { style: { alignItems: "flex-start" }, children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx54("span", { children: t("publishDialog.libraryDesc") }),
              /* @__PURE__ */ jsx54("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx54(
              "textarea",
              {
                name: "description",
                rows: 4,
                required: true,
                value: libraryData.description,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryDesc")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx54("span", { children: t("publishDialog.authorName") }),
              /* @__PURE__ */ jsx54("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx54(
              "input",
              {
                type: "text",
                name: "authorName",
                required: true,
                value: libraryData.authorName,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.authorName")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx54("span", { children: t("publishDialog.githubUsername") }),
            /* @__PURE__ */ jsx54(
              "input",
              {
                type: "text",
                name: "githubHandle",
                value: libraryData.githubHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.githubHandle")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx54("span", { children: t("publishDialog.twitterUsername") }),
            /* @__PURE__ */ jsx54(
              "input",
              {
                type: "text",
                name: "twitterHandle",
                value: libraryData.twitterHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.twitterHandle")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx54("span", { children: t("publishDialog.website") }),
            /* @__PURE__ */ jsx54(
              "input",
              {
                type: "text",
                name: "website",
                pattern: "https?://.+",
                title: t("publishDialog.errors.website"),
                value: libraryData.website,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.website")
              }
            )
          ] }),
          /* @__PURE__ */ jsx54("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx54(
            Trans_default,
            {
              i18nKey: "publishDialog.noteLicense",
              link: (el) => /* @__PURE__ */ jsx54(
                "a",
                {
                  href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "publish-library__buttons", children: [
          /* @__PURE__ */ jsx54(
            DialogActionButton_default,
            {
              label: t("buttons.saveLibNames"),
              onClick: onDialogClose,
              "data-testid": "cancel-clear-canvas-button"
            }
          ),
          /* @__PURE__ */ jsx54(
            DialogActionButton_default,
            {
              type: "submit",
              label: t("buttons.submit"),
              actionType: "primary",
              isLoading: isSubmitting
            }
          )
        ] })
      ] }) : /* @__PURE__ */ jsx54("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: t("publishDialog.atleastOneLibItem") })
    }
  );
};
var PublishLibrary_default = PublishLibrary;

// components/dropdownMenu/DropdownMenu.tsx
import React21 from "react";
import { DropdownMenu as DropdownMenuPrimitive8 } from "radix-ui";
import { CLASSES as CLASSES3 } from "@excalidraw/common";

// components/dropdownMenu/DropdownMenuContent.tsx
import clsx24 from "clsx";
import { useCallback as useCallback8, useEffect as useEffect21, useRef as useRef15 } from "react";
import { CLASSES as CLASSES2, EVENT as EVENT7, KEYS as KEYS30 } from "@excalidraw/common";
import { DropdownMenu as DropdownMenuPrimitive2 } from "radix-ui";

// components/Stack.tsx
import { forwardRef as forwardRef2 } from "react";
import clsx23 from "clsx";
import { jsx as jsx55 } from "react/jsx-runtime";
var RowStack = forwardRef2(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ jsx55(
      "div",
      {
        className: clsx23("Stack Stack_horizontal", className),
        style: {
          "--gap": gap,
          alignItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var ColStack = forwardRef2(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ jsx55(
      "div",
      {
        className: clsx23("Stack Stack_vertical", className),
        style: {
          "--gap": gap,
          justifyItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var Stack_default = {
  Row: RowStack,
  Col: ColStack
};

// components/dropdownMenu/DropdownMenuContent.tsx
import { jsx as jsx56 } from "react/jsx-runtime";
var MenuContent = ({
  children,
  onClickOutside,
  className = "",
  onSelect,
  open = true,
  align = "end",
  style
}) => {
  const editorInterface = useEditorInterface();
  const menuRef = useRef15(null);
  const callbacksRef = useStable({ onClickOutside });
  useOutsideClick(
    menuRef,
    useCallback8(
      (event) => {
        if (!menuRef.current?.closest(`.${CLASSES2.DROPDOWN_MENU_EVENT_WRAPPER}`)?.contains(event.target)) {
          callbacksRef.onClickOutside?.();
        }
      },
      [callbacksRef]
    )
  );
  useEffect21(() => {
    if (!open) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.key === KEYS30.ESCAPE) {
        event.stopImmediatePropagation();
        callbacksRef.onClickOutside?.();
      }
    };
    const option = {
      // so that we can stop propagation of the event before it reaches
      // event handlers that were bound before this one
      capture: true
    };
    document.addEventListener(EVENT7.KEYDOWN, onKeyDown, option);
    return () => {
      document.removeEventListener(EVENT7.KEYDOWN, onKeyDown, option);
    };
  }, [callbacksRef, open]);
  const classNames = clsx24(`dropdown-menu ${className}`, {
    "dropdown-menu--mobile": editorInterface.formFactor === "phone"
  }).trim();
  return /* @__PURE__ */ jsx56(DropdownMenuContentPropsContext.Provider, { value: { onSelect }, children: /* @__PURE__ */ jsx56(
    DropdownMenuPrimitive2.Content,
    {
      ref: menuRef,
      className: classNames,
      style,
      "data-testid": "dropdown-menu",
      align,
      sideOffset: 8,
      onCloseAutoFocus: (event) => event.preventDefault(),
      children: editorInterface.formFactor === "phone" ? /* @__PURE__ */ jsx56(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ jsx56(Island, { className: "dropdown-menu-container", padding: 2, children })
    }
  ) });
};
MenuContent.displayName = "DropdownMenuContent";
var DropdownMenuContent_default = MenuContent;

// components/dropdownMenu/DropdownMenuItemCustom.tsx
import { jsx as jsx57 } from "react/jsx-runtime";
var DropdownMenuItemCustom = ({
  children,
  className = "",
  selected,
  ...rest
}) => {
  return /* @__PURE__ */ jsx57(
    "div",
    {
      ...rest,
      className: `dropdown-menu-item-base dropdown-menu-item-custom ${className} ${selected ? `dropdown-menu-item--selected` : ``}`.trim(),
      children
    }
  );
};
var DropdownMenuItemCustom_default = DropdownMenuItemCustom;

// components/dropdownMenu/DropdownMenuItemLink.tsx
import { DropdownMenu as DropdownMenuPrimitive3 } from "radix-ui";
import { jsx as jsx58 } from "react/jsx-runtime";
var DropdownMenuItemLink = ({
  icon,
  shortcut,
  href,
  children,
  onSelect,
  className = "",
  selected,
  rel = "noopener",
  ...rest
}) => {
  const handleSelect = useHandleDropdownMenuItemSelect(onSelect);
  return (
    // eslint-disable-next-line react/jsx-no-target-blank
    /* @__PURE__ */ jsx58(
      DropdownMenuPrimitive3.Item,
      {
        className: "radix-menu-item",
        onSelect: handleSelect,
        asChild: true,
        children: /* @__PURE__ */ jsx58(
          "a",
          {
            ...rest,
            href,
            target: "_blank",
            rel: `noopener ${rel}`,
            className: getDropdownMenuItemClassName(className, selected),
            title: rest.title ?? rest["aria-label"],
            children: /* @__PURE__ */ jsx58(DropdownMenuItemContent_default, { icon, shortcut, children })
          }
        )
      }
    )
  );
};
var DropdownMenuItemLink_default = DropdownMenuItemLink;
DropdownMenuItemLink.displayName = "DropdownMenuItemLink";

// components/dropdownMenu/DropdownMenuSeparator.tsx
import { jsx as jsx59 } from "react/jsx-runtime";
var MenuSeparator = () => /* @__PURE__ */ jsx59(
  "div",
  {
    style: {
      height: "1px",
      backgroundColor: "var(--default-border-color)",
      margin: "6px 0",
      flex: "0 0 auto"
    }
  }
);
var DropdownMenuSeparator_default = MenuSeparator;
MenuSeparator.displayName = "DropdownMenuSeparator";

// components/dropdownMenu/DropdownMenuSub.tsx
import { DropdownMenu as DropdownMenuPrimitive6 } from "radix-ui";

// components/dropdownMenu/DropdownMenuSubContent.tsx
import clsx25 from "clsx";
import { DropdownMenu as DropdownMenuPrimitive4 } from "radix-ui";
import { useCallback as useCallback9, useState as useState15 } from "react";
import { jsx as jsx60 } from "react/jsx-runtime";
var BASE_ALIGN_OFFSET = -4;
var BASE_SIDE_OFFSET = 4;
var DropdownMenuSubContent = ({
  children,
  className
}) => {
  const editorInterface = useEditorInterface();
  const classNames = clsx25(`dropdown-menu dropdown-submenu ${className}`, {
    "dropdown-menu--mobile": editorInterface.formFactor === "phone"
  }).trim();
  const callbacksRef = useCallback9((node) => {
    if (node) {
      const parentContainer = node.closest(".dropdown-menu-container");
      const parentRect = parentContainer?.getBoundingClientRect();
      if (parentRect) {
        const menuWidth = node.getBoundingClientRect().width;
        const viewportWidth = window.innerWidth;
        const spaceRemaining = viewportWidth - parentRect.right;
        if (spaceRemaining < menuWidth + 20) {
          setSideOffset(spaceRemaining - menuWidth + BASE_ALIGN_OFFSET);
          setAlignOffset(BASE_ALIGN_OFFSET + 8);
        }
      }
    }
  }, []);
  const [sideOffset, setSideOffset] = useState15(BASE_SIDE_OFFSET);
  const [alignOffset, setAlignOffset] = useState15(BASE_ALIGN_OFFSET);
  return /* @__PURE__ */ jsx60(
    DropdownMenuPrimitive4.SubContent,
    {
      className: classNames,
      sideOffset,
      alignOffset,
      collisionPadding: 8,
      ref: callbacksRef,
      children: editorInterface.formFactor === "phone" ? /* @__PURE__ */ jsx60(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ jsx60(
        Island,
        {
          className: "dropdown-menu-container",
          padding: 2,
          style: { zIndex: 1 },
          children
        }
      )
    }
  );
};
var DropdownMenuSubContent_default = DropdownMenuSubContent;
DropdownMenuSubContent.displayName = "DropdownMenuSubContent";

// components/dropdownMenu/DropdownMenuSubTrigger.tsx
import { DropdownMenu as DropdownMenuPrimitive5 } from "radix-ui";
import { jsx as jsx61, jsxs as jsxs31 } from "react/jsx-runtime";
var DropdownMenuSubTrigger = ({
  children,
  icon,
  shortcut,
  className
}) => {
  return /* @__PURE__ */ jsxs31(
    DropdownMenuPrimitive5.SubTrigger,
    {
      className: `${getDropdownMenuItemClassName(
        className
      )} dropdown-menu__submenu-trigger`,
      children: [
        /* @__PURE__ */ jsx61(DropdownMenuItemContent_default, { icon, shortcut, children }),
        /* @__PURE__ */ jsx61("div", { className: "dropdown-menu__submenu-trigger-icon", children: chevronRight })
      ]
    }
  );
};
var DropdownMenuSubTrigger_default = DropdownMenuSubTrigger;
DropdownMenuSubTrigger.displayName = "DropdownMenuSubTrigger";

// components/dropdownMenu/dropdownMenuUtils.ts
import React20 from "react";
var getMenuComponent = (component) => (children) => {
  const comp = React20.Children.toArray(children).find(
    (child) => React20.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === component
  );
  if (!comp) {
    return null;
  }
  return comp;
};
var getMenuTriggerComponent = getMenuComponent("DropdownMenuTrigger");
var getMenuContentComponent = getMenuComponent("DropdownMenuContent");
var getSubMenuTriggerComponent = getMenuComponent(
  "DropdownMenuSubTrigger"
);
var getSubMenuContentComponent = getMenuComponent(
  "DropdownMenuSubContent"
);

// components/dropdownMenu/DropdownMenuSub.tsx
import { jsxs as jsxs32 } from "react/jsx-runtime";
var DropdownMenuSub = ({ children }) => {
  const MenuTriggerComp = getSubMenuTriggerComponent(children);
  const MenuContentComp = getSubMenuContentComponent(children);
  return /* @__PURE__ */ jsxs32(DropdownMenuPrimitive6.Sub, { children: [
    MenuTriggerComp,
    MenuContentComp
  ] });
};
DropdownMenuSub.Trigger = DropdownMenuSubTrigger_default;
DropdownMenuSub.Content = DropdownMenuSubContent_default;
DropdownMenuSub.displayName = "DropdownMenuSub";
var DropdownMenuSub_default = DropdownMenuSub;

// components/dropdownMenu/DropdownMenuTrigger.tsx
import clsx26 from "clsx";
import { DropdownMenu as DropdownMenuPrimitive7 } from "radix-ui";
import { jsx as jsx62 } from "react/jsx-runtime";
var MenuTrigger = ({
  className = "",
  children,
  onToggle,
  title,
  ...rest
}) => {
  const editorInterface = useEditorInterface();
  const classNames = clsx26(
    `dropdown-menu-button ${className}`,
    "zen-mode-transition",
    {
      "dropdown-menu-button--mobile": editorInterface.formFactor === "phone"
    }
  ).trim();
  return /* @__PURE__ */ jsx62(
    DropdownMenuPrimitive7.Trigger,
    {
      className: classNames,
      onClick: onToggle,
      type: "button",
      "data-testid": "dropdown-menu-button",
      title,
      ...rest,
      children
    }
  );
};
var DropdownMenuTrigger_default = MenuTrigger;
MenuTrigger.displayName = "DropdownMenuTrigger";

// components/dropdownMenu/DropdownMenuItemCheckbox.tsx
import { jsx as jsx63 } from "react/jsx-runtime";
var DropdownMenuItemCheckbox = (props) => {
  return /* @__PURE__ */ jsx63(DropdownMenuItem_default, { ...props, icon: props.checked ? checkIcon : emptyIcon });
};
var DropdownMenuItemCheckbox_default = DropdownMenuItemCheckbox;

// components/dropdownMenu/DropdownMenu.tsx
import { jsx as jsx64, jsxs as jsxs33 } from "react/jsx-runtime";
var DropdownMenu = ({
  children,
  open
}) => {
  const MenuTriggerComp = getMenuTriggerComponent(children);
  const MenuContentComp = getMenuContentComponent(children);
  const MenuContentWithState = MenuContentComp && React21.isValidElement(MenuContentComp) ? React21.cloneElement(
    MenuContentComp,
    { open }
  ) : MenuContentComp;
  return /* @__PURE__ */ jsx64(DropdownMenuPrimitive8.Root, { open, modal: false, children: /* @__PURE__ */ jsxs33(
    "div",
    {
      className: CLASSES3.DROPDOWN_MENU_EVENT_WRAPPER,
      style: {
        // remove this div from box layout
        display: "contents"
      },
      children: [
        MenuTriggerComp,
        MenuContentWithState
      ]
    }
  ) });
};
DropdownMenu.Trigger = DropdownMenuTrigger_default;
DropdownMenu.Content = DropdownMenuContent_default;
DropdownMenu.Item = DropdownMenuItem_default;
DropdownMenu.ItemCheckbox = DropdownMenuItemCheckbox_default;
DropdownMenu.ItemLink = DropdownMenuItemLink_default;
DropdownMenu.ItemCustom = DropdownMenuItemCustom_default;
DropdownMenu.Group = DropdownMenuGroup_default;
DropdownMenu.Separator = DropdownMenuSeparator_default;
DropdownMenu.Sub = DropdownMenuSub_default;
var DropdownMenu_default = DropdownMenu;
DropdownMenu.displayName = "DropdownMenu";

// components/LibraryMenuHeaderContent.tsx
import { jsx as jsx65, jsxs as jsxs34 } from "react/jsx-runtime";
var getSelectedItems = (libraryItems, selectedItems) => libraryItems.filter((item) => selectedItems.includes(item.id));
var LibraryDropdownMenuButton = ({
  setAppState,
  selectedItems,
  library,
  onRemoveFromLibrary,
  resetLibrary,
  onSelectItems,
  appState,
  className
}) => {
  const [libraryItemsData] = useAtom(libraryItemsAtom);
  const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom(
    isLibraryMenuOpenAtom
  );
  const renderRemoveLibAlert = () => {
    const content = selectedItems.length ? t("alerts.removeItemsFromsLibrary", { count: selectedItems.length }) : t("alerts.resetLibrary");
    const title = selectedItems.length ? t("confirmDialog.removeItemsFromLib") : t("confirmDialog.resetLibrary");
    return /* @__PURE__ */ jsx65(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          if (selectedItems.length) {
            onRemoveFromLibrary();
          } else {
            resetLibrary();
          }
          setShowRemoveLibAlert(false);
        },
        onCancel: () => {
          setShowRemoveLibAlert(false);
        },
        title,
        children: /* @__PURE__ */ jsx65("p", { children: content })
      }
    );
  };
  const [showRemoveLibAlert, setShowRemoveLibAlert] = useState16(false);
  const itemsSelected = !!selectedItems.length;
  const items = itemsSelected ? libraryItemsData.libraryItems.filter(
    (item) => selectedItems.includes(item.id)
  ) : libraryItemsData.libraryItems;
  const resetLabel = itemsSelected ? t("buttons.remove") : t("buttons.resetLibrary");
  const [showPublishLibraryDialog, setShowPublishLibraryDialog] = useState16(false);
  const [publishLibSuccess, setPublishLibSuccess] = useState16(null);
  const renderPublishSuccess = useCallback10(() => {
    return /* @__PURE__ */ jsxs34(
      Dialog,
      {
        onCloseRequest: () => setPublishLibSuccess(null),
        title: t("publishSuccessDialog.title"),
        className: "publish-library-success",
        size: "small",
        children: [
          /* @__PURE__ */ jsx65("p", { children: /* @__PURE__ */ jsx65(
            Trans_default,
            {
              i18nKey: "publishSuccessDialog.content",
              authorName: publishLibSuccess.authorName,
              link: (el) => /* @__PURE__ */ jsx65(
                "a",
                {
                  href: publishLibSuccess?.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsx65(
            ToolButton,
            {
              type: "button",
              title: t("buttons.close"),
              "aria-label": t("buttons.close"),
              label: t("buttons.close"),
              onClick: () => setPublishLibSuccess(null),
              "data-testid": "publish-library-success-close",
              className: "publish-library-success-close"
            }
          )
        ]
      }
    );
  }, [setPublishLibSuccess, publishLibSuccess]);
  const onPublishLibSuccess = (data, libraryItems) => {
    setShowPublishLibraryDialog(false);
    setPublishLibSuccess({ url: data.url, authorName: data.authorName });
    const nextLibItems = libraryItems.slice();
    nextLibItems.forEach((libItem) => {
      if (selectedItems.includes(libItem.id)) {
        libItem.status = "published";
      }
    });
    library.setLibrary(nextLibItems);
  };
  const onLibraryImport = async () => {
    try {
      await library.updateLibrary({
        libraryItems: fileOpen({
          description: "Excalidraw library files"
          // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
          // gets resolved. Else, iOS users cannot open `.excalidraw` files.
          /*
            extensions: [".json", ".excalidrawlib"],
            */
        }),
        merge: true,
        openLibraryMenu: true
      });
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      setAppState({ errorMessage: t("errors.importLibraryError") });
    }
  };
  const onLibraryExport = async () => {
    const libraryItems = itemsSelected ? items : await library.getLatestLibrary();
    saveLibraryAsJSON(libraryItems).catch(muteFSAbortError).catch((error) => {
      setAppState({ errorMessage: error.message });
    });
  };
  const renderLibraryMenu = () => {
    return /* @__PURE__ */ jsxs34(DropdownMenu_default, { open: isLibraryMenuOpen, children: [
      /* @__PURE__ */ jsx65(
        DropdownMenu_default.Trigger,
        {
          onToggle: () => setIsLibraryMenuOpen(!isLibraryMenuOpen),
          children: DotsIcon
        }
      ),
      /* @__PURE__ */ jsxs34(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsLibraryMenuOpen(false),
          onSelect: () => setIsLibraryMenuOpen(false),
          className: "library-menu",
          children: [
            !itemsSelected && /* @__PURE__ */ jsx65(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryImport,
                icon: LoadIcon,
                "data-testid": "lib-dropdown--load",
                children: t("buttons.load")
              }
            ),
            !!items.length && /* @__PURE__ */ jsx65(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryExport,
                icon: ExportIcon,
                "data-testid": "lib-dropdown--export",
                children: t("buttons.export")
              }
            ),
            itemsSelected && /* @__PURE__ */ jsx65(
              DropdownMenu_default.Item,
              {
                icon: publishIcon,
                onSelect: () => setShowPublishLibraryDialog(true),
                "data-testid": "lib-dropdown--remove",
                children: t("buttons.publishLibrary")
              }
            ),
            !!items.length && /* @__PURE__ */ jsx65(
              DropdownMenu_default.Item,
              {
                onSelect: () => setShowRemoveLibAlert(true),
                icon: TrashIcon,
                children: resetLabel
              }
            )
          ]
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxs34("div", { className: clsx27("library-menu-dropdown-container", className), children: [
    renderLibraryMenu(),
    selectedItems.length > 0 && /* @__PURE__ */ jsx65("div", { className: "library-actions-counter", children: selectedItems.length }),
    showRemoveLibAlert && renderRemoveLibAlert(),
    showPublishLibraryDialog && /* @__PURE__ */ jsx65(
      PublishLibrary_default,
      {
        onClose: () => setShowPublishLibraryDialog(false),
        libraryItems: getSelectedItems(
          libraryItemsData.libraryItems,
          selectedItems
        ),
        appState,
        onSuccess: (data) => onPublishLibSuccess(data, libraryItemsData.libraryItems),
        onError: (error) => window.alert(error),
        updateItemsInStorage: () => library.setLibrary(libraryItemsData.libraryItems),
        onRemove: (id) => onSelectItems(selectedItems.filter((_id) => _id !== id))
      }
    ),
    publishLibSuccess && renderPublishSuccess()
  ] });
};
var LibraryDropdownMenu = ({
  selectedItems,
  onSelectItems,
  className
}) => {
  const { library } = useApp();
  const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const [libraryItemsData] = useAtom(libraryItemsAtom);
  const removeFromLibrary = async (libraryItems) => {
    const nextItems = libraryItems.filter(
      (item) => !selectedItems.includes(item.id)
    );
    library.setLibrary(nextItems).catch(() => {
      setAppState({ errorMessage: t("alerts.errorRemovingFromLibrary") });
    });
    deleteItemsFromLibraryCache(selectedItems);
    onSelectItems([]);
  };
  const resetLibrary = () => {
    library.resetLibrary();
    clearLibraryCache();
  };
  return /* @__PURE__ */ jsx65(
    LibraryDropdownMenuButton,
    {
      appState,
      setAppState,
      selectedItems,
      onSelectItems,
      library,
      onRemoveFromLibrary: () => removeFromLibrary(libraryItemsData.libraryItems),
      resetLibrary,
      className
    }
  );
};

// components/LibraryMenuSection.tsx
import { memo as memo2, useEffect as useEffect22, useState as useState18 } from "react";

// hooks/useTransition.ts
import React22, { useCallback as useCallback11 } from "react";
function useTransitionPolyfill() {
  const startTransition = useCallback11((callback) => callback(), []);
  return [false, startTransition];
}
var useTransition = React22.useTransition || useTransitionPolyfill;

// components/LibraryUnit.tsx
import clsx28 from "clsx";
import { memo, useRef as useRef16, useState as useState17 } from "react";
import { jsx as jsx66, jsxs as jsxs35 } from "react/jsx-runtime";
var LibraryUnit = memo(
  ({
    id,
    elements,
    isPending,
    onClick,
    selected,
    onToggle,
    onDrag,
    svgCache
  }) => {
    const ref = useRef16(null);
    const svg = useLibraryItemSvg(id, elements, svgCache, ref);
    const [isHovered, setIsHovered] = useState17(false);
    const isMobile = useEditorInterface().formFactor === "phone";
    const adder = isPending && /* @__PURE__ */ jsx66("div", { className: "library-unit__adder", children: PlusIcon });
    return /* @__PURE__ */ jsxs35(
      "div",
      {
        className: clsx28("library-unit", {
          "library-unit__active": elements,
          "library-unit--hover": elements && isHovered,
          "library-unit--selected": selected,
          "library-unit--skeleton": !svg
        }),
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsx66(
            "div",
            {
              className: clsx28("library-unit__dragger", {
                "library-unit__pulse": !!isPending
              }),
              ref,
              draggable: !!elements,
              onClick: !!elements || !!isPending ? (event) => {
                if (id && event.shiftKey) {
                  onToggle(id, event);
                } else {
                  onClick(id);
                }
              } : void 0,
              onDragStart: (event) => {
                if (!id) {
                  event.preventDefault();
                  return;
                }
                setIsHovered(false);
                onDrag(id, event);
              }
            }
          ),
          adder,
          id && elements && (isHovered || isMobile || selected) && /* @__PURE__ */ jsx66(
            CheckboxItem,
            {
              checked: selected,
              onChange: (checked, event) => onToggle(id, event),
              className: "library-unit__checkbox"
            }
          )
        ]
      }
    );
  }
);
var EmptyLibraryUnit = () => /* @__PURE__ */ jsx66("div", { className: "library-unit library-unit--skeleton" });

// components/LibraryMenuSection.tsx
import { Fragment as Fragment8, jsx as jsx67 } from "react/jsx-runtime";
var LibraryMenuSectionGrid = ({
  children
}) => {
  return /* @__PURE__ */ jsx67("div", { className: "library-menu-items-container__grid", children });
};
var LibraryMenuSection = memo2(
  ({
    items,
    onItemSelectToggle,
    onItemDrag,
    isItemSelected,
    onClick,
    svgCache,
    itemsRenderedPerBatch
  }) => {
    const [, startTransition] = useTransition();
    const [index, setIndex] = useState18(0);
    useEffect22(() => {
      if (index < items.length) {
        startTransition(() => {
          setIndex(index + itemsRenderedPerBatch);
        });
      }
    }, [index, items.length, startTransition, itemsRenderedPerBatch]);
    return /* @__PURE__ */ jsx67(Fragment8, { children: items.map((item, i) => {
      return i < index ? /* @__PURE__ */ jsx67(
        LibraryUnit,
        {
          elements: item?.elements,
          isPending: !item?.id && !!item?.elements,
          onClick,
          svgCache,
          id: item?.id,
          selected: isItemSelected(item.id),
          onToggle: onItemSelectToggle,
          onDrag: onItemDrag
        },
        item?.id ?? i
      ) : /* @__PURE__ */ jsx67(EmptyLibraryUnit, {}, i);
    }) });
  }
);

// components/TextField.tsx
import clsx30 from "clsx";
import {
  forwardRef as forwardRef3,
  useRef as useRef17,
  useImperativeHandle as useImperativeHandle2,
  useLayoutEffect as useLayoutEffect3,
  useState as useState19
} from "react";

// components/Button.tsx
import clsx29 from "clsx";
import { composeEventHandlers as composeEventHandlers2 } from "@excalidraw/common";
import { jsx as jsx68 } from "react/jsx-runtime";
var Button = ({
  type = "button",
  onSelect,
  selected,
  children,
  className = "",
  ...rest
}) => {
  return /* @__PURE__ */ jsx68(
    "button",
    {
      onClick: composeEventHandlers2(rest.onClick, (event) => {
        onSelect();
      }),
      type,
      className: clsx29("excalidraw-button", className, { selected }),
      ...rest,
      children
    }
  );
};

// components/TextField.tsx
import { jsx as jsx69, jsxs as jsxs36 } from "react/jsx-runtime";
var TextField = forwardRef3(
  ({
    onChange,
    label,
    fullWidth,
    placeholder,
    readonly,
    selectOnRender,
    onKeyDown,
    isRedacted = false,
    icon,
    className,
    type,
    ...rest
  }, ref) => {
    const innerRef = useRef17(null);
    useImperativeHandle2(ref, () => innerRef.current);
    useLayoutEffect3(() => {
      if (selectOnRender) {
        innerRef.current?.focus();
        innerRef.current?.select();
      }
    }, [selectOnRender]);
    const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] = useState19(false);
    return /* @__PURE__ */ jsxs36(
      "div",
      {
        className: clsx30("ExcTextField", className, {
          "ExcTextField--fullWidth": fullWidth,
          "ExcTextField--hasIcon": !!icon
        }),
        onClick: () => {
          innerRef.current?.focus();
        },
        children: [
          icon,
          label && /* @__PURE__ */ jsx69("div", { className: "ExcTextField__label", children: label }),
          /* @__PURE__ */ jsxs36(
            "div",
            {
              className: clsx30("ExcTextField__input", {
                "ExcTextField__input--readonly": readonly
              }),
              children: [
                /* @__PURE__ */ jsx69(
                  "input",
                  {
                    className: clsx30({
                      "is-redacted": "value" in rest && rest.value && isRedacted && !isTemporarilyUnredacted
                    }),
                    readOnly: readonly,
                    value: "value" in rest ? rest.value : void 0,
                    defaultValue: "defaultValue" in rest ? rest.defaultValue : void 0,
                    placeholder,
                    ref: innerRef,
                    onChange: (event) => onChange?.(event.target.value),
                    onKeyDown,
                    type
                  }
                ),
                isRedacted && /* @__PURE__ */ jsx69(
                  Button,
                  {
                    onSelect: () => setIsTemporarilyUnredacted(!isTemporarilyUnredacted),
                    style: { border: 0, userSelect: "none" },
                    children: isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
);

// components/LibraryMenuItems.tsx
import { Fragment as Fragment9, jsx as jsx70, jsxs as jsxs37 } from "react/jsx-runtime";
var ITEMS_RENDERED_PER_BATCH = 17;
var CACHED_ITEMS_RENDERED_PER_BATCH = 64;
function LibraryMenuItems({
  isLoading,
  libraryItems,
  onAddToLibrary,
  onInsertLibraryItems,
  pendingElements,
  theme,
  id,
  libraryReturnUrl,
  onSelectItems,
  selectedItems
}) {
  const editorInterface = useEditorInterface();
  const libraryContainerRef = useRef18(null);
  const scrollPosition = useScrollPosition(libraryContainerRef);
  useEffect23(() => {
    if (scrollPosition > 0) {
      libraryContainerRef.current?.scrollTo(0, scrollPosition);
    }
  }, []);
  const { svgCache } = useLibraryCache();
  const [lastSelectedItem, setLastSelectedItem] = useState20(null);
  const [searchInputValue, setSearchInputValue] = useState20("");
  const IS_LIBRARY_EMPTY = !libraryItems.length && !pendingElements.length;
  const IS_SEARCHING = !IS_LIBRARY_EMPTY && !!searchInputValue.trim();
  const filteredItems = useMemo5(() => {
    const searchQuery = deburr(searchInputValue.trim().toLowerCase());
    if (!searchQuery) {
      return [];
    }
    return libraryItems.filter((item) => {
      const itemName = item.name || "";
      return itemName.trim() && deburr(itemName.toLowerCase()).includes(searchQuery);
    });
  }, [libraryItems, searchInputValue]);
  const unpublishedItems = useMemo5(
    () => libraryItems.filter((item) => item.status !== "published"),
    [libraryItems]
  );
  const publishedItems = useMemo5(
    () => libraryItems.filter((item) => item.status === "published"),
    [libraryItems]
  );
  const onItemSelectToggle = useCallback12(
    (id2, event) => {
      const shouldSelect = !selectedItems.includes(id2);
      const orderedItems = [...unpublishedItems, ...publishedItems];
      if (shouldSelect) {
        if (event.shiftKey && lastSelectedItem) {
          const rangeStart = orderedItems.findIndex(
            (item) => item.id === lastSelectedItem
          );
          const rangeEnd = orderedItems.findIndex((item) => item.id === id2);
          if (rangeStart === -1 || rangeEnd === -1) {
            onSelectItems([...selectedItems, id2]);
            return;
          }
          const selectedItemsMap = arrayToMap13(selectedItems);
          const minRange = Math.min(rangeStart, rangeEnd);
          const maxRange = Math.max(rangeStart, rangeEnd);
          const nextSelectedIds = orderedItems.reduce(
            (acc, item, idx) => {
              if (idx >= minRange && idx <= maxRange || selectedItemsMap.has(item.id)) {
                acc.push(item.id);
              }
              return acc;
            },
            []
          );
          onSelectItems(nextSelectedIds);
        } else {
          onSelectItems([...selectedItems, id2]);
        }
        setLastSelectedItem(id2);
      } else {
        setLastSelectedItem(null);
        onSelectItems(selectedItems.filter((_id) => _id !== id2));
      }
    },
    [
      lastSelectedItem,
      onSelectItems,
      publishedItems,
      selectedItems,
      unpublishedItems
    ]
  );
  useEffect23(() => {
    if (!selectedItems.length) {
      setLastSelectedItem(null);
    }
  }, [selectedItems]);
  const getInsertedElements = useCallback12(
    (id2) => {
      let targetElements;
      if (selectedItems.includes(id2)) {
        targetElements = libraryItems.filter(
          (item) => selectedItems.includes(item.id)
        );
      } else {
        targetElements = libraryItems.filter((item) => item.id === id2);
      }
      return targetElements.map((item) => {
        return {
          ...item,
          // duplicate each library item before inserting on canvas to confine
          // ids and bindings to each library item. See #6465
          elements: duplicateElements2({
            type: "everything",
            elements: item.elements,
            randomizeSeed: true
          }).duplicatedElements
        };
      });
    },
    [libraryItems, selectedItems]
  );
  const onItemDrag = useCallback12(
    (id2, event) => {
      const data = {
        itemIds: selectedItems.includes(id2) ? selectedItems : [id2]
      };
      event.dataTransfer.setData(
        MIME_TYPES6.excalidrawlibIds,
        JSON.stringify(data)
      );
    },
    [selectedItems]
  );
  const isItemSelected = useCallback12(
    (id2) => {
      if (!id2) {
        return false;
      }
      return selectedItems.includes(id2);
    },
    [selectedItems]
  );
  const onAddToLibraryClick = useCallback12(() => {
    onAddToLibrary(pendingElements);
  }, [pendingElements, onAddToLibrary]);
  const onItemClick = useCallback12(
    (id2) => {
      if (id2) {
        onInsertLibraryItems(getInsertedElements(id2));
      }
    },
    [getInsertedElements, onInsertLibraryItems]
  );
  const itemsRenderedPerBatch = svgCache.size >= (filteredItems.length ? filteredItems : libraryItems).length ? CACHED_ITEMS_RENDERED_PER_BATCH : ITEMS_RENDERED_PER_BATCH;
  const searchInputRef = useRef18(null);
  useEffect23(() => {
    nextAnimationFrame(() => {
      searchInputRef.current?.focus();
    });
  }, []);
  const JSX_whenNotSearching = !IS_SEARCHING && /* @__PURE__ */ jsxs37(Fragment9, { children: [
    !IS_LIBRARY_EMPTY && /* @__PURE__ */ jsx70("div", { className: "library-menu-items-container__header", children: t("labels.personalLib") }),
    !pendingElements.length && !unpublishedItems.length ? /* @__PURE__ */ jsxs37("div", { className: "library-menu-items__no-items", children: [
      !publishedItems.length && /* @__PURE__ */ jsx70("div", { className: "library-menu-items__no-items__label", children: t("library.noItems") }),
      /* @__PURE__ */ jsx70("div", { className: "library-menu-items__no-items__hint", children: publishedItems.length > 0 ? t("library.hint_emptyPrivateLibrary") : t("library.hint_emptyLibrary") })
    ] }) : /* @__PURE__ */ jsxs37(LibraryMenuSectionGrid, { children: [
      pendingElements.length > 0 && /* @__PURE__ */ jsx70(
        LibraryMenuSection,
        {
          itemsRenderedPerBatch,
          items: [{ id: null, elements: pendingElements }],
          onItemSelectToggle,
          onItemDrag,
          onClick: onAddToLibraryClick,
          isItemSelected,
          svgCache
        }
      ),
      /* @__PURE__ */ jsx70(
        LibraryMenuSection,
        {
          itemsRenderedPerBatch,
          items: unpublishedItems,
          onItemSelectToggle,
          onItemDrag,
          onClick: onItemClick,
          isItemSelected,
          svgCache
        }
      )
    ] }),
    publishedItems.length > 0 && /* @__PURE__ */ jsx70(
      "div",
      {
        className: "library-menu-items-container__header",
        style: { marginTop: "0.75rem" },
        children: t("labels.excalidrawLib")
      }
    ),
    publishedItems.length > 0 && /* @__PURE__ */ jsx70(LibraryMenuSectionGrid, { children: /* @__PURE__ */ jsx70(
      LibraryMenuSection,
      {
        itemsRenderedPerBatch,
        items: publishedItems,
        onItemSelectToggle,
        onItemDrag,
        onClick: onItemClick,
        isItemSelected,
        svgCache
      }
    ) })
  ] });
  const JSX_whenSearching = IS_SEARCHING && /* @__PURE__ */ jsxs37(Fragment9, { children: [
    /* @__PURE__ */ jsxs37("div", { className: "library-menu-items-container__header", children: [
      t("library.search.heading"),
      !isLoading && /* @__PURE__ */ jsxs37(
        "div",
        {
          className: "library-menu-items-container__header__hint",
          style: { cursor: "pointer" },
          onPointerDown: (e) => e.preventDefault(),
          onClick: (event) => {
            setSearchInputValue("");
          },
          children: [
            /* @__PURE__ */ jsx70("kbd", { children: "esc" }),
            " to clear"
          ]
        }
      )
    ] }),
    filteredItems.length > 0 ? /* @__PURE__ */ jsx70(LibraryMenuSectionGrid, { children: /* @__PURE__ */ jsx70(
      LibraryMenuSection,
      {
        itemsRenderedPerBatch,
        items: filteredItems,
        onItemSelectToggle,
        onItemDrag,
        onClick: onItemClick,
        isItemSelected,
        svgCache
      }
    ) }) : /* @__PURE__ */ jsxs37("div", { className: "library-menu-items__no-items", children: [
      /* @__PURE__ */ jsx70("div", { className: "library-menu-items__no-items__hint", children: t("library.search.noResults") }),
      /* @__PURE__ */ jsx70(
        Button,
        {
          onPointerDown: (e) => e.preventDefault(),
          onSelect: () => {
            setSearchInputValue("");
          },
          style: { width: "auto", marginTop: "1rem" },
          children: t("library.search.clearSearch")
        }
      )
    ] })
  ] });
  return /* @__PURE__ */ jsxs37(
    "div",
    {
      className: "library-menu-items-container",
      style: pendingElements.length || unpublishedItems.length || publishedItems.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
      children: [
        /* @__PURE__ */ jsxs37("div", { className: "library-menu-items-header", children: [
          !IS_LIBRARY_EMPTY && /* @__PURE__ */ jsx70(
            TextField,
            {
              ref: searchInputRef,
              type: "search",
              className: clsx31("library-menu-items-container__search", {
                hideCancelButton: editorInterface.formFactor !== "phone"
              }),
              placeholder: t("library.search.inputPlaceholder"),
              value: searchInputValue,
              onChange: (value) => setSearchInputValue(value)
            }
          ),
          /* @__PURE__ */ jsx70(
            LibraryDropdownMenu,
            {
              selectedItems,
              onSelectItems,
              className: "library-menu-dropdown-container--in-heading"
            }
          )
        ] }),
        /* @__PURE__ */ jsxs37(
          Stack_default.Col,
          {
            className: "library-menu-items-container__items",
            align: "start",
            gap: 1,
            style: {
              flex: publishedItems.length > 0 ? 1 : "0 1 auto",
              margin: IS_LIBRARY_EMPTY ? "auto" : 0
            },
            ref: libraryContainerRef,
            children: [
              isLoading && /* @__PURE__ */ jsx70(
                "div",
                {
                  style: {
                    position: "absolute",
                    top: "var(--container-padding-y)",
                    right: "var(--container-padding-x)",
                    transform: "translateY(50%)"
                  },
                  children: /* @__PURE__ */ jsx70(Spinner_default, {})
                }
              ),
              JSX_whenNotSearching,
              JSX_whenSearching,
              IS_LIBRARY_EMPTY && /* @__PURE__ */ jsx70(
                LibraryMenuControlButtons,
                {
                  style: { padding: "16px 0", width: "100%" },
                  id,
                  libraryReturnUrl,
                  theme
                }
              )
            ]
          }
        )
      ]
    }
  );
}

// components/LibraryMenu.tsx
import { jsx as jsx71, jsxs as jsxs38 } from "react/jsx-runtime";
var isLibraryMenuOpenAtom = atom(false);
var LibraryMenuWrapper = ({ children }) => {
  return /* @__PURE__ */ jsx71("div", { className: "layer-ui__library", children });
};
var LibraryMenuContent = memo3(
  ({
    onInsertLibraryItems,
    pendingElements,
    onAddToLibrary,
    setAppState,
    libraryReturnUrl,
    library,
    id,
    theme,
    selectedItems,
    onSelectItems
  }) => {
    const [libraryItemsData] = useAtom(libraryItemsAtom);
    const _onAddToLibrary = useCallback13(
      (elements) => {
        const addToLibrary = async (processedElements, libraryItems2) => {
          trackEvent("element", "addToLibrary", "ui");
          for (const type of LIBRARY_DISABLED_TYPES2) {
            if (processedElements.some((element) => element.type === type)) {
              return setAppState({
                errorMessage: t(`errors.libraryElementTypeError.${type}`)
              });
            }
          }
          const nextItems = [
            {
              status: "unpublished",
              elements: processedElements,
              id: randomId5(),
              created: Date.now()
            },
            ...libraryItems2
          ];
          onAddToLibrary();
          library.setLibrary(nextItems).catch(() => {
            setAppState({ errorMessage: t("alerts.errorAddingToLibrary") });
          });
        };
        addToLibrary(elements, libraryItemsData.libraryItems);
      },
      [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems]
    );
    const libraryItems = useMemo6(
      () => libraryItemsData.libraryItems,
      [libraryItemsData]
    );
    if (libraryItemsData.status === "loading" && !libraryItemsData.isInitialized) {
      return /* @__PURE__ */ jsx71(LibraryMenuWrapper, { children: /* @__PURE__ */ jsx71("div", { className: "layer-ui__library-message", children: /* @__PURE__ */ jsxs38("div", { children: [
        /* @__PURE__ */ jsx71(Spinner_default, { size: "2em" }),
        /* @__PURE__ */ jsx71("span", { children: t("labels.libraryLoadingMessage") })
      ] }) }) });
    }
    const showBtn = libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;
    return /* @__PURE__ */ jsxs38(LibraryMenuWrapper, { children: [
      /* @__PURE__ */ jsx71(
        LibraryMenuItems,
        {
          isLoading: libraryItemsData.status === "loading",
          libraryItems,
          onAddToLibrary: _onAddToLibrary,
          onInsertLibraryItems,
          pendingElements,
          id,
          libraryReturnUrl,
          theme,
          onSelectItems,
          selectedItems
        }
      ),
      showBtn && /* @__PURE__ */ jsx71(
        LibraryMenuControlButtons,
        {
          className: "library-menu-control-buttons--at-bottom",
          style: { padding: "16px 12px 0 12px" },
          id,
          libraryReturnUrl,
          theme
        }
      )
    ] });
  }
);
var getPendingElements = (elements, selectedElementIds) => ({
  elements,
  pending: getSelectedElements(
    elements,
    { selectedElementIds },
    {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    }
  ),
  selectedElementIds
});
var usePendingElementsMemo = (appState, app) => {
  const elements = useExcalidrawElements();
  const [state, setState] = useState21(
    () => getPendingElements(elements, appState.selectedElementIds)
  );
  const selectedElementVersions = useRef19(
    /* @__PURE__ */ new Map()
  );
  useEffect24(() => {
    for (const element of state.pending) {
      selectedElementVersions.current.set(element.id, element.version);
    }
  }, [state.pending]);
  useEffect24(() => {
    if (
      // Only update once pointer is released.
      // Reading directly from app.state to make it clear it's not reactive
      // (hence, there's potential for stale state)
      app.state.cursorButton === "up" && app.state.activeTool.type === "selection"
    ) {
      setState((prev) => {
        if (!isShallowEqual(prev.selectedElementIds, appState.selectedElementIds)) {
          selectedElementVersions.current.clear();
          return getPendingElements(elements, appState.selectedElementIds);
        }
        const elementsMap = app.scene.getNonDeletedElementsMap();
        for (const id of Object.keys(appState.selectedElementIds)) {
          const currVersion = elementsMap.get(id)?.version;
          if (currVersion && currVersion !== selectedElementVersions.current.get(id)) {
            return getPendingElements(elements, appState.selectedElementIds);
          }
        }
        return prev;
      });
    }
  }, [
    app,
    app.state.cursorButton,
    app.state.activeTool.type,
    appState.selectedElementIds,
    elements
  ]);
  return state.pending;
};
var LibraryMenu = memo3(() => {
  const app = useApp();
  const { onInsertElements } = app;
  const appProps = useAppProps();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const [selectedItems, setSelectedItems] = useState21([]);
  const memoizedLibrary = useMemo6(() => app.library, [app.library]);
  const pendingElements = usePendingElementsMemo(appState, app);
  useEffect24(() => {
    return addEventListener(
      document,
      EVENT8.KEYDOWN,
      (event) => {
        if (event.key === KEYS31.ESCAPE && event.target instanceof HTMLElement) {
          const target = event.target;
          if (target.closest(`.${CLASSES4.SIDEBAR}`)) {
            if (selectedItems.length > 0) {
              event.stopPropagation();
              setSelectedItems([]);
            } else if (isWritableElement2(target) && target instanceof HTMLInputElement && !target.value) {
              event.stopPropagation();
              setAppState({ openSidebar: null });
              app.focusContainer();
            }
          } else if (selectedItems.length > 0) {
            const { x, y } = app.lastViewportPosition;
            const elementUnderCursor = document.elementFromPoint(x, y);
            if (elementUnderCursor?.closest(`.${CLASSES4.SIDEBAR}`)) {
              event.stopPropagation();
              setSelectedItems([]);
            }
          }
        }
      },
      { capture: true }
    );
  }, [selectedItems, setAppState, app]);
  const onInsertLibraryItems = useCallback13(
    (libraryItems) => {
      onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));
      app.focusContainer();
    },
    [onInsertElements, app]
  );
  const deselectItems = useCallback13(() => {
    setAppState({
      selectedElementIds: {},
      selectedGroupIds: {},
      activeEmbeddable: null
    });
  }, [setAppState]);
  return /* @__PURE__ */ jsx71(
    LibraryMenuContent,
    {
      pendingElements,
      onInsertLibraryItems,
      onAddToLibrary: deselectItems,
      setAppState,
      libraryReturnUrl: appProps.libraryReturnUrl,
      library: memoizedLibrary,
      id: app.id,
      theme: appState.theme,
      selectedItems,
      onSelectItems: setSelectedItems
    }
  );
});

// components/Modal.tsx
import clsx32 from "clsx";
import { useRef as useRef20 } from "react";
import { createPortal as createPortal2 } from "react-dom";
import { KEYS as KEYS32 } from "@excalidraw/common";
import { jsx as jsx72, jsxs as jsxs39 } from "react/jsx-runtime";
var Modal = (props) => {
  const { closeOnClickOutside = true } = props;
  const modalRoot = useCreatePortalContainer({
    className: "excalidraw-modal-container"
  });
  const animationsDisabledRef = useRef20(
    document.body.classList.contains("excalidraw-animations-disabled")
  );
  if (!modalRoot) {
    return null;
  }
  const handleKeydown = (event) => {
    if (event.key === KEYS32.ESCAPE) {
      event.nativeEvent.stopImmediatePropagation();
      event.stopPropagation();
      props.onCloseRequest();
    }
  };
  return createPortal2(
    /* @__PURE__ */ jsxs39(
      "div",
      {
        className: clsx32("Modal", props.className, {
          "animations-disabled": animationsDisabledRef.current
        }),
        role: "dialog",
        "aria-modal": "true",
        onKeyDown: handleKeydown,
        "aria-labelledby": props.labelledBy,
        children: [
          /* @__PURE__ */ jsx72(
            "div",
            {
              className: "Modal__background",
              onClick: closeOnClickOutside ? props.onCloseRequest : void 0
            }
          ),
          /* @__PURE__ */ jsx72(
            "div",
            {
              className: "Modal__content",
              style: { "--max-width": `${props.maxWidth}px` },
              tabIndex: 0,
              children: props.children
            }
          )
        ]
      }
    ),
    modalRoot
  );
};

// components/Dialog.tsx
import { jsx as jsx73, jsxs as jsxs40 } from "react/jsx-runtime";
function getDialogSize(size) {
  if (size && typeof size === "number") {
    return size;
  }
  switch (size) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Dialog = (props) => {
  const [islandNode, setIslandNode] = useCallbackRefState();
  const [lastActiveElement] = useState22(document.activeElement);
  const { id } = useExcalidrawContainer();
  const isFullscreen = useEditorInterface().formFactor === "phone";
  useEffect25(() => {
    if (!islandNode) {
      return;
    }
    const focusableElements = queryFocusableElements(islandNode);
    setTimeout(() => {
      if (focusableElements.length > 0 && props.autofocus !== false) {
        (focusableElements[1] || focusableElements[0]).focus();
      }
    });
    const handleKeyDown = (event) => {
      if (event.key === KEYS33.TAB) {
        const focusableElements2 = queryFocusableElements(islandNode);
        const { activeElement } = document;
        const currentIndex = focusableElements2.findIndex(
          (element) => element === activeElement
        );
        if (currentIndex === 0 && event.shiftKey) {
          focusableElements2[focusableElements2.length - 1].focus();
          event.preventDefault();
        } else if (currentIndex === focusableElements2.length - 1 && !event.shiftKey) {
          focusableElements2[0].focus();
          event.preventDefault();
        }
      }
    };
    islandNode.addEventListener("keydown", handleKeyDown);
    return () => islandNode.removeEventListener("keydown", handleKeyDown);
  }, [islandNode, props.autofocus]);
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom);
  const onClose = () => {
    setAppState({ openMenu: null });
    setIsLibraryMenuOpen(false);
    lastActiveElement.focus();
    props.onCloseRequest();
  };
  return /* @__PURE__ */ jsx73(
    Modal,
    {
      className: clsx33("Dialog", props.className, {
        "Dialog--fullscreen": isFullscreen
      }),
      labelledBy: "dialog-title",
      maxWidth: getDialogSize(props.size),
      onCloseRequest: onClose,
      closeOnClickOutside: props.closeOnClickOutside,
      children: /* @__PURE__ */ jsxs40(Island, { ref: setIslandNode, children: [
        props.title && /* @__PURE__ */ jsx73("h2", { id: `${id}-dialog-title`, className: "Dialog__title", children: /* @__PURE__ */ jsx73("span", { className: "Dialog__titleContent", children: props.title }) }),
        isFullscreen && /* @__PURE__ */ jsx73(
          "button",
          {
            className: "Dialog__close",
            onClick: onClose,
            title: t("buttons.close"),
            "aria-label": t("buttons.close"),
            type: "button",
            children: CloseIcon
          }
        ),
        /* @__PURE__ */ jsx73("div", { className: "Dialog__content", children: props.children })
      ] })
    }
  );
};

// components/shapes.tsx
import { KEYS as KEYS34 } from "@excalidraw/common";
var SHAPES = [
  {
    icon: StickyNoteIcon,
    value: "StickyNote",
    key: KEYS34.N,
    numericKey: KEYS34["4"],
    fillable: true
  },
  {
    icon: FreedrawIcon,
    value: "freedraw",
    key: [KEYS34.P, KEYS34.X],
    numericKey: KEYS34["7"],
    fillable: false
  },
  {
    icon: DiamondIcon,
    value: "diamond",
    key: KEYS34.D,
    numericKey: KEYS34["3"],
    fillable: true
  },
  {
    icon: EllipseIcon,
    value: "ellipse",
    key: KEYS34.O,
    numericKey: KEYS34["4"],
    fillable: true
  },
  {
    icon: RectangleIcon,
    value: "rectangle",
    key: KEYS34.R,
    numericKey: KEYS34["2"],
    fillable: true
  },
  {
    icon: ArrowIcon,
    value: "arrow",
    key: KEYS34.A,
    numericKey: KEYS34["5"],
    fillable: true
  },
  {
    icon: LineIcon,
    value: "line",
    key: KEYS34.L,
    numericKey: KEYS34["6"],
    fillable: true
  },
  {
    icon: TextIcon,
    value: "text",
    key: KEYS34.T,
    numericKey: KEYS34["8"],
    fillable: false
  },
  {
    icon: frameToolIcon,
    value: "frame",
    key: KEYS34.F,
    numericKey: KEYS34["9"],
    fillable: false
  }
];
var getToolbarTools = (app) => SHAPES;
var findShapeByKey = (key, app) => {
  if (key === KEYS34.V || key === KEYS34["1"]) {
    return app.state.preferredSelectionTool.type;
  }
  const shape = SHAPES.find((s) => {
    if (s.numericKey != null && key === s.numericKey.toString())
      return true;
    const k = s.key;
    if (k == null)
      return false;
    return typeof k === "string" ? k === key : k.includes(key);
  });
  return shape?.value || null;
};

// components/Actions.tsx
import clsx34 from "clsx";
import { useRef as useRef21, useState as useState23 } from "react";
import { Popover as Popover6 } from "radix-ui";
import {
  CLASSES as CLASSES5,
  capitalizeString,
  isTransparent as isTransparent2
} from "@excalidraw/common";
import {
  getContainerElement as getContainerElement3,
  shouldAllowVerticalAlign,
  suppportsHorizontalAlign,
  hasBoundTextElement as hasBoundTextElement4,
  isElbowArrow as isElbowArrow5,
  isImageElement,
  isLinearElement as isLinearElement5,
  isTextElement as isTextElement6,
  isArrowElement as isArrowElement6,
  hasStrokeColor as hasStrokeColor2,
  toolIsArrow
} from "@excalidraw/element";

// context/tunnels.ts
import { createIsolation as createIsolation2 } from "jotai-scope";
import React27 from "react";
import tunnel from "tunnel-rat";
var TunnelsContext = React27.createContext(null);
var useTunnels = () => React27.useContext(TunnelsContext);
var tunnelsJotai = createIsolation2();
var useInitializeTunnels = () => {
  return React27.useMemo(() => {
    return {
      MainMenuTunnel: tunnel(),
      WelcomeScreenMenuHintTunnel: tunnel(),
      WelcomeScreenToolbarHintTunnel: tunnel(),
      WelcomeScreenHelpHintTunnel: tunnel(),
      WelcomeScreenCenterTunnel: tunnel(),
      FooterCenterTunnel: tunnel(),
      DefaultSidebarTriggerTunnel: tunnel(),
      DefaultSidebarTabTriggersTunnel: tunnel(),
      OverwriteConfirmDialogTunnel: tunnel(),
      TTDDialogTriggerTunnel: tunnel(),
      tunnelsJotai
    };
  }, []);
};

// actions/actionToggleViewMode.tsx
import { CODES as CODES11, KEYS as KEYS35 } from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction28 } from "@excalidraw/element";
var actionToggleViewMode = register({
  name: "viewMode",
  label: "labels.viewMode",
  icon: eyeIcon,
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.viewModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        viewModeEnabled: !this.checked(appState)
      },
      captureUpdate: CaptureUpdateAction28.EVENTUALLY
    };
  },
  checked: (appState) => appState.viewModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.viewModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS35.CTRL_OR_CMD] && event.altKey && event.code === CODES11.R
});

// components/Actions.tsx
import { Fragment as Fragment10, jsx as jsx74, jsxs as jsxs41 } from "react/jsx-runtime";
var PROPERTIES_CLASSES = clsx34([
  CLASSES5.SHAPE_ACTIONS_THEME_SCOPE,
  "properties-content"
]);
var canChangeStrokeColor = (appState, targetElements) => {
  let commonSelectedType = targetElements[0]?.type || null;
  for (const element of targetElements) {
    if (element.type !== commonSelectedType) {
      commonSelectedType = null;
      break;
    }
  }
  return hasStrokeColor2(appState.activeTool.type) && commonSelectedType !== "image" && commonSelectedType !== "frame" && commonSelectedType !== "magicframe" || targetElements.some((element) => hasStrokeColor2(element.type));
};
var canChangeBackgroundColor = (appState, targetElements) => {
  return hasBackground(appState.activeTool.type) || targetElements.some((element) => hasBackground(element.type));
};
var SelectedShapeActions = ({
  appState,
  elementsMap,
  renderAction,
  app
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  let isSingleElementBoundContainer = false;
  if (targetElements.length === 2 && (hasBoundTextElement4(targetElements[0]) || hasBoundTextElement4(targetElements[1]))) {
    isSingleElementBoundContainer = true;
  }
  const isEditingTextOrNewElement = Boolean(
    appState.editingTextElement || appState.newElement
  );
  const editorInterface = useEditorInterface();
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent2(appState.currentItemBackgroundColor) || targetElements.some(
    (element) => hasBackground(element.type) && !isTransparent2(element.backgroundColor)
  );
  const showLinkIcon = targetElements.length === 1 || isSingleElementBoundContainer;
  const showLineEditorAction = !appState.selectedLinearElement?.isEditing && targetElements.length === 1 && isLinearElement5(targetElements[0]) && !isElbowArrow5(targetElements[0]);
  const showCropEditorAction = !appState.croppingElementId && targetElements.length === 1 && isImageElement(targetElements[0]);
  const showAlignActions = !isSingleElementBoundContainer && alignActionsPredicate(appState, app);
  return /* @__PURE__ */ jsxs41("div", { className: "selected-shape-actions", children: [
    /* @__PURE__ */ jsx74("div", { children: canChangeStrokeColor(appState, targetElements) && renderAction("changeStrokeColor") }),
    canChangeBackgroundColor(appState, targetElements) && /* @__PURE__ */ jsx74("div", { children: renderAction("changeBackgroundColor") }),
    showFillIcons && renderAction("changeFillStyle"),
    (hasStrokeWidth(appState.activeTool.type) || targetElements.some((element) => hasStrokeWidth(element.type))) && renderAction("changeStrokeWidth"),
    (appState.activeTool.type === "freedraw" || targetElements.some((element) => element.type === "freedraw")) && renderAction("changeStrokeShape"),
    (hasStrokeStyle(appState.activeTool.type) || targetElements.some((element) => hasStrokeStyle(element.type))) && /* @__PURE__ */ jsxs41(Fragment10, { children: [
      renderAction("changeStrokeStyle"),
      renderAction("changeSloppiness")
    ] }),
    (canChangeRoundness(appState.activeTool.type) || targetElements.some((element) => canChangeRoundness(element.type))) && /* @__PURE__ */ jsx74(Fragment10, { children: renderAction("changeRoundness") }),
    (toolIsArrow(appState.activeTool.type) || targetElements.some((element) => toolIsArrow(element.type))) && /* @__PURE__ */ jsx74(Fragment10, { children: renderAction("changeArrowType") }),
    (appState.activeTool.type === "text" || targetElements.some(isTextElement6)) && /* @__PURE__ */ jsxs41(Fragment10, { children: [
      renderAction("changeFontFamily"),
      renderAction("changeFontSize"),
      (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign")
    ] }),
    shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign"),
    (canHaveArrowheads(appState.activeTool.type) || targetElements.some((element) => canHaveArrowheads(element.type))) && /* @__PURE__ */ jsx74(Fragment10, { children: renderAction("changeArrowhead") }),
    renderAction("changeOpacity"),
    /* @__PURE__ */ jsxs41("fieldset", { children: [
      /* @__PURE__ */ jsx74("legend", { children: t("labels.layers") }),
      /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
        renderAction("sendToBack"),
        renderAction("sendBackward"),
        renderAction("bringForward"),
        renderAction("bringToFront")
      ] })
    ] }),
    showAlignActions && !isSingleElementBoundContainer && /* @__PURE__ */ jsxs41("fieldset", { children: [
      /* @__PURE__ */ jsx74("legend", { children: t("labels.align") }),
      /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
        isRTL2 ? /* @__PURE__ */ jsxs41(Fragment10, { children: [
          renderAction("alignRight"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignLeft")
        ] }) : /* @__PURE__ */ jsxs41(Fragment10, { children: [
          renderAction("alignLeft"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignRight")
        ] }),
        targetElements.length > 2 && renderAction("distributeHorizontally"),
        /* @__PURE__ */ jsx74("div", { style: { flexBasis: "100%", height: 0 } }),
        /* @__PURE__ */ jsxs41(
          "div",
          {
            style: {
              display: "flex",
              flexWrap: "wrap",
              gap: ".5rem",
              marginTop: "-0.5rem"
            },
            children: [
              renderAction("alignTop"),
              renderAction("alignVerticallyCentered"),
              renderAction("alignBottom"),
              targetElements.length > 2 && renderAction("distributeVertically")
            ]
          }
        )
      ] })
    ] }),
    !isEditingTextOrNewElement && targetElements.length > 0 && /* @__PURE__ */ jsxs41("fieldset", { children: [
      /* @__PURE__ */ jsx74("legend", { children: t("labels.actions") }),
      /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
        editorInterface.formFactor !== "phone" && renderAction("duplicateSelection"),
        editorInterface.formFactor !== "phone" && renderAction("deleteSelectedElements"),
        renderAction("group"),
        renderAction("ungroup"),
        showLinkIcon && renderAction("hyperlink"),
        showCropEditorAction && renderAction("cropEditor"),
        showLineEditorAction && renderAction("toggleLinearEditor")
      ] })
    ] })
  ] });
};
var CombinedShapeProperties = ({
  appState,
  renderAction,
  setAppState,
  targetElements,
  container
}) => {
  const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent2(appState.currentItemBackgroundColor) || targetElements.some(
    (element) => hasBackground(element.type) && !isTransparent2(element.backgroundColor)
  );
  const shouldShowCombinedProperties = targetElements.length > 0 || appState.activeTool.type !== "selection" && appState.activeTool.type !== "eraser" && appState.activeTool.type !== "hand" && appState.activeTool.type !== "laser" && appState.activeTool.type !== "lasso";
  const isOpen = appState.openPopup === "compactStrokeStyles";
  if (!shouldShowCombinedProperties) {
    return null;
  }
  return /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: /* @__PURE__ */ jsxs41(
    Popover6.Root,
    {
      open: isOpen,
      onOpenChange: (open) => {
        if (open) {
          setAppState({ openPopup: "compactStrokeStyles" });
        } else {
          setAppState({ openPopup: null });
        }
      },
      children: [
        /* @__PURE__ */ jsx74(Popover6.Trigger, { asChild: true, children: /* @__PURE__ */ jsx74(
          "button",
          {
            type: "button",
            className: clsx34("compact-action-button properties-trigger", {
              active: isOpen
            }),
            title: t("labels.stroke"),
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              setAppState({
                openPopup: isOpen ? null : "compactStrokeStyles"
              });
            },
            children: adjustmentsIcon
          }
        ) }),
        isOpen && /* @__PURE__ */ jsx74(
          PropertiesPopover,
          {
            className: PROPERTIES_CLASSES,
            container,
            style: { maxWidth: "13rem" },
            onClose: () => {
            },
            children: /* @__PURE__ */ jsxs41("div", { className: "selected-shape-actions", children: [
              showFillIcons && renderAction("changeFillStyle"),
              (hasStrokeWidth(appState.activeTool.type) || targetElements.some(
                (element) => hasStrokeWidth(element.type)
              )) && renderAction("changeStrokeWidth"),
              (hasStrokeStyle(appState.activeTool.type) || targetElements.some(
                (element) => hasStrokeStyle(element.type)
              )) && /* @__PURE__ */ jsxs41(Fragment10, { children: [
                renderAction("changeStrokeStyle"),
                renderAction("changeSloppiness")
              ] }),
              (canChangeRoundness(appState.activeTool.type) || targetElements.some(
                (element) => canChangeRoundness(element.type)
              )) && renderAction("changeRoundness"),
              renderAction("changeOpacity")
            ] })
          }
        )
      ]
    }
  ) });
};
var CombinedArrowProperties = ({
  appState,
  renderAction,
  setAppState,
  targetElements,
  container,
  app
}) => {
  const showShowArrowProperties = toolIsArrow(appState.activeTool.type) || targetElements.some((element) => toolIsArrow(element.type));
  const isOpen = appState.openPopup === "compactArrowProperties";
  if (!showShowArrowProperties) {
    return null;
  }
  return /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: /* @__PURE__ */ jsxs41(
    Popover6.Root,
    {
      open: isOpen,
      onOpenChange: (open) => {
        if (open) {
          setAppState({ openPopup: "compactArrowProperties" });
        } else {
          setAppState({ openPopup: null });
        }
      },
      children: [
        /* @__PURE__ */ jsx74(Popover6.Trigger, { asChild: true, children: /* @__PURE__ */ jsx74(
          "button",
          {
            type: "button",
            className: clsx34("compact-action-button properties-trigger", {
              active: isOpen
            }),
            title: t("labels.arrowtypes"),
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              setAppState({
                openPopup: isOpen ? null : "compactArrowProperties"
              });
            },
            children: (() => {
              const arrowType = getFormValue(
                targetElements,
                app,
                (element) => {
                  if (isArrowElement6(element)) {
                    return element.elbowed ? "elbow" : element.roundness ? "round" : "sharp";
                  }
                  return null;
                },
                (element) => isArrowElement6(element),
                (hasSelection) => hasSelection ? null : appState.currentItemArrowType
              );
              if (arrowType === "elbow") {
                return elbowArrowIcon;
              }
              if (arrowType === "round") {
                return roundArrowIcon;
              }
              return sharpArrowIcon;
            })()
          }
        ) }),
        isOpen && /* @__PURE__ */ jsx74(
          PropertiesPopover,
          {
            container,
            className: "properties-content",
            style: { maxWidth: "13rem" },
            onClose: () => {
            },
            children: renderAction("changeArrowProperties")
          }
        )
      ]
    }
  ) });
};
var CombinedTextProperties = ({
  appState,
  renderAction,
  setAppState,
  targetElements,
  container,
  elementsMap
}) => {
  const { saveCaretPosition: saveCaretPosition2, restoreCaretPosition: restoreCaretPosition2 } = useTextEditorFocus();
  const isOpen = appState.openPopup === "compactTextProperties";
  return /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: /* @__PURE__ */ jsxs41(
    Popover6.Root,
    {
      open: isOpen,
      onOpenChange: (open) => {
        if (open) {
          if (appState.editingTextElement) {
            saveCaretPosition2();
          }
          setAppState({ openPopup: "compactTextProperties" });
        } else {
          setAppState({ openPopup: null });
          if (appState.editingTextElement) {
            restoreCaretPosition2();
          }
        }
      },
      children: [
        /* @__PURE__ */ jsx74(Popover6.Trigger, { asChild: true, children: /* @__PURE__ */ jsx74(
          "button",
          {
            type: "button",
            className: clsx34("compact-action-button properties-trigger", {
              active: isOpen
            }),
            title: t("labels.textAlign"),
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (isOpen) {
                setAppState({ openPopup: null });
              } else {
                if (appState.editingTextElement) {
                  saveCaretPosition2();
                }
                setAppState({ openPopup: "compactTextProperties" });
              }
            },
            children: TextSizeIcon
          }
        ) }),
        appState.openPopup === "compactTextProperties" && /* @__PURE__ */ jsx74(
          PropertiesPopover,
          {
            className: PROPERTIES_CLASSES,
            container,
            style: { maxWidth: "13rem" },
            preventAutoFocusOnTouch: !!appState.editingTextElement,
            onClose: () => {
              if (appState.editingTextElement) {
                restoreCaretPosition2();
              }
            },
            children: /* @__PURE__ */ jsxs41("div", { className: "selected-shape-actions", children: [
              (appState.activeTool.type === "text" || targetElements.some(isTextElement6)) && renderAction("changeFontSize"),
              (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign"),
              shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign")
            ] })
          }
        )
      ]
    }
  ) });
};
var CombinedExtraActions = ({
  appState,
  renderAction,
  targetElements,
  setAppState,
  container,
  app,
  showDuplicate,
  showDelete
}) => {
  const isEditingTextOrNewElement = Boolean(
    appState.editingTextElement || appState.newElement
  );
  const showCropEditorAction = !appState.croppingElementId && targetElements.length === 1 && isImageElement(targetElements[0]);
  const showLinkIcon = targetElements.length === 1;
  const showAlignActions = alignActionsPredicate(appState, app);
  let isSingleElementBoundContainer = false;
  if (targetElements.length === 2 && (hasBoundTextElement4(targetElements[0]) || hasBoundTextElement4(targetElements[1]))) {
    isSingleElementBoundContainer = true;
  }
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const isOpen = appState.openPopup === "compactOtherProperties";
  if (isEditingTextOrNewElement || targetElements.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: /* @__PURE__ */ jsxs41(
    Popover6.Root,
    {
      open: isOpen,
      onOpenChange: (open) => {
        if (open) {
          setAppState({ openPopup: "compactOtherProperties" });
        } else {
          setAppState({ openPopup: null });
        }
      },
      children: [
        /* @__PURE__ */ jsx74(Popover6.Trigger, { asChild: true, children: /* @__PURE__ */ jsx74(
          "button",
          {
            type: "button",
            className: clsx34("compact-action-button properties-trigger", {
              active: isOpen
            }),
            title: t("labels.actions"),
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              setAppState({
                openPopup: isOpen ? null : "compactOtherProperties"
              });
            },
            children: DotsHorizontalIcon
          }
        ) }),
        isOpen && /* @__PURE__ */ jsx74(
          PropertiesPopover,
          {
            className: PROPERTIES_CLASSES,
            container,
            style: {
              maxWidth: "12rem",
              justifyContent: "center",
              alignItems: "center"
            },
            onClose: () => {
            },
            children: /* @__PURE__ */ jsxs41("div", { className: "selected-shape-actions", children: [
              /* @__PURE__ */ jsxs41("fieldset", { children: [
                /* @__PURE__ */ jsx74("legend", { children: t("labels.layers") }),
                /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
                  renderAction("sendToBack"),
                  renderAction("sendBackward"),
                  renderAction("bringForward"),
                  renderAction("bringToFront")
                ] })
              ] }),
              showAlignActions && !isSingleElementBoundContainer && /* @__PURE__ */ jsxs41("fieldset", { children: [
                /* @__PURE__ */ jsx74("legend", { children: t("labels.align") }),
                /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
                  isRTL2 ? /* @__PURE__ */ jsxs41(Fragment10, { children: [
                    renderAction("alignRight"),
                    renderAction("alignHorizontallyCentered"),
                    renderAction("alignLeft")
                  ] }) : /* @__PURE__ */ jsxs41(Fragment10, { children: [
                    renderAction("alignLeft"),
                    renderAction("alignHorizontallyCentered"),
                    renderAction("alignRight")
                  ] }),
                  targetElements.length > 2 && renderAction("distributeHorizontally"),
                  /* @__PURE__ */ jsx74("div", { style: { flexBasis: "100%", height: 0 } }),
                  /* @__PURE__ */ jsxs41(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexWrap: "wrap",
                        gap: ".5rem",
                        marginTop: "-0.5rem"
                      },
                      children: [
                        renderAction("alignTop"),
                        renderAction("alignVerticallyCentered"),
                        renderAction("alignBottom"),
                        targetElements.length > 2 && renderAction("distributeVertically")
                      ]
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxs41("fieldset", { children: [
                /* @__PURE__ */ jsx74("legend", { children: t("labels.actions") }),
                /* @__PURE__ */ jsxs41("div", { className: "buttonList", children: [
                  renderAction("group"),
                  renderAction("ungroup"),
                  showLinkIcon && renderAction("hyperlink"),
                  showCropEditorAction && renderAction("cropEditor"),
                  showDuplicate && renderAction("duplicateSelection"),
                  showDelete && renderAction("deleteSelectedElements")
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  ) });
};
var LinearEditorAction = ({
  appState,
  renderAction,
  targetElements
}) => {
  const showLineEditorAction = !appState.selectedLinearElement?.isEditing && targetElements.length === 1 && isLinearElement5(targetElements[0]) && !isElbowArrow5(targetElements[0]);
  if (!showLineEditorAction) {
    return null;
  }
  return /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("toggleLinearEditor") });
};
var CompactShapeActions = ({
  appState,
  elementsMap,
  renderAction,
  app,
  setAppState
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  const { container } = useExcalidrawContainer();
  const targetElementsForShapeActions = targetElements.length === 1 && isTextElement6(targetElements[0]) && targetElements[0].containerId ? (() => {
    const parent = getContainerElement3(targetElements[0], elementsMap);
    return parent ? [parent, ...targetElements] : targetElements;
  })() : targetElements;
  const isEditingTextOrNewElement = Boolean(
    appState.editingTextElement || appState.newElement
  );
  const showLineEditorAction = !appState.selectedLinearElement?.isEditing && targetElements.length === 1 && isLinearElement5(targetElements[0]) && !isElbowArrow5(targetElements[0]);
  return /* @__PURE__ */ jsxs41("div", { className: "compact-shape-actions", children: [
    canChangeStrokeColor(appState, targetElementsForShapeActions) && /* @__PURE__ */ jsx74("div", { className: clsx34("compact-action-item"), children: renderAction("changeStrokeColor") }),
    canChangeBackgroundColor(appState, targetElementsForShapeActions) && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("changeBackgroundColor") }),
    /* @__PURE__ */ jsx74(
      CombinedShapeProperties,
      {
        appState,
        renderAction,
        setAppState,
        targetElements: targetElementsForShapeActions,
        container
      }
    ),
    /* @__PURE__ */ jsx74(
      CombinedArrowProperties,
      {
        appState,
        renderAction,
        setAppState,
        targetElements: targetElementsForShapeActions,
        container,
        app
      }
    ),
    showLineEditorAction && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("toggleLinearEditor") }),
    (appState.activeTool.type === "text" || targetElements.some(isTextElement6)) && /* @__PURE__ */ jsxs41(Fragment10, { children: [
      /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("changeFontFamily") }),
      /* @__PURE__ */ jsx74(
        CombinedTextProperties,
        {
          appState,
          renderAction,
          setAppState,
          targetElements,
          container,
          elementsMap
        }
      )
    ] }),
    !isEditingTextOrNewElement && targetElements.length > 0 && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("duplicateSelection") }),
    !isEditingTextOrNewElement && targetElements.length > 0 && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("deleteSelectedElements") }),
    /* @__PURE__ */ jsx74(
      CombinedExtraActions,
      {
        appState,
        renderAction,
        targetElements,
        setAppState,
        container,
        app
      }
    )
  ] });
};
var MobileShapeActions = ({
  appState,
  elementsMap,
  renderAction,
  app,
  setAppState
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  const { container } = useExcalidrawContainer();
  const targetElementsForShapeActions = targetElements.length === 1 && isTextElement6(targetElements[0]) && targetElements[0].containerId ? (() => {
    const parent = getContainerElement3(targetElements[0], elementsMap);
    return parent ? [parent, ...targetElements] : targetElements;
  })() : targetElements;
  const mobileActionsRef = useRef21(null);
  const ACTIONS_WIDTH = mobileActionsRef.current?.getBoundingClientRect()?.width ?? 0;
  const MIN_ACTIONS = 9;
  const GAP = 6;
  const WIDTH = 32;
  const MIN_WIDTH = MIN_ACTIONS * WIDTH + (MIN_ACTIONS - 1) * GAP;
  const ADDITIONAL_WIDTH = WIDTH + GAP;
  const showDeleteOutside = ACTIONS_WIDTH >= MIN_WIDTH + ADDITIONAL_WIDTH;
  const showDuplicateOutside = ACTIONS_WIDTH >= MIN_WIDTH + 2 * ADDITIONAL_WIDTH;
  return /* @__PURE__ */ jsxs41(
    Island,
    {
      className: "compact-shape-actions mobile-shape-actions",
      style: {
        flexDirection: "row",
        boxShadow: "none",
        padding: 0,
        zIndex: 2,
        backgroundColor: "transparent",
        height: WIDTH * 1.35,
        marginBottom: 4,
        alignItems: "center",
        gap: GAP,
        pointerEvents: "none"
      },
      ref: mobileActionsRef,
      children: [
        /* @__PURE__ */ jsxs41(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              gap: GAP,
              flex: 1
            },
            children: [
              canChangeStrokeColor(appState, targetElementsForShapeActions) && /* @__PURE__ */ jsx74("div", { className: clsx34("compact-action-item"), children: renderAction("changeStrokeColor") }),
              canChangeBackgroundColor(appState, targetElementsForShapeActions) && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("changeBackgroundColor") }),
              /* @__PURE__ */ jsx74(
                CombinedShapeProperties,
                {
                  appState,
                  renderAction,
                  setAppState,
                  targetElements: targetElementsForShapeActions,
                  container
                }
              ),
              /* @__PURE__ */ jsx74(
                CombinedArrowProperties,
                {
                  appState,
                  renderAction,
                  setAppState,
                  targetElements: targetElementsForShapeActions,
                  container,
                  app
                }
              ),
              /* @__PURE__ */ jsx74(
                LinearEditorAction,
                {
                  appState,
                  renderAction,
                  targetElements
                }
              ),
              (appState.activeTool.type === "text" || targetElements.some(isTextElement6)) && /* @__PURE__ */ jsxs41(Fragment10, { children: [
                /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("changeFontFamily") }),
                /* @__PURE__ */ jsx74(
                  CombinedTextProperties,
                  {
                    appState,
                    renderAction,
                    setAppState,
                    targetElements,
                    container,
                    elementsMap
                  }
                )
              ] }),
              /* @__PURE__ */ jsx74(
                CombinedExtraActions,
                {
                  appState,
                  renderAction,
                  targetElements,
                  setAppState,
                  container,
                  app,
                  showDuplicate: !showDuplicateOutside,
                  showDelete: !showDeleteOutside
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxs41(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              gap: GAP
            },
            children: [
              /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("undo") }),
              /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("redo") }),
              showDuplicateOutside && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("duplicateSelection") }),
              showDeleteOutside && /* @__PURE__ */ jsx74("div", { className: "compact-action-item", children: renderAction("deleteSelectedElements") })
            ]
          }
        )
      ]
    }
  );
};
var ShapesSwitcher = ({
  activeTool,
  setAppState,
  app,
  UIOptions
}) => {
  const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = useState23(false);
  const stylesPanelMode = useStylesPanelMode();
  const isFullStylesPanel = stylesPanelMode === "full";
  const isCompactStylesPanel = stylesPanelMode === "compact";
  const laserToolSelected = activeTool.type === "laser";
  const lassoToolSelected = isFullStylesPanel && activeTool.type === "lasso" && app.state.preferredSelectionTool.type !== "lasso";
  const embeddableToolSelected = activeTool.type === "embeddable";
  const { TTDDialogTriggerTunnel } = useTunnels();
  return /* @__PURE__ */ jsx74(Fragment10, { children: getToolbarTools(app).map(
    ({ value, icon, key, numericKey, fillable }, index) => {
      if (UIOptions.tools?.[value] === false) {
        return null;
      }
      const label = t(`toolBar.${value}`);
      const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
      const shortcut = letter ? `${letter} ${t("helpDialog.or")} ${numericKey}` : `${numericKey}`;
      const frameButton = /* @__PURE__ */ jsx74(
        ToolButton,
        {
          className: clsx34("Shape", { fillable }),
          type: "radio",
          icon,
          checked: activeTool.type === value,
          name: "editor-current-shape",
          title: `${capitalizeString(label)} \u2014 ${shortcut}`,
          keyBindingLabel: numericKey || letter,
          "aria-label": capitalizeString(label),
          "aria-keyshortcuts": shortcut,
          "data-testid": `toolbar-${value}`,
          onPointerDown: ({ pointerType }) => {
            if (!app.state.penDetected && pointerType === "pen") {
              app.togglePenMode(true);
            }
          },
          onChange: ({ pointerType }) => {
            if (app.state.activeTool.type !== value) {
              trackEvent("toolbar", value, "ui");
            }
            app.setActiveTool({ type: value });
          }
        },
        value
      );
      if (value === "frame") {
        return [
          /* @__PURE__ */ jsx74(
            "div",
            {
              className: "App-toolbar__divider"
            },
            "divider-before-frame"
          ),
          frameButton
        ];
      }
      return frameButton;
    }
  ) });
};
var ZoomActions = ({
  renderAction,
  zoom
}) => /* @__PURE__ */ jsx74(Stack_default.Col, { gap: 1, className: CLASSES5.ZOOM_ACTIONS, children: /* @__PURE__ */ jsxs41(Stack_default.Row, { align: "center", children: [
  renderAction("zoomOut"),
  renderAction("zoomIn")
] }) });
var ExitZenModeButton = ({
  actionManager,
  showExitZenModeBtn
}) => /* @__PURE__ */ jsx74(
  "button",
  {
    type: "button",
    className: clsx34("disable-zen-mode", {
      "disable-zen-mode--visible": showExitZenModeBtn
    }),
    onClick: () => actionManager.executeAction(actionToggleZenMode),
    children: t("buttons.exitZenMode")
  }
);
var ExitViewModeButton = ({
  actionManager
}) => /* @__PURE__ */ jsx74(
  "button",
  {
    type: "button",
    className: "disable-view-mode",
    onClick: () => actionManager.executeAction(actionToggleViewMode),
    children: pencilIcon
  }
);

// hooks/useStableCallback.ts
import { useRef as useRef22 } from "react";
var useStableCallback = (userFn) => {
  const stableRef = useRef22({ userFn });
  stableRef.current.userFn = userFn;
  if (!stableRef.current.stableFn) {
    stableRef.current.stableFn = (...args) => stableRef.current.userFn(...args);
  }
  return stableRef.current.stableFn;
};

// components/ActiveConfirmDialog.tsx
import { jsx as jsx75, jsxs as jsxs42 } from "react/jsx-runtime";
var activeConfirmDialogAtom = atom(null);
var ActiveConfirmDialog = () => {
  const [activeConfirmDialog, setActiveConfirmDialog] = useAtom(
    activeConfirmDialogAtom
  );
  const actionManager = useExcalidrawActionManager();
  if (!activeConfirmDialog) {
    return null;
  }
  if (activeConfirmDialog === "clearCanvas") {
    return /* @__PURE__ */ jsx75(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          actionManager.executeAction(actionClearCanvas);
          setActiveConfirmDialog(null);
        },
        onCancel: () => setActiveConfirmDialog(null),
        title: t("clearCanvasDialog.title"),
        children: /* @__PURE__ */ jsxs42("p", { className: "clear-canvas__content", children: [
          " ",
          t("alerts.clearReset")
        ] })
      }
    );
  }
  return null;
};

// components/CommandPalette/defaultCommandPaletteItems.ts
var defaultCommandPaletteItems_exports = {};
__export(defaultCommandPaletteItems_exports, {
  toggleTheme: () => toggleTheme
});
var toggleTheme = {
  ...actionToggleTheme,
  category: "App",
  label: "Toggle theme",
  perform: ({ actionManager }) => {
    actionManager.executeAction(actionToggleTheme, "commandPalette");
  }
};

// components/CommandPalette/CommandPalette.tsx
import { jsx as jsx76, jsxs as jsxs43 } from "react/jsx-runtime";
var lastUsedPaletteItem = atom(null);
var DEFAULT_CATEGORIES = {
  app: "App",
  export: "Export",
  tools: "Tools",
  editor: "Editor",
  elements: "Elements",
  links: "Links",
  library: "Library"
};
var getCategoryOrder = (category) => {
  switch (category) {
    case DEFAULT_CATEGORIES.app:
      return 1;
    case DEFAULT_CATEGORIES.export:
      return 2;
    case DEFAULT_CATEGORIES.editor:
      return 3;
    case DEFAULT_CATEGORIES.tools:
      return 4;
    case DEFAULT_CATEGORIES.elements:
      return 5;
    case DEFAULT_CATEGORIES.links:
      return 6;
    default:
      return 10;
  }
};
var CommandShortcutHint = ({
  shortcut,
  className,
  children
}) => {
  const shortcuts = shortcut.replace("++", "+$").split("+");
  return /* @__PURE__ */ jsxs43("div", { className: clsx35("shortcut", className), children: [
    shortcuts.map((item, idx) => {
      return /* @__PURE__ */ jsx76("div", { className: "shortcut-wrapper", children: /* @__PURE__ */ jsx76("div", { className: "shortcut-key", children: item === "$" ? "+" : item }) }, item);
    }),
    /* @__PURE__ */ jsx76("div", { className: "shortcut-desc", children })
  ] });
};
var isCommandPaletteToggleShortcut = (event) => {
  return !event.altKey && event[KEYS37.CTRL_OR_CMD] && (event.shiftKey && event.key.toLowerCase() === KEYS37.P || event.key === KEYS37.SLASH);
};
var CommandPalette = Object.assign(
  (props) => {
    const uiAppState = useUIAppState();
    const setAppState = useExcalidrawSetAppState();
    useEffect26(() => {
      const commandPaletteShortcut = (event) => {
        if (isCommandPaletteToggleShortcut(event)) {
          event.preventDefault();
          event.stopPropagation();
          setAppState((appState) => {
            const nextState = appState.openDialog?.name === "commandPalette" ? null : { name: "commandPalette" };
            if (nextState) {
              trackEvent("command_palette", "open", "shortcut");
            }
            return {
              openDialog: nextState
            };
          });
        }
      };
      window.addEventListener(EVENT9.KEYDOWN, commandPaletteShortcut, {
        capture: true
      });
      return () => window.removeEventListener(EVENT9.KEYDOWN, commandPaletteShortcut, {
        capture: true
      });
    }, [setAppState]);
    if (uiAppState.openDialog?.name !== "commandPalette") {
      return null;
    }
    return /* @__PURE__ */ jsx76(CommandPaletteInner, { ...props });
  },
  {
    defaultItems: defaultCommandPaletteItems_exports
  }
);
function CommandPaletteInner({
  customCommandPaletteItems
}) {
  const app = useApp();
  const uiAppState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const appProps = useAppProps();
  const actionManager = useExcalidrawActionManager();
  const [lastUsed, setLastUsed] = useAtom(lastUsedPaletteItem);
  const [allCommands, setAllCommands] = useState24(null);
  const inputRef = useRef23(null);
  const stableDeps = useStable({
    uiAppState,
    customCommandPaletteItems,
    appProps
  });
  const [libraryItemsData] = useAtom(libraryItemsAtom);
  const libraryCommands = useMemo7(() => {
    return libraryItemsData.libraryItems?.filter(
      (libraryItem) => !!libraryItem.name
    ).map((libraryItem) => ({
      label: libraryItem.name,
      icon: /* @__PURE__ */ jsx76(
        LibraryItemIcon,
        {
          id: libraryItem.id,
          elements: libraryItem.elements
        }
      ),
      category: "Library",
      order: getCategoryOrder("Library"),
      haystack: deburr(libraryItem.name),
      perform: () => {
        app.onInsertElements(
          distributeLibraryItemsOnSquareGrid([libraryItem])
        );
      }
    })) || [];
  }, [app, libraryItemsData.libraryItems]);
  useEffect26(() => {
    const { uiAppState: uiAppState2, customCommandPaletteItems: customCommandPaletteItems2, appProps: appProps2 } = stableDeps;
    const getActionLabel = (action) => {
      let label = "";
      if (action.label) {
        if (typeof action.label === "function") {
          label = t(
            action.label(
              app.scene.getNonDeletedElements(),
              uiAppState2,
              app
            )
          );
        } else {
          label = t(action.label);
        }
      }
      return label;
    };
    const getActionIcon = (action) => {
      if (typeof action.icon === "function") {
        return action.icon(uiAppState2, app.scene.getNonDeletedElements());
      }
      return action.icon;
    };
    let commandsFromActions = [];
    const actionToCommand = (action, category, transformer) => {
      const command = {
        label: getActionLabel(action),
        icon: getActionIcon(action),
        category,
        shortcut: getShortcutFromShortcutName(action.name),
        keywords: action.keywords,
        predicate: action.predicate,
        viewMode: action.viewMode,
        perform: () => {
          actionManager.executeAction(action, "commandPalette");
        }
      };
      return transformer ? transformer(command, action) : command;
    };
    if (uiAppState2 && app.scene && actionManager) {
      const elementsCommands = [
        actionManager.actions.group,
        actionManager.actions.ungroup,
        actionManager.actions.cut,
        actionManager.actions.copy,
        actionManager.actions.deleteSelectedElements,
        actionManager.actions.wrapSelectionInFrame,
        actionManager.actions.copyStyles,
        actionManager.actions.pasteStyles,
        actionManager.actions.bringToFront,
        actionManager.actions.bringForward,
        actionManager.actions.sendBackward,
        actionManager.actions.sendToBack,
        actionManager.actions.alignTop,
        actionManager.actions.alignBottom,
        actionManager.actions.alignLeft,
        actionManager.actions.alignRight,
        actionManager.actions.alignVerticallyCentered,
        actionManager.actions.alignHorizontallyCentered,
        actionManager.actions.duplicateSelection,
        actionManager.actions.flipHorizontal,
        actionManager.actions.flipVertical,
        actionManager.actions.zoomToFitSelection,
        actionManager.actions.zoomToFitSelectionInViewport,
        actionManager.actions.increaseFontSize,
        actionManager.actions.decreaseFontSize,
        actionManager.actions.toggleLinearEditor,
        actionManager.actions.cropEditor,
        actionManager.actions.togglePolygon,
        actionLink,
        actionCopyElementLink,
        actionLinkToElement
      ].map(
        (action) => actionToCommand(
          action,
          DEFAULT_CATEGORIES.elements,
          (command, action2) => ({
            ...command,
            predicate: action2.predicate ? action2.predicate : (elements, appState, appProps3, app2) => {
              const selectedElements = getSelectedElements(
                elements,
                appState
              );
              return selectedElements.length > 0;
            }
          })
        )
      );
      const toolCommands = [
        actionManager.actions.toggleHandTool,
        actionManager.actions.setFrameAsActiveTool,
        actionManager.actions.toggleLassoTool
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.tools));
      const editorCommands = [
        actionManager.actions.undo,
        actionManager.actions.redo,
        actionManager.actions.zoomIn,
        actionManager.actions.zoomOut,
        actionManager.actions.resetZoom,
        actionManager.actions.zoomToFit,
        actionManager.actions.zenMode,
        actionManager.actions.viewMode,
        actionManager.actions.gridMode,
        actionManager.actions.objectsSnapMode,
        actionManager.actions.toggleShortcuts,
        actionManager.actions.selectAll,
        actionManager.actions.toggleElementLock,
        actionManager.actions.unlockAllElements,
        actionManager.actions.stats
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.editor));
      const exportCommands = [
        actionManager.actions.saveToActiveFile,
        actionManager.actions.saveFileToDisk,
        actionManager.actions.copyAsPng,
        actionManager.actions.copyAsSvg
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.export));
      commandsFromActions = [
        ...elementsCommands,
        ...editorCommands,
        {
          label: getActionLabel(actionClearCanvas),
          icon: getActionIcon(actionClearCanvas),
          shortcut: getShortcutFromShortcutName(
            actionClearCanvas.name
          ),
          category: DEFAULT_CATEGORIES.editor,
          keywords: ["delete", "destroy"],
          viewMode: false,
          perform: () => {
            editorJotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
          }
        },
        {
          label: t("buttons.exportImage"),
          category: DEFAULT_CATEGORIES.export,
          icon: ExportImageIcon,
          shortcut: getShortcutFromShortcutName("imageExport"),
          keywords: [
            "export",
            "image",
            "png",
            "jpeg",
            "svg",
            "clipboard",
            "picture"
          ],
          perform: () => {
            setAppState({ openDialog: { name: "imageExport" } });
          }
        },
        ...exportCommands
      ];
      const additionalCommands = [
        {
          label: t("toolBar.library"),
          category: DEFAULT_CATEGORIES.app,
          icon: LibraryIcon,
          viewMode: false,
          perform: () => {
            if (uiAppState2.openSidebar) {
              setAppState({
                openSidebar: null
              });
            } else {
              setAppState({
                openSidebar: {
                  name: DEFAULT_SIDEBAR2.name,
                  tab: DEFAULT_SIDEBAR2.defaultTab
                }
              });
            }
          }
        },
        {
          label: t("search.title"),
          category: DEFAULT_CATEGORIES.app,
          icon: searchIcon,
          viewMode: true,
          perform: () => {
            actionManager.executeAction(actionToggleSearchMenu);
          }
        },
        {
          label: t("labels.shapeSwitch"),
          category: DEFAULT_CATEGORIES.elements,
          icon: boltIcon,
          perform: () => {
            actionManager.executeAction(actionToggleShapeSwitch);
          }
        },
        {
          label: t("labels.changeStroke"),
          keywords: ["color", "outline"],
          category: DEFAULT_CATEGORIES.elements,
          icon: bucketFillIcon,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeStrokeColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openPopup: "elementStroke"
            }));
          }
        },
        {
          label: t("labels.changeBackground"),
          keywords: ["color", "fill"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.elements,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeBackgroundColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openPopup: "elementBackground"
            }));
          }
        },
        {
          label: t("labels.canvasBackground"),
          keywords: ["color"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.editor,
          viewMode: false,
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "canvas" ? null : "canvas",
              openPopup: "canvasBackground"
            }));
          }
        },
        ...appProps2.UIOptions.tools?.selection !== false ? [
          {
            label: t("toolBar.selection"),
            category: DEFAULT_CATEGORIES.tools,
            shortcut: KEYS37.V,
            icon: SelectionIcon,
            keywords: ["toolbar", "select"],
            viewMode: false,
            perform: () => {
              app.setActiveTool({ type: "selection" });
              setAppState({
                preferredSelectionTool: {
                  type: "selection",
                  initialized: true
                }
              });
            }
          },
          {
            label: t("toolBar.lasso"),
            category: DEFAULT_CATEGORIES.tools,
            shortcut: void 0,
            icon: LassoIcon,
            keywords: ["toolbar", "select"],
            viewMode: false,
            perform: () => {
              app.setActiveTool({ type: "lasso" });
              setAppState({
                preferredSelectionTool: {
                  type: "lasso",
                  initialized: true
                }
              });
            }
          }
        ] : [],
        ...SHAPES.reduce((acc, shape) => {
          const { value, icon, key, numericKey } = shape;
          if (appProps2.UIOptions.tools?.[value] === false) {
            return acc;
          }
          const letter = key && capitalizeString2(typeof key === "string" ? key : key[0]);
          const shortcut = letter || numericKey;
          const command = {
            label: t(`toolBar.${value}`),
            category: DEFAULT_CATEGORIES.tools,
            shortcut,
            icon,
            keywords: ["toolbar"],
            viewMode: false,
            perform: ({ event }) => {
              app.setActiveTool({ type: value });
            }
          };
          acc.push(command);
          return acc;
        }, []),
        ...toolCommands,
        {
          label: t("toolBar.lock"),
          category: DEFAULT_CATEGORIES.tools,
          icon: uiAppState2.activeTool.locked ? LockedIcon : UnlockedIcon,
          shortcut: KEYS37.Q.toLocaleUpperCase(),
          viewMode: false,
          perform: () => {
            app.toggleLock();
          }
        },
        {
          label: `${t("labels.textToDiagram")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: brainIconThin,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "text-to-diagram"
              }
            }));
          }
        },
        {
          label: `${t("toolBar.mermaidToExcalidraw")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: mermaidLogoIcon,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "mermaid"
              }
            }));
          }
        }
        // {
        //   label: `${t("toolBar.magicframe")}...`,
        //   category: DEFAULT_CATEGORIES.tools,
        //   icon: MagicIconThin,
        //   viewMode: false,
        //   predicate: appProps.aiEnabled,
        //   perform: () => {
        //     app.onMagicframeToolSelect();
        //   },
        // },
      ];
      const allCommands2 = [
        ...commandsFromActions,
        ...additionalCommands,
        ...customCommandPaletteItems2 || []
      ].map((command) => {
        return {
          ...command,
          icon: command.icon || boltIcon,
          order: command.order ?? getCategoryOrder(command.category),
          haystack: `${deburr(command.label.toLocaleLowerCase())} ${command.keywords?.join(" ") || ""}`
        };
      });
      setAllCommands(allCommands2);
      setLastUsed(
        [...allCommands2, ...libraryCommands].find(
          (command) => command.label === lastUsed?.label
        ) ?? null
      );
    }
  }, [
    stableDeps,
    app,
    actionManager,
    setAllCommands,
    lastUsed?.label,
    setLastUsed,
    setAppState,
    libraryCommands
  ]);
  const [commandSearch, setCommandSearch] = useState24("");
  const [currentCommand, setCurrentCommand] = useState24(null);
  const [commandsByCategory, setCommandsByCategory] = useState24({});
  const closeCommandPalette = (cb) => {
    setAppState(
      {
        openDialog: null
      },
      cb
    );
    setCommandSearch("");
  };
  const executeCommand = (command, event) => {
    if (uiAppState.openDialog?.name === "commandPalette") {
      event.stopPropagation();
      event.preventDefault();
      document.body.classList.add("excalidraw-animations-disabled");
      closeCommandPalette(() => {
        command.perform({ actionManager, event });
        setLastUsed(command);
        requestAnimationFrame(() => {
          document.body.classList.remove("excalidraw-animations-disabled");
        });
      });
    }
  };
  const isCommandAvailable = useStableCallback(
    (command) => {
      if (command.viewMode === false && uiAppState.viewModeEnabled) {
        return false;
      }
      return typeof command.predicate === "function" ? command.predicate(
        app.scene.getNonDeletedElements(),
        uiAppState,
        appProps,
        app
      ) : command.predicate === void 0 || command.predicate;
    }
  );
  const handleKeyDown = useStableCallback((event) => {
    const ignoreAlphanumerics = isWritableElement3(event.target) || isCommandPaletteToggleShortcut(event) || event.key === KEYS37.ESCAPE;
    if (ignoreAlphanumerics && event.key !== KEYS37.ARROW_UP && event.key !== KEYS37.ARROW_DOWN && event.key !== KEYS37.ENTER) {
      return;
    }
    const matchingCommands = Object.values(commandsByCategory).flat();
    const shouldConsiderLastUsed = lastUsed && !commandSearch && isCommandAvailable(lastUsed);
    if (event.key === KEYS37.ARROW_UP) {
      event.preventDefault();
      const index = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (index === 0) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[matchingCommands.length - 1];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      let nextIndex;
      if (index === -1) {
        nextIndex = matchingCommands.length - 1;
      } else {
        nextIndex = index === 0 ? matchingCommands.length - 1 : (index - 1) % matchingCommands.length;
      }
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS37.ARROW_DOWN) {
      event.preventDefault();
      const index = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (!currentCommand || index === matchingCommands.length - 1) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[0];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      const nextIndex = (index + 1) % matchingCommands.length;
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS37.ENTER) {
      if (currentCommand) {
        setTimeout(() => {
          executeCommand(currentCommand, event);
        });
      }
    }
    if (ignoreAlphanumerics) {
      return;
    }
    event.stopPropagation();
    if (/^[a-zA-Z0-9]$/.test(event.key)) {
      inputRef?.current?.focus();
      return;
    }
    event.preventDefault();
  });
  useEffect26(() => {
    window.addEventListener(EVENT9.KEYDOWN, handleKeyDown, {
      capture: true
    });
    return () => window.removeEventListener(EVENT9.KEYDOWN, handleKeyDown, {
      capture: true
    });
  }, [handleKeyDown]);
  useEffect26(() => {
    if (!allCommands) {
      return;
    }
    const getNextCommandsByCategory = (commands) => {
      const nextCommandsByCategory = {};
      for (const command of commands) {
        if (nextCommandsByCategory[command.category]) {
          nextCommandsByCategory[command.category].push(command);
        } else {
          nextCommandsByCategory[command.category] = [command];
        }
      }
      return nextCommandsByCategory;
    };
    let matchingCommands = commandSearch?.length > 1 ? [
      ...allCommands.filter(isCommandAvailable).sort((a, b) => a.order - b.order),
      ...libraryCommands
    ] : allCommands.filter(isCommandAvailable).sort((a, b) => a.order - b.order);
    const showLastUsed = !commandSearch && lastUsed && isCommandAvailable(lastUsed);
    if (!commandSearch) {
      setCommandsByCategory(
        getNextCommandsByCategory(
          showLastUsed ? matchingCommands.filter(
            (command) => command.label !== lastUsed?.label
          ) : matchingCommands
        )
      );
      setCurrentCommand(showLastUsed ? lastUsed : matchingCommands[0] || null);
      return;
    }
    const _query = deburr(
      commandSearch.toLocaleLowerCase().replace(/[<>_| -]/g, "")
    );
    matchingCommands = fuzzy.filter(_query, matchingCommands, {
      extract: (command) => command.haystack ?? ""
    }).sort((a, b) => b.score - a.score).map((item) => item.original);
    setCommandsByCategory(getNextCommandsByCategory(matchingCommands));
    setCurrentCommand(matchingCommands[0] ?? null);
  }, [
    commandSearch,
    allCommands,
    isCommandAvailable,
    lastUsed,
    libraryCommands
  ]);
  return /* @__PURE__ */ jsxs43(
    Dialog,
    {
      onCloseRequest: () => closeCommandPalette(),
      closeOnClickOutside: true,
      title: false,
      size: 720,
      autofocus: true,
      className: "command-palette-dialog",
      children: [
        /* @__PURE__ */ jsx76(
          TextField,
          {
            value: commandSearch,
            placeholder: t("commandPalette.search.placeholder"),
            onChange: (value) => {
              setCommandSearch(value);
            },
            selectOnRender: true,
            ref: inputRef
          }
        ),
        app.editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsxs43("div", { className: "shortcuts-wrapper", children: [
          /* @__PURE__ */ jsx76(CommandShortcutHint, { shortcut: "\u2191\u2193", children: t("commandPalette.shortcuts.select") }),
          /* @__PURE__ */ jsx76(CommandShortcutHint, { shortcut: "\u21B5", children: t("commandPalette.shortcuts.confirm") }),
          /* @__PURE__ */ jsx76(CommandShortcutHint, { shortcut: getShortcutKey("Esc"), children: t("commandPalette.shortcuts.close") })
        ] }),
        /* @__PURE__ */ jsxs43("div", { className: "commands", children: [
          lastUsed && !commandSearch && /* @__PURE__ */ jsxs43("div", { className: "command-category", children: [
            /* @__PURE__ */ jsxs43("div", { className: "command-category-title", children: [
              t("commandPalette.recents"),
              /* @__PURE__ */ jsx76(
                "div",
                {
                  className: "icon",
                  style: {
                    marginLeft: "6px"
                  },
                  children: historyCommandIcon
                }
              )
            ] }),
            /* @__PURE__ */ jsx76(
              CommandItem,
              {
                command: lastUsed,
                isSelected: lastUsed.label === currentCommand?.label,
                onClick: (event) => executeCommand(lastUsed, event),
                disabled: !isCommandAvailable(lastUsed),
                onMouseMove: () => setCurrentCommand(lastUsed),
                showShortcut: app.editorInterface.formFactor !== "phone",
                appState: uiAppState
              }
            )
          ] }),
          Object.keys(commandsByCategory).length > 0 ? Object.keys(commandsByCategory).map((category, idx) => {
            return /* @__PURE__ */ jsxs43("div", { className: "command-category", children: [
              /* @__PURE__ */ jsx76("div", { className: "command-category-title", children: category }),
              commandsByCategory[category].map((command) => /* @__PURE__ */ jsx76(
                CommandItem,
                {
                  command,
                  isSelected: command.label === currentCommand?.label,
                  onClick: (event) => executeCommand(command, event),
                  onMouseMove: () => setCurrentCommand(command),
                  showShortcut: app.editorInterface.formFactor !== "phone",
                  appState: uiAppState,
                  size: category === "Library" ? "large" : "small"
                },
                command.label
              ))
            ] }, category);
          }) : allCommands ? /* @__PURE__ */ jsxs43("div", { className: "no-match", children: [
            /* @__PURE__ */ jsx76("div", { className: "icon", children: searchIcon }),
            " ",
            t("commandPalette.search.noMatch")
          ] }) : null
        ] })
      ]
    }
  );
}
var LibraryItemIcon = ({
  id,
  elements
}) => {
  const ref = useRef23(null);
  const { svgCache } = useLibraryCache();
  useLibraryItemSvg(id, elements, svgCache, ref);
  return /* @__PURE__ */ jsx76("div", { className: "library-item-icon", ref });
};
var CommandItem = ({
  command,
  isSelected,
  disabled,
  onMouseMove,
  onClick,
  showShortcut,
  appState,
  size = "small"
}) => {
  const noop = () => {
  };
  return /* @__PURE__ */ jsxs43(
    "div",
    {
      className: clsx35("command-item", {
        "item-selected": isSelected,
        "item-disabled": disabled,
        "command-item-large": size === "large"
      }),
      ref: (ref) => {
        if (isSelected && !disabled) {
          ref?.scrollIntoView?.({
            block: "nearest"
          });
        }
      },
      onClick: disabled ? noop : onClick,
      onMouseMove: disabled ? noop : onMouseMove,
      title: disabled ? t("commandPalette.itemNotAvailable") : "",
      children: [
        /* @__PURE__ */ jsxs43("div", { className: "name", children: [
          command.icon && /* @__PURE__ */ jsx76(
            InlineIcon,
            {
              className: "icon",
              size: "var(--icon-size, 1rem)",
              icon: typeof command.icon === "function" ? command.icon(appState, []) : command.icon
            }
          ),
          /* @__PURE__ */ jsx76(Ellipsify, { children: command.label })
        ] }),
        showShortcut && command.shortcut && /* @__PURE__ */ jsx76(CommandShortcutHint, { shortcut: command.shortcut })
      ]
    }
  );
};

// ../element/src/mutateElement.ts
import {
  getSizeFromPoints as getSizeFromPoints2,
  randomInteger as randomInteger2,
  getUpdatedTimestamp
} from "@excalidraw/common";

// ../element/src/shape.ts
import { simplify } from "points-on-curve";
import { getStroke } from "perfect-freehand";

// ../utils/src/shape.ts
import { pointsOnBezierCurves } from "points-on-curve";
import { invariant as invariant4 } from "@excalidraw/common";
import {
  curve,
  lineSegment,
  pointFrom as pointFrom6,
  pointDistance,
  pointFromArray,
  pointFromVector,
  pointRotateRads as pointRotateRads2,
  polygon,
  polygonFromPoints,
  PRECISION,
  segmentsIntersectAt,
  vector,
  vectorAdd,
  vectorFromPoint,
  vectorScale
} from "@excalidraw/math";
import { getElementAbsoluteCoords as getElementAbsoluteCoords3 } from "@excalidraw/element";
var getCurvePathOps = (shape) => {
  if (!shape) {
    return [];
  }
  for (const set of shape.sets) {
    if (set.type === "path") {
      return set.ops;
    }
  }
  return shape.sets[0].ops;
};

// ../element/src/shape.ts
import {
  pointFrom as pointFrom19,
  pointDistance as pointDistance7,
  pointRotateRads as pointRotateRads14
} from "@excalidraw/math";
import {
  ROUGHNESS,
  THEME as THEME10,
  isTransparent as isTransparent5,
  assertNever as assertNever3,
  COLOR_PALETTE as COLOR_PALETTE5,
  LINE_POLYGON_POINT_MERGE_DISTANCE,
  applyDarkModeFilter as applyDarkModeFilter2
} from "@excalidraw/common";
import { RoughGenerator } from "roughjs/bin/generator";

// ../element/src/renderElement.ts
import rough2 from "roughjs/bin/rough";
import {
  isRightAngleRads,
  lineSegment as lineSegment7,
  pointFrom as pointFrom18,
  pointRotateRads as pointRotateRads13
} from "@excalidraw/math";
import {
  BOUND_TEXT_PADDING as BOUND_TEXT_PADDING4,
  DEFAULT_FONT_FAMILY as DEFAULT_FONT_FAMILY5,
  DEFAULT_FONT_SIZE as DEFAULT_FONT_SIZE6,
  DEFAULT_REDUCED_GLOBAL_ALPHA,
  ELEMENT_READY_TO_ERASE_OPACITY,
  FRAME_STYLE,
  DARK_THEME_FILTER,
  MIME_TYPES as MIME_TYPES7,
  STICKY_NOTE_PADDING as STICKY_NOTE_PADDING2,
  THEME as THEME9,
  distance,
  getFontString as getFontString5,
  isRTL,
  getVerticalOffset,
  invariant as invariant13,
  applyDarkModeFilter,
  isSafari
} from "@excalidraw/common";

// ../element/src/bounds.ts
import rough from "roughjs/bin/rough";
import {
  arrayToMap as arrayToMap16,
  invariant as invariant12,
  rescalePoints,
  sizeOf
} from "@excalidraw/common";
import {
  degreesToRadians,
  lineSegment as lineSegment6,
  pointDistance as pointDistance6,
  pointFrom as pointFrom14,
  pointFromArray as pointFromArray3,
  pointRotateRads as pointRotateRads10
} from "@excalidraw/math";
import { pointsOnBezierCurves as pointsOnBezierCurves2 } from "points-on-curve";

// ../element/src/linearElementEditor.ts
import {
  pointCenter,
  pointFrom as pointFrom13,
  pointRotateRads as pointRotateRads9,
  pointsEqual as pointsEqual7,
  pointDistance as pointDistance5,
  vectorFromPoint as vectorFromPoint7,
  curveLength,
  curvePointAtLength,
  lineSegment as lineSegment5
} from "@excalidraw/math";
import {
  DRAGGING_THRESHOLD,
  KEYS as KEYS39,
  shouldRotateWithDiscreteAngle as shouldRotateWithDiscreteAngle2,
  getGridPoint,
  invariant as invariant11,
  isShallowEqual as isShallowEqual2,
  getFeatureFlag as getFeatureFlag2
} from "@excalidraw/common";
import {
  deconstructLinearOrFreeDrawElement as deconstructLinearOrFreeDrawElement2,
  getSnapOutlineMidPoint,
  isPathALoop as isPathALoop3,
  moveArrowAboveBindable,
  projectFixedPointOntoDiagonal as projectFixedPointOntoDiagonal2
} from "@excalidraw/element";

// ../element/src/binding.ts
import {
  KEYS as KEYS38,
  arrayToMap as arrayToMap15,
  getFeatureFlag,
  invariant as invariant10,
  isTransparent as isTransparent4
} from "@excalidraw/common";
import {
  PRECISION as PRECISION2,
  clamp as clamp3,
  lineSegment as lineSegment4,
  pointDistance as pointDistance4,
  pointDistanceSq,
  pointFrom as pointFrom12,
  pointFromVector as pointFromVector5,
  pointRotateRads as pointRotateRads8,
  pointsEqual as pointsEqual5,
  vectorFromPoint as vectorFromPoint6,
  vectorNormalize as vectorNormalize3,
  vectorScale as vectorScale6
} from "@excalidraw/math";

// ../element/src/collision.ts
import { invariant as invariant7, isTransparent as isTransparent3 } from "@excalidraw/common";
import {
  curveIntersectLineSegment,
  isPointWithinBounds,
  lineSegment as lineSegment3,
  lineSegmentIntersectionPoints as lineSegmentIntersectionPoints2,
  pointFrom as pointFrom9,
  pointFromVector as pointFromVector3,
  pointRotateRads as pointRotateRads6,
  pointsEqual as pointsEqual2,
  vectorFromPoint as vectorFromPoint3,
  vectorNormalize as vectorNormalize2,
  vectorScale as vectorScale3
} from "@excalidraw/math";
import {
  ellipse as ellipse2,
  ellipseSegmentInterceptPoints
} from "@excalidraw/math/ellipse";

// ../element/src/utils.ts
import {
  DEFAULT_ADAPTIVE_RADIUS,
  DEFAULT_PROPORTIONAL_RADIUS,
  invariant as invariant5,
  LINE_CONFIRM_THRESHOLD,
  ROUNDNESS as ROUNDNESS5
} from "@excalidraw/common";
import {
  bezierEquation,
  curve as curve2,
  curveCatmullRomCubicApproxPoints,
  curveOffsetPoints,
  lineSegment as lineSegment2,
  lineSegmentIntersectionPoints,
  pointDistance as pointDistance2,
  pointFrom as pointFrom7,
  pointFromArray as pointFromArray2,
  pointFromVector as pointFromVector2,
  pointRotateRads as pointRotateRads3,
  pointTranslate,
  rectangle,
  vectorFromPoint as vectorFromPoint2,
  vectorNormalize,
  vectorScale as vectorScale2
} from "@excalidraw/math";

// ../element/src/typeChecks.ts
import { ROUNDNESS as ROUNDNESS4, assertNever as assertNever2 } from "@excalidraw/common";
import { pointsEqual } from "@excalidraw/math";
var isEmbeddableElement3 = (element) => {
  return !!element && element.type === "embeddable";
};
var isIframeElement = (element) => {
  return !!element && element.type === "iframe";
};
var isIframeLikeElement = (element) => {
  return !!element && (element.type === "iframe" || element.type === "embeddable");
};
var isTextElement7 = (element) => {
  return element != null && element.type === "text";
};
var isFrameLikeElement7 = (element) => {
  return element != null && (element.type === "frame" || element.type === "magicframe");
};
var isLinearElement6 = (element) => {
  return element != null && isLinearElementType(element.type);
};
var isArrowElement7 = (element) => {
  return element != null && element.type === "arrow";
};
var isElbowArrow6 = (element) => {
  return isArrowElement7(element) && element.elbowed;
};
var isLinearElementType = (elementType) => {
  return elementType === "arrow" || elementType === "line";
};
var isBoundToContainer5 = (element) => {
  return element !== null && "containerId" in element && element.containerId !== null && isTextElement7(element);
};

// ../element/src/utils.ts
var isPathALoop2 = (points, zoomValue = 1) => {
  if (points.length >= 3) {
    const [first, last] = [points[0], points[points.length - 1]];
    const distance3 = pointDistance2(first, last);
    return distance3 <= LINE_CONFIRM_THRESHOLD / zoomValue;
  }
  return false;
};
var getCornerRadius = (x, element) => {
  if (element.roundness?.type === ROUNDNESS5.PROPORTIONAL_RADIUS || element.roundness?.type === ROUNDNESS5.LEGACY) {
    return x * DEFAULT_PROPORTIONAL_RADIUS;
  }
  if (element.roundness?.type === ROUNDNESS5.ADAPTIVE_RADIUS) {
    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;
    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;
    if (x <= CUTOFF_SIZE) {
      return x * DEFAULT_PROPORTIONAL_RADIUS;
    }
    return fixedRadiusSize;
  }
  return 0;
};

// ../element/src/textElement.ts
import {
  ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO,
  ARROW_LABEL_WIDTH_FRACTION,
  BOUND_TEXT_PADDING as BOUND_TEXT_PADDING3,
  DEFAULT_FONT_SIZE as DEFAULT_FONT_SIZE5,
  STICKY_NOTE_PADDING,
  TEXT_ALIGN as TEXT_ALIGN2,
  VERTICAL_ALIGN as VERTICAL_ALIGN4,
  getFontString as getFontString4,
  isProdEnv as isProdEnv2,
  invariant as invariant6
} from "@excalidraw/common";
import { pointFrom as pointFrom8, pointRotateRads as pointRotateRads4 } from "@excalidraw/math";

// ../element/src/textMeasurements.ts
import {
  BOUND_TEXT_PADDING as BOUND_TEXT_PADDING2,
  DEFAULT_FONT_SIZE as DEFAULT_FONT_SIZE4,
  DEFAULT_FONT_FAMILY as DEFAULT_FONT_FAMILY4,
  getFontString as getFontString3,
  isTestEnv,
  normalizeEOL
} from "@excalidraw/common";
var DUMMY_TEXT = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase();

// ../element/src/textWrapping.ts
import { isDevEnv as isDevEnv4, isTestEnv as isTestEnv2 } from "@excalidraw/common";

// ../element/src/distance.ts
import {
  curvePointDistance,
  distanceToLineSegment,
  pointRotateRads as pointRotateRads5
} from "@excalidraw/math";
import { ellipse, ellipseDistanceFromPoint } from "@excalidraw/math/ellipse";

// ../element/src/heading.ts
import {
  invariant as invariant8,
  isDevEnv as isDevEnv5,
  isTestEnv as isTestEnv3
} from "@excalidraw/common";
import {
  pointFrom as pointFrom10,
  pointFromVector as pointFromVector4,
  pointRotateRads as pointRotateRads7,
  pointScaleFromOrigin,
  pointsEqual as pointsEqual3,
  triangleIncludesPoint,
  vectorCross,
  vectorFromPoint as vectorFromPoint4,
  vectorScale as vectorScale4
} from "@excalidraw/math";
var HEADING_RIGHT = [1, 0];
var HEADING_DOWN = [0, 1];
var HEADING_LEFT = [-1, 0];
var HEADING_UP = [0, -1];
var vectorToHeading = (vec) => {
  const [x, y] = vec;
  const absX = Math.abs(x);
  const absY = Math.abs(y);
  if (x > absY) {
    return HEADING_RIGHT;
  } else if (x <= -absY) {
    return HEADING_LEFT;
  } else if (y > absX) {
    return HEADING_DOWN;
  }
  return HEADING_UP;
};
var headingForPoint = (p, o) => vectorToHeading(vectorFromPoint4(p, o));
var headingForPointIsHorizontal = (p, o) => headingIsHorizontal(headingForPoint(p, o));
var compareHeading = (a, b) => a[0] === b[0] && a[1] === b[1];
var headingIsHorizontal = (a) => compareHeading(a, HEADING_RIGHT) || compareHeading(a, HEADING_LEFT);

// ../element/src/elbowArrow.ts
import {
  clamp as clamp2,
  pointDistance as pointDistance3,
  pointFrom as pointFrom11,
  pointScaleFromOrigin as pointScaleFromOrigin2,
  pointsEqual as pointsEqual4,
  pointTranslate as pointTranslate2,
  vector as vector2,
  vectorCross as vectorCross2,
  vectorFromPoint as vectorFromPoint5,
  vectorScale as vectorScale5
} from "@excalidraw/math";
import {
  BinaryHeap,
  invariant as invariant9,
  isAnyTrue,
  getSizeFromPoints,
  isDevEnv as isDevEnv6,
  arrayToMap as arrayToMap14
} from "@excalidraw/common";

// ../element/src/binding.ts
var FOCUS_POINT_SIZE = 10 / 1.5;

// ../element/src/sizeHelpers.ts
import {
  SHIFT_LOCKING_ANGLE,
  viewportCoordsToSceneCoords as viewportCoordsToSceneCoords2
} from "@excalidraw/common";
import {
  normalizeRadians,
  radiansBetweenAngles,
  radiansDifference
} from "@excalidraw/math";
import { pointsEqual as pointsEqual6 } from "@excalidraw/math";

// ../element/src/bounds.ts
var getDiamondPoints = (element) => {
  const topX = Math.floor(element.width / 2) + 1;
  const topY = 0;
  const rightX = element.width;
  const rightY = Math.floor(element.height / 2) + 1;
  const bottomX = topX;
  const bottomY = element.height;
  const leftX = 0;
  const leftY = rightY;
  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];
};
var getArrowheadSize = (arrowhead) => {
  switch (arrowhead) {
    case "arrow":
      return 25;
    case "diamond":
    case "diamond_outline":
      return 12;
    case "crowfoot_many":
    case "crowfoot_one":
    case "crowfoot_one_or_many":
      return 20;
    default:
      return 15;
  }
};
var getArrowheadAngle = (arrowhead) => {
  switch (arrowhead) {
    case "bar":
      return 90;
    case "arrow":
      return 20;
    default:
      return 25;
  }
};
var getArrowheadPoints = (element, shape, position, arrowhead) => {
  if (shape.length < 1) {
    return null;
  }
  const ops = getCurvePathOps(shape[0]);
  if (ops.length < 1) {
    return null;
  }
  const index = position === "start" ? 1 : ops.length - 1;
  const data = ops[index].data;
  invariant12(data.length === 6, "Op data length is not 6");
  const p3 = pointFrom14(data[4], data[5]);
  const p2 = pointFrom14(data[2], data[3]);
  const p1 = pointFrom14(data[0], data[1]);
  const prevOp = ops[index - 1];
  let p0 = pointFrom14(0, 0);
  if (prevOp.op === "move") {
    const p = pointFromArray3(prevOp.data);
    invariant12(p != null, "Op data is not a point");
    p0 = p;
  } else if (prevOp.op === "bcurveTo") {
    p0 = pointFrom14(prevOp.data[4], prevOp.data[5]);
  }
  const equation = (t2, idx) => Math.pow(1 - t2, 3) * p3[idx] + 3 * t2 * Math.pow(1 - t2, 2) * p2[idx] + 3 * Math.pow(t2, 2) * (1 - t2) * p1[idx] + p0[idx] * Math.pow(t2, 3);
  const [x2, y2] = position === "start" ? p0 : p3;
  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];
  const distance3 = Math.hypot(x2 - x1, y2 - y1);
  const nx = (x2 - x1) / distance3;
  const ny = (y2 - y1) / distance3;
  const size = getArrowheadSize(arrowhead);
  let length = 0;
  {
    const [cx, cy] = position === "end" ? element.points[element.points.length - 1] : element.points[0];
    const [px, py] = element.points.length > 1 ? position === "end" ? element.points[element.points.length - 2] : element.points[1] : [0, 0];
    length = Math.hypot(cx - px, cy - py);
  }
  const lengthMultiplier = arrowhead === "diamond" || arrowhead === "diamond_outline" ? 0.25 : 0.5;
  const minSize = Math.min(size, length * lengthMultiplier);
  const xs = x2 - nx * minSize;
  const ys = y2 - ny * minSize;
  if (arrowhead === "dot" || arrowhead === "circle" || arrowhead === "circle_outline") {
    const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;
    return [x2, y2, diameter];
  }
  const angle = getArrowheadAngle(arrowhead);
  if (arrowhead === "crowfoot_many" || arrowhead === "crowfoot_one_or_many") {
    const [x32, y32] = pointRotateRads10(
      pointFrom14(x2, y2),
      pointFrom14(xs, ys),
      degreesToRadians(-angle)
    );
    const [x42, y42] = pointRotateRads10(
      pointFrom14(x2, y2),
      pointFrom14(xs, ys),
      degreesToRadians(angle)
    );
    return [xs, ys, x32, y32, x42, y42];
  }
  const [x3, y3] = pointRotateRads10(
    pointFrom14(xs, ys),
    pointFrom14(x2, y2),
    -angle * Math.PI / 180
  );
  const [x4, y4] = pointRotateRads10(
    pointFrom14(xs, ys),
    pointFrom14(x2, y2),
    degreesToRadians(angle)
  );
  if (arrowhead === "diamond" || arrowhead === "diamond_outline") {
    let ox;
    let oy;
    if (position === "start") {
      const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];
      [ox, oy] = pointRotateRads10(
        pointFrom14(x2 + minSize * 2, y2),
        pointFrom14(x2, y2),
        Math.atan2(py - y2, px - x2)
      );
    } else {
      const [px, py] = element.points.length > 1 ? element.points[element.points.length - 2] : [0, 0];
      [ox, oy] = pointRotateRads10(
        pointFrom14(x2 - minSize * 2, y2),
        pointFrom14(x2, y2),
        Math.atan2(y2 - py, x2 - px)
      );
    }
    return [x2, y2, x3, y3, ox, oy, x4, y4];
  }
  return [x2, y2, x3, y3, x4, y4];
};

// ../element/src/cropElement.ts
import {
  pointFrom as pointFrom15,
  pointCenter as pointCenter2,
  pointRotateRads as pointRotateRads11,
  vectorFromPoint as vectorFromPoint8,
  vectorNormalize as vectorNormalize4,
  vectorSubtract,
  vectorAdd as vectorAdd2,
  vectorScale as vectorScale7,
  pointFromVector as pointFromVector6,
  clamp as clamp4,
  isCloseTo
} from "@excalidraw/math";

// ../element/src/frame.ts
import { arrayToMap as arrayToMap19 } from "@excalidraw/common";
import { isPointWithinBounds as isPointWithinBounds2, pointFrom as pointFrom17 } from "@excalidraw/math";

// ../utils/src/bbox.ts
import {
  vectorCross as vectorCross3,
  vectorFromPoint as vectorFromPoint9
} from "@excalidraw/math";

// ../utils/src/withinBounds.ts
import { arrayToMap as arrayToMap17 } from "@excalidraw/common";
import { getElementBounds as getElementBounds2 } from "@excalidraw/element";
import {
  isArrowElement as isArrowElement8,
  isExcalidrawElement as isExcalidrawElement2,
  isFreeDrawElement as isFreeDrawElement3,
  isLinearElement as isLinearElement7,
  isTextElement as isTextElement8
} from "@excalidraw/element";
import {
  rangeIncludesValue,
  pointFrom as pointFrom16,
  pointRotateRads as pointRotateRads12,
  rangeInclusive
} from "@excalidraw/math";
var getNonLinearElementRelativePoints = (element) => {
  if (element.type === "diamond") {
    return [
      pointFrom16(element.width / 2, 0),
      pointFrom16(element.width, element.height / 2),
      pointFrom16(element.width / 2, element.height),
      pointFrom16(0, element.height / 2)
    ];
  }
  return [
    pointFrom16(0, 0),
    pointFrom16(0 + element.width, 0),
    pointFrom16(0 + element.width, element.height),
    pointFrom16(0, element.height)
  ];
};
var getElementRelativePoints = (element) => {
  if (isLinearElement7(element) || isFreeDrawElement3(element)) {
    return element.points;
  }
  return getNonLinearElementRelativePoints(element);
};
var getMinMaxPoints = (points) => {
  const ret = points.reduce(
    (limits, [x, y]) => {
      limits.minY = Math.min(limits.minY, y);
      limits.minX = Math.min(limits.minX, x);
      limits.maxX = Math.max(limits.maxX, x);
      limits.maxY = Math.max(limits.maxY, y);
      return limits;
    },
    {
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity,
      cx: 0,
      cy: 0
    }
  );
  ret.cx = (ret.maxX + ret.minX) / 2;
  ret.cy = (ret.maxY + ret.minY) / 2;
  return ret;
};
var getRotatedBBox = (element) => {
  const points = getElementRelativePoints(element);
  const { cx, cy } = getMinMaxPoints(points);
  const centerPoint = pointFrom16(cx, cy);
  const rotatedPoints = points.map(
    (p) => pointRotateRads12(p, centerPoint, element.angle)
  );
  const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);
  return [
    minX + element.x,
    minY + element.y,
    maxX + element.x,
    maxY + element.y
  ];
};
var isElementInsideBBox = (element, bbox, eitherDirection = false) => {
  const elementBBox = getRotatedBBox(element);
  const elementInsideBbox = bbox[0] <= elementBBox[0] && bbox[2] >= elementBBox[2] && bbox[1] <= elementBBox[1] && bbox[3] >= elementBBox[3];
  if (!eitherDirection) {
    return elementInsideBbox;
  }
  if (elementInsideBbox) {
    return true;
  }
  return elementBBox[0] <= bbox[0] && elementBBox[2] >= bbox[2] && elementBBox[1] <= bbox[1] && elementBBox[3] >= bbox[3];
};
var elementPartiallyOverlapsWithOrContainsBBox = (element, bbox) => {
  const elementBBox = getRotatedBBox(element);
  return (rangeIncludesValue(elementBBox[0], rangeInclusive(bbox[0], bbox[2])) || rangeIncludesValue(
    bbox[0],
    rangeInclusive(elementBBox[0], elementBBox[2])
  )) && (rangeIncludesValue(elementBBox[1], rangeInclusive(bbox[1], bbox[3])) || rangeIncludesValue(
    bbox[1],
    rangeInclusive(elementBBox[1], elementBBox[3])
  ));
};
var elementsOverlappingBBox = ({
  elements,
  bounds,
  type,
  errorMargin = 0
}) => {
  if (isExcalidrawElement2(bounds)) {
    bounds = getElementBounds2(bounds, arrayToMap17(elements));
  }
  const adjustedBBox = [
    bounds[0] - errorMargin,
    bounds[1] - errorMargin,
    bounds[2] + errorMargin,
    bounds[3] + errorMargin
  ];
  const includedElementSet = /* @__PURE__ */ new Set();
  for (const element of elements) {
    if (includedElementSet.has(element.id)) {
      continue;
    }
    const isOverlaping = type === "overlap" ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox) : type === "inside" ? isElementInsideBBox(element, adjustedBBox) : isElementInsideBBox(element, adjustedBBox, true);
    if (isOverlaping) {
      includedElementSet.add(element.id);
      if (element.boundElements) {
        for (const boundElement of element.boundElements) {
          includedElementSet.add(boundElement.id);
        }
      }
      if (isTextElement8(element) && element.containerId) {
        includedElementSet.add(element.containerId);
      }
      if (isArrowElement8(element)) {
        if (element.startBinding) {
          includedElementSet.add(element.startBinding.elementId);
        }
        if (element.endBinding) {
          includedElementSet.add(element.endBinding?.elementId);
        }
      }
    }
  }
  return elements.filter((element) => includedElementSet.has(element.id));
};

// ../element/src/selection.ts
import { arrayToMap as arrayToMap18, isShallowEqual as isShallowEqual3 } from "@excalidraw/common";

// ../element/src/groups.ts
var selectGroupsForSelectedElements4 = function() {
  let lastSelectedElements = null;
  let lastElements = null;
  let lastReturnValue = null;
  const _selectGroups = (selectedElements, elements, appState, prevAppState) => {
    if (lastReturnValue !== void 0 && elements === lastElements && selectedElements === lastSelectedElements && appState.editingGroupId === lastReturnValue?.editingGroupId) {
      return lastReturnValue;
    }
    const selectedGroupIds = {};
    for (const selectedElement of selectedElements) {
      let groupIds = selectedElement.groupIds;
      if (appState.editingGroupId) {
        const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
        if (indexOfEditingGroup > -1) {
          groupIds = groupIds.slice(0, indexOfEditingGroup);
        }
      }
      if (groupIds.length > 0) {
        const lastSelectedGroup = groupIds[groupIds.length - 1];
        selectedGroupIds[lastSelectedGroup] = true;
      }
    }
    const groupElementsIndex = {};
    const selectedElementIdsInGroups = elements.reduce(
      (acc, element) => {
        if (element.isDeleted) {
          return acc;
        }
        const groupId = element.groupIds.find((id) => selectedGroupIds[id]);
        if (groupId) {
          acc[element.id] = true;
          if (!Array.isArray(groupElementsIndex[groupId])) {
            groupElementsIndex[groupId] = [element.id];
          } else {
            groupElementsIndex[groupId].push(element.id);
          }
        }
        return acc;
      },
      {}
    );
    for (const groupId of Object.keys(groupElementsIndex)) {
      if (groupElementsIndex[groupId].length < 2) {
        if (selectedGroupIds[groupId]) {
          selectedGroupIds[groupId] = false;
        }
      }
    }
    lastElements = elements;
    lastSelectedElements = selectedElements;
    lastReturnValue = {
      editingGroupId: appState.editingGroupId,
      selectedGroupIds,
      selectedElementIds: makeNextSelectedElementIds(
        {
          ...appState.selectedElementIds,
          ...selectedElementIdsInGroups
        },
        prevAppState
      )
    };
    return lastReturnValue;
  };
  const selectGroupsForSelectedElements7 = (appState, elements, prevAppState, app) => {
    const selectedElements = app ? app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      // supplying elements explicitly in case we're passed non-state elements
      elements
    }) : getSelectedElements3(elements, appState);
    if (!selectedElements.length) {
      return {
        selectedGroupIds: {},
        editingGroupId: null,
        selectedElementIds: makeNextSelectedElementIds(
          appState.selectedElementIds,
          prevAppState
        )
      };
    }
    return _selectGroups(selectedElements, elements, appState, prevAppState);
  };
  selectGroupsForSelectedElements7.clearCache = () => {
    lastElements = null;
    lastSelectedElements = null;
    lastReturnValue = null;
  };
  return selectGroupsForSelectedElements7;
}();

// ../element/src/selection.ts
var isSomeElementSelected2 = function() {
  let lastElements = null;
  let lastSelectedElementIds = null;
  let isSelected = null;
  const ret = (elements, appState) => {
    if (isSelected != null && elements === lastElements && appState.selectedElementIds === lastSelectedElementIds) {
      return isSelected;
    }
    isSelected = elements.some(
      (element) => appState.selectedElementIds[element.id]
    );
    lastElements = elements;
    lastSelectedElementIds = appState.selectedElementIds;
    return isSelected;
  };
  ret.clearCache = () => {
    lastElements = null;
    lastSelectedElementIds = null;
    isSelected = null;
  };
  return ret;
}();
var getSelectedElements3 = (elements, appState, opts) => {
  const addedElements = /* @__PURE__ */ new Set();
  const selectedElements = [];
  for (const element of elements.values()) {
    if (appState.selectedElementIds[element.id]) {
      selectedElements.push(element);
      addedElements.add(element.id);
      continue;
    }
    if (opts?.includeBoundTextElement && isBoundToContainer5(element) && appState.selectedElementIds[element?.containerId]) {
      selectedElements.push(element);
      addedElements.add(element.id);
      continue;
    }
  }
  if (opts?.includeElementsInFrames) {
    const elementsToInclude = [];
    selectedElements.forEach((element) => {
      if (isFrameLikeElement7(element)) {
        getFrameChildren2(elements, element.id).forEach(
          (e) => !addedElements.has(e.id) && elementsToInclude.push(e)
        );
      }
      elementsToInclude.push(element);
    });
    return elementsToInclude;
  }
  return selectedElements;
};
var makeNextSelectedElementIds = (nextSelectedElementIds, prevState) => {
  if (isShallowEqual3(prevState.selectedElementIds, nextSelectedElementIds)) {
    return prevState.selectedElementIds;
  }
  return nextSelectedElementIds;
};

// ../element/src/frame.ts
var getFrameChildren2 = (allElements, frameId) => {
  const frameChildren = [];
  for (const element of allElements.values()) {
    if (element.frameId === frameId) {
      frameChildren.push(element);
    }
  }
  return frameChildren;
};

// ../element/src/renderElement.ts
var IMAGE_PLACEHOLDER_IMG = typeof document !== "undefined" ? document.createElement("img") : { src: "" };
IMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES7.svg},${encodeURIComponent(
  `<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>`
)}`;
var IMAGE_ERROR_PLACEHOLDER_IMG = typeof document !== "undefined" ? document.createElement("img") : { src: "" };
IMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES7.svg},${encodeURIComponent(
  `<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>`
)}`;
var elementWithCanvasCache = /* @__PURE__ */ new WeakMap();

// ../element/src/comparisons.ts
var canChangeRoundness2 = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "line" || type === "diamond" || type === "image";

// ../element/src/shape.ts
var _ShapeCache = class _ShapeCache {
};
__publicField(_ShapeCache, "rg", new RoughGenerator());
__publicField(_ShapeCache, "cache", /* @__PURE__ */ new WeakMap());
/**
 * Retrieves shape from cache if available. Use this only if shape
 * is optional and you have a fallback in case it's not cached.
 */
__publicField(_ShapeCache, "get", (element, theme) => {
  const cached = _ShapeCache.cache.get(element);
  if (cached && (theme === null || cached.theme === theme)) {
    return cached.shape;
  }
  return void 0;
});
__publicField(_ShapeCache, "delete", (element) => {
  _ShapeCache.cache.delete(element);
  elementWithCanvasCache.delete(element);
});
__publicField(_ShapeCache, "destroy", () => {
  _ShapeCache.cache = /* @__PURE__ */ new WeakMap();
});
/**
 * Generates & caches shape for element if not already cached, otherwise
 * returns cached shape.
 */
__publicField(_ShapeCache, "generateElementShape", (element, renderConfig) => {
  const cachedShape = renderConfig?.isExporting ? void 0 : _ShapeCache.get(element, renderConfig ? renderConfig.theme : null);
  if (cachedShape !== void 0) {
    return cachedShape;
  }
  elementWithCanvasCache.delete(element);
  const shape = _generateElementShape(
    element,
    _ShapeCache.rg,
    renderConfig || {
      isExporting: false,
      canvasBackgroundColor: COLOR_PALETTE5.white,
      embedsValidationStatus: null,
      theme: THEME10.LIGHT
    }
  );
  if (!renderConfig?.isExporting) {
    _ShapeCache.cache.set(element, {
      shape,
      theme: renderConfig?.theme || THEME10.LIGHT
    });
  }
  return shape;
});
var ShapeCache2 = _ShapeCache;
var getDashArrayDashed = (strokeWidth) => [8, 8 + strokeWidth];
var getDashArrayDotted = (strokeWidth) => [1.5, 6 + strokeWidth];
function adjustRoughness(element) {
  const roughness = element.roughness;
  const maxSize = Math.max(element.width, element.height);
  const minSize = Math.min(element.width, element.height);
  if (
    // both sides relatively big
    minSize >= 20 && maxSize >= 50 || // is round & both sides above 15px
    minSize >= 15 && !!element.roundness && canChangeRoundness2(element.type) || // relatively long linear element
    isLinearElement6(element) && maxSize >= 50
  ) {
    return roughness;
  }
  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);
}
var generateRoughOptions = (element, continuousPath = false, isDarkMode = false) => {
  const options = {
    seed: element.seed,
    strokeLineDash: element.strokeStyle === "dashed" ? getDashArrayDashed(element.strokeWidth) : element.strokeStyle === "dotted" ? getDashArrayDotted(element.strokeWidth) : void 0,
    // for non-solid strokes, disable multiStroke because it tends to make
    // dashes/dots overlay each other
    disableMultiStroke: element.strokeStyle !== "solid",
    // for non-solid strokes, increase the width a bit to make it visually
    // similar to solid strokes, because we're also disabling multiStroke
    strokeWidth: element.strokeStyle !== "solid" ? element.strokeWidth + 0.5 : element.strokeWidth,
    // when increasing strokeWidth, we must explicitly set fillWeight and
    // hachureGap because if not specified, roughjs uses strokeWidth to
    // calculate them (and we don't want the fills to be modified)
    fillWeight: element.strokeWidth / 2,
    hachureGap: element.strokeWidth * 4,
    roughness: adjustRoughness(element),
    stroke: isDarkMode ? applyDarkModeFilter2(element.strokeColor) : element.strokeColor,
    preserveVertices: continuousPath || element.roughness < ROUGHNESS.cartoonist
  };
  switch (element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse": {
      options.fillStyle = element.fillStyle;
      options.fill = isTransparent5(element.backgroundColor) ? void 0 : isDarkMode ? applyDarkModeFilter2(element.backgroundColor) : element.backgroundColor;
      if (element.type === "rectangle" && element.customData?.isStickyNote === true) {
        options.stroke = "none";
      }
      if (element.type === "ellipse") {
        options.curveFitting = 1;
      }
      return options;
    }
    case "line":
    case "freedraw": {
      if (isPathALoop2(element.points)) {
        options.fillStyle = element.fillStyle;
        options.fill = element.backgroundColor === "transparent" ? void 0 : isDarkMode ? applyDarkModeFilter2(element.backgroundColor) : element.backgroundColor;
      }
      return options;
    }
    case "arrow":
      return options;
    default: {
      throw new Error(`Unimplemented type ${element.type}`);
    }
  }
};
var modifyIframeLikeForRoughOptions = (element, isExporting, embedsValidationStatus) => {
  if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement3(element) && embedsValidationStatus?.get(element.id) !== true) && isTransparent5(element.backgroundColor) && isTransparent5(element.strokeColor)) {
    return {
      ...element,
      roughness: 0,
      backgroundColor: "#d3d3d3",
      fillStyle: "solid"
    };
  } else if (isIframeElement(element)) {
    return {
      ...element,
      strokeColor: isTransparent5(element.strokeColor) ? "#000000" : element.strokeColor,
      backgroundColor: isTransparent5(element.backgroundColor) ? "#f4f4f6" : element.backgroundColor
    };
  }
  return element;
};
var getArrowheadShapes = (element, shape, position, arrowhead, generator, options, canvasBackgroundColor, isDarkMode) => {
  const arrowheadPoints = getArrowheadPoints(
    element,
    shape,
    position,
    arrowhead
  );
  if (arrowheadPoints === null) {
    return [];
  }
  const generateCrowfootOne = (arrowheadPoints2, options2) => {
    if (arrowheadPoints2 === null) {
      return [];
    }
    const [, , x3, y3, x4, y4] = arrowheadPoints2;
    return [generator.line(x3, y3, x4, y4, options2)];
  };
  const strokeColor = isDarkMode ? applyDarkModeFilter2(element.strokeColor) : element.strokeColor;
  switch (arrowhead) {
    case "dot":
    case "circle":
    case "circle_outline": {
      const [x, y, diameter] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.circle(x, y, diameter, {
          ...options,
          fill: arrowhead === "circle_outline" ? canvasBackgroundColor : strokeColor,
          fillStyle: "solid",
          stroke: strokeColor,
          roughness: Math.min(0.5, options.roughness || 0)
        })
      ];
    }
    case "triangle":
    case "triangle_outline": {
      const [x, y, x2, y2, x3, y3] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.polygon(
          [
            [x, y],
            [x2, y2],
            [x3, y3],
            [x, y]
          ],
          {
            ...options,
            fill: arrowhead === "triangle_outline" ? canvasBackgroundColor : strokeColor,
            fillStyle: "solid",
            roughness: Math.min(1, options.roughness || 0)
          }
        )
      ];
    }
    case "diamond":
    case "diamond_outline": {
      const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;
      delete options.strokeLineDash;
      return [
        generator.polygon(
          [
            [x, y],
            [x2, y2],
            [x3, y3],
            [x4, y4],
            [x, y]
          ],
          {
            ...options,
            fill: arrowhead === "diamond_outline" ? canvasBackgroundColor : strokeColor,
            fillStyle: "solid",
            roughness: Math.min(1, options.roughness || 0)
          }
        )
      ];
    }
    case "crowfoot_one":
      return generateCrowfootOne(arrowheadPoints, options);
    case "bar":
    case "arrow":
    case "crowfoot_many":
    case "crowfoot_one_or_many":
    default: {
      const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;
      if (element.strokeStyle === "dotted") {
        const dash = getDashArrayDotted(element.strokeWidth - 1);
        options.strokeLineDash = [dash[0], dash[1] - 1];
      } else {
        delete options.strokeLineDash;
      }
      options.roughness = Math.min(1, options.roughness || 0);
      return [
        generator.line(x3, y3, x2, y2, options),
        generator.line(x4, y4, x2, y2, options),
        ...arrowhead === "crowfoot_one_or_many" ? generateCrowfootOne(
          getArrowheadPoints(element, shape, position, "crowfoot_one"),
          options
        ) : []
      ];
    }
  }
};
var _generateElementShape = (element, generator, {
  isExporting,
  canvasBackgroundColor,
  embedsValidationStatus,
  theme
}) => {
  const isDarkMode = theme === THEME10.DARK;
  switch (element.type) {
    case "rectangle":
    case "iframe":
    case "embeddable": {
      let shape;
      if (element.roundness) {
        const w = element.width;
        const h = element.height;
        const r = getCornerRadius(Math.min(w, h), element);
        shape = generator.path(
          `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${h - r} Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${h - r} L 0 ${r} Q 0 0, ${r} 0`,
          generateRoughOptions(
            modifyIframeLikeForRoughOptions(
              element,
              isExporting,
              embedsValidationStatus
            ),
            true,
            isDarkMode
          )
        );
      } else {
        shape = generator.rectangle(
          0,
          0,
          element.width,
          element.height,
          generateRoughOptions(
            modifyIframeLikeForRoughOptions(
              element,
              isExporting,
              embedsValidationStatus
            ),
            false,
            isDarkMode
          )
        );
      }
      return shape;
    }
    case "diamond": {
      let shape;
      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);
      if (element.roundness) {
        const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);
        const horizontalRadius = getCornerRadius(
          Math.abs(rightY - topY),
          element
        );
        shape = generator.path(
          `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${rightX - verticalRadius} ${rightY - horizontalRadius}
            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${rightX - verticalRadius} ${rightY + horizontalRadius}
            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}
            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${bottomX - verticalRadius} ${bottomY - horizontalRadius}
            L ${leftX + verticalRadius} ${leftY + horizontalRadius}
            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${leftY - horizontalRadius}
            L ${topX - verticalRadius} ${topY + horizontalRadius}
            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${topY + horizontalRadius}`,
          generateRoughOptions(element, true, isDarkMode)
        );
      } else {
        shape = generator.polygon(
          [
            [topX, topY],
            [rightX, rightY],
            [bottomX, bottomY],
            [leftX, leftY]
          ],
          generateRoughOptions(element, false, isDarkMode)
        );
      }
      return shape;
    }
    case "ellipse": {
      const shape = generator.ellipse(
        element.width / 2,
        element.height / 2,
        element.width,
        element.height,
        generateRoughOptions(element, false, isDarkMode)
      );
      return shape;
    }
    case "line":
    case "arrow": {
      let shape;
      const options = generateRoughOptions(element, false, isDarkMode);
      const points = element.points.length ? element.points : [pointFrom19(0, 0)];
      if (isElbowArrow6(element)) {
        if (!points.every(
          (point) => Math.abs(point[0]) <= 1e6 && Math.abs(point[1]) <= 1e6
        )) {
          console.error(
            `Elbow arrow with extreme point positions detected. Arrow not rendered.`,
            element.id,
            JSON.stringify(points)
          );
          shape = [];
        } else {
          shape = [
            generator.path(
              generateElbowArrowShape(points, 16),
              generateRoughOptions(element, true, isDarkMode)
            )
          ];
        }
      } else if (!element.roundness) {
        if (options.fill) {
          shape = [
            generator.polygon(points, options)
          ];
        } else {
          shape = [
            generator.linearPath(points, options)
          ];
        }
      } else {
        shape = [generator.curve(points, options)];
      }
      if (element.type === "arrow") {
        const { startArrowhead = null, endArrowhead = "arrow" } = element;
        if (startArrowhead !== null) {
          const shapes = getArrowheadShapes(
            element,
            shape,
            "start",
            startArrowhead,
            generator,
            options,
            canvasBackgroundColor,
            isDarkMode
          );
          shape.push(...shapes);
        }
        if (endArrowhead !== null) {
          if (endArrowhead === void 0) {
          }
          const shapes = getArrowheadShapes(
            element,
            shape,
            "end",
            endArrowhead,
            generator,
            options,
            canvasBackgroundColor,
            isDarkMode
          );
          shape.push(...shapes);
        }
      }
      return shape;
    }
    case "freedraw": {
      const shapes = [];
      if (isPathALoop2(element.points)) {
        const simplifiedPoints = simplify(
          element.points,
          0.75
        );
        shapes.push(
          generator.curve(simplifiedPoints, {
            ...generateRoughOptions(element, false, isDarkMode),
            stroke: "none"
          })
        );
      }
      shapes.push(getFreeDrawSvgPath(element));
      return shapes;
    }
    case "frame":
    case "magicframe":
    case "text":
    case "image": {
      const shape = null;
      return shape;
    }
    default: {
      assertNever3(
        element,
        `generateElementShape(): Unimplemented type ${element?.type}`
      );
      return null;
    }
  }
};
var generateElbowArrowShape = (points, radius) => {
  const subpoints = [];
  for (let i = 1; i < points.length - 1; i += 1) {
    const prev = points[i - 1];
    const next = points[i + 1];
    const point = points[i];
    const prevIsHorizontal = headingForPointIsHorizontal(point, prev);
    const nextIsHorizontal = headingForPointIsHorizontal(next, point);
    const corner = Math.min(
      radius,
      pointDistance7(points[i], next) / 2,
      pointDistance7(points[i], prev) / 2
    );
    if (prevIsHorizontal) {
      if (prev[0] < point[0]) {
        subpoints.push([points[i][0] - corner, points[i][1]]);
      } else {
        subpoints.push([points[i][0] + corner, points[i][1]]);
      }
    } else if (prev[1] < point[1]) {
      subpoints.push([points[i][0], points[i][1] - corner]);
    } else {
      subpoints.push([points[i][0], points[i][1] + corner]);
    }
    subpoints.push(points[i]);
    if (nextIsHorizontal) {
      if (next[0] < point[0]) {
        subpoints.push([points[i][0] - corner, points[i][1]]);
      } else {
        subpoints.push([points[i][0] + corner, points[i][1]]);
      }
    } else if (next[1] < point[1]) {
      subpoints.push([points[i][0], points[i][1] - corner]);
    } else {
      subpoints.push([points[i][0], points[i][1] + corner]);
    }
  }
  const d = [`M ${points[0][0]} ${points[0][1]}`];
  for (let i = 0; i < subpoints.length; i += 3) {
    d.push(`L ${subpoints[i][0]} ${subpoints[i][1]}`);
    d.push(
      `Q ${subpoints[i + 1][0]} ${subpoints[i + 1][1]}, ${subpoints[i + 2][0]} ${subpoints[i + 2][1]}`
    );
  }
  d.push(`L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`);
  return d.join(" ");
};
var getFreeDrawSvgPath = (element) => {
  return getSvgPathFromStroke(
    getFreedrawOutlinePoints(element)
  );
};
var getFreedrawOutlinePoints = (element) => {
  const inputPoints = element.simulatePressure ? element.points : element.points.length ? element.points.map(([x, y], i) => [x, y, element.pressures[i]]) : [[0, 0, 0.5]];
  return getStroke(inputPoints, {
    simulatePressure: element.simulatePressure,
    size: element.strokeWidth * 4.25,
    thinning: 0.6,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t2) => Math.sin(t2 * Math.PI / 2),
    // https://easings.net/#easeOutSine
    last: true
  });
};
var med = (A, B) => {
  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];
};
var TO_FIXED_PRECISION = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
var getSvgPathFromStroke = (points) => {
  if (!points.length) {
    return "";
  }
  const max = points.length - 1;
  return points.reduce(
    (acc, point, i, arr) => {
      if (i === max) {
        acc.push(point, med(point, arr[0]), "L", arr[0], "Z");
      } else {
        acc.push(point, med(point, arr[i + 1]));
      }
      return acc;
    },
    ["M", points[0], "Q"]
  ).join(" ").replace(TO_FIXED_PRECISION, "$1");
};

// ../element/src/mutateElement.ts
var newElementWith9 = (element, updates, force = false) => {
  let didChange = false;
  for (const key in updates) {
    const value = updates[key];
    if (typeof value !== "undefined") {
      if (element[key] === value && // if object, always update because its attrs could have changed
      (typeof value !== "object" || value === null)) {
        continue;
      }
      didChange = true;
    }
  }
  if (!didChange && !force) {
    return element;
  }
  return {
    ...element,
    ...updates,
    version: updates.version ?? element.version + 1,
    versionNonce: updates.versionNonce ?? randomInteger2(),
    updated: getUpdatedTimestamp()
  };
};

// actions/actionLinearEditor.tsx
import { jsx as jsx77 } from "react/jsx-runtime";
var actionToggleLinearEditor = register({
  name: "toggleLinearEditor",
  category: DEFAULT_CATEGORIES.elements,
  label: (elements, appState, app) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    return selectedElement?.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit";
  },
  keywords: ["line"],
  trackEvent: {
    category: "element"
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (!appState.selectedLinearElement?.isEditing && selectedElements.length === 1 && isLinearElement8(selectedElements[0]) && !isElbowArrow7(selectedElements[0])) {
      return true;
    }
    return false;
  },
  perform(elements, appState, _, app) {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    invariant14(selectedElement, "No selected element found");
    invariant14(
      appState.selectedLinearElement,
      "No selected linear element found"
    );
    invariant14(
      selectedElement.id === appState.selectedLinearElement.elementId,
      "Selected element ID and linear editor elementId does not match"
    );
    const selectedLinearElement = {
      ...appState.selectedLinearElement,
      isEditing: !appState.selectedLinearElement.isEditing
    };
    return {
      appState: {
        ...appState,
        selectedLinearElement
      },
      captureUpdate: CaptureUpdateAction29.IMMEDIATELY
    };
  },
  PanelComponent: ({ appState, updateData, app }) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    if (!selectedElement) {
      return null;
    }
    const label = t(
      selectedElement.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit"
    );
    return /* @__PURE__ */ jsx77(
      ToolButton,
      {
        type: "button",
        icon: lineEditorIcon,
        title: label,
        "aria-label": label,
        onClick: () => updateData(null)
      }
    );
  }
});
var actionTogglePolygon = register({
  name: "togglePolygon",
  category: DEFAULT_CATEGORIES.elements,
  icon: polygonIcon,
  keywords: ["loop"],
  label: (elements, appState, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    });
    const allPolygons = !selectedElements.some(
      (element) => !isLineElement4(element) || !element.polygon
    );
    return allPolygons ? "labels.polygon.breakPolygon" : "labels.polygon.convertToPolygon";
  },
  trackEvent: {
    category: "element"
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    });
    return selectedElements.length > 0 && selectedElements.every(
      (element) => isLineElement4(element) && element.points.length >= 4
    );
  },
  perform(elements, appState, _, app) {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.some((element) => !isLineElement4(element))) {
      return false;
    }
    const targetElements = selectedElements;
    const nextPolygonState = targetElements.some((element) => !element.polygon);
    const targetElementsMap = arrayToMap20(targetElements);
    return {
      elements: elements.map((element) => {
        if (!targetElementsMap.has(element.id) || !isLineElement4(element)) {
          return element;
        }
        return newElementWith9(element, {
          backgroundColor: nextPolygonState ? element.backgroundColor : "transparent",
          ...toggleLinePolygonState3(element, nextPolygonState)
        });
      }),
      appState,
      captureUpdate: CaptureUpdateAction29.IMMEDIATELY
    };
  },
  PanelComponent: ({ appState, updateData, app }) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    });
    if (selectedElements.length === 0 || selectedElements.some(
      (element) => !isLineElement4(element) || // only show polygon button if every selected element is already
      // a polygon, effectively showing this button only to allow for
      // disabling the polygon state
      !element.polygon || element.points.length < 3
    )) {
      return null;
    }
    const allPolygon = selectedElements.every(
      (element) => isLineElement4(element) && element.polygon
    );
    const label = t(
      allPolygon ? "labels.polygon.breakPolygon" : "labels.polygon.convertToPolygon"
    );
    return /* @__PURE__ */ jsx77(
      ButtonIcon,
      {
        icon: polygonIcon,
        title: label,
        "aria-label": label,
        active: allPolygon,
        onClick: () => updateData(null),
        style: { marginLeft: "auto" }
      }
    );
  }
});

// actions/actionToggleSearchMenu.ts
import {
  KEYS as KEYS40,
  CANVAS_SEARCH_TAB,
  CLASSES as CLASSES6,
  DEFAULT_SIDEBAR as DEFAULT_SIDEBAR3
} from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction30 } from "@excalidraw/element";
var actionToggleSearchMenu = register({
  name: "searchMenu",
  icon: searchIcon,
  keywords: ["search", "find"],
  label: "search.title",
  viewMode: true,
  trackEvent: {
    category: "search_menu",
    action: "toggle",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState, _, app) {
    if (appState.openDialog) {
      return false;
    }
    if (appState.openSidebar?.name === DEFAULT_SIDEBAR3.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB) {
      const searchInput = app.excalidrawContainerValue.container?.querySelector(
        `.${CLASSES6.SEARCH_MENU_INPUT_WRAPPER} input`
      );
      searchInput?.focus();
      searchInput?.select();
      return false;
    }
    return {
      appState: {
        ...appState,
        openSidebar: { name: DEFAULT_SIDEBAR3.name, tab: CANVAS_SEARCH_TAB },
        openDialog: null
      },
      captureUpdate: CaptureUpdateAction30.EVENTUALLY
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS40.CTRL_OR_CMD] && event.key === KEYS40.F
});

// actions/actionCropEditor.tsx
import { isImageElement as isImageElement3 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction31 } from "@excalidraw/element";
import { jsx as jsx78 } from "react/jsx-runtime";
var actionToggleCropEditor = register({
  name: "cropEditor",
  label: "helpDialog.cropStart",
  icon: cropIcon,
  viewMode: true,
  trackEvent: { category: "menu" },
  keywords: ["image", "crop"],
  perform(elements, appState, _, app) {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    return {
      appState: {
        ...appState,
        isCropping: false,
        croppingElementId: selectedElement.id
      },
      captureUpdate: CaptureUpdateAction31.IMMEDIATELY
    };
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (!appState.croppingElementId && selectedElements.length === 1 && isImageElement3(selectedElements[0])) {
      return true;
    }
    return false;
  },
  PanelComponent: ({ appState, updateData, app }) => {
    const label = t("helpDialog.cropStart");
    return /* @__PURE__ */ jsx78(
      ToolButton,
      {
        type: "button",
        icon: cropIcon,
        title: label,
        "aria-label": label,
        onClick: () => updateData(null)
      }
    );
  }
});

// actions/actionFrame.ts
import { getNonDeletedElements as getNonDeletedElements12 } from "@excalidraw/element";
import { mutateElement as mutateElement4 } from "@excalidraw/element";
import { newFrameElement } from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement8 } from "@excalidraw/element";
import { FRAME_STYLE as FRAME_STYLE2 } from "@excalidraw/common";
import {
  addElementsToFrame,
  removeAllElementsFromFrame
} from "@excalidraw/element";
import { getFrameChildren as getFrameChildren3 } from "@excalidraw/element";
import { KEYS as KEYS41, updateActiveTool as updateActiveTool6 } from "@excalidraw/common";
import { getElementsInGroup as getElementsInGroup4 } from "@excalidraw/element";
import { getCommonBounds as getCommonBounds3 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction32 } from "@excalidraw/element";
var isSingleFrameSelected = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length === 1 && isFrameLikeElement8(selectedElements[0]);
};
var actionSelectAllElementsInFrame = register({
  name: "selectAllElementsInFrame",
  label: "labels.selectAllElementsInFrame",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement8(selectedElement)) {
      const elementsInFrame = getFrameChildren3(
        getNonDeletedElements12(elements),
        selectedElement.id
      ).filter((element) => !(element.type === "text" && element.containerId));
      return {
        elements,
        appState: {
          ...appState,
          selectedElementIds: elementsInFrame.reduce((acc, element) => {
            acc[element.id] = true;
            return acc;
          }, {})
        },
        captureUpdate: CaptureUpdateAction32.IMMEDIATELY
      };
    }
    return {
      elements,
      appState,
      captureUpdate: CaptureUpdateAction32.EVENTUALLY
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionRemoveAllElementsFromFrame = register({
  name: "removeAllElementsFromFrame",
  label: "labels.removeAllElementsFromFrame",
  trackEvent: { category: "history" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement8(selectedElement)) {
      return {
        elements: removeAllElementsFromFrame(elements, selectedElement),
        appState: {
          ...appState,
          selectedElementIds: {
            [selectedElement.id]: true
          }
        },
        captureUpdate: CaptureUpdateAction32.IMMEDIATELY
      };
    }
    return {
      elements,
      appState,
      captureUpdate: CaptureUpdateAction32.EVENTUALLY
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionupdateFrameRendering = register({
  name: "updateFrameRendering",
  label: "labels.updateFrameRendering",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState) => {
    return {
      elements,
      appState: {
        ...appState,
        frameRendering: {
          ...appState.frameRendering,
          enabled: !appState.frameRendering.enabled
        }
      },
      captureUpdate: CaptureUpdateAction32.EVENTUALLY
    };
  },
  checked: (appState) => appState.frameRendering.enabled
});
var actionSetFrameAsActiveTool = register({
  name: "setFrameAsActiveTool",
  label: "toolBar.frame",
  trackEvent: { category: "toolbar" },
  icon: frameToolIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool6(appState, {
      type: "frame"
    });
    setCursorForShape(app.interactiveCanvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool6(appState, {
          type: "frame"
        })
      },
      captureUpdate: CaptureUpdateAction32.EVENTUALLY
    };
  },
  keyTest: (event) => !event[KEYS41.CTRL_OR_CMD] && !event.shiftKey && !event.altKey && event.key.toLocaleLowerCase() === KEYS41.F
});
var actionWrapSelectionInFrame = register({
  name: "wrapSelectionInFrame",
  label: "labels.wrapSelectionInFrame",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length > 0 && !selectedElements.some((element) => isFrameLikeElement8(element));
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    const elementsMap = app.scene.getNonDeletedElementsMap();
    const [x1, y1, x2, y2] = getCommonBounds3(selectedElements, elementsMap);
    const PADDING = 16;
    const frame = newFrameElement({
      ...FRAME_STYLE2,
      x: x1 - PADDING,
      y: y1 - PADDING,
      width: x2 - x1 + PADDING * 2,
      height: y2 - y1 + PADDING * 2
    });
    if (appState.editingGroupId) {
      const elementsInGroup = getElementsInGroup4(
        selectedElements,
        appState.editingGroupId
      );
      for (const elementInGroup of elementsInGroup) {
        const index = elementInGroup.groupIds.indexOf(appState.editingGroupId);
        mutateElement4(elementInGroup, elementsMap, {
          groupIds: elementInGroup.groupIds.slice(0, index)
        });
      }
    }
    const nextElements = addElementsToFrame(
      [...app.scene.getElementsIncludingDeleted(), frame],
      selectedElements,
      frame,
      appState
    );
    return {
      elements: nextElements,
      appState: {
        selectedElementIds: { [frame.id]: true }
      },
      captureUpdate: CaptureUpdateAction32.IMMEDIATELY
    };
  }
});

// actions/actionHistory.tsx
import {
  isWindows,
  KEYS as KEYS42,
  matchKey,
  arrayToMap as arrayToMap21,
  MOBILE_ACTION_BUTTON_BG as MOBILE_ACTION_BUTTON_BG4
} from "@excalidraw/common";
import { CaptureUpdateAction as CaptureUpdateAction34 } from "@excalidraw/element";
import { orderByFractionalIndex } from "@excalidraw/element";

// history.ts
import { Emitter as Emitter2 } from "@excalidraw/common";
import {
  CaptureUpdateAction as CaptureUpdateAction33,
  StoreChange,
  StoreDelta
} from "@excalidraw/element";
var HistoryDelta = class extends StoreDelta {
  /**
   * Apply the delta to the passed elements and appState, does not modify the snapshot.
   */
  applyTo(elements, appState, snapshot) {
    const [nextElements, elementsContainVisibleChange] = this.elements.applyTo(
      elements,
      // used to fallback into local snapshot in case we couldn't apply the delta
      // due to a missing (force deleted) elements in the scene
      snapshot.elements,
      // we don't want to apply the `version` and `versionNonce` properties for history
      // as we always need to end up with a new version due to collaboration,
      // approaching each undo / redo as a new user action
      {
        excludedProperties: /* @__PURE__ */ new Set(["version", "versionNonce"])
      }
    );
    const [nextAppState, appStateContainsVisibleChange] = this.appState.applyTo(
      appState,
      nextElements
    );
    const appliedVisibleChanges = elementsContainVisibleChange || appStateContainsVisibleChange;
    return [nextElements, nextAppState, appliedVisibleChanges];
  }
  /**
   * Overriding once to avoid type casting everywhere.
   */
  static calculate(prevSnapshot, nextSnapshot) {
    return super.calculate(prevSnapshot, nextSnapshot);
  }
  /**
   * Overriding once to avoid type casting everywhere.
   */
  static inverse(delta) {
    return super.inverse(delta);
  }
  /**
   * Overriding once to avoid type casting everywhere.
   */
  static applyLatestChanges(delta, prevElements, nextElements, modifierOptions) {
    return super.applyLatestChanges(
      delta,
      prevElements,
      nextElements,
      modifierOptions
    );
  }
};
var HistoryChangedEvent = class {
  constructor(isUndoStackEmpty = true, isRedoStackEmpty = true) {
    this.isUndoStackEmpty = isUndoStackEmpty;
    this.isRedoStackEmpty = isRedoStackEmpty;
  }
};
var History = class _History {
  constructor(store) {
    this.store = store;
    __publicField(this, "onHistoryChangedEmitter", new Emitter2());
    __publicField(this, "undoStack", []);
    __publicField(this, "redoStack", []);
  }
  get isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  get isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  clear() {
    this.undoStack.length = 0;
    this.redoStack.length = 0;
  }
  /**
   * Record a non-empty local durable increment, which will go into the undo stack..
   * Do not re-record history entries, which were already pushed to undo / redo stack, as part of history action.
   */
  record(delta) {
    if (delta.isEmpty() || delta instanceof HistoryDelta) {
      return;
    }
    const historyDelta = HistoryDelta.inverse(delta);
    this.undoStack.push(historyDelta);
    if (!historyDelta.elements.isEmpty()) {
      this.redoStack.length = 0;
    }
    this.onHistoryChangedEmitter.trigger(
      new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
    );
  }
  undo(elements, appState) {
    return this.perform(
      elements,
      appState,
      () => _History.pop(this.undoStack),
      (entry) => _History.push(this.redoStack, entry)
    );
  }
  redo(elements, appState) {
    return this.perform(
      elements,
      appState,
      () => _History.pop(this.redoStack),
      (entry) => _History.push(this.undoStack, entry)
    );
  }
  perform(elements, appState, pop, push) {
    try {
      let historyDelta = pop();
      if (historyDelta === null) {
        return;
      }
      const action = CaptureUpdateAction33.IMMEDIATELY;
      let prevSnapshot = this.store.snapshot;
      let nextElements = elements;
      let nextAppState = appState;
      let containsVisibleChange = false;
      while (historyDelta) {
        try {
          [nextElements, nextAppState, containsVisibleChange] = historyDelta.applyTo(nextElements, nextAppState, prevSnapshot);
          const prevElements = prevSnapshot.elements;
          const nextSnapshot = prevSnapshot.maybeClone(
            action,
            nextElements,
            nextAppState
          );
          const change = StoreChange.create(prevSnapshot, nextSnapshot);
          const delta = HistoryDelta.applyLatestChanges(
            historyDelta,
            prevElements,
            nextElements
          );
          if (!delta.isEmpty()) {
            this.store.scheduleMicroAction({
              action,
              change,
              delta
            });
            historyDelta = delta;
          }
          prevSnapshot = nextSnapshot;
        } finally {
          push(historyDelta);
        }
        if (containsVisibleChange) {
          break;
        }
        historyDelta = pop();
      }
      return [nextElements, nextAppState];
    } finally {
      this.onHistoryChangedEmitter.trigger(
        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
      );
    }
  }
  static pop(stack) {
    if (!stack.length) {
      return null;
    }
    const entry = stack.pop();
    if (entry !== void 0) {
      return entry;
    }
    return null;
  }
  static push(stack, entry) {
    const inversedEntry = HistoryDelta.inverse(entry);
    return stack.push(inversedEntry);
  }
};

// hooks/useEmitter.ts
import { useEffect as useEffect27, useState as useState25 } from "react";
var useEmitter = (emitter, initialState) => {
  const [event, setEvent] = useState25(initialState);
  useEffect27(() => {
    const unsubscribe = emitter.on((event2) => {
      setEvent(event2);
    });
    return () => {
      unsubscribe();
    };
  }, [emitter]);
  return event;
};

// actions/actionHistory.tsx
import { jsx as jsx79 } from "react/jsx-runtime";
var executeHistoryAction = (app, appState, updater) => {
  if (!appState.multiElement && !appState.resizingElement && !appState.editingTextElement && !appState.newElement && !appState.selectedElementsAreBeingDragged && !appState.selectionElement && !app.flowChartCreator.isCreatingChart) {
    const result = updater();
    if (!result) {
      return { captureUpdate: CaptureUpdateAction34.EVENTUALLY };
    }
    const [nextElementsMap, nextAppState] = result;
    const nextElements = orderByFractionalIndex(
      Array.from(nextElementsMap.values())
    );
    return {
      appState: nextAppState,
      elements: nextElements,
      captureUpdate: CaptureUpdateAction34.NEVER
    };
  }
  return { captureUpdate: CaptureUpdateAction34.EVENTUALLY };
};
var createUndoAction = (history) => ({
  name: "undo",
  label: "buttons.undo",
  icon: UndoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, value, app) => executeHistoryAction(
    app,
    appState,
    () => history.undo(arrayToMap21(elements), appState)
  ),
  keyTest: (event) => event[KEYS42.CTRL_OR_CMD] && matchKey(event, KEYS42.Z) && !event.shiftKey,
  PanelComponent: ({ appState, updateData, data, app }) => {
    const { isUndoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    const isMobile = useStylesPanelMode() === "mobile";
    return /* @__PURE__ */ jsx79(
      ToolButton,
      {
        type: "button",
        icon: UndoIcon,
        "aria-label": t("buttons.undo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isUndoStackEmpty,
        "data-testid": "button-undo",
        style: {
          ...isMobile ? MOBILE_ACTION_BUTTON_BG4 : {}
        }
      }
    );
  }
});
var createRedoAction = (history) => ({
  name: "redo",
  label: "buttons.redo",
  icon: RedoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, __, app) => executeHistoryAction(
    app,
    appState,
    () => history.redo(arrayToMap21(elements), appState)
  ),
  keyTest: (event) => event[KEYS42.CTRL_OR_CMD] && event.shiftKey && matchKey(event, KEYS42.Z) || isWindows && event.ctrlKey && !event.shiftKey && matchKey(event, KEYS42.Y),
  PanelComponent: ({ appState, updateData, data, app }) => {
    const { isRedoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    const isMobile = useStylesPanelMode() === "mobile";
    return /* @__PURE__ */ jsx79(
      ToolButton,
      {
        type: "button",
        icon: RedoIcon,
        "aria-label": t("buttons.redo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isRedoStackEmpty,
        "data-testid": "button-redo",
        style: {
          ...isMobile ? MOBILE_ACTION_BUTTON_BG4 : {}
        }
      }
    );
  }
});

// actions/actionTextAutoResize.ts
import { getFontString as getFontString6 } from "@excalidraw/common";
import { newElementWith as newElementWith10 } from "@excalidraw/element";
import { measureText as measureText4 } from "@excalidraw/element";
import { isTextElement as isTextElement9 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction35 } from "@excalidraw/element";
var actionTextAutoResize = register({
  name: "autoResize",
  label: "labels.autoResize",
  icon: null,
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1 && isTextElement9(selectedElements[0]) && !selectedElements[0].autoResize;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return {
      appState,
      elements: elements.map((element) => {
        if (element.id === selectedElements[0].id && isTextElement9(element)) {
          const metrics = measureText4(
            element.originalText,
            getFontString6(element),
            element.lineHeight
          );
          return newElementWith10(element, {
            autoResize: true,
            width: metrics.width,
            height: metrics.height,
            text: element.originalText
          });
        }
        return element;
      }),
      captureUpdate: CaptureUpdateAction35.IMMEDIATELY
    };
  }
});

// actions/manager.tsx
import { isPromiseLike as isPromiseLike3 } from "@excalidraw/common";
import { jsx as jsx80 } from "react/jsx-runtime";
var trackAction = (action, source, appState, elements, app, value) => {
  if (action.trackEvent) {
    try {
      if (typeof action.trackEvent === "object") {
        const shouldTrack = action.trackEvent.predicate ? action.trackEvent.predicate(appState, elements, value) : true;
        if (shouldTrack) {
          trackEvent(
            action.trackEvent.category,
            action.trackEvent.action || action.name,
            `${source} (${app.editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
          );
        }
      }
    } catch (error) {
      console.error("error while logging action:", error);
    }
  }
};
var ActionManager = class {
  constructor(updater, getAppState, getElementsIncludingDeleted, app) {
    __publicField(this, "actions", {});
    __publicField(this, "updater");
    __publicField(this, "getAppState");
    __publicField(this, "getElementsIncludingDeleted");
    __publicField(this, "app");
    /**
     * @param data additional data sent to the PanelComponent
     */
    __publicField(this, "renderAction", (name, data) => {
      const canvasActions = this.app.props.UIOptions.canvasActions;
      if (this.actions[name] && "PanelComponent" in this.actions[name] && (name in canvasActions ? canvasActions[name] : true)) {
        const action = this.actions[name];
        const PanelComponent = action.PanelComponent;
        PanelComponent.displayName = "PanelComponent";
        const elements = this.getElementsIncludingDeleted();
        const appState = this.getAppState();
        const updateData = (formState) => {
          trackAction(action, "ui", appState, elements, this.app, formState);
          this.updater(
            action.perform(
              this.getElementsIncludingDeleted(),
              this.getAppState(),
              formState,
              this.app
            )
          );
        };
        return /* @__PURE__ */ jsx80(
          PanelComponent,
          {
            elements: this.getElementsIncludingDeleted(),
            appState: this.getAppState(),
            updateData,
            appProps: this.app.props,
            app: this.app,
            data,
            renderAction: this.renderAction
          }
        );
      }
      return null;
    });
    __publicField(this, "isActionEnabled", (action) => {
      const elements = this.getElementsIncludingDeleted();
      const appState = this.getAppState();
      return !action.predicate || action.predicate(elements, appState, this.app.props, this.app);
    });
    this.updater = (actionResult) => {
      if (isPromiseLike3(actionResult)) {
        actionResult.then((actionResult2) => {
          return updater(actionResult2);
        });
      } else {
        return updater(actionResult);
      }
    };
    this.getAppState = getAppState;
    this.getElementsIncludingDeleted = getElementsIncludingDeleted;
    this.app = app;
  }
  registerAction(action) {
    this.actions[action.name] = action;
  }
  registerAll(actions2) {
    actions2.forEach((action) => this.registerAction(action));
  }
  handleKeyDown(event) {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    const data = Object.values(this.actions).sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0)).filter(
      (action2) => (action2.name in canvasActions ? canvasActions[action2.name] : true) && action2.keyTest && action2.keyTest(
        event,
        this.getAppState(),
        this.getElementsIncludingDeleted(),
        this.app
      )
    );
    if (data.length !== 1) {
      if (data.length > 1) {
        console.warn("Canceling as multiple actions match this shortcut", data);
      }
      return false;
    }
    const action = data[0];
    if (this.getAppState().viewModeEnabled && action.viewMode !== true) {
      return false;
    }
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    const value = null;
    trackAction(action, "keyboard", appState, elements, this.app, null);
    event.preventDefault();
    event.stopPropagation();
    this.updater(data[0].perform(elements, appState, value, this.app));
    return true;
  }
  executeAction(action, source = "api", value = null) {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    trackAction(action, source, appState, elements, this.app, value);
    this.updater(action.perform(elements, appState, value, this.app));
  }
};

// animation-frame-handler.ts
var AnimationFrameHandler = class {
  constructor() {
    __publicField(this, "targets", /* @__PURE__ */ new WeakMap());
    __publicField(this, "rafIds", /* @__PURE__ */ new WeakMap());
  }
  register(key, callback) {
    this.targets.set(key, { callback, stopped: true });
  }
  start(key) {
    const target = this.targets.get(key);
    if (!target) {
      return;
    }
    if (this.rafIds.has(key)) {
      return;
    }
    this.targets.set(key, { ...target, stopped: false });
    this.scheduleFrame(key);
  }
  stop(key) {
    const target = this.targets.get(key);
    if (target && !target.stopped) {
      this.targets.set(key, { ...target, stopped: true });
    }
    this.cancelFrame(key);
  }
  constructFrame(key) {
    return (timestamp) => {
      const target = this.targets.get(key);
      if (!target) {
        return;
      }
      const shouldAbort = this.onFrame(target, timestamp);
      if (!target.stopped && !shouldAbort) {
        this.scheduleFrame(key);
      } else {
        this.cancelFrame(key);
      }
    };
  }
  scheduleFrame(key) {
    const rafId = requestAnimationFrame(this.constructFrame(key));
    this.rafIds.set(key, rafId);
  }
  cancelFrame(key) {
    if (this.rafIds.has(key)) {
      const rafId = this.rafIds.get(key);
      cancelAnimationFrame(rafId);
    }
    this.rafIds.delete(key);
  }
  onFrame(target, timestamp) {
    const shouldAbort = target.callback(timestamp);
    return shouldAbort ?? false;
  }
};

// gesture.ts
var getCenter = (pointers) => {
  const allCoords = Array.from(pointers.values());
  return {
    x: sum(allCoords, (coords) => coords.x) / allCoords.length,
    y: sum(allCoords, (coords) => coords.y) / allCoords.length
  };
};
var getDistance = ([a, b]) => Math.hypot(a.x - b.x, a.y - b.y);
var sum = (array, mapper) => array.reduce((acc, item) => acc + mapper(item), 0);

// snapping.ts
import {
  pointFrom as pointFrom20,
  pointRotateRads as pointRotateRads15,
  rangeInclusive as rangeInclusive2,
  rangeIntersection,
  rangesOverlap
} from "@excalidraw/math";
import { TOOL_TYPE, KEYS as KEYS43 } from "@excalidraw/common";
import {
  getCommonBounds as getCommonBounds4,
  getDraggedElementsBounds,
  getElementAbsoluteCoords as getElementAbsoluteCoords5
} from "@excalidraw/element";
import { isBoundToContainer as isBoundToContainer6 } from "@excalidraw/element";
import { getMaximumGroups } from "@excalidraw/element";
import {
  getSelectedElements as getSelectedElements4,
  getVisibleAndNonSelectedElements
} from "@excalidraw/element";
var SNAP_DISTANCE = 8;
var VISIBLE_GAPS_LIMIT_PER_AXIS = 99999;
var getSnapDistance = (zoomValue) => {
  return SNAP_DISTANCE / zoomValue;
};
var _SnapCache = class _SnapCache {
};
__publicField(_SnapCache, "referenceSnapPoints", null);
__publicField(_SnapCache, "visibleGaps", null);
__publicField(_SnapCache, "setReferenceSnapPoints", (snapPoints) => {
  _SnapCache.referenceSnapPoints = snapPoints;
});
__publicField(_SnapCache, "getReferenceSnapPoints", () => {
  return _SnapCache.referenceSnapPoints;
});
__publicField(_SnapCache, "setVisibleGaps", (gaps) => {
  _SnapCache.visibleGaps = gaps;
});
__publicField(_SnapCache, "getVisibleGaps", () => {
  return _SnapCache.visibleGaps;
});
__publicField(_SnapCache, "destroy", () => {
  _SnapCache.referenceSnapPoints = null;
  _SnapCache.visibleGaps = null;
});
var SnapCache = _SnapCache;
var isGridModeEnabled = (app) => app.props.gridModeEnabled ?? app.state.gridModeEnabled;
var isSnappingEnabled = ({
  event,
  app,
  selectedElements
}) => {
  if (event) {
    const isLassoDragging = app.state.activeTool.type === "lasso" && app.state.selectedElementsAreBeingDragged;
    return (app.state.activeTool.type !== "lasso" || isLassoDragging) && (app.state.objectsSnapModeEnabled && !event[KEYS43.CTRL_OR_CMD] || !app.state.objectsSnapModeEnabled && event[KEYS43.CTRL_OR_CMD] && !isGridModeEnabled(app));
  }
  if (selectedElements.length === 1 && selectedElements[0].type === "arrow") {
    return false;
  }
  return app.state.objectsSnapModeEnabled;
};
var areRoughlyEqual = (a, b, precision = 0.01) => {
  return Math.abs(a - b) <= precision;
};
var getElementsCorners = (elements, elementsMap, {
  omitCenter,
  boundingBoxCorners,
  dragOffset
} = {
  omitCenter: false,
  boundingBoxCorners: false
}) => {
  let result = [];
  if (elements.length === 1) {
    const element = elements[0];
    let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords5(
      element,
      elementsMap
    );
    if (dragOffset) {
      x1 += dragOffset.x;
      x2 += dragOffset.x;
      cx += dragOffset.x;
      y1 += dragOffset.y;
      y2 += dragOffset.y;
      cy += dragOffset.y;
    }
    const halfWidth = (x2 - x1) / 2;
    const halfHeight = (y2 - y1) / 2;
    if ((element.type === "diamond" || element.type === "ellipse") && !boundingBoxCorners) {
      const leftMid = pointRotateRads15(
        pointFrom20(x1, y1 + halfHeight),
        pointFrom20(cx, cy),
        element.angle
      );
      const topMid = pointRotateRads15(
        pointFrom20(x1 + halfWidth, y1),
        pointFrom20(cx, cy),
        element.angle
      );
      const rightMid = pointRotateRads15(
        pointFrom20(x2, y1 + halfHeight),
        pointFrom20(cx, cy),
        element.angle
      );
      const bottomMid = pointRotateRads15(
        pointFrom20(x1 + halfWidth, y2),
        pointFrom20(cx, cy),
        element.angle
      );
      const center = pointFrom20(cx, cy);
      result = omitCenter ? [leftMid, topMid, rightMid, bottomMid] : [leftMid, topMid, rightMid, bottomMid, center];
    } else {
      const topLeft = pointRotateRads15(
        pointFrom20(x1, y1),
        pointFrom20(cx, cy),
        element.angle
      );
      const topRight = pointRotateRads15(
        pointFrom20(x2, y1),
        pointFrom20(cx, cy),
        element.angle
      );
      const bottomLeft = pointRotateRads15(
        pointFrom20(x1, y2),
        pointFrom20(cx, cy),
        element.angle
      );
      const bottomRight = pointRotateRads15(
        pointFrom20(x2, y2),
        pointFrom20(cx, cy),
        element.angle
      );
      const center = pointFrom20(cx, cy);
      result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
    }
  } else if (elements.length > 1) {
    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
      elements,
      dragOffset ?? { x: 0, y: 0 }
    );
    const width = maxX - minX;
    const height = maxY - minY;
    const topLeft = pointFrom20(minX, minY);
    const topRight = pointFrom20(maxX, minY);
    const bottomLeft = pointFrom20(minX, maxY);
    const bottomRight = pointFrom20(maxX, maxY);
    const center = pointFrom20(minX + width / 2, minY + height / 2);
    result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
  }
  return result.map((p) => pointFrom20(round(p[0]), round(p[1])));
};
var getReferenceElements = (elements, selectedElements, appState, elementsMap) => getVisibleAndNonSelectedElements(
  elements,
  selectedElements,
  appState,
  elementsMap
);
var getVisibleGaps = (elements, selectedElements, appState, elementsMap) => {
  const referenceElements = getReferenceElements(
    elements,
    selectedElements,
    appState,
    elementsMap
  );
  const referenceBounds = getMaximumGroups(referenceElements, elementsMap).filter(
    (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer6(elementsGroup[0]))
  ).map(
    (group) => getCommonBounds4(group).map(
      (bound) => round(bound)
    )
  );
  const horizontallySorted = referenceBounds.sort((a, b) => a[0] - b[0]);
  const horizontalGaps = [];
  let c = 0;
  horizontal:
    for (let i = 0; i < horizontallySorted.length; i++) {
      const startBounds = horizontallySorted[i];
      for (let j = i + 1; j < horizontallySorted.length; j++) {
        if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
          break horizontal;
        }
        const endBounds = horizontallySorted[j];
        const [, startMinY, startMaxX, startMaxY] = startBounds;
        const [endMinX, endMinY, , endMaxY] = endBounds;
        if (startMaxX < endMinX && rangesOverlap(
          rangeInclusive2(startMinY, startMaxY),
          rangeInclusive2(endMinY, endMaxY)
        )) {
          horizontalGaps.push({
            startBounds,
            endBounds,
            startSide: [
              pointFrom20(startMaxX, startMinY),
              pointFrom20(startMaxX, startMaxY)
            ],
            endSide: [pointFrom20(endMinX, endMinY), pointFrom20(endMinX, endMaxY)],
            length: endMinX - startMaxX,
            overlap: rangeIntersection(
              rangeInclusive2(startMinY, startMaxY),
              rangeInclusive2(endMinY, endMaxY)
            )
          });
        }
      }
    }
  const verticallySorted = referenceBounds.sort((a, b) => a[1] - b[1]);
  const verticalGaps = [];
  c = 0;
  vertical:
    for (let i = 0; i < verticallySorted.length; i++) {
      const startBounds = verticallySorted[i];
      for (let j = i + 1; j < verticallySorted.length; j++) {
        if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
          break vertical;
        }
        const endBounds = verticallySorted[j];
        const [startMinX, , startMaxX, startMaxY] = startBounds;
        const [endMinX, endMinY, endMaxX] = endBounds;
        if (startMaxY < endMinY && rangesOverlap(
          rangeInclusive2(startMinX, startMaxX),
          rangeInclusive2(endMinX, endMaxX)
        )) {
          verticalGaps.push({
            startBounds,
            endBounds,
            startSide: [
              pointFrom20(startMinX, startMaxY),
              pointFrom20(startMaxX, startMaxY)
            ],
            endSide: [pointFrom20(endMinX, endMinY), pointFrom20(endMaxX, endMinY)],
            length: endMinY - startMaxY,
            overlap: rangeIntersection(
              rangeInclusive2(startMinX, startMaxX),
              rangeInclusive2(endMinX, endMaxX)
            )
          });
        }
      }
    }
  return {
    horizontalGaps,
    verticalGaps
  };
};
var getGapSnaps = (selectedElements, dragOffset, app, event, nearestSnapsX, nearestSnapsY, minOffset) => {
  if (!isSnappingEnabled({ app, event, selectedElements })) {
    return [];
  }
  if (selectedElements.length === 0) {
    return [];
  }
  const visibleGaps = SnapCache.getVisibleGaps();
  if (visibleGaps) {
    const { horizontalGaps, verticalGaps } = visibleGaps;
    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
      selectedElements,
      dragOffset
    ).map((bound) => round(bound));
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    for (const gap of horizontalGaps) {
      if (!rangesOverlap(rangeInclusive2(minY, maxY), gap.overlap)) {
        continue;
      }
      const gapMidX = gap.startSide[0][0] + gap.length / 2;
      const centerOffset = round(gapMidX - centerX);
      const gapIsLargerThanSelection = gap.length > maxX - minX;
      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.x) {
        if (Math.abs(centerOffset) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerOffset);
        const snap = {
          type: "gap",
          direction: "center_horizontal",
          gap,
          offset: centerOffset
        };
        nearestSnapsX.push(snap);
        continue;
      }
      const [, , endMaxX] = gap.endBounds;
      const distanceToEndElementX = minX - endMaxX;
      const sideOffsetRight = round(gap.length - distanceToEndElementX);
      if (Math.abs(sideOffsetRight) <= minOffset.x) {
        if (Math.abs(sideOffsetRight) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(sideOffsetRight);
        const snap = {
          type: "gap",
          direction: "side_right",
          gap,
          offset: sideOffsetRight
        };
        nearestSnapsX.push(snap);
        continue;
      }
      const [startMinX, , ,] = gap.startBounds;
      const distanceToStartElementX = startMinX - maxX;
      const sideOffsetLeft = round(distanceToStartElementX - gap.length);
      if (Math.abs(sideOffsetLeft) <= minOffset.x) {
        if (Math.abs(sideOffsetLeft) < minOffset.x) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(sideOffsetLeft);
        const snap = {
          type: "gap",
          direction: "side_left",
          gap,
          offset: sideOffsetLeft
        };
        nearestSnapsX.push(snap);
        continue;
      }
    }
    for (const gap of verticalGaps) {
      if (!rangesOverlap(rangeInclusive2(minX, maxX), gap.overlap)) {
        continue;
      }
      const gapMidY = gap.startSide[0][1] + gap.length / 2;
      const centerOffset = round(gapMidY - centerY);
      const gapIsLargerThanSelection = gap.length > maxY - minY;
      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.y) {
        if (Math.abs(centerOffset) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerOffset);
        const snap = {
          type: "gap",
          direction: "center_vertical",
          gap,
          offset: centerOffset
        };
        nearestSnapsY.push(snap);
        continue;
      }
      const [, startMinY, ,] = gap.startBounds;
      const distanceToStartElementY = startMinY - maxY;
      const sideOffsetTop = round(distanceToStartElementY - gap.length);
      if (Math.abs(sideOffsetTop) <= minOffset.y) {
        if (Math.abs(sideOffsetTop) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(sideOffsetTop);
        const snap = {
          type: "gap",
          direction: "side_top",
          gap,
          offset: sideOffsetTop
        };
        nearestSnapsY.push(snap);
        continue;
      }
      const [, , , endMaxY] = gap.endBounds;
      const distanceToEndElementY = round(minY - endMaxY);
      const sideOffsetBottom = gap.length - distanceToEndElementY;
      if (Math.abs(sideOffsetBottom) <= minOffset.y) {
        if (Math.abs(sideOffsetBottom) < minOffset.y) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(sideOffsetBottom);
        const snap = {
          type: "gap",
          direction: "side_bottom",
          gap,
          offset: sideOffsetBottom
        };
        nearestSnapsY.push(snap);
        continue;
      }
    }
  }
};
var getReferenceSnapPoints = (elements, selectedElements, appState, elementsMap) => {
  const referenceElements = getReferenceElements(
    elements,
    selectedElements,
    appState,
    elementsMap
  );
  return getMaximumGroups(referenceElements, elementsMap).filter(
    (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer6(elementsGroup[0]))
  ).flatMap((elementGroup) => getElementsCorners(elementGroup, elementsMap));
};
var getPointSnaps = (selectedElements, selectionSnapPoints, app, event, nearestSnapsX, nearestSnapsY, minOffset) => {
  if (!isSnappingEnabled({ app, event, selectedElements }) || selectedElements.length === 0 && selectionSnapPoints.length === 0) {
    return [];
  }
  const referenceSnapPoints = SnapCache.getReferenceSnapPoints();
  if (referenceSnapPoints) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of referenceSnapPoints) {
        const offsetX = otherSnapPoint[0] - thisSnapPoint[0];
        const offsetY = otherSnapPoint[1] - thisSnapPoint[1];
        if (Math.abs(offsetX) <= minOffset.x) {
          if (Math.abs(offsetX) < minOffset.x) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "point",
            points: [thisSnapPoint, otherSnapPoint],
            offset: offsetX
          });
          minOffset.x = Math.abs(offsetX);
        }
        if (Math.abs(offsetY) <= minOffset.y) {
          if (Math.abs(offsetY) < minOffset.y) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "point",
            points: [thisSnapPoint, otherSnapPoint],
            offset: offsetY
          });
          minOffset.y = Math.abs(offsetY);
        }
      }
    }
  }
};
var snapDraggedElements = (elements, dragOffset, app, event, elementsMap) => {
  const appState = app.state;
  const selectedElements = getSelectedElements4(elements, appState);
  if (!isSnappingEnabled({ app, event, selectedElements }) || selectedElements.length === 0) {
    return {
      snapOffset: {
        x: 0,
        y: 0
      },
      snapLines: []
    };
  }
  dragOffset.x = round(dragOffset.x);
  dragOffset.y = round(dragOffset.y);
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  const snapDistance = getSnapDistance(appState.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const selectionPoints = getElementsCorners(selectedElements, elementsMap, {
    dragOffset
  });
  getPointSnaps(
    selectedElements,
    selectionPoints,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  getGapSnaps(
    selectedElements,
    dragOffset,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const newDragOffset = {
    x: round(dragOffset.x + snapOffset.x),
    y: round(dragOffset.y + snapOffset.y)
  };
  getPointSnaps(
    selectedElements,
    getElementsCorners(selectedElements, elementsMap, {
      dragOffset: newDragOffset
    }),
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  getGapSnaps(
    selectedElements,
    newDragOffset,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  const gapSnapLines = createGapSnapLines(
    selectedElements,
    newDragOffset,
    [...nearestSnapsX, ...nearestSnapsY].filter(
      (snap) => snap.type === "gap"
    )
  );
  return {
    snapOffset,
    snapLines: [...pointSnapLines, ...gapSnapLines]
  };
};
var round = (x) => {
  const decimalPlaces = 6;
  return Math.round(x * 10 ** decimalPlaces) / 10 ** decimalPlaces;
};
var dedupePoints = (points) => {
  const map = /* @__PURE__ */ new Map();
  for (const point of points) {
    const key = point.join(",");
    if (!map.has(key)) {
      map.set(key, point);
    }
  }
  return Array.from(map.values());
};
var createPointSnapLines = (nearestSnapsX, nearestSnapsY) => {
  const snapsX = {};
  const snapsY = {};
  if (nearestSnapsX.length > 0) {
    for (const snap of nearestSnapsX) {
      if (snap.type === "point") {
        const key = round(snap.points[0][0]);
        if (!snapsX[key]) {
          snapsX[key] = [];
        }
        snapsX[key].push(
          ...snap.points.map(
            (p) => pointFrom20(round(p[0]), round(p[1]))
          )
        );
      }
    }
  }
  if (nearestSnapsY.length > 0) {
    for (const snap of nearestSnapsY) {
      if (snap.type === "point") {
        const key = round(snap.points[0][1]);
        if (!snapsY[key]) {
          snapsY[key] = [];
        }
        snapsY[key].push(
          ...snap.points.map(
            (p) => pointFrom20(round(p[0]), round(p[1]))
          )
        );
      }
    }
  }
  return Object.entries(snapsX).map(([key, points]) => {
    return {
      type: "points",
      points: dedupePoints(
        points.map((p) => {
          return pointFrom20(Number(key), p[1]);
        }).sort((a, b) => a[1] - b[1])
      )
    };
  }).concat(
    Object.entries(snapsY).map(([key, points]) => {
      return {
        type: "points",
        points: dedupePoints(
          points.map((p) => {
            return pointFrom20(p[0], Number(key));
          }).sort((a, b) => a[0] - b[0])
        )
      };
    })
  );
};
var dedupeGapSnapLines = (gapSnapLines) => {
  const map = /* @__PURE__ */ new Map();
  for (const gapSnapLine of gapSnapLines) {
    const key = gapSnapLine.points.flat().map((point) => [round(point)]).join(",");
    if (!map.has(key)) {
      map.set(key, gapSnapLine);
    }
  }
  return Array.from(map.values());
};
var createGapSnapLines = (selectedElements, dragOffset, gapSnaps) => {
  const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
    selectedElements,
    dragOffset
  );
  const gapSnapLines = [];
  for (const gapSnap of gapSnaps) {
    const [startMinX, startMinY, startMaxX, startMaxY] = gapSnap.gap.startBounds;
    const [endMinX, endMinY, endMaxX, endMaxY] = gapSnap.gap.endBounds;
    const verticalIntersection = rangeIntersection(
      rangeInclusive2(minY, maxY),
      gapSnap.gap.overlap
    );
    const horizontalGapIntersection = rangeIntersection(
      rangeInclusive2(minX, maxX),
      gapSnap.gap.overlap
    );
    switch (gapSnap.direction) {
      case "center_horizontal": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                pointFrom20(gapSnap.gap.startSide[0][0], gapLineY),
                pointFrom20(minX, gapLineY)
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [
                pointFrom20(maxX, gapLineY),
                pointFrom20(gapSnap.gap.endSide[0][0], gapLineY)
              ]
            }
          );
        }
        break;
      }
      case "center_vertical": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                pointFrom20(gapLineX, gapSnap.gap.startSide[0][1]),
                pointFrom20(gapLineX, minY)
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [
                pointFrom20(gapLineX, maxY),
                pointFrom20(gapLineX, gapSnap.gap.endSide[0][1])
              ]
            }
          );
        }
        break;
      }
      case "side_right": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                pointFrom20(startMaxX, gapLineY),
                pointFrom20(endMinX, gapLineY)
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [pointFrom20(endMaxX, gapLineY), pointFrom20(minX, gapLineY)]
            }
          );
        }
        break;
      }
      case "side_left": {
        if (verticalIntersection) {
          const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "horizontal",
              points: [
                pointFrom20(maxX, gapLineY),
                pointFrom20(startMinX, gapLineY)
              ]
            },
            {
              type: "gap",
              direction: "horizontal",
              points: [
                pointFrom20(startMaxX, gapLineY),
                pointFrom20(endMinX, gapLineY)
              ]
            }
          );
        }
        break;
      }
      case "side_top": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                pointFrom20(gapLineX, maxY),
                pointFrom20(gapLineX, startMinY)
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [
                pointFrom20(gapLineX, startMaxY),
                pointFrom20(gapLineX, endMinY)
              ]
            }
          );
        }
        break;
      }
      case "side_bottom": {
        if (horizontalGapIntersection) {
          const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
          gapSnapLines.push(
            {
              type: "gap",
              direction: "vertical",
              points: [
                pointFrom20(gapLineX, startMaxY),
                pointFrom20(gapLineX, endMinY)
              ]
            },
            {
              type: "gap",
              direction: "vertical",
              points: [pointFrom20(gapLineX, endMaxY), pointFrom20(gapLineX, minY)]
            }
          );
        }
        break;
      }
    }
  }
  return dedupeGapSnapLines(
    gapSnapLines.map((gapSnapLine) => {
      return {
        ...gapSnapLine,
        points: gapSnapLine.points.map(
          (p) => pointFrom20(round(p[0]), round(p[1]))
        )
      };
    })
  );
};
var snapResizingElements = (selectedElements, selectedOriginalElements, app, event, dragOffset, transformHandle) => {
  if (!isSnappingEnabled({ event, selectedElements, app }) || selectedElements.length === 0 || selectedElements.length === 1 && !areRoughlyEqual(selectedElements[0].angle, 0)) {
    return {
      snapOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  let [minX, minY, maxX, maxY] = getCommonBounds4(selectedOriginalElements);
  if (transformHandle) {
    if (transformHandle.includes("e")) {
      maxX += dragOffset.x;
    } else if (transformHandle.includes("w")) {
      minX += dragOffset.x;
    }
    if (transformHandle.includes("n")) {
      minY += dragOffset.y;
    } else if (transformHandle.includes("s")) {
      maxY += dragOffset.y;
    }
  }
  const selectionSnapPoints = [];
  if (transformHandle) {
    switch (transformHandle) {
      case "e": {
        selectionSnapPoints.push(pointFrom20(maxX, minY), pointFrom20(maxX, maxY));
        break;
      }
      case "w": {
        selectionSnapPoints.push(pointFrom20(minX, minY), pointFrom20(minX, maxY));
        break;
      }
      case "n": {
        selectionSnapPoints.push(pointFrom20(minX, minY), pointFrom20(maxX, minY));
        break;
      }
      case "s": {
        selectionSnapPoints.push(pointFrom20(minX, maxY), pointFrom20(maxX, maxY));
        break;
      }
      case "ne": {
        selectionSnapPoints.push(pointFrom20(maxX, minY));
        break;
      }
      case "nw": {
        selectionSnapPoints.push(pointFrom20(minX, minY));
        break;
      }
      case "se": {
        selectionSnapPoints.push(pointFrom20(maxX, maxY));
        break;
      }
      case "sw": {
        selectionSnapPoints.push(pointFrom20(minX, maxY));
        break;
      }
    }
  }
  const snapDistance = getSnapDistance(app.state.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  getPointSnaps(
    selectedOriginalElements,
    selectionSnapPoints,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const [x1, y1, x2, y2] = getCommonBounds4(selectedElements).map(
    (bound) => round(bound)
  );
  const corners = [
    pointFrom20(x1, y1),
    pointFrom20(x1, y2),
    pointFrom20(x2, y1),
    pointFrom20(x2, y2)
  ];
  getPointSnaps(
    selectedElements,
    corners,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  return {
    snapOffset,
    snapLines: pointSnapLines
  };
};
var snapNewElement = (newElement5, app, event, origin, dragOffset, elementsMap) => {
  if (!isSnappingEnabled({ event, selectedElements: [newElement5], app })) {
    return {
      snapOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  const selectionSnapPoints = [
    pointFrom20(origin.x + dragOffset.x, origin.y + dragOffset.y)
  ];
  const snapDistance = getSnapDistance(app.state.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const nearestSnapsX = [];
  const nearestSnapsY = [];
  getPointSnaps(
    [newElement5],
    selectionSnapPoints,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const snapOffset = {
    x: nearestSnapsX[0]?.offset ?? 0,
    y: nearestSnapsY[0]?.offset ?? 0
  };
  minOffset.x = 0;
  minOffset.y = 0;
  nearestSnapsX.length = 0;
  nearestSnapsY.length = 0;
  const corners = getElementsCorners([newElement5], elementsMap, {
    boundingBoxCorners: true,
    omitCenter: true
  });
  getPointSnaps(
    [newElement5],
    corners,
    app,
    event,
    nearestSnapsX,
    nearestSnapsY,
    minOffset
  );
  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
  return {
    snapOffset,
    snapLines: pointSnapLines
  };
};
var getSnapLinesAtPointer = (elements, app, pointer, event, elementsMap) => {
  if (!isSnappingEnabled({ event, selectedElements: [], app })) {
    return {
      originOffset: { x: 0, y: 0 },
      snapLines: []
    };
  }
  const referenceElements = getVisibleAndNonSelectedElements(
    elements,
    [],
    app.state,
    elementsMap
  );
  const snapDistance = getSnapDistance(app.state.zoom.value);
  const minOffset = {
    x: snapDistance,
    y: snapDistance
  };
  const horizontalSnapLines = [];
  const verticalSnapLines = [];
  for (const referenceElement of referenceElements) {
    const corners = getElementsCorners([referenceElement], elementsMap);
    for (const corner of corners) {
      const offsetX = corner[0] - pointer.x;
      if (Math.abs(offsetX) <= Math.abs(minOffset.x)) {
        if (Math.abs(offsetX) < Math.abs(minOffset.x)) {
          verticalSnapLines.length = 0;
        }
        verticalSnapLines.push({
          type: "pointer",
          points: [corner, pointFrom20(corner[0], pointer.y)],
          direction: "vertical"
        });
        minOffset.x = offsetX;
      }
      const offsetY = corner[1] - pointer.y;
      if (Math.abs(offsetY) <= Math.abs(minOffset.y)) {
        if (Math.abs(offsetY) < Math.abs(minOffset.y)) {
          horizontalSnapLines.length = 0;
        }
        horizontalSnapLines.push({
          type: "pointer",
          points: [corner, pointFrom20(pointer.x, corner[1])],
          direction: "horizontal"
        });
        minOffset.y = offsetY;
      }
    }
  }
  return {
    originOffset: {
      x: verticalSnapLines.length > 0 ? verticalSnapLines[0].points[0][0] - pointer.x : 0,
      y: horizontalSnapLines.length > 0 ? horizontalSnapLines[0].points[0][1] - pointer.y : 0
    },
    snapLines: [...verticalSnapLines, ...horizontalSnapLines]
  };
};
var isActiveToolNonLinearSnappable = (activeToolType) => {
  return activeToolType === TOOL_TYPE.rectangle || activeToolType === TOOL_TYPE.ellipse || activeToolType === TOOL_TYPE.diamond || activeToolType === TOOL_TYPE.frame || activeToolType === TOOL_TYPE.magicframe || activeToolType === TOOL_TYPE.image || activeToolType === TOOL_TYPE.text;
};

// scene/Renderer.ts
import { isElementInViewport as isElementInViewport2 } from "@excalidraw/element";
import { memoize, toBrandedType } from "@excalidraw/common";
var Renderer = class {
  constructor(scene) {
    __publicField(this, "scene");
    __publicField(this, "getRenderableElements", (() => {
      const getVisibleCanvasElements = ({
        elementsMap,
        zoom,
        offsetLeft,
        offsetTop,
        scrollX,
        scrollY,
        height,
        width
      }) => {
        const visibleElements = [];
        for (const element of elementsMap.values()) {
          if (isElementInViewport2(
            element,
            width,
            height,
            {
              zoom,
              offsetLeft,
              offsetTop,
              scrollX,
              scrollY
            },
            elementsMap
          )) {
            visibleElements.push(element);
          }
        }
        return visibleElements;
      };
      const getRenderableElements = ({
        elements,
        editingTextElement,
        newElementId
      }) => {
        const elementsMap = toBrandedType(/* @__PURE__ */ new Map());
        for (const element of elements) {
          if (newElementId === element.id) {
            continue;
          }
          if (!editingTextElement || editingTextElement.type !== "text" || element.id !== editingTextElement.id) {
            elementsMap.set(element.id, element);
          }
        }
        return elementsMap;
      };
      return memoize(
        ({
          zoom,
          offsetLeft,
          offsetTop,
          scrollX,
          scrollY,
          height,
          width,
          editingTextElement,
          newElementId,
          // cache-invalidation nonce
          sceneNonce: _sceneNonce
        }) => {
          const elements = this.scene.getNonDeletedElements();
          const elementsMap = getRenderableElements({
            elements,
            editingTextElement,
            newElementId
          });
          const visibleElements = getVisibleCanvasElements({
            elementsMap,
            zoom,
            offsetLeft,
            offsetTop,
            scrollX,
            scrollY,
            height,
            width
          });
          return { elementsMap, visibleElements };
        }
      );
    })());
    this.scene = scene;
  }
  // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be
  // safe to break TS contract here (for upstream cases)
  destroy() {
    renderStaticSceneThrottled.cancel();
    this.getRenderableElements.clear();
  }
};

// components/ElementCanvasButtons.tsx
import { sceneCoordsToViewportCoords as sceneCoordsToViewportCoords3 } from "@excalidraw/common";
import { getElementAbsoluteCoords as getElementAbsoluteCoords6 } from "@excalidraw/element";
import { jsx as jsx81 } from "react/jsx-runtime";
var CONTAINER_PADDING = 5;
var getContainerCoords2 = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords6(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords3(
    { sceneX: x1 + element.width, sceneY: y1 },
    appState
  );
  const x = viewportX - appState.offsetLeft + 10;
  const y = viewportY - appState.offsetTop;
  return { x, y };
};
var ElementCanvasButtons = ({
  children,
  element,
  elementsMap
}) => {
  const appState = useExcalidrawAppState();
  if (appState.contextMenu || appState.newElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  const { x, y } = getContainerCoords2(element, appState, elementsMap);
  return /* @__PURE__ */ jsx81(
    "div",
    {
      className: "excalidraw-canvas-buttons",
      style: {
        top: `${y}px`,
        left: `${x}px`,
        // width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING
      },
      children
    }
  );
};

// components/QuickAddHandles/QuickAddHandles.tsx
import { useCallback as useCallback14, useRef as useRef24, useState as useState26 } from "react";
import { COLOR_PALETTE as COLOR_PALETTE6 } from "@excalidraw/common";

// components/QuickAddHandles/utils.ts
import { pointFrom as pointFrom21, pointRotateRads as pointRotateRads16 } from "@excalidraw/math";
import { sceneCoordsToViewportCoords as sceneCoordsToViewportCoords4 } from "@excalidraw/common";
import { isTextElement as isTextElement10 } from "@excalidraw/element";
var HANDLE_OFFSET_FACTOR = 0.12;
var HANDLE_OFFSET_MIN = 8;
var BUFFER_ZONE_THICKNESS = 22;
function isQuickAddHandleSupported(element) {
  if (element.locked)
    return false;
  if (element.type === "rectangle") {
    return true;
  }
  if (element.type === "diamond" || element.type === "ellipse") {
    return true;
  }
  return false;
}
function getQuickAddOriginShape(selectedElement, elementsMap) {
  const container = isTextElement10(selectedElement) && selectedElement.containerId ? elementsMap.get(selectedElement.containerId) ?? null : null;
  const shape = container ?? selectedElement;
  return isQuickAddHandleSupported(shape) ? shape : null;
}
function getQuickAddHandleOffset(element) {
  return Math.max(
    HANDLE_OFFSET_MIN,
    HANDLE_OFFSET_FACTOR * Math.min(element.width, element.height)
  );
}
function getLocalHandlePositions(width, height, offset) {
  const halfW = width / 2;
  const halfH = height / 2;
  return {
    top: [halfW, -offset],
    right: [width + offset, halfH],
    bottom: [halfW, height + offset],
    left: [-offset, halfH]
  };
}
function getQuickAddHandlePositions(element, appState) {
  const { width, height, angle } = element;
  const offset = getQuickAddHandleOffset(element);
  const centerLocal = [width / 2, height / 2];
  const centerSceneX = element.x + centerLocal[0];
  const centerSceneY = element.y + centerLocal[1];
  const localPositions = getLocalHandlePositions(width, height, offset);
  const sides = ["top", "right", "bottom", "left"];
  const viewportWidth = appState.width;
  const viewportHeight = appState.height;
  const handleRadius = 6;
  const bufferThickness = BUFFER_ZONE_THICKNESS;
  return sides.map((side) => {
    const [lx, ly] = localPositions[side];
    const rotated = pointRotateRads16(
      pointFrom21(element.x + lx, element.y + ly),
      pointFrom21(centerSceneX, centerSceneY),
      angle ?? 0
    );
    const sx = rotated[0];
    const sy = rotated[1];
    const { x: vx, y: vy } = sceneCoordsToViewportCoords4(
      { sceneX: sx, sceneY: sy },
      appState
    );
    const relX = vx - appState.offsetLeft;
    const relY = vy - appState.offsetTop;
    const clampedX = Math.max(
      handleRadius,
      Math.min(viewportWidth - handleRadius, relX)
    );
    const clampedY = Math.max(
      handleRadius,
      Math.min(viewportHeight - handleRadius, relY)
    );
    return {
      side,
      x: clampedX,
      y: clampedY,
      radius: handleRadius,
      bufferThickness
    };
  });
}

// components/QuickAddHandles/QuickAddHandles.tsx
import { jsx as jsx82, jsxs as jsxs44 } from "react/jsx-runtime";
var QUICK_ADD_HANDLE_BLUE = COLOR_PALETTE6.blue[2];
var TOOLTIP_DELAY_MS = 300;
var TOOLTIP_LABEL = "Add shape";
function Handle({
  position,
  originShapeId,
  onActivate
}) {
  const [hoveredOrFocused, setHoveredOrFocused] = useState26(false);
  const tooltipTimerRef = useRef24(null);
  const handleRef = useRef24(null);
  const showTooltip = useCallback14(() => {
    const tooltip = getTooltipDiv();
    tooltip.classList.add("excalidraw-tooltip--visible");
    tooltip.textContent = TOOLTIP_LABEL;
    if (handleRef.current) {
      const rect = handleRef.current.getBoundingClientRect();
      updateTooltipPosition(tooltip, rect, "top");
    }
  }, []);
  const hideTooltip = useCallback14(() => {
    tooltipTimerRef.current && clearTimeout(tooltipTimerRef.current);
    tooltipTimerRef.current = null;
    getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }, []);
  const scheduleTooltip = useCallback14(() => {
    tooltipTimerRef.current = setTimeout(showTooltip, TOOLTIP_DELAY_MS);
  }, [showTooltip]);
  const handlePointerEnter = useCallback14(() => {
    setHoveredOrFocused(true);
    scheduleTooltip();
  }, [scheduleTooltip]);
  const handlePointerLeave = useCallback14(() => {
    setHoveredOrFocused(false);
    hideTooltip();
  }, [hideTooltip]);
  const handleFocus = useCallback14(() => {
    setHoveredOrFocused(true);
    scheduleTooltip();
  }, [scheduleTooltip]);
  const handleBlur = useCallback14(() => {
    setHoveredOrFocused(false);
    hideTooltip();
  }, [hideTooltip]);
  const handleKeyDown = useCallback14(
    (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onActivate(position.side, originShapeId);
      }
    },
    [onActivate, position.side, originShapeId]
  );
  const handlePointerDown = useCallback14(
    (e) => {
      e.preventDefault();
      e.stopPropagation();
    },
    []
  );
  const handleClick = useCallback14(
    (e) => {
      e.preventDefault();
      e.stopPropagation();
      onActivate(position.side, originShapeId);
    },
    [onActivate, position.side, originShapeId]
  );
  const { x, y, radius, bufferThickness } = position;
  const hitSize = Math.max(radius * 2 + bufferThickness, 44);
  const left = x - hitSize / 2;
  const top = y - hitSize / 2;
  return /* @__PURE__ */ jsxs44(
    "button",
    {
      ref: handleRef,
      type: "button",
      className: "quick-add-handle",
      style: {
        left: `${left}px`,
        top: `${top}px`,
        width: hitSize,
        height: hitSize
      },
      onPointerDown: handlePointerDown,
      onPointerEnter: handlePointerEnter,
      onPointerLeave: handlePointerLeave,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onClick: handleClick,
      "aria-label": TOOLTIP_LABEL,
      title: TOOLTIP_LABEL,
      children: [
        /* @__PURE__ */ jsx82(
          "span",
          {
            className: "quick-add-handle__hit",
            style: {
              width: hitSize,
              height: hitSize
            }
          }
        ),
        /* @__PURE__ */ jsxs44(
          "span",
          {
            className: `quick-add-handle__icon ${hoveredOrFocused ? "quick-add-handle__icon--plus" : ""}`,
            style: {
              width: radius * 2,
              height: radius * 2,
              marginLeft: -radius,
              marginTop: -radius
            },
            children: [
              /* @__PURE__ */ jsx82("span", { className: "quick-add-handle__circle" }),
              /* @__PURE__ */ jsx82("span", { className: "quick-add-handle__plus", "aria-hidden": true, children: /* @__PURE__ */ jsxs44("svg", { width: "24", height: "24", viewBox: "0 0 14 14", fill: "none", children: [
                /* @__PURE__ */ jsx82(
                  "circle",
                  {
                    cx: "7",
                    cy: "7",
                    r: "5.5",
                    stroke: "currentColor",
                    strokeWidth: "1.75",
                    fill: "none"
                  }
                ),
                /* @__PURE__ */ jsx82(
                  "path",
                  {
                    d: "M7 4.5v5M4.5 7h5",
                    stroke: "currentColor",
                    strokeWidth: "1.75",
                    strokeLinecap: "square"
                  }
                )
              ] }) })
            ]
          }
        )
      ]
    }
  );
}
function QuickAddHandles({
  originShape,
  appState,
  onActivate
}) {
  const positions = getQuickAddHandlePositions(originShape, appState);
  return /* @__PURE__ */ jsx82(
    "div",
    {
      className: "quick-add-handles",
      "aria-hidden": true,
      style: { "--quick-add-handle-color": QUICK_ADD_HANDLE_BLUE },
      children: positions.map((pos) => /* @__PURE__ */ jsx82(
        Handle,
        {
          position: pos,
          originShapeId: originShape.id,
          onActivate
        },
        pos.side
      ))
    }
  );
}

// laser-trails.ts
import { DEFAULT_LASER_COLOR, easeOut } from "@excalidraw/common";

// animated-trail.ts
import { LaserPointer } from "@excalidraw/laser-pointer";
import {
  SVG_NS,
  getSvgPathFromStroke as getSvgPathFromStroke2,
  sceneCoordsToViewportCoords as sceneCoordsToViewportCoords5
} from "@excalidraw/common";
var AnimatedTrail = class {
  constructor(animationFrameHandler, app, options) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.options = options;
    __publicField(this, "currentTrail");
    __publicField(this, "pastTrails", []);
    __publicField(this, "container");
    __publicField(this, "trailElement");
    __publicField(this, "trailAnimation");
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.trailElement = document.createElementNS(SVG_NS, "path");
    if (this.options.animateTrail) {
      this.trailAnimation = document.createElementNS(SVG_NS, "animate");
      this.trailAnimation.setAttribute("attributeName", "stroke-dashoffset");
      this.trailElement.setAttribute("stroke-dasharray", "7 7");
      this.trailElement.setAttribute("stroke-dashoffset", "10");
      this.trailAnimation.setAttribute("from", "0");
      this.trailAnimation.setAttribute("to", `-14`);
      this.trailAnimation.setAttribute("dur", "0.3s");
      this.trailElement.appendChild(this.trailAnimation);
    }
  }
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(x, y) {
    if (this.currentTrail) {
      const len = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[len - 1][0] === x && this.currentTrail.originalPoints[len - 1][1] === y;
    }
    return false;
  }
  start(container) {
    if (container) {
      this.container = container;
    }
    if (this.trailElement.parentNode !== this.container && this.container) {
      this.container.appendChild(this.trailElement);
    }
    this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    if (this.trailElement.parentNode === this.container) {
      this.container?.removeChild(this.trailElement);
    }
  }
  startPath(x, y) {
    this.currentTrail = new LaserPointer(this.options);
    this.currentTrail.addPoint([x, y, performance.now()]);
    this.update();
  }
  addPointToPath(x, y) {
    if (this.currentTrail) {
      this.currentTrail.addPoint([x, y, performance.now()]);
      this.update();
    }
  }
  endPath() {
    if (this.currentTrail) {
      this.currentTrail.close();
      this.currentTrail.options.keepHead = false;
      this.pastTrails.push(this.currentTrail);
      this.currentTrail = void 0;
      this.update();
    }
  }
  getCurrentTrail() {
    return this.currentTrail;
  }
  clearTrails() {
    this.pastTrails = [];
    this.currentTrail = void 0;
    this.update();
  }
  update() {
    this.start();
    if (this.trailAnimation) {
      this.trailAnimation.setAttribute("begin", "indefinite");
      this.trailAnimation.setAttribute("repeatCount", "indefinite");
    }
  }
  onFrame() {
    const paths = [];
    for (const trail of this.pastTrails) {
      paths.push(this.drawTrail(trail, this.app.state));
    }
    if (this.currentTrail) {
      const currentPath = this.drawTrail(this.currentTrail, this.app.state);
      paths.push(currentPath);
    }
    this.pastTrails = this.pastTrails.filter((trail) => {
      return trail.getStrokeOutline().length !== 0;
    });
    if (paths.length === 0) {
      this.stop();
    }
    const svgPaths = paths.join(" ").trim();
    this.trailElement.setAttribute("d", svgPaths);
    if (this.trailAnimation) {
      this.trailElement.setAttribute(
        "fill",
        (this.options.fill ?? (() => "black"))(this)
      );
      this.trailElement.setAttribute(
        "stroke",
        (this.options.stroke ?? (() => "black"))(this)
      );
    } else {
      this.trailElement.setAttribute(
        "fill",
        (this.options.fill ?? (() => "black"))(this)
      );
    }
  }
  drawTrail(trail, state) {
    const _stroke = trail.getStrokeOutline(trail.options.size / state.zoom.value).map(([x, y]) => {
      const result = sceneCoordsToViewportCoords5(
        { sceneX: x, sceneY: y },
        state
      );
      return [result.x, result.y];
    });
    const stroke = this.trailAnimation ? _stroke.slice(0, _stroke.length / 2) : _stroke;
    return getSvgPathFromStroke2(stroke, true);
  }
};

// laser-trails.ts
var LaserTrails = class {
  constructor(animationFrameHandler, app) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    __publicField(this, "localTrail");
    __publicField(this, "collabTrails", /* @__PURE__ */ new Map());
    __publicField(this, "container");
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
      ...this.getTrailOptions(),
      fill: () => DEFAULT_LASER_COLOR
    });
  }
  getTrailOptions() {
    return {
      simplify: 0,
      streamline: 0.4,
      sizeMapping: (c) => {
        const DECAY_TIME = 1e3;
        const DECAY_LENGTH = 50;
        const t2 = Math.max(
          0,
          1 - (performance.now() - c.pressure) / DECAY_TIME
        );
        const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut(l), easeOut(t2));
      }
    };
  }
  startPath(x, y) {
    this.localTrail.startPath(x, y);
  }
  addPointToPath(x, y) {
    this.localTrail.addPointToPath(x, y);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(container) {
    this.container = container;
    this.animationFrameHandler.start(this);
    this.localTrail.start(container);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!this.container || this.app.state.collaborators.size === 0) {
      return;
    }
    for (const [key, collaborator] of this.app.state.collaborators.entries()) {
      let trail;
      if (!this.collabTrails.has(key)) {
        trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
          ...this.getTrailOptions(),
          fill: () => collaborator.pointer?.laserColor || getClientColor(key, collaborator)
        });
        trail.start(this.container);
        this.collabTrails.set(key, trail);
      } else {
        trail = this.collabTrails.get(key);
      }
      if (collaborator.pointer && collaborator.pointer.tool === "laser") {
        if (collaborator.button === "down" && !trail.hasCurrentTrail) {
          trail.startPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "down" && trail.hasCurrentTrail && !trail.hasLastPoint(collaborator.pointer.x, collaborator.pointer.y)) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "up" && trail.hasCurrentTrail) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
          trail.endPath();
        }
      }
    }
    for (const key of this.collabTrails.keys()) {
      if (!this.app.state.collaborators.has(key)) {
        const trail = this.collabTrails.get(key);
        trail.stop();
        this.collabTrails.delete(key);
      }
    }
  }
};

// reactUtils.ts
import { version as ReactVersion } from "react";
import { unstable_batchedUpdates } from "react-dom";
import { throttleRAF } from "@excalidraw/common";
var withBatchedUpdates = (func) => (event) => {
  unstable_batchedUpdates(func, event);
};
var withBatchedUpdatesThrottled = (func) => {
  return throttleRAF((event) => {
    unstable_batchedUpdates(func, event);
  });
};
var isRenderThrottlingEnabled = (() => {
  let IS_REACT_18_AND_UP;
  try {
    const version = ReactVersion.split(".");
    IS_REACT_18_AND_UP = Number(version[0]) > 17;
  } catch {
    IS_REACT_18_AND_UP = false;
  }
  let hasWarned = false;
  return () => {
    if (window.EXCALIDRAW_THROTTLE_RENDER === true) {
      if (!IS_REACT_18_AND_UP) {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(
            "Excalidraw: render throttling is disabled on React versions < 18."
          );
        }
        return false;
      }
      return true;
    }
    return false;
  };
})();

// wysiwyg/textWysiwyg.tsx
import {
  CODES as CODES12,
  KEYS as KEYS44,
  CLASSES as CLASSES7,
  POINTER_BUTTON,
  THEME as THEME11,
  VERTICAL_ALIGN as VERTICAL_ALIGN5,
  isWritableElement as isWritableElement4,
  getFontString as getFontString7,
  getFontFamilyString as getFontFamilyString3,
  isTestEnv as isTestEnv4,
  MIME_TYPES as MIME_TYPES8,
  applyDarkModeFilter as applyDarkModeFilter3
} from "@excalidraw/common";
import {
  getTextFromElements as getTextFromElements2,
  originalContainerCache,
  updateBoundElements as updateBoundElements2,
  updateOriginalContainerCache as updateOriginalContainerCache3
} from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor8 } from "@excalidraw/element";
import { bumpVersion as bumpVersion2 } from "@excalidraw/element";
import {
  getBoundTextElementId,
  getContainerCoords as getContainerCoords3,
  getContainerElement as getContainerElement5,
  getTextElementAngle,
  redrawTextBoundingBox as redrawTextBoundingBox5,
  getBoundTextMaxHeight as getBoundTextMaxHeight3,
  getBoundTextMaxWidth as getBoundTextMaxWidth3,
  computeContainerDimensionForBoundText as computeContainerDimensionForBoundText2,
  computeBoundTextPosition as computeBoundTextPosition2,
  getBoundTextElement as getBoundTextElement6
} from "@excalidraw/element";
import { getLineHeightInPx as getLineHeightInPx2, getTextWidth } from "@excalidraw/element";
import { normalizeText } from "@excalidraw/element";
import { wrapText as wrapText3 } from "@excalidraw/element";
import {
  isArrowElement as isArrowElement9,
  isBoundToContainer as isBoundToContainer7,
  isTextElement as isTextElement11
} from "@excalidraw/element";
var getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {
  const { zoom } = appState;
  const degree = 180 * angle / Math.PI;
  let translateX = width * (zoom.value - 1) / 2;
  let translateY = height * (zoom.value - 1) / 2;
  if (width > maxWidth && zoom.value !== 1) {
    translateX = maxWidth * (zoom.value - 1) / 2;
  }
  if (height > maxHeight && zoom.value !== 1) {
    translateY = maxHeight * (zoom.value - 1) / 2;
  }
  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;
};
var textWysiwyg = ({
  id,
  onChange,
  onSubmit,
  getViewportCoords,
  element,
  canvas,
  excalidrawContainer,
  app,
  autoSelect = true,
  placeholder = ""
}) => {
  const textPropertiesUpdated = (updatedTextElement, editable2) => {
    if (!editable2.style.fontFamily || !editable2.style.fontSize) {
      return false;
    }
    const currentFont = editable2.style.fontFamily.replace(/"/g, "");
    if (getFontFamilyString3({ fontFamily: updatedTextElement.fontFamily }) !== currentFont) {
      return true;
    }
    if (`${updatedTextElement.fontSize}px` !== editable2.style.fontSize) {
      return true;
    }
    return false;
  };
  let LAST_THEME = app.state.theme;
  const updateWysiwygStyle = () => {
    LAST_THEME = app.state.theme;
    const appState = app.state;
    const updatedTextElement = app.scene.getElement(id);
    if (!updatedTextElement) {
      return;
    }
    const { textAlign, verticalAlign } = updatedTextElement;
    const elementsMap = app.scene.getNonDeletedElementsMap();
    if (updatedTextElement && isTextElement11(updatedTextElement)) {
      let coordX = updatedTextElement.x;
      let coordY = updatedTextElement.y;
      const container = getContainerElement5(
        updatedTextElement,
        app.scene.getNonDeletedElementsMap()
      );
      let width = updatedTextElement.width;
      let height = updatedTextElement.height;
      let maxWidth = updatedTextElement.width;
      let maxHeight = updatedTextElement.height;
      let isEmptyContainerText = false;
      if (container && updatedTextElement.containerId) {
        if (isArrowElement9(container)) {
          const boundTextCoords = LinearElementEditor8.getBoundTextElementPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordX = boundTextCoords.x;
          coordY = boundTextCoords.y;
        }
        const propertiesUpdated = textPropertiesUpdated(
          updatedTextElement,
          editable
        );
        let originalContainerData;
        if (propertiesUpdated) {
          originalContainerData = updateOriginalContainerCache3(
            container.id,
            container.height
          );
        } else {
          originalContainerData = originalContainerCache[container.id];
          if (!originalContainerData) {
            originalContainerData = updateOriginalContainerCache3(
              container.id,
              container.height
            );
          }
        }
        maxWidth = getBoundTextMaxWidth3(container, updatedTextElement);
        maxHeight = getBoundTextMaxHeight3(
          container,
          updatedTextElement
        );
        if (!updatedTextElement.originalText.trim()) {
          isEmptyContainerText = true;
          const contentTopLeft = getContainerCoords3(container);
          coordX = contentTopLeft.x;
          coordY = contentTopLeft.y;
          width = maxWidth;
          height = Math.max(height, maxHeight);
        }
        if (!isArrowElement9(container) && height > maxHeight) {
          const targetContainerHeight = computeContainerDimensionForBoundText2(
            height,
            container.type
          );
          app.scene.mutateElement(container, { height: targetContainerHeight });
          updateBoundElements2(container, app.scene);
          return;
        } else if (
          // autoshrink container height until original container height
          // is reached when text is removed
          !isArrowElement9(container) && container.height > originalContainerData.height && height < maxHeight
        ) {
          const targetContainerHeight = computeContainerDimensionForBoundText2(
            height,
            container.type
          );
          app.scene.mutateElement(container, { height: targetContainerHeight });
          updateBoundElements2(container, app.scene);
        } else if (!isEmptyContainerText) {
          const { x, y } = computeBoundTextPosition2(
            container,
            updatedTextElement,
            elementsMap
          );
          coordX = x;
          coordY = y;
        }
      }
      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);
      if (!container) {
        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;
        width = Math.min(width, maxWidth);
      } else if (!isEmptyContainerText) {
        width += 0.5;
      }
      if (!isEmptyContainerText) {
        height *= 1.05;
      }
      const font = getFontString7(updatedTextElement);
      let verticalPadding = 0;
      let horizontalPadding = 0;
      if (isEmptyContainerText) {
        if (verticalAlign === VERTICAL_ALIGN5.MIDDLE) {
          const lineHeightPx = getLineHeightInPx2(
            updatedTextElement.fontSize,
            updatedTextElement.lineHeight
          );
          verticalPadding = Math.max(0, (height - lineHeightPx) / 2);
        }
        if (textAlign === "center" && placeholder) {
          const placeholderWidth = getTextWidth(placeholder, font);
          if (placeholderWidth > 0 && placeholderWidth < width) {
            horizontalPadding = (width - placeholderWidth) / 2;
          }
        }
      }
      const styleWidth = width - 2 * horizontalPadding;
      const styleHeight = height - 2 * verticalPadding;
      const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;
      Object.assign(editable.style, {
        font,
        // must be defined *after* font \_()_/
        lineHeight: updatedTextElement.lineHeight,
        width: `${styleWidth}px`,
        height: `${styleHeight}px`,
        left: `${viewportX}px`,
        top: `${viewportY}px`,
        transform: getTransform(
          width,
          height,
          getTextElementAngle(updatedTextElement, container),
          appState,
          maxWidth,
          editorMaxHeight
        ),
        textAlign,
        verticalAlign,
        paddingTop: `${verticalPadding}px`,
        paddingBottom: `${verticalPadding}px`,
        paddingLeft: `${horizontalPadding}px`,
        paddingRight: `${horizontalPadding}px`,
        color: appState.theme === THEME11.DARK ? applyDarkModeFilter3(updatedTextElement.strokeColor) : updatedTextElement.strokeColor,
        opacity: updatedTextElement.opacity / 100,
        maxHeight: `${editorMaxHeight}px`
      });
      editable.scrollTop = 0;
      if (isTestEnv4()) {
        editable.style.fontFamily = getFontFamilyString3(updatedTextElement);
      }
      app.scene.mutateElement(updatedTextElement, { x: coordX, y: coordY });
    }
  };
  const editable = document.createElement("textarea");
  editable.dir = "auto";
  editable.tabIndex = 0;
  editable.dataset.type = "wysiwyg";
  editable.wrap = "off";
  editable.classList.add("excalidraw-wysiwyg");
  let whiteSpace = "pre";
  let wordBreak = "normal";
  if (isBoundToContainer7(element) || !element.autoResize) {
    whiteSpace = "pre-wrap";
    wordBreak = "break-word";
  }
  Object.assign(editable.style, {
    position: "absolute",
    display: "inline-block",
    minHeight: "1em",
    backfaceVisibility: "hidden",
    margin: 0,
    padding: 0,
    border: 0,
    outline: 0,
    resize: "none",
    background: "transparent",
    overflow: "hidden",
    // must be specified because in dark mode canvas creates a stacking context
    zIndex: "var(--zIndex-wysiwyg)",
    wordBreak,
    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)
    whiteSpace,
    overflowWrap: "break-word",
    boxSizing: "content-box"
  });
  editable.value = element.originalText;
  editable.placeholder = placeholder;
  updateWysiwygStyle();
  if (onChange) {
    editable.onpaste = async (event) => {
      const mimeTypes = parseDataTransferEventMimeTypes(event);
      let dataList = null;
      if (mimeTypes.has(MIME_TYPES8.excalidrawClipboard) || mimeTypes.has(MIME_TYPES8.excalidraw)) {
        event.preventDefault();
        dataList = await parseDataTransferEvent(event);
        try {
          const parsed = await parseClipboard(dataList);
          if (parsed.elements) {
            const text2 = getTextFromElements2(parsed.elements);
            if (text2) {
              const { selectionStart, selectionEnd, value } = editable;
              editable.value = value.slice(0, selectionStart) + text2 + value.slice(selectionEnd);
              const newPos = selectionStart + text2.length;
              editable.selectionStart = editable.selectionEnd = newPos;
              editable.dispatchEvent(new Event("input"));
            }
          }
          return;
        } catch {
          console.warn("failed to parse excalidraw clipboard data");
        }
      }
      dataList = dataList || await parseDataTransferEvent(event);
      const textItem = dataList.findByType(MIME_TYPES8.text);
      if (!textItem) {
        return;
      }
      const text = normalizeText(textItem.value);
      if (!text) {
        return;
      }
      const container = getContainerElement5(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      const font = getFontString7({
        fontSize: app.state.currentItemFontSize,
        fontFamily: app.state.currentItemFontFamily
      });
      if (container) {
        const boundTextElement = getBoundTextElement6(
          container,
          app.scene.getNonDeletedElementsMap()
        );
        const wrappedText = wrapText3(
          `${editable.value}${text}`,
          font,
          getBoundTextMaxWidth3(container, boundTextElement)
        );
        const width = getTextWidth(wrappedText, font);
        editable.style.width = `${width}px`;
      }
    };
    editable.oninput = () => {
      const normalized = normalizeText(editable.value);
      if (editable.value !== normalized) {
        const selectionStart = editable.selectionStart;
        editable.value = normalized;
        editable.selectionStart = selectionStart;
        editable.selectionEnd = selectionStart;
      }
      onChange(editable.value);
    };
  }
  editable.onkeydown = (event) => {
    if (!event.shiftKey && actionZoomIn.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomIn);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomOut);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionResetZoom.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionResetZoom);
      updateWysiwygStyle();
    } else if (actionDecreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionDecreaseFontSize);
    } else if (actionIncreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionIncreaseFontSize);
    } else if (event.key === KEYS44.ESCAPE) {
      event.preventDefault();
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (actionSaveToActiveFile.keyTest(event)) {
      event.preventDefault();
      handleSubmit();
      app.actionManager.executeAction(actionSaveToActiveFile);
    } else if (event.key === KEYS44.ENTER && event[KEYS44.CTRL_OR_CMD]) {
      event.preventDefault();
      if (event.isComposing || event.keyCode === 229) {
        return;
      }
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS44.TAB || event[KEYS44.CTRL_OR_CMD] && (event.code === CODES12.BRACKET_LEFT || event.code === CODES12.BRACKET_RIGHT)) {
      event.preventDefault();
      if (event.isComposing) {
        return;
      } else if (event.shiftKey || event.code === CODES12.BRACKET_LEFT) {
        outdent();
      } else {
        indent();
      }
      editable.dispatchEvent(new Event("input"));
    }
  };
  const TAB_SIZE = 4;
  const TAB = " ".repeat(TAB_SIZE);
  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);
  const indent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const startValue = value.slice(0, startIndex);
      const endValue = value.slice(startIndex);
      value = `${startValue}${TAB}${endValue}`;
    });
    editable.value = value;
    editable.selectionStart = selectionStart + TAB_SIZE;
    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;
  };
  const outdent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    const removedTabs = [];
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);
      if (tabMatch) {
        const startValue = value.slice(0, startIndex);
        const endValue = value.slice(startIndex + tabMatch[0].length);
        value = `${startValue}${endValue}`;
        removedTabs.push(startIndex);
      }
    });
    editable.value = value;
    if (removedTabs.length) {
      if (selectionStart > removedTabs[removedTabs.length - 1]) {
        editable.selectionStart = Math.max(
          selectionStart - TAB_SIZE,
          removedTabs[removedTabs.length - 1]
        );
      } else {
        editable.selectionStart = selectionStart;
      }
      editable.selectionEnd = Math.max(
        editable.selectionStart,
        selectionEnd - TAB_SIZE * removedTabs.length
      );
    }
  };
  const getSelectedLinesStartIndices = () => {
    let { selectionStart, selectionEnd, value } = editable;
    const startOffset = value.slice(0, selectionStart).match(/[^\n]*$/)[0].length;
    selectionStart = selectionStart - startOffset;
    const selected = value.slice(selectionStart, selectionEnd);
    return selected.split("\n").reduce(
      (startIndices, line, idx, lines) => startIndices.concat(
        idx ? (
          // curr line index is prev line's start + prev line's length + \n
          startIndices[idx - 1] + lines[idx - 1].length + 1
        ) : (
          // first selected line
          selectionStart
        )
      ),
      []
    ).reverse();
  };
  const stopEvent = (event) => {
    if (event.target instanceof HTMLCanvasElement) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  let submittedViaKeyboard = false;
  const handleSubmit = () => {
    if (isDestroyed) {
      return;
    }
    isDestroyed = true;
    cleanup();
    const updateElement = app.scene.getElement(
      element.id
    );
    if (!updateElement) {
      return;
    }
    const container = getContainerElement5(
      updateElement,
      app.scene.getNonDeletedElementsMap()
    );
    if (container) {
      if (editable.value.trim()) {
        const boundTextElementId = getBoundTextElementId(container);
        if (!boundTextElementId || boundTextElementId !== element.id) {
          app.scene.mutateElement(container, {
            boundElements: (container.boundElements || []).concat({
              type: "text",
              id: element.id
            })
          });
        } else if (isArrowElement9(container)) {
          bumpVersion2(container);
        }
      } else {
        app.scene.mutateElement(container, {
          boundElements: container.boundElements?.filter(
            (ele) => !isTextElement11(
              ele
            )
          )
        });
      }
      redrawTextBoundingBox5(updateElement, container, app.scene);
    }
    onSubmit({
      viaKeyboard: submittedViaKeyboard,
      nextOriginalText: editable.value
    });
  };
  const cleanup = () => {
    editable.onblur = null;
    editable.oninput = null;
    editable.onkeydown = null;
    if (observer) {
      observer.disconnect();
    }
    window.removeEventListener("resize", updateWysiwygStyle);
    window.removeEventListener("wheel", stopEvent, true);
    window.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointerup", bindBlurEvent);
    window.removeEventListener("blur", handleSubmit);
    window.removeEventListener("beforeunload", handleSubmit);
    unbindUpdate();
    unsubOnChange();
    unbindOnScroll();
    editable.remove();
  };
  const bindBlurEvent = (event) => {
    window.removeEventListener("pointerup", bindBlurEvent);
    const target = event?.target;
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    const isPropertiesContent = (target instanceof HTMLElement || target instanceof SVGElement) && !!target.closest(".properties-content");
    const inShapeActionsMenu = (target instanceof HTMLElement || target instanceof SVGElement) && (!!target.closest(`.${CLASSES7.SHAPE_ACTIONS_MENU}`) || !!target.closest(".compact-shape-actions-island"));
    setTimeout(() => {
      if (inShapeActionsMenu || isPropertiesTrigger || isPropertiesContent) {
        return;
      }
      editable.onblur = handleSubmit;
      editable.focus();
    });
  };
  const temporarilyDisableSubmit = () => {
    editable.onblur = null;
    window.addEventListener("pointerup", bindBlurEvent);
    window.addEventListener("blur", handleSubmit);
  };
  const onPointerDown = (event) => {
    const target = event?.target;
    if (event.button === POINTER_BUTTON.WHEEL) {
      if (target instanceof HTMLTextAreaElement) {
        event.preventDefault();
        app.handleCanvasPanUsingWheelOrSpaceDrag(event);
      }
      temporarilyDisableSubmit();
      return;
    }
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    const isPropertiesContent = (target instanceof HTMLElement || target instanceof SVGElement) && !!target.closest(".properties-content");
    if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && (event.target.closest(
      `.${CLASSES7.SHAPE_ACTIONS_MENU}, .${CLASSES7.ZOOM_ACTIONS}`
    ) || event.target.closest(".compact-shape-actions-island")) && !isWritableElement4(event.target) || isPropertiesTrigger || isPropertiesContent) {
      temporarilyDisableSubmit();
    } else if (event.target instanceof HTMLCanvasElement && // Vitest simply ignores stopPropagation, capture-mode, or rAF
    // so without introducing crazier hacks, nothing we can do
    !isTestEnv4()) {
      requestAnimationFrame(() => {
        handleSubmit();
      });
    }
  };
  const unsubOnChange = app.onChangeEmitter.on((elements) => {
    if (app.state.theme !== LAST_THEME) {
      updateWysiwygStyle();
    }
  });
  const unbindUpdate = app.scene.onUpdate(() => {
    updateWysiwygStyle();
    const isPopupOpened = !!document.activeElement?.closest(
      ".properties-content"
    );
    if (!isPopupOpened) {
      editable.focus();
    }
  });
  const unbindOnScroll = app.onScrollChangeEmitter.on(() => {
    updateWysiwygStyle();
  });
  let isDestroyed = false;
  if (autoSelect) {
    editable.select();
  }
  bindBlurEvent();
  let observer = null;
  if (canvas && "ResizeObserver" in window) {
    observer = new window.ResizeObserver(() => {
      updateWysiwygStyle();
    });
    observer.observe(canvas);
  } else {
    window.addEventListener("resize", updateWysiwygStyle);
  }
  editable.onpointerdown = (event) => event.stopPropagation();
  requestAnimationFrame(() => {
    window.addEventListener("pointerdown", onPointerDown, { capture: true });
  });
  window.addEventListener("beforeunload", handleSubmit);
  excalidrawContainer?.querySelector(".excalidraw-textEditorContainer").appendChild(editable);
  return handleSubmit;
};

// scene/scrollbars.ts
import { getGlobalCSSVariable } from "@excalidraw/common";
import { getCommonBounds as getCommonBounds5 } from "@excalidraw/element";
var SCROLLBAR_MARGIN = 4;
var SCROLLBAR_WIDTH = 6;
var SCROLLBAR_COLOR = "rgba(0,0,0,0.3)";
var getScrollBars = (elements, viewportWidth, viewportHeight, appState) => {
  if (!elements.size) {
    return {
      horizontal: null,
      vertical: null
    };
  }
  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] = getCommonBounds5(elements);
  const viewportWidthWithZoom = viewportWidth / appState.zoom.value;
  const viewportHeightWithZoom = viewportHeight / appState.zoom.value;
  const safeArea = {
    top: parseInt(getGlobalCSSVariable("sat")) || 0,
    bottom: parseInt(getGlobalCSSVariable("sab")) || 0,
    left: parseInt(getGlobalCSSVariable("sal")) || 0,
    right: parseInt(getGlobalCSSVariable("sar")) || 0
  };
  const isRTL2 = getLanguage().rtl;
  const viewportMinX = -appState.scrollX + safeArea.left;
  const viewportMinY = -appState.scrollY + safeArea.top;
  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;
  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;
  const sceneMinX = Math.min(elementsMinX, viewportMinX);
  const sceneMinY = Math.min(elementsMinY, viewportMinY);
  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);
  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);
  const sceneWidth = elementsMaxX - elementsMinX;
  const sceneHeight = elementsMaxY - elementsMinY;
  const extendedSceneWidth = sceneMaxX - sceneMinX;
  const extendedSceneHeight = sceneMaxY - sceneMinY;
  const scrollWidthOffset = Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right) + SCROLLBAR_WIDTH * 2;
  const scrollbarWidth = viewportWidth * (viewportWidthWithZoom / extendedSceneWidth) - scrollWidthOffset;
  const scrollbarHeightOffset = Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom) + SCROLLBAR_WIDTH * 2;
  const scrollbarHeight = viewportHeight * (viewportHeightWithZoom / extendedSceneHeight) - scrollbarHeightOffset;
  const horizontalDeltaMultiplier = extendedSceneWidth > sceneWidth ? extendedSceneWidth * appState.zoom.value / (scrollbarWidth + scrollWidthOffset) : viewportWidth / (scrollbarWidth + scrollWidthOffset);
  const verticalDeltaMultiplier = extendedSceneHeight > sceneHeight ? extendedSceneHeight * appState.zoom.value / (scrollbarHeight + scrollbarHeightOffset) : viewportHeight / (scrollbarHeight + scrollbarHeightOffset);
  return {
    horizontal: viewportMinX === sceneMinX && viewportMaxX === sceneMaxX ? null : {
      x: Math.max(safeArea.left, SCROLLBAR_MARGIN) + SCROLLBAR_WIDTH + (viewportMinX - sceneMinX) / extendedSceneWidth * viewportWidth,
      y: viewportHeight - SCROLLBAR_WIDTH - Math.max(SCROLLBAR_MARGIN, safeArea.bottom),
      width: scrollbarWidth,
      height: SCROLLBAR_WIDTH,
      deltaMultiplier: horizontalDeltaMultiplier
    },
    vertical: viewportMinY === sceneMinY && viewportMaxY === sceneMaxY ? null : {
      x: isRTL2 ? Math.max(safeArea.left, SCROLLBAR_MARGIN) : viewportWidth - SCROLLBAR_WIDTH - Math.max(safeArea.right, SCROLLBAR_MARGIN),
      y: Math.max(safeArea.top, SCROLLBAR_MARGIN) + SCROLLBAR_WIDTH + (viewportMinY - sceneMinY) / extendedSceneHeight * viewportHeight,
      width: SCROLLBAR_WIDTH,
      height: scrollbarHeight,
      deltaMultiplier: verticalDeltaMultiplier
    }
  };
};
var isOverScrollBars = (scrollBars, x, y) => {
  const [isOverHorizontal, isOverVertical] = [
    scrollBars.horizontal,
    scrollBars.vertical
  ].map((scrollBar) => {
    return scrollBar != null && scrollBar.x <= x && x <= scrollBar.x + scrollBar.width && scrollBar.y <= y && y <= scrollBar.y + scrollBar.height;
  });
  const isOverEither = isOverHorizontal || isOverVertical;
  return { isOverEither, isOverHorizontal, isOverVertical };
};

// mermaid.ts
var isMaybeMermaidDefinition = (text) => {
  const chartTypes = [
    "flowchart",
    "graph",
    "sequenceDiagram",
    "classDiagram",
    "stateDiagram",
    "stateDiagram-v2",
    "erDiagram",
    "journey",
    "gantt",
    "pie",
    "quadrantChart",
    "requirementDiagram",
    "gitGraph",
    "C4Context",
    "mindmap",
    "timeline",
    "zenuml",
    "sankey",
    "xychart",
    "block"
  ];
  const re = new RegExp(
    `^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${chartTypes.map((x) => `\\s*${x}(-beta)?`).join("|")})\\b`
  );
  return re.test(text.trim());
};

// lasso/index.ts
import {
  pointFrom as pointFrom22
} from "@excalidraw/math";
import { getElementLineSegments as getElementLineSegments2 } from "@excalidraw/element";
import { LinearElementEditor as LinearElementEditor9 } from "@excalidraw/element";
import {
  isFrameLikeElement as isFrameLikeElement9,
  isLinearElement as isLinearElement9,
  isTextElement as isTextElement12
} from "@excalidraw/element";
import { getFrameChildren as getFrameChildren4 } from "@excalidraw/element";
import { selectGroupsForSelectedElements as selectGroupsForSelectedElements5 } from "@excalidraw/element";
import { getContainerElement as getContainerElement6 } from "@excalidraw/element";
import { arrayToMap as arrayToMap22, easeOut as easeOut2, isShallowEqual as isShallowEqual4 } from "@excalidraw/common";

// lasso/utils.ts
import { simplify as simplify2 } from "points-on-curve";
import {
  polygonFromPoints as polygonFromPoints2,
  lineSegment as lineSegment8,
  polygonIncludesPointNonZero
} from "@excalidraw/math";
import {
  computeBoundTextPosition as computeBoundTextPosition3,
  doBoundsIntersect as doBoundsIntersect2,
  getBoundTextElement as getBoundTextElement7,
  getElementBounds as getElementBounds3,
  intersectElementWithLineSegment as intersectElementWithLineSegment2
} from "@excalidraw/element";
var getLassoSelectedElementIds = (input) => {
  const {
    lassoPath,
    elements,
    elementsMap,
    elementsSegments,
    intersectedElements,
    enclosedElements,
    simplifyDistance
  } = input;
  let path = lassoPath;
  if (simplifyDistance) {
    path = simplify2(lassoPath, simplifyDistance);
  }
  const unlockedElements = elements.filter((el) => !el.locked);
  enclosedElements.clear();
  intersectedElements.clear();
  const lassoBounds = lassoPath.reduce(
    (acc, item) => {
      return [
        Math.min(acc[0], item[0]),
        Math.min(acc[1], item[1]),
        Math.max(acc[2], item[0]),
        Math.max(acc[3], item[1])
      ];
    },
    [Infinity, Infinity, -Infinity, -Infinity]
  );
  for (const element of unlockedElements) {
    const elementBounds = getElementBounds3(element, elementsMap);
    if (doBoundsIntersect2(lassoBounds, elementBounds) && !intersectedElements.has(element.id) && !enclosedElements.has(element.id)) {
      const enclosed = enclosureTest(path, element, elementsSegments);
      if (enclosed) {
        enclosedElements.add(element.id);
      } else {
        const intersects = intersectionTest(path, element, elementsMap);
        if (intersects) {
          intersectedElements.add(element.id);
        }
      }
    }
  }
  const results = [...intersectedElements, ...enclosedElements];
  return {
    selectedElementIds: results
  };
};
var enclosureTest = (lassoPath, element, elementsSegments) => {
  const lassoPolygon = polygonFromPoints2(lassoPath);
  const segments = elementsSegments.get(element.id);
  if (!segments) {
    return false;
  }
  return segments.some((segment) => {
    return segment.some(
      (point) => polygonIncludesPointNonZero(point, lassoPolygon)
    );
  });
};
var intersectionTest = (lassoPath, element, elementsMap) => {
  const lassoSegments = lassoPath.slice(1).map((point, index) => lineSegment8(lassoPath[index], point)).concat([lineSegment8(lassoPath[lassoPath.length - 1], lassoPath[0])]);
  const boundTextElement = getBoundTextElement7(element, elementsMap);
  return lassoSegments.some(
    (lassoSegment) => intersectElementWithLineSegment2(
      element,
      elementsMap,
      lassoSegment,
      0,
      true
    ).length > 0 || !!boundTextElement && intersectElementWithLineSegment2(
      {
        ...boundTextElement,
        ...computeBoundTextPosition3(element, boundTextElement, elementsMap)
      },
      elementsMap,
      lassoSegment,
      0,
      true
    ).length > 0
  );
};

// lasso/index.ts
var LassoTrail = class extends AnimatedTrail {
  constructor(animationFrameHandler, app) {
    super(animationFrameHandler, app, {
      animateTrail: true,
      streamline: 0.4,
      sizeMapping: (c) => {
        const DECAY_TIME = Infinity;
        const DECAY_LENGTH = 5e3;
        const t2 = Math.max(
          0,
          1 - (performance.now() - c.pressure) / DECAY_TIME
        );
        const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut2(l), easeOut2(t2));
      },
      fill: () => "rgba(105,101,219,0.05)",
      stroke: () => "rgba(105,101,219)"
    });
    __publicField(this, "intersectedElements", /* @__PURE__ */ new Set());
    __publicField(this, "enclosedElements", /* @__PURE__ */ new Set());
    __publicField(this, "elementsSegments", null);
    __publicField(this, "canvasTranslate", null);
    __publicField(this, "keepPreviousSelection", false);
    __publicField(this, "selectElementsFromIds", (ids) => {
      this.app.setState((prevState) => {
        const nextSelectedElementIds = ids.reduce((acc, id) => {
          acc[id] = true;
          return acc;
        }, {});
        if (this.keepPreviousSelection) {
          for (const id of Object.keys(prevState.selectedElementIds)) {
            nextSelectedElementIds[id] = true;
          }
        }
        for (const [id] of Object.entries(nextSelectedElementIds)) {
          const element = this.app.scene.getNonDeletedElement(id);
          if (element && isTextElement12(element)) {
            const container = getContainerElement6(
              element,
              this.app.scene.getNonDeletedElementsMap()
            );
            if (container) {
              nextSelectedElementIds[container.id] = true;
              delete nextSelectedElementIds[element.id];
            }
          }
        }
        for (const [id] of Object.entries(nextSelectedElementIds)) {
          const element = this.app.scene.getNonDeletedElement(id);
          if (element && isFrameLikeElement9(element)) {
            const elementsInFrame = getFrameChildren4(
              this.app.scene.getNonDeletedElementsMap(),
              element.id
            );
            for (const child of elementsInFrame) {
              delete nextSelectedElementIds[child.id];
            }
          }
        }
        const nextSelection = selectGroupsForSelectedElements5(
          {
            editingGroupId: prevState.editingGroupId,
            selectedElementIds: nextSelectedElementIds
          },
          this.app.scene.getNonDeletedElements(),
          prevState,
          this.app
        );
        const selectedIds = [...Object.keys(nextSelection.selectedElementIds)];
        const selectedGroupIds = [...Object.keys(nextSelection.selectedGroupIds)];
        return {
          selectedElementIds: nextSelection.selectedElementIds,
          selectedGroupIds: nextSelection.selectedGroupIds,
          selectedLinearElement: selectedIds.length === 1 && !selectedGroupIds.length && isLinearElement9(this.app.scene.getNonDeletedElement(selectedIds[0])) ? new LinearElementEditor9(
            this.app.scene.getNonDeletedElement(
              selectedIds[0]
            ),
            this.app.scene.getNonDeletedElementsMap()
          ) : null
        };
      });
    });
    __publicField(this, "addPointToPath", (x, y, keepPreviousSelection = false) => {
      super.addPointToPath(x, y);
      this.keepPreviousSelection = keepPreviousSelection;
      this.updateSelection();
    });
    __publicField(this, "updateSelection", () => {
      const lassoPath = super.getCurrentTrail()?.originalPoints?.map((p) => pointFrom22(p[0], p[1]));
      const currentCanvasTranslate = {
        scrollX: this.app.state.scrollX,
        scrollY: this.app.state.scrollY,
        zoom: this.app.state.zoom.value
      };
      if (!this.elementsSegments || !isShallowEqual4(currentCanvasTranslate, this.canvasTranslate ?? {})) {
        this.canvasTranslate = currentCanvasTranslate;
        this.elementsSegments = /* @__PURE__ */ new Map();
        const visibleElementsMap = arrayToMap22(this.app.visibleElements);
        for (const element of this.app.visibleElements) {
          const segments = getElementLineSegments2(element, visibleElementsMap);
          this.elementsSegments.set(element.id, segments);
        }
      }
      if (lassoPath) {
        const { selectedElementIds } = getLassoSelectedElementIds({
          lassoPath,
          elements: this.app.visibleElements,
          elementsMap: this.app.scene.getNonDeletedElementsMap(),
          elementsSegments: this.elementsSegments,
          intersectedElements: this.intersectedElements,
          enclosedElements: this.enclosedElements,
          simplifyDistance: 5 / this.app.state.zoom.value
        });
        this.selectElementsFromIds(selectedElementIds);
      }
    });
  }
  startPath(x, y, keepPreviousSelection = false) {
    this.endPath();
    super.startPath(x, y);
    this.intersectedElements.clear();
    this.enclosedElements.clear();
    this.keepPreviousSelection = keepPreviousSelection;
    if (!this.keepPreviousSelection) {
      this.app.setState({
        selectedElementIds: {},
        selectedGroupIds: {},
        selectedLinearElement: null
      });
    }
  }
  endPath() {
    super.endPath();
    super.clearTrails();
    this.intersectedElements.clear();
    this.enclosedElements.clear();
    this.elementsSegments = null;
  }
};

// eraser/index.ts
import { arrayToMap as arrayToMap23, easeOut as easeOut3, THEME as THEME12 } from "@excalidraw/common";
import {
  computeBoundTextPosition as computeBoundTextPosition4,
  doBoundsIntersect as doBoundsIntersect3,
  getBoundTextElement as getBoundTextElement8,
  getElementBounds as getElementBounds4,
  getElementLineSegments as getElementLineSegments3,
  getFreedrawOutlineAsSegments,
  getFreedrawOutlinePoints as getFreedrawOutlinePoints2,
  intersectElementWithLineSegment as intersectElementWithLineSegment3,
  isArrowElement as isArrowElement10,
  isFreeDrawElement as isFreeDrawElement4,
  isLineElement as isLineElement5,
  isPointInElement as isPointInElement2
} from "@excalidraw/element";
import {
  lineSegment as lineSegment9,
  lineSegmentsDistance,
  pointFrom as pointFrom23,
  polygon as polygon2,
  polygonIncludesPointNonZero as polygonIncludesPointNonZero2
} from "@excalidraw/math";
import { getElementsInGroup as getElementsInGroup5 } from "@excalidraw/element";
import { shouldTestInside as shouldTestInside2 } from "@excalidraw/element";
import { hasBoundTextElement as hasBoundTextElement6, isBoundToContainer as isBoundToContainer8 } from "@excalidraw/element";
import { getBoundTextElementId as getBoundTextElementId2 } from "@excalidraw/element";
var EraserTrail = class extends AnimatedTrail {
  constructor(animationFrameHandler, app) {
    super(animationFrameHandler, app, {
      streamline: 0.2,
      size: 5,
      keepHead: true,
      sizeMapping: (c) => {
        const DECAY_TIME = 200;
        const DECAY_LENGTH = 10;
        const t2 = Math.max(
          0,
          1 - (performance.now() - c.pressure) / DECAY_TIME
        );
        const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut3(l), easeOut3(t2));
      },
      fill: () => app.state.theme === THEME12.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
    });
    __publicField(this, "elementsToErase", /* @__PURE__ */ new Set());
    __publicField(this, "groupsToErase", /* @__PURE__ */ new Set());
  }
  startPath(x, y) {
    this.endPath();
    super.startPath(x, y);
    this.elementsToErase.clear();
  }
  addPointToPath(x, y, restore = false) {
    super.addPointToPath(x, y);
    const elementsToEraser = this.updateElementsToBeErased(restore);
    return elementsToEraser;
  }
  updateElementsToBeErased(restoreToErase) {
    const eraserPath = super.getCurrentTrail()?.originalPoints?.map((p) => pointFrom23(p[0], p[1])) || [];
    if (eraserPath.length < 2) {
      return [];
    }
    const pathSegment = lineSegment9(
      eraserPath[eraserPath.length - 1],
      eraserPath[eraserPath.length - 2]
    );
    const candidateElements = this.app.visibleElements.filter(
      (el) => !el.locked
    );
    const candidateElementsMap = arrayToMap23(candidateElements);
    for (const element of candidateElements) {
      if (restoreToErase && this.elementsToErase.has(element.id)) {
        const intersects = eraserTest(
          pathSegment,
          element,
          candidateElementsMap,
          this.app.state.zoom.value
        );
        if (intersects) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (this.groupsToErase.has(shallowestGroupId)) {
            const elementsInGroup = getElementsInGroup5(
              this.app.scene.getNonDeletedElementsMap(),
              shallowestGroupId
            );
            for (const elementInGroup of elementsInGroup) {
              this.elementsToErase.delete(elementInGroup.id);
            }
            this.groupsToErase.delete(shallowestGroupId);
          }
          if (isBoundToContainer8(element)) {
            this.elementsToErase.delete(element.containerId);
          }
          if (hasBoundTextElement6(element)) {
            const boundText = getBoundTextElementId2(element);
            if (boundText) {
              this.elementsToErase.delete(boundText);
            }
          }
          this.elementsToErase.delete(element.id);
        }
      } else if (!restoreToErase && !this.elementsToErase.has(element.id)) {
        const intersects = eraserTest(
          pathSegment,
          element,
          candidateElementsMap,
          this.app.state.zoom.value
        );
        if (intersects) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!this.groupsToErase.has(shallowestGroupId)) {
            const elementsInGroup = getElementsInGroup5(
              this.app.scene.getNonDeletedElementsMap(),
              shallowestGroupId
            );
            for (const elementInGroup of elementsInGroup) {
              this.elementsToErase.add(elementInGroup.id);
            }
            this.groupsToErase.add(shallowestGroupId);
          }
          if (hasBoundTextElement6(element)) {
            const boundText = getBoundTextElementId2(element);
            if (boundText) {
              this.elementsToErase.add(boundText);
            }
          }
          if (isBoundToContainer8(element)) {
            this.elementsToErase.add(element.containerId);
          }
          this.elementsToErase.add(element.id);
        }
      }
    }
    return Array.from(this.elementsToErase);
  }
  endPath() {
    super.endPath();
    super.clearTrails();
    this.elementsToErase.clear();
    this.groupsToErase.clear();
  }
};
var eraserTest = (pathSegment, element, elementsMap, zoom) => {
  const lastPoint = pathSegment[1];
  const threshold = isFreeDrawElement4(element) ? 15 : element.strokeWidth / 2;
  const segmentBounds = [
    Math.min(pathSegment[0][0], pathSegment[1][0]) - threshold,
    Math.min(pathSegment[0][1], pathSegment[1][1]) - threshold,
    Math.max(pathSegment[0][0], pathSegment[1][0]) + threshold,
    Math.max(pathSegment[0][1], pathSegment[1][1]) + threshold
  ];
  const origElementBounds = getElementBounds4(element, elementsMap);
  const elementBounds = [
    origElementBounds[0] - threshold,
    origElementBounds[1] - threshold,
    origElementBounds[2] + threshold,
    origElementBounds[3] + threshold
  ];
  if (!doBoundsIntersect3(segmentBounds, elementBounds)) {
    return false;
  }
  if (shouldTestInside2(element) && isPointInElement2(lastPoint, element, elementsMap)) {
    return true;
  }
  if (isFreeDrawElement4(element)) {
    const outlinePoints = getFreedrawOutlinePoints2(element);
    const strokeSegments = getFreedrawOutlineAsSegments(
      element,
      outlinePoints,
      elementsMap
    );
    const tolerance = Math.max(2.25, 5 / zoom);
    for (const seg of strokeSegments) {
      if (lineSegmentsDistance(seg, pathSegment) <= tolerance) {
        return true;
      }
    }
    const poly = polygon2(
      ...outlinePoints.map(
        ([x, y]) => pointFrom23(element.x + x, element.y + y)
      )
    );
    if (polygonIncludesPointNonZero2(pathSegment[0], poly)) {
      return true;
    }
    return false;
  }
  const boundTextElement = getBoundTextElement8(element, elementsMap);
  if (isArrowElement10(element) || isLineElement5(element) && !element.polygon) {
    const tolerance = Math.max(
      element.strokeWidth,
      element.strokeWidth * 2 / zoom
    );
    const segments = getElementLineSegments3(element, elementsMap);
    for (const seg of segments) {
      if (lineSegmentsDistance(seg, pathSegment) <= tolerance) {
        return true;
      }
    }
    return false;
  }
  return intersectElementWithLineSegment3(element, elementsMap, pathSegment, 0, true).length > 0 || !!boundTextElement && intersectElementWithLineSegment3(
    {
      ...boundTextElement,
      ...computeBoundTextPosition4(element, boundTextElement, elementsMap)
    },
    elementsMap,
    pathSegment,
    0,
    true
  ).length > 0;
};

// components/BraveMeasureTextError.tsx
import { jsx as jsx83, jsxs as jsxs45 } from "react/jsx-runtime";
var BraveMeasureTextError = () => {
  return /* @__PURE__ */ jsxs45("div", { "data-testid": "brave-measure-text-error", children: [
    /* @__PURE__ */ jsx83("p", { children: /* @__PURE__ */ jsx83(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line1",
        bold: (el) => /* @__PURE__ */ jsx83("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ jsx83("p", { children: /* @__PURE__ */ jsx83(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line2",
        bold: (el) => /* @__PURE__ */ jsx83("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ jsx83("p", { children: /* @__PURE__ */ jsx83(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line3",
        link: (el) => /* @__PURE__ */ jsx83("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: el })
      }
    ) }),
    /* @__PURE__ */ jsx83("p", { children: /* @__PURE__ */ jsx83(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line4",
        issueLink: (el) => /* @__PURE__ */ jsx83("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: el }),
        discordLink: (el) => /* @__PURE__ */ jsxs45("a", { href: "https://discord.gg/UexuTaE", children: [
          el,
          "."
        ] })
      }
    ) })
  ] });
};
var BraveMeasureTextError_default = BraveMeasureTextError;

// components/ContextMenu.tsx
import clsx37 from "clsx";
import React30 from "react";

// components/Popover.tsx
import { useLayoutEffect as useLayoutEffect4, useRef as useRef25, useEffect as useEffect28 } from "react";
import { unstable_batchedUpdates as unstable_batchedUpdates2 } from "react-dom";
import { KEYS as KEYS45, queryFocusableElements as queryFocusableElements2 } from "@excalidraw/common";
import clsx36 from "clsx";
import { jsx as jsx84 } from "react/jsx-runtime";
var Popover7 = ({
  children,
  left,
  top,
  onCloseRequest,
  fitInViewport = false,
  offsetLeft = 0,
  offsetTop = 0,
  viewportWidth = window.innerWidth,
  viewportHeight = window.innerHeight,
  className
}) => {
  const popoverRef = useRef25(null);
  useEffect28(() => {
    const container = popoverRef.current;
    if (!container) {
      return;
    }
    if (!container.contains(document.activeElement)) {
      container.focus();
    }
    const handleKeyDown = (event) => {
      if (event.key === KEYS45.TAB) {
        const focusableElements = queryFocusableElements2(container);
        const { activeElement } = document;
        const currentIndex = focusableElements.findIndex(
          (element) => element === activeElement
        );
        if (activeElement === container) {
          if (event.shiftKey) {
            focusableElements[focusableElements.length - 1]?.focus();
          } else {
            focusableElements[0].focus();
          }
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === 0 && event.shiftKey) {
          focusableElements[focusableElements.length - 1]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {
          focusableElements[0]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }
    };
    container.addEventListener("keydown", handleKeyDown);
    return () => container.removeEventListener("keydown", handleKeyDown);
  }, []);
  const lastInitializedPosRef = useRef25(
    null
  );
  useLayoutEffect4(() => {
    if (fitInViewport && popoverRef.current && top != null && left != null) {
      const container = popoverRef.current;
      const { width, height } = container.getBoundingClientRect();
      if (lastInitializedPosRef.current?.top === top && lastInitializedPosRef.current?.left === left) {
        return;
      }
      lastInitializedPosRef.current = { top, left };
      if (width >= viewportWidth) {
        container.style.width = `${viewportWidth}px`;
        container.style.left = "0px";
        container.style.overflowX = "scroll";
      } else if (left + width - offsetLeft > viewportWidth) {
        container.style.left = `${viewportWidth - width - 10}px`;
      } else {
        container.style.left = `${left}px`;
      }
      if (height >= viewportHeight) {
        container.style.height = `${viewportHeight - 20}px`;
        container.style.top = "10px";
        container.style.overflowY = "scroll";
      } else if (top + height - offsetTop > viewportHeight) {
        container.style.top = `${viewportHeight - height}px`;
      } else {
        container.style.top = `${top}px`;
      }
    }
  }, [
    top,
    left,
    fitInViewport,
    viewportWidth,
    viewportHeight,
    offsetLeft,
    offsetTop
  ]);
  useEffect28(() => {
    if (onCloseRequest) {
      const handler = (event) => {
        if (!popoverRef.current?.contains(event.target)) {
          unstable_batchedUpdates2(() => onCloseRequest(event));
        }
      };
      document.addEventListener("pointerdown", handler, false);
      return () => document.removeEventListener("pointerdown", handler, false);
    }
  }, [onCloseRequest]);
  return /* @__PURE__ */ jsx84("div", { className: clsx36("popover", className), ref: popoverRef, tabIndex: -1, children });
};

// components/ContextMenu.tsx
import { jsx as jsx85, jsxs as jsxs46 } from "react/jsx-runtime";
var CONTEXT_MENU_SEPARATOR = "separator";
var ContextMenu = React30.memo(
  ({ actionManager, items, top, left, onClose }) => {
    const appState = useExcalidrawAppState();
    const elements = useExcalidrawElements();
    const filteredItems = items.reduce((acc, item) => {
      if (item && (item === CONTEXT_MENU_SEPARATOR || !item.predicate || item.predicate(
        elements,
        appState,
        actionManager.app.props,
        actionManager.app
      ))) {
        acc.push(item);
      }
      return acc;
    }, []);
    return /* @__PURE__ */ jsx85(
      Popover7,
      {
        onCloseRequest: () => {
          onClose();
        },
        top,
        left,
        fitInViewport: true,
        offsetLeft: appState.offsetLeft,
        offsetTop: appState.offsetTop,
        viewportWidth: appState.width,
        viewportHeight: appState.height,
        className: "context-menu-popover",
        children: /* @__PURE__ */ jsx85(
          "ul",
          {
            className: "context-menu",
            onContextMenu: (event) => event.preventDefault(),
            children: filteredItems.map((item, idx) => {
              if (item === CONTEXT_MENU_SEPARATOR) {
                if (!filteredItems[idx - 1] || filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR) {
                  return null;
                }
                return /* @__PURE__ */ jsx85("hr", { className: "context-menu-item-separator" }, idx);
              }
              const actionName = item.name;
              let label = "";
              if (item.label) {
                if (typeof item.label === "function") {
                  label = t(
                    item.label(
                      elements,
                      appState,
                      actionManager.app
                    )
                  );
                } else {
                  label = t(item.label);
                }
              }
              return /* @__PURE__ */ jsx85(
                "li",
                {
                  "data-testid": actionName,
                  onClick: () => {
                    onClose(() => {
                      actionManager.executeAction(item, "contextMenu");
                    });
                  },
                  children: /* @__PURE__ */ jsxs46(
                    "button",
                    {
                      type: "button",
                      className: clsx37("context-menu-item", {
                        dangerous: actionName === "deleteSelectedElements",
                        checkmark: item.checked?.(appState)
                      }),
                      children: [
                        /* @__PURE__ */ jsx85("div", { className: "context-menu-item__label", children: label }),
                        /* @__PURE__ */ jsx85("kbd", { className: "context-menu-item__shortcut", children: actionName ? getShortcutFromShortcutName(actionName) : "" })
                      ]
                    }
                  )
                },
                idx
              );
            })
          }
        )
      }
    );
  }
);

// components/FollowMode/FollowMode.tsx
import { jsx as jsx86, jsxs as jsxs47 } from "react/jsx-runtime";
var FollowMode = ({
  height,
  width,
  userToFollow,
  onDisconnect
}) => {
  return /* @__PURE__ */ jsx86("div", { className: "follow-mode", style: { width, height }, children: /* @__PURE__ */ jsxs47("div", { className: "follow-mode__badge", children: [
    /* @__PURE__ */ jsxs47("div", { className: "follow-mode__badge__label", children: [
      "Following",
      " ",
      /* @__PURE__ */ jsx86(
        "span",
        {
          className: "follow-mode__badge__username",
          title: userToFollow.username,
          children: userToFollow.username
        }
      )
    ] }),
    /* @__PURE__ */ jsx86(
      "button",
      {
        type: "button",
        onClick: onDisconnect,
        className: "follow-mode__disconnect-btn",
        children: CloseIcon
      }
    )
  ] }) });
};
var FollowMode_default = FollowMode;

// components/LayerUI.tsx
import clsx60 from "clsx";
import React44 from "react";
import {
  CLASSES as CLASSES10,
  DEFAULT_SIDEBAR as DEFAULT_SIDEBAR6,
  arrayToMap as arrayToMap24,
  capitalizeString as capitalizeString6,
  isShallowEqual as isShallowEqual6
} from "@excalidraw/common";
import { mutateElement as mutateElement5 } from "@excalidraw/element";
import { showSelectedShapeActions } from "@excalidraw/element";
import { ShapeCache as ShapeCache3 } from "@excalidraw/element";

// components/LoadingMessage.tsx
import clsx38 from "clsx";
import { useState as useState27, useEffect as useEffect29 } from "react";
import { THEME as THEME13 } from "@excalidraw/common";
import { jsx as jsx87, jsxs as jsxs48 } from "react/jsx-runtime";
var LoadingMessage = ({
  delay,
  theme
}) => {
  const [isWaiting, setIsWaiting] = useState27(!!delay);
  useEffect29(() => {
    if (!delay) {
      return;
    }
    const timer = setTimeout(() => {
      setIsWaiting(false);
    }, delay);
    return () => clearTimeout(timer);
  }, [delay]);
  if (isWaiting) {
    return null;
  }
  return /* @__PURE__ */ jsxs48(
    "div",
    {
      className: clsx38("LoadingMessage", {
        "LoadingMessage--dark": theme === THEME13.DARK
      }),
      children: [
        /* @__PURE__ */ jsx87("div", { children: /* @__PURE__ */ jsx87(Spinner_default, {}) }),
        /* @__PURE__ */ jsx87("div", { className: "LoadingMessage-text", children: t("labels.loadingScene") })
      ]
    }
  );
};

// components/MobileToolBar.tsx
import { useState as useState29, useEffect as useEffect31 } from "react";
import clsx41 from "clsx";
import { KEYS as KEYS47, capitalizeString as capitalizeString4 } from "@excalidraw/common";

// components/HandButton.tsx
import clsx39 from "clsx";
import { KEYS as KEYS46 } from "@excalidraw/common";
import { jsx as jsx88 } from "react/jsx-runtime";
var HandButton = (props) => {
  return /* @__PURE__ */ jsx88(
    ToolButton,
    {
      className: clsx39("Shape", { fillable: false, active: props.checked }),
      type: "radio",
      icon: handIcon,
      name: "editor-current-shape",
      checked: props.checked,
      title: `${props.title} \u2014 H`,
      keyBindingLabel: !props.isMobile ? KEYS46.H.toLocaleUpperCase() : void 0,
      "aria-label": `${props.title} \u2014 H`,
      "aria-keyshortcuts": KEYS46.H,
      "data-testid": `toolbar-hand`,
      onChange: () => props.onChange?.()
    }
  );
};

// components/ToolPopover.tsx
import { useEffect as useEffect30, useState as useState28 } from "react";
import clsx40 from "clsx";
import { capitalizeString as capitalizeString3 } from "@excalidraw/common";
import { Popover as Popover8 } from "radix-ui";
import { jsx as jsx89, jsxs as jsxs49 } from "react/jsx-runtime";
var ToolPopover = ({
  app,
  options,
  activeTool,
  defaultOption,
  className = "Shape",
  namePrefix,
  title,
  "data-testid": dataTestId,
  onToolChange,
  displayedOption,
  fillable = false
}) => {
  const [isPopupOpen, setIsPopupOpen] = useState28(false);
  const currentType = activeTool.type;
  const isActive = displayedOption.type === currentType;
  const SIDE_OFFSET = 32 / 2 + 10;
  const { container } = useExcalidrawContainer();
  if (!options.some((o) => o.type === currentType) && isPopupOpen) {
    setIsPopupOpen(false);
  }
  useEffect30(() => {
    const unsubscribe = app.onPointerDownEmitter.on(() => {
      setIsPopupOpen(false);
    });
    return () => unsubscribe?.();
  }, [app]);
  return /* @__PURE__ */ jsxs49(Popover8.Root, { open: isPopupOpen, children: [
    /* @__PURE__ */ jsx89(Popover8.Trigger, { asChild: true, children: /* @__PURE__ */ jsx89(
      ToolButton,
      {
        className: clsx40(className, {
          fillable,
          active: options.some((o) => o.type === activeTool.type)
        }),
        type: "radio",
        icon: displayedOption.icon,
        checked: isActive,
        name: "editor-current-shape",
        title,
        "aria-label": title,
        "data-testid": dataTestId,
        onPointerDown: () => {
          setIsPopupOpen((v) => !v);
          onToolChange(defaultOption);
        }
      }
    ) }),
    /* @__PURE__ */ jsx89(
      Popover8.Content,
      {
        className: "tool-popover-content",
        sideOffset: SIDE_OFFSET,
        collisionBoundary: container ?? void 0,
        children: options.map(({ type, icon, title: title2 }) => /* @__PURE__ */ jsx89(
          ToolButton,
          {
            className: clsx40(className, {
              active: currentType === type
            }),
            type: "radio",
            icon,
            checked: currentType === type,
            name: `${namePrefix}-option`,
            title: title2 || capitalizeString3(type),
            keyBindingLabel: "",
            "aria-label": title2 || capitalizeString3(type),
            "data-testid": `toolbar-${type}`,
            onChange: () => {
              if (app.state.activeTool.type !== type) {
                trackEvent("toolbar", type, "ui");
              }
              app.setActiveTool({ type });
              onToolChange?.(type);
            }
          },
          type
        ))
      }
    )
  ] });
};

// components/MobileToolBar.tsx
import { Fragment as Fragment11, jsx as jsx90, jsxs as jsxs50 } from "react/jsx-runtime";
var SHAPE_TOOLS = [
  {
    type: "rectangle",
    icon: RectangleIcon,
    title: capitalizeString4(t("toolBar.rectangle"))
  },
  {
    type: "diamond",
    icon: DiamondIcon,
    title: capitalizeString4(t("toolBar.diamond"))
  },
  {
    type: "ellipse",
    icon: EllipseIcon,
    title: capitalizeString4(t("toolBar.ellipse"))
  }
];
var SELECTION_TOOLS = [
  {
    type: "selection",
    icon: SelectionIcon,
    title: capitalizeString4(t("toolBar.selection"))
  },
  {
    type: "lasso",
    icon: LassoIcon,
    title: capitalizeString4(t("toolBar.lasso"))
  }
];
var LINEAR_ELEMENT_TOOLS = [
  {
    type: "arrow",
    icon: ArrowIcon,
    title: capitalizeString4(t("toolBar.arrow"))
  },
  { type: "line", icon: LineIcon, title: capitalizeString4(t("toolBar.line")) }
];
var MobileToolBar = ({
  app,
  onHandToolToggle,
  setAppState
}) => {
  const activeTool = app.state.activeTool;
  const [isOtherShapesMenuOpen, setIsOtherShapesMenuOpen] = useState29(false);
  const [lastActiveGenericShape, setLastActiveGenericShape] = useState29("rectangle");
  const [lastActiveLinearElement, setLastActiveLinearElement] = useState29("arrow");
  useEffect31(() => {
    if (activeTool.type === "rectangle" || activeTool.type === "diamond" || activeTool.type === "ellipse") {
      setLastActiveGenericShape(activeTool.type);
    }
  }, [activeTool.type]);
  useEffect31(() => {
    if (activeTool.type === "arrow" || activeTool.type === "line") {
      setLastActiveLinearElement(activeTool.type);
    }
  }, [activeTool.type]);
  const frameToolSelected = activeTool.type === "frame";
  const laserToolSelected = activeTool.type === "laser";
  const embeddableToolSelected = activeTool.type === "embeddable";
  const { TTDDialogTriggerTunnel } = useTunnels();
  const handleToolChange = (toolType, pointerType) => {
    if (app.state.activeTool.type !== toolType) {
      trackEvent("toolbar", toolType, "ui");
    }
    if (toolType === "selection") {
      if (app.state.activeTool.type === "selection") {
      } else {
        app.setActiveTool({ type: "selection" });
      }
    } else {
      app.setActiveTool({ type: toolType });
    }
  };
  const [toolbarWidth, setToolbarWidth] = useState29(0);
  const WIDTH = 36;
  const GAP = 4;
  const MIN_TOOLS = 7;
  const MIN_WIDTH = MIN_TOOLS * WIDTH + (MIN_TOOLS - 1) * GAP;
  const ADDITIONAL_WIDTH = WIDTH + GAP;
  const showTextToolOutside = toolbarWidth >= MIN_WIDTH + 1 * ADDITIONAL_WIDTH;
  const showImageToolOutside = toolbarWidth >= MIN_WIDTH + 2 * ADDITIONAL_WIDTH;
  const showFrameToolOutside = toolbarWidth >= MIN_WIDTH + 3 * ADDITIONAL_WIDTH;
  const extraTools = [
    "text",
    "frame",
    "embeddable",
    "laser",
    "magicframe"
  ].filter((tool) => {
    if (showTextToolOutside && tool === "text") {
      return false;
    }
    if (showImageToolOutside && tool === "image") {
      return false;
    }
    if (showFrameToolOutside && tool === "frame") {
      return false;
    }
    return true;
  });
  const extraToolSelected = extraTools.includes(activeTool.type);
  const extraIcon = extraToolSelected ? activeTool.type === "text" ? TextIcon : activeTool.type === "image" ? ImageIcon : activeTool.type === "frame" ? frameToolIcon : activeTool.type === "embeddable" ? EmbedIcon : activeTool.type === "laser" ? laserPointerToolIcon : activeTool.type === "magicframe" ? MagicIcon : extraToolsIcon : extraToolsIcon;
  return /* @__PURE__ */ jsxs50(
    "div",
    {
      className: "mobile-toolbar",
      ref: (div) => {
        if (div) {
          setToolbarWidth(div.getBoundingClientRect().width);
        }
      },
      children: [
        /* @__PURE__ */ jsx90(
          HandButton,
          {
            checked: isHandToolActive(app.state),
            onChange: onHandToolToggle,
            title: t("toolBar.hand"),
            isMobile: true
          }
        ),
        /* @__PURE__ */ jsx90(
          ToolPopover,
          {
            app,
            options: SELECTION_TOOLS,
            activeTool,
            defaultOption: app.state.preferredSelectionTool.type,
            namePrefix: "selectionType",
            title: capitalizeString4(t("toolBar.selection")),
            "data-testid": "toolbar-selection",
            onToolChange: (type) => {
              if (type === "selection" || type === "lasso") {
                app.setActiveTool({ type });
                setAppState({
                  preferredSelectionTool: { type, initialized: true }
                });
              }
            },
            displayedOption: SELECTION_TOOLS.find(
              (tool) => tool.type === app.state.preferredSelectionTool.type
            ) || SELECTION_TOOLS[0]
          }
        ),
        /* @__PURE__ */ jsx90(
          ToolButton,
          {
            className: clsx41({
              active: activeTool.type === "freedraw"
            }),
            type: "radio",
            icon: FreedrawIcon,
            checked: activeTool.type === "freedraw",
            name: "editor-current-shape",
            title: `${capitalizeString4(t("toolBar.freedraw"))}`,
            "aria-label": capitalizeString4(t("toolBar.freedraw")),
            "data-testid": "toolbar-freedraw",
            onChange: () => handleToolChange("freedraw")
          }
        ),
        /* @__PURE__ */ jsx90(
          ToolButton,
          {
            className: clsx41({
              active: activeTool.type === "eraser"
            }),
            type: "radio",
            icon: EraserIcon,
            checked: activeTool.type === "eraser",
            name: "editor-current-shape",
            title: `${capitalizeString4(t("toolBar.eraser"))}`,
            "aria-label": capitalizeString4(t("toolBar.eraser")),
            "data-testid": "toolbar-eraser",
            onChange: () => handleToolChange("eraser")
          }
        ),
        /* @__PURE__ */ jsx90(
          ToolPopover,
          {
            app,
            options: SHAPE_TOOLS,
            activeTool,
            defaultOption: lastActiveGenericShape,
            namePrefix: "shapeType",
            title: capitalizeString4(
              t(
                lastActiveGenericShape === "rectangle" ? "toolBar.rectangle" : lastActiveGenericShape === "diamond" ? "toolBar.diamond" : lastActiveGenericShape === "ellipse" ? "toolBar.ellipse" : "toolBar.rectangle"
              )
            ),
            "data-testid": "toolbar-rectangle",
            onToolChange: (type) => {
              if (type === "rectangle" || type === "diamond" || type === "ellipse") {
                setLastActiveGenericShape(type);
                app.setActiveTool({ type });
              }
            },
            displayedOption: SHAPE_TOOLS.find((tool) => tool.type === lastActiveGenericShape) || SHAPE_TOOLS[0]
          }
        ),
        /* @__PURE__ */ jsx90(
          ToolPopover,
          {
            app,
            options: LINEAR_ELEMENT_TOOLS,
            activeTool,
            defaultOption: lastActiveLinearElement,
            namePrefix: "linearElementType",
            title: capitalizeString4(
              t(
                lastActiveLinearElement === "arrow" ? "toolBar.arrow" : "toolBar.line"
              )
            ),
            "data-testid": "toolbar-arrow",
            fillable: true,
            onToolChange: (type) => {
              if (type === "arrow" || type === "line") {
                setLastActiveLinearElement(type);
                app.setActiveTool({ type });
              }
            },
            displayedOption: LINEAR_ELEMENT_TOOLS.find(
              (tool) => tool.type === lastActiveLinearElement
            ) || LINEAR_ELEMENT_TOOLS[0]
          }
        ),
        showTextToolOutside && /* @__PURE__ */ jsx90(
          ToolButton,
          {
            className: clsx41({
              active: activeTool.type === "text"
            }),
            type: "radio",
            icon: TextIcon,
            checked: activeTool.type === "text",
            name: "editor-current-shape",
            title: `${capitalizeString4(t("toolBar.text"))}`,
            "aria-label": capitalizeString4(t("toolBar.text")),
            "data-testid": "toolbar-text",
            onChange: () => handleToolChange("text")
          }
        ),
        showImageToolOutside && /* @__PURE__ */ jsx90(
          ToolButton,
          {
            className: clsx41({
              active: activeTool.type === "image"
            }),
            type: "radio",
            icon: ImageIcon,
            checked: activeTool.type === "image",
            name: "editor-current-shape",
            title: `${capitalizeString4(t("toolBar.image"))}`,
            "aria-label": capitalizeString4(t("toolBar.image")),
            "data-testid": "toolbar-image",
            onChange: () => handleToolChange("image")
          }
        ),
        showFrameToolOutside && /* @__PURE__ */ jsx90(
          ToolButton,
          {
            className: clsx41({ active: frameToolSelected }),
            type: "radio",
            icon: frameToolIcon,
            checked: frameToolSelected,
            name: "editor-current-shape",
            title: `${capitalizeString4(t("toolBar.frame"))}`,
            "aria-label": capitalizeString4(t("toolBar.frame")),
            "data-testid": "toolbar-frame",
            onChange: () => handleToolChange("frame")
          }
        ),
        /* @__PURE__ */ jsxs50(DropdownMenu_default, { open: isOtherShapesMenuOpen, children: [
          /* @__PURE__ */ jsx90(
            DropdownMenu_default.Trigger,
            {
              className: clsx41(
                "App-toolbar__extra-tools-trigger App-toolbar__extra-tools-trigger--mobile",
                {
                  "App-toolbar__extra-tools-trigger--selected": extraToolSelected || isOtherShapesMenuOpen
                }
              ),
              onToggle: () => {
                setIsOtherShapesMenuOpen(!isOtherShapesMenuOpen);
                setAppState({ openMenu: null, openPopup: null });
              },
              title: t("toolBar.extraTools"),
              style: {
                width: WIDTH,
                height: WIDTH,
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              children: extraIcon
            }
          ),
          /* @__PURE__ */ jsxs50(
            DropdownMenu_default.Content,
            {
              onClickOutside: () => setIsOtherShapesMenuOpen(false),
              onSelect: () => setIsOtherShapesMenuOpen(false),
              className: "App-toolbar__extra-tools-dropdown",
              align: "start",
              children: [
                !showTextToolOutside && /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "text" }),
                    icon: TextIcon,
                    shortcut: KEYS47.T.toLocaleUpperCase(),
                    "data-testid": "toolbar-text",
                    selected: activeTool.type === "text",
                    children: t("toolBar.text")
                  }
                ),
                !showImageToolOutside && /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "image" }),
                    icon: ImageIcon,
                    "data-testid": "toolbar-image",
                    selected: activeTool.type === "image",
                    children: t("toolBar.image")
                  }
                ),
                !showFrameToolOutside && /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "frame" }),
                    icon: frameToolIcon,
                    shortcut: KEYS47.F.toLocaleUpperCase(),
                    "data-testid": "toolbar-frame",
                    selected: frameToolSelected,
                    children: t("toolBar.frame")
                  }
                ),
                /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "embeddable" }),
                    icon: EmbedIcon,
                    "data-testid": "toolbar-embeddable",
                    selected: embeddableToolSelected,
                    children: t("toolBar.embeddable")
                  }
                ),
                /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setActiveTool({ type: "laser" }),
                    icon: laserPointerToolIcon,
                    "data-testid": "toolbar-laser",
                    selected: laserToolSelected,
                    shortcut: KEYS47.K.toLocaleUpperCase(),
                    children: t("toolBar.laser")
                  }
                ),
                /* @__PURE__ */ jsx90("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }),
                app.props.aiEnabled !== false && /* @__PURE__ */ jsx90(TTDDialogTriggerTunnel.Out, {}),
                /* @__PURE__ */ jsx90(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                    icon: mermaidLogoIcon,
                    "data-testid": "toolbar-embeddable",
                    children: t("toolBar.mermaidToExcalidraw")
                  }
                ),
                app.props.aiEnabled !== false && app.plugins.diagramToCode && /* @__PURE__ */ jsx90(Fragment11, { children: /* @__PURE__ */ jsxs50(
                  DropdownMenu_default.Item,
                  {
                    onSelect: () => app.onMagicframeToolSelect(),
                    icon: MagicIcon,
                    "data-testid": "toolbar-magicframe",
                    children: [
                      t("toolBar.magicframe"),
                      /* @__PURE__ */ jsx90(DropdownMenu_default.Item.Badge, { children: "AI" })
                    ]
                  }
                ) })
              ]
            }
          )
        ] })
      ]
    }
  );
};

// components/FixedSideContainer.tsx
import clsx42 from "clsx";
import { jsx as jsx91 } from "react/jsx-runtime";
var FixedSideContainer = ({
  children,
  side,
  className
}) => /* @__PURE__ */ jsx91(
  "div",
  {
    className: clsx42(
      "FixedSideContainer",
      `FixedSideContainer_side_${side}`,
      className
    ),
    children
  }
);

// components/PenModeButton.tsx
import clsx43 from "clsx";
import { jsx as jsx92, jsxs as jsxs51 } from "react/jsx-runtime";
var DEFAULT_SIZE = "medium";
var PenModeButton = (props) => {
  if (!props.penDetected) {
    return null;
  }
  return /* @__PURE__ */ jsxs51(
    "label",
    {
      className: clsx43(
        "ToolIcon ToolIcon__penMode",
        `ToolIcon_size_${DEFAULT_SIZE}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx92(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ jsx92("div", { className: "ToolIcon__icon", children: PenModeIcon })
      ]
    }
  );
};

// components/MobileMenu.tsx
import { Fragment as Fragment12, jsx as jsx93, jsxs as jsxs52 } from "react/jsx-runtime";
var MobileMenu = ({
  appState,
  elements,
  actionManager,
  setAppState,
  onHandToolToggle,
  renderTopLeftUI,
  renderTopRightUI,
  renderSidebars,
  renderWelcomeScreen,
  UIOptions,
  app,
  onPenModeToggle
}) => {
  const {
    WelcomeScreenCenterTunnel,
    MainMenuTunnel,
    DefaultSidebarTriggerTunnel
  } = useTunnels();
  const renderAppTopBar = () => {
    if (appState.openDialog?.name === "elementLinkSelector") {
      return null;
    }
    const topRightUI = /* @__PURE__ */ jsxs52("div", { className: "excalidraw-ui-top-right", children: [
      renderTopRightUI?.(true, appState) ?? (!appState.viewModeEnabled && /* @__PURE__ */ jsxs52(Fragment12, { children: [
        /* @__PURE__ */ jsx93(
          PenModeButton,
          {
            checked: appState.penMode,
            onChange: () => onPenModeToggle(null),
            title: t("toolBar.penMode"),
            isMobile: true,
            penDetected: appState.penDetected
          }
        ),
        /* @__PURE__ */ jsx93(DefaultSidebarTriggerTunnel.Out, {})
      ] })),
      appState.viewModeEnabled && /* @__PURE__ */ jsx93(ExitViewModeButton, { actionManager })
    ] });
    const topLeftUI = /* @__PURE__ */ jsxs52("div", { className: "excalidraw-ui-top-left", children: [
      renderTopLeftUI?.(true, appState),
      /* @__PURE__ */ jsx93(MainMenuTunnel.Out, {})
    ] });
    return /* @__PURE__ */ jsxs52(
      "div",
      {
        className: "App-toolbar-content",
        style: {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between"
        },
        children: [
          topLeftUI,
          topRightUI
        ]
      }
    );
  };
  const renderToolbar = () => {
    return /* @__PURE__ */ jsx93(
      MobileToolBar,
      {
        app,
        onHandToolToggle,
        setAppState
      }
    );
  };
  return /* @__PURE__ */ jsxs52(Fragment12, { children: [
    renderSidebars(),
    /* @__PURE__ */ jsx93("div", { className: "App-welcome-screen", children: renderWelcomeScreen && /* @__PURE__ */ jsx93(WelcomeScreenCenterTunnel.Out, {}) }),
    !appState.viewModeEnabled && /* @__PURE__ */ jsxs52(
      "div",
      {
        className: "App-bottom-bar",
        style: {
          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN
        },
        children: [
          /* @__PURE__ */ jsx93(
            MobileShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction,
              app,
              setAppState
            }
          ),
          /* @__PURE__ */ jsxs52(Island, { className: "App-toolbar", children: [
            !appState.viewModeEnabled && appState.openDialog?.name !== "elementLinkSelector" && renderToolbar(),
            appState.scrolledOutside && !appState.openMenu && !appState.openSidebar && /* @__PURE__ */ jsx93(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsx93(FixedSideContainer, { side: "top", className: "App-top-bar", children: renderAppTopBar() })
  ] });
};

// components/PasteChartDialog.tsx
import React32, { useLayoutEffect as useLayoutEffect5, useRef as useRef26, useState as useState30 } from "react";
import { jsx as jsx94, jsxs as jsxs53 } from "react/jsx-runtime";
var ChartPreviewBtn = (props) => {
  const previewRef = useRef26(null);
  const [chartElements, setChartElements] = useState30(
    null
  );
  useLayoutEffect5(() => {
    if (!props.spreadsheet) {
      return;
    }
    const elements = renderSpreadsheet(
      props.chartType,
      props.spreadsheet,
      0,
      0
    );
    setChartElements(elements);
    let svg;
    const previewNode = previewRef.current;
    (async () => {
      svg = await exportToSvg(
        elements,
        {
          exportBackground: false,
          viewBackgroundColor: "#fff"
        },
        null,
        // files
        {
          skipInliningFonts: true
        }
      );
      svg.querySelector(".style-fonts")?.remove();
      previewNode.replaceChildren();
      previewNode.appendChild(svg);
      if (props.selected) {
        previewNode.parentNode.focus();
      }
    })();
    return () => {
      previewNode.replaceChildren();
    };
  }, [props.spreadsheet, props.chartType, props.selected]);
  return /* @__PURE__ */ jsx94(
    "button",
    {
      type: "button",
      className: "ChartPreview",
      onClick: () => {
        if (chartElements) {
          props.onClick(props.chartType, chartElements);
        }
      },
      children: /* @__PURE__ */ jsx94("div", { ref: previewRef })
    }
  );
};
var PasteChartDialog = ({
  setAppState,
  appState,
  onClose
}) => {
  const { onInsertElements } = useApp();
  const handleClose = React32.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  const handleChartClick = (chartType, elements) => {
    onInsertElements(elements);
    trackEvent("paste", "chart", chartType);
    setAppState({
      currentChartType: chartType,
      pasteDialog: {
        shown: false,
        data: null
      }
    });
  };
  return /* @__PURE__ */ jsx94(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("labels.pasteCharts"),
      className: "PasteChartDialog",
      autofocus: false,
      children: /* @__PURE__ */ jsxs53("div", { className: "container", children: [
        /* @__PURE__ */ jsx94(
          ChartPreviewBtn,
          {
            chartType: "bar",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "bar",
            onClick: handleChartClick
          }
        ),
        /* @__PURE__ */ jsx94(
          ChartPreviewBtn,
          {
            chartType: "line",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "line",
            onClick: handleChartClick
          }
        )
      ] })
    }
  );
};

// components/Section.tsx
import { Fragment as Fragment13, jsx as jsx95, jsxs as jsxs54 } from "react/jsx-runtime";
var Section = ({ heading, children, ...props }) => {
  const { id } = useExcalidrawContainer();
  const header = /* @__PURE__ */ jsx95("h2", { className: "visually-hidden", id: `${id}-${heading}-title`, children: t(`headings.${heading}`) });
  return /* @__PURE__ */ jsx95("section", { ...props, "aria-labelledby": `${id}-${heading}-title`, children: typeof children === "function" ? children(header) : /* @__PURE__ */ jsxs54(Fragment13, { children: [
    header,
    children
  ] }) });
};

// components/footer/Footer.tsx
import clsx45 from "clsx";
import { capitalizeString as capitalizeString5, TOOL_TYPE as TOOL_TYPE2 } from "@excalidraw/common";

// components/HelpButton.tsx
import { jsx as jsx96 } from "react/jsx-runtime";
var HelpButton = (props) => /* @__PURE__ */ jsx96(
  "button",
  {
    className: "help-icon",
    onClick: props.onClick,
    type: "button",
    title: `${t("helpDialog.title")} \u2014 ?`,
    "aria-label": t("helpDialog.title"),
    children: HelpIcon
  }
);

// components/HintViewer.tsx
import { CANVAS_SEARCH_TAB as CANVAS_SEARCH_TAB2, DEFAULT_SIDEBAR as DEFAULT_SIDEBAR4 } from "@excalidraw/common";
import {
  isFlowchartNodeElement,
  isImageElement as isImageElement4,
  isLinearElement as isLinearElement10,
  isLineElement as isLineElement6,
  isTextBindableContainer as isTextBindableContainer2,
  isTextElement as isTextElement13
} from "@excalidraw/element";
import { isNodeInFlowchart } from "@excalidraw/element";
import { jsx as jsx97 } from "react/jsx-runtime";
var getTaggedShortcutKey = (key) => Array.isArray(key) ? `<kbd>${key.map(getShortcutKey).join(" + ")}</kbd>` : `<kbd>${getShortcutKey(key)}</kbd>`;
var getHints = ({
  appState,
  isMobile,
  editorInterface,
  app
}) => {
  const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;
  const multiMode = appState.multiElement !== null;
  if (appState.openSidebar?.name === DEFAULT_SIDEBAR4.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB2 && appState.searchMatches?.matches.length) {
    return t("hints.dismissSearch", {
      shortcut: getTaggedShortcutKey("Escape")
    });
  }
  if (appState.openSidebar && !editorInterface.canFitSidebar) {
    return null;
  }
  if (isEraserActive(appState)) {
    return t("hints.eraserRevert", {
      shortcut: getTaggedShortcutKey("Alt")
    });
  }
  const selectedElements = app.scene.getSelectedElements(appState);
  if (appState.selectedLinearElement?.isDragging && selectedElements[0]?.type === "arrow") {
    return t("hints.arrowBindModifiers", {
      shortcut_1: getTaggedShortcutKey("Ctrl"),
      shortcut_2: getTaggedShortcutKey("Alt")
    });
  }
  if (activeTool.type === "arrow" || activeTool.type === "line") {
    if (multiMode) {
      return t("hints.linearElementMulti", {
        shortcut_1: getTaggedShortcutKey("Escape"),
        shortcut_2: getTaggedShortcutKey("Enter")
      });
    }
    if (activeTool.type === "arrow") {
      return t("hints.arrowTool", {
        shortcut: getTaggedShortcutKey("A")
      });
    }
    return t("hints.linearElement");
  }
  if (activeTool.type === "freedraw") {
    return t("hints.freeDraw");
  }
  if (activeTool.type === "text") {
    return t("hints.text");
  }
  if (activeTool.type === "embeddable") {
    return t("hints.embeddable");
  }
  if (isResizing && lastPointerDownWith === "mouse" && selectedElements.length === 1) {
    const targetElement = selectedElements[0];
    if (isLinearElement10(targetElement) && targetElement.points.length === 2) {
      return t("hints.lockAngle", {
        shortcut: getTaggedShortcutKey("Shift")
      });
    }
    return isImageElement4(targetElement) ? t("hints.resizeImage", {
      shortcut_1: getTaggedShortcutKey("Shift"),
      shortcut_2: getTaggedShortcutKey("Alt")
    }) : t("hints.resize", {
      shortcut_1: getTaggedShortcutKey("Shift"),
      shortcut_2: getTaggedShortcutKey("Alt")
    });
  }
  if (isRotating && lastPointerDownWith === "mouse") {
    return t("hints.rotate", {
      shortcut: getTaggedShortcutKey("Shift")
    });
  }
  if (selectedElements.length === 1 && isTextElement13(selectedElements[0])) {
    return t("hints.text_selected", {
      shortcut: getTaggedShortcutKey("Enter")
    });
  }
  if (appState.editingTextElement) {
    return t("hints.text_editing", {
      shortcut_1: getTaggedShortcutKey("Escape"),
      shortcut_2: getTaggedShortcutKey(["CtrlOrCmd", "Enter"])
    });
  }
  if (appState.croppingElementId) {
    return t("hints.leaveCropEditor", {
      shortcut_1: getTaggedShortcutKey("Enter"),
      shortcut_2: getTaggedShortcutKey("Escape")
    });
  }
  if (selectedElements.length === 1 && isImageElement4(selectedElements[0])) {
    return t("hints.enterCropEditor", {
      shortcut: getTaggedShortcutKey("Enter")
    });
  }
  if (activeTool.type === "selection") {
    if (appState.selectionElement && !selectedElements.length && !appState.editingTextElement && !appState.selectedLinearElement?.isEditing) {
      return t("hints.deepBoxSelect", {
        shortcut: getTaggedShortcutKey("CtrlOrCmd")
      });
    }
    if (isGridModeEnabled(app) && appState.selectedElementsAreBeingDragged) {
      return t("hints.disableSnapping", {
        shortcut: getTaggedShortcutKey("CtrlOrCmd")
      });
    }
    if (!selectedElements.length && !isMobile) {
      return t("hints.canvasPanning", {
        shortcut_1: getTaggedShortcutKey(t("keys.mmb")),
        shortcut_2: getTaggedShortcutKey("Space")
      });
    }
    if (selectedElements.length === 1) {
      if (isLinearElement10(selectedElements[0])) {
        if (appState.selectedLinearElement?.isEditing) {
          return appState.selectedLinearElement.selectedPointsIndices ? t("hints.lineEditor_pointSelected", {
            shortcut_1: getTaggedShortcutKey("Delete"),
            shortcut_2: getTaggedShortcutKey(["CtrlOrCmd", "D"])
          }) : t("hints.lineEditor_nothingSelected", {
            shortcut_1: getTaggedShortcutKey("Shift"),
            shortcut_2: getTaggedShortcutKey("Alt")
          });
        }
        return isLineElement6(selectedElements[0]) ? t("hints.lineEditor_line_info", {
          shortcut: getTaggedShortcutKey("Enter")
        }) : t("hints.lineEditor_info", {
          shortcut_1: getTaggedShortcutKey("CtrlOrCmd"),
          shortcut_2: getTaggedShortcutKey(["CtrlOrCmd", "Enter"])
        });
      }
      if (!appState.newElement && !appState.selectedElementsAreBeingDragged && isTextBindableContainer2(selectedElements[0])) {
        const bindTextToElement = t("hints.bindTextToElement", {
          shortcut: getTaggedShortcutKey("Enter")
        });
        const createFlowchart = t("hints.createFlowchart", {
          shortcut: getTaggedShortcutKey(["CtrlOrCmd", "\u2191\u2193"])
        });
        if (isFlowchartNodeElement(selectedElements[0])) {
          if (isNodeInFlowchart(
            selectedElements[0],
            app.scene.getNonDeletedElementsMap()
          )) {
            return [bindTextToElement, createFlowchart];
          }
          return [bindTextToElement, createFlowchart];
        }
        return bindTextToElement;
      }
    }
  }
  return null;
};
var HintViewer = ({
  appState,
  isMobile,
  editorInterface,
  app
}) => {
  const hints = getHints({
    appState,
    isMobile,
    editorInterface,
    app
  });
  if (!hints) {
    return null;
  }
  const hint = Array.isArray(hints) ? hints.map((hint2) => hint2.replace(/\. ?$/, "")).join(", ") : hints;
  const hintJSX = hint.split(/(<kbd>[^<]+<\/kbd>)/g).map((part, index) => {
    if (index % 2 === 1) {
      const shortcutMatch = part[0] === "<" && part.match(/^<kbd>([^<]+)<\/kbd>$/);
      return /* @__PURE__ */ jsx97("kbd", { children: shortcutMatch ? shortcutMatch[1] : part }, index);
    }
    return part;
  });
  return /* @__PURE__ */ jsx97("div", { className: "HintViewer", children: /* @__PURE__ */ jsx97("span", { children: hintJSX }) });
};

// components/LaserPointerButton.tsx
import clsx44 from "clsx";
import { jsx as jsx98, jsxs as jsxs55 } from "react/jsx-runtime";
var DEFAULT_SIZE2 = "small";
var LaserPointerButton = (props) => {
  return /* @__PURE__ */ jsxs55(
    "label",
    {
      className: clsx44(
        "ToolIcon ToolIcon__LaserPointer",
        `ToolIcon_size_${DEFAULT_SIZE2}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx98(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-LaserPointer"
          }
        ),
        /* @__PURE__ */ jsx98("div", { className: "ToolIcon__icon", children: laserPointerToolIcon })
      ]
    }
  );
};

// components/footer/Footer.tsx
import { jsx as jsx99, jsxs as jsxs56 } from "react/jsx-runtime";
var Footer = ({
  appState,
  actionManager,
  showExitZenModeBtn,
  renderWelcomeScreen,
  footerCenterContent,
  setAppState,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  UIOptions,
  app,
  isCollaborating,
  editorInterface,
  spacing,
  isCompactStylesPanel
}) => {
  const {
    FooterCenterTunnel,
    WelcomeScreenHelpHintTunnel,
    WelcomeScreenToolbarHintTunnel
  } = useTunnels();
  return /* @__PURE__ */ jsxs56(
    "footer",
    {
      role: "contentinfo",
      className: "layer-ui__wrapper__footer App-menu App-menu_bottom drawing-footer",
      children: [
        /* @__PURE__ */ jsx99(
          "div",
          {
            className: clsx45("layer-ui__wrapper__footer-left zen-mode-transition", {
              "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ jsx99(Stack_default.Col, { gap: 2, children: /* @__PURE__ */ jsx99(Section, { heading: "canvasActions", children: /* @__PURE__ */ jsx99(
              ZoomActions,
              {
                renderAction: actionManager.renderAction,
                zoom: appState.zoom
              }
            ) }) })
          }
        ),
        /* @__PURE__ */ jsx99(
          "div",
          {
            className: clsx45("zen-mode-transition", {
              "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
            }),
            children: !appState.viewModeEnabled && appState.openDialog?.name !== "elementLinkSelector" && /* @__PURE__ */ jsx99(
              Section,
              {
                heading: "shapes",
                className: "shapes-section App-menu_bottom_center",
                children: (heading) => /* @__PURE__ */ jsxs56("div", { style: { position: "relative" }, children: [
                  renderWelcomeScreen && /* @__PURE__ */ jsx99(WelcomeScreenToolbarHintTunnel.Out, {}),
                  /* @__PURE__ */ jsx99(Stack_default.Col, { gap: spacing.toolbarColGap, align: "start", children: /* @__PURE__ */ jsxs56(
                    Stack_default.Row,
                    {
                      gap: spacing.toolbarRowGap,
                      className: clsx45("App-toolbar-container", {
                        "zen-mode": appState.zenModeEnabled
                      }),
                      children: [
                        /* @__PURE__ */ jsxs56(
                          Island,
                          {
                            padding: spacing.islandPadding,
                            className: clsx45("App-toolbar", {
                              "zen-mode": appState.zenModeEnabled,
                              "App-toolbar--compact": isCompactStylesPanel
                            }),
                            children: [
                              /* @__PURE__ */ jsx99(
                                HintViewer,
                                {
                                  appState,
                                  isMobile: editorInterface.formFactor === "phone",
                                  editorInterface,
                                  app
                                }
                              ),
                              heading,
                              /* @__PURE__ */ jsxs56(Stack_default.Row, { gap: spacing.toolbarInnerRowGap, children: [
                                /* @__PURE__ */ jsx99(
                                  PenModeButton,
                                  {
                                    zenModeEnabled: appState.zenModeEnabled,
                                    checked: appState.penMode,
                                    onChange: () => onPenModeToggle(null),
                                    title: t("toolBar.penMode"),
                                    penDetected: appState.penDetected
                                  }
                                ),
                                UIOptions.tools?.selection !== false && /* @__PURE__ */ jsx99(
                                  ToolPopover,
                                  {
                                    app,
                                    options: [
                                      {
                                        type: "selection",
                                        icon: SelectionIcon,
                                        title: capitalizeString5(t("toolBar.selection"))
                                      },
                                      {
                                        type: "lasso",
                                        icon: LassoIcon,
                                        title: capitalizeString5(t("toolBar.lasso"))
                                      }
                                    ],
                                    activeTool: appState.activeTool,
                                    defaultOption: app.state.preferredSelectionTool.type,
                                    namePrefix: "selectionType",
                                    title: capitalizeString5(t("toolBar.selection")),
                                    "data-testid": "toolbar-selection",
                                    onToolChange: (type) => {
                                      if (type === "selection" || type === "lasso") {
                                        app.setActiveTool({ type });
                                        setAppState({
                                          preferredSelectionTool: { type, initialized: true }
                                        });
                                      }
                                    },
                                    displayedOption: app.state.preferredSelectionTool.type === "lasso" ? {
                                      type: "lasso",
                                      icon: LassoIcon,
                                      title: capitalizeString5(t("toolBar.lasso"))
                                    } : {
                                      type: "selection",
                                      icon: SelectionIcon,
                                      title: capitalizeString5(t("toolBar.selection"))
                                    },
                                    fillable: appState.activeTool.type === "selection"
                                  }
                                ),
                                /* @__PURE__ */ jsx99(
                                  HandButton,
                                  {
                                    checked: isHandToolActive(appState),
                                    onChange: () => onHandToolToggle(),
                                    title: t("toolBar.hand"),
                                    isMobile: true
                                  }
                                ),
                                /* @__PURE__ */ jsx99("div", { className: "App-toolbar__divider" }),
                                /* @__PURE__ */ jsx99(
                                  ShapesSwitcher,
                                  {
                                    setAppState,
                                    activeTool: appState.activeTool,
                                    UIOptions,
                                    app
                                  }
                                )
                              ] })
                            ]
                          }
                        ),
                        isCollaborating && /* @__PURE__ */ jsx99(
                          Island,
                          {
                            style: {
                              marginLeft: spacing.collabMarginLeft,
                              alignSelf: "center",
                              height: "fit-content"
                            },
                            children: /* @__PURE__ */ jsx99(
                              LaserPointerButton,
                              {
                                title: t("toolBar.laser"),
                                checked: appState.activeTool.type === TOOL_TYPE2.laser,
                                onChange: () => app.setActiveTool({ type: TOOL_TYPE2.laser }),
                                isMobile: true
                              }
                            )
                          }
                        )
                      ]
                    }
                  ) })
                ] })
              }
            )
          }
        ),
        /* @__PURE__ */ jsx99(
          "div",
          {
            className: clsx45("layer-ui__wrapper__footer-right zen-mode-transition", {
              "transition-right": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ jsxs56("div", { style: { position: "relative" }, children: [
              renderWelcomeScreen && /* @__PURE__ */ jsx99(WelcomeScreenHelpHintTunnel.Out, {}),
              /* @__PURE__ */ jsx99(
                HelpButton,
                {
                  onClick: () => actionManager.executeAction(actionShortcuts)
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsx99(
          ExitZenModeButton,
          {
            actionManager,
            showExitZenModeBtn
          }
        )
      ]
    }
  );
};
var Footer_default = Footer;
Footer.displayName = "Footer";

// components/Sidebar/Sidebar.tsx
import clsx48 from "clsx";
import {
  useEffect as useEffect32,
  useLayoutEffect as useLayoutEffect6,
  useRef as useRef27,
  useState as useState31,
  forwardRef as forwardRef4,
  useImperativeHandle as useImperativeHandle3,
  useCallback as useCallback15
} from "react";
import {
  CLASSES as CLASSES8,
  EVENT as EVENT10,
  isDevEnv as isDevEnv7,
  KEYS as KEYS48,
  updateObject
} from "@excalidraw/common";

// components/Sidebar/SidebarHeader.tsx
import clsx46 from "clsx";
import { useContext as useContext2 } from "react";

// components/Sidebar/common.ts
import React33 from "react";
var SidebarPropsContext = React33.createContext({});

// components/Sidebar/SidebarHeader.tsx
import { jsx as jsx100, jsxs as jsxs57 } from "react/jsx-runtime";
var SidebarHeader = ({
  children,
  className
}) => {
  const editorInterface = useEditorInterface();
  const props = useContext2(SidebarPropsContext);
  const renderDockButton = !!(editorInterface.canFitSidebar && props.shouldRenderDockButton);
  return /* @__PURE__ */ jsxs57(
    "div",
    {
      className: clsx46("sidebar__header", className),
      "data-testid": "sidebar-header",
      children: [
        children,
        /* @__PURE__ */ jsxs57("div", { className: "sidebar__header__buttons", children: [
          renderDockButton && /* @__PURE__ */ jsx100(Tooltip, { label: t("labels.sidebarLock"), children: /* @__PURE__ */ jsx100(
            Button,
            {
              onSelect: () => props.onDock?.(!props.docked),
              selected: !!props.docked,
              className: "sidebar__dock",
              "data-testid": "sidebar-dock",
              "aria-label": t("labels.sidebarLock"),
              children: PinIcon
            }
          ) }),
          /* @__PURE__ */ jsx100(
            Button,
            {
              "data-testid": "sidebar-close",
              className: "sidebar__close",
              onSelect: props.onCloseRequest,
              "aria-label": t("buttons.close"),
              children: CloseIcon
            }
          )
        ] })
      ]
    }
  );
};
SidebarHeader.displayName = "SidebarHeader";

// components/Sidebar/SidebarTabTrigger.tsx
import { Tabs as RadixTabs } from "radix-ui";
import { jsx as jsx101 } from "react/jsx-runtime";
var SidebarTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ jsx101(RadixTabs.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx101(
    "button",
    {
      type: "button",
      className: `excalidraw-button sidebar-tab-trigger`,
      ...rest,
      children
    }
  ) });
};
SidebarTabTrigger.displayName = "SidebarTabTrigger";

// components/Sidebar/SidebarTabTriggers.tsx
import { Tabs as RadixTabs2 } from "radix-ui";
import { jsx as jsx102 } from "react/jsx-runtime";
var SidebarTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx102(RadixTabs2.List, { className: "sidebar-triggers", ...rest, children });
};
SidebarTabTriggers.displayName = "SidebarTabTriggers";

// components/Sidebar/SidebarTrigger.tsx
import clsx47 from "clsx";
import { jsx as jsx103, jsxs as jsxs58 } from "react/jsx-runtime";
var SidebarTrigger = ({
  name,
  tab,
  icon,
  title,
  children,
  onToggle,
  className,
  style
}) => {
  const setAppState = useExcalidrawSetAppState();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsxs58("label", { title, className: "sidebar-trigger__label-element", children: [
    /* @__PURE__ */ jsx103(
      "input",
      {
        className: "ToolIcon_type_checkbox",
        type: "checkbox",
        onChange: (event) => {
          document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
          const isOpen = event.target.checked;
          setAppState({
            openSidebar: isOpen ? { name, tab } : null,
            openMenu: null,
            openPopup: null
          });
          onToggle?.(isOpen);
        },
        checked: appState.openSidebar?.name === name,
        "aria-label": title,
        "aria-keyshortcuts": "0"
      }
    ),
    /* @__PURE__ */ jsxs58("div", { className: clsx47("sidebar-trigger", className), style, children: [
      icon && /* @__PURE__ */ jsx103("div", { children: icon }),
      children && /* @__PURE__ */ jsx103("div", { className: "sidebar-trigger__label", children })
    ] })
  ] });
};
SidebarTrigger.displayName = "SidebarTrigger";

// components/Sidebar/SidebarTabs.tsx
import { Tabs as RadixTabs3 } from "radix-ui";
import { jsx as jsx104 } from "react/jsx-runtime";
var SidebarTabs = ({
  children,
  ...rest
}) => {
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  if (!appState.openSidebar) {
    return null;
  }
  const { name } = appState.openSidebar;
  return /* @__PURE__ */ jsx104(
    RadixTabs3.Root,
    {
      className: "sidebar-tabs-root",
      value: appState.openSidebar.tab,
      onValueChange: (tab) => setAppState((state) => ({
        ...state,
        openSidebar: { ...state.openSidebar, name, tab }
      })),
      ...rest,
      children
    }
  );
};
SidebarTabs.displayName = "SidebarTabs";

// components/Sidebar/SidebarTab.tsx
import { Tabs as RadixTabs4 } from "radix-ui";
import { jsx as jsx105 } from "react/jsx-runtime";
var SidebarTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx105(RadixTabs4.Content, { ...rest, value: tab, "data-testid": tab, children });
};
SidebarTab.displayName = "SidebarTab";

// components/Sidebar/Sidebar.tsx
import { jsx as jsx106 } from "react/jsx-runtime";
import { createElement } from "react";
var isSidebarDockedAtom = atom(false);
var SidebarInner = forwardRef4(
  ({
    name,
    children,
    onDock,
    docked,
    className,
    ...rest
  }, ref) => {
    if (isDevEnv7() && onDock && docked == null) {
      console.warn(
        "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
      );
    }
    const setAppState = useExcalidrawSetAppState();
    const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom);
    useLayoutEffect6(() => {
      setIsSidebarDockedAtom(!!docked);
      return () => {
        setIsSidebarDockedAtom(false);
      };
    }, [setIsSidebarDockedAtom, docked]);
    const headerPropsRef = useRef27(
      {}
    );
    headerPropsRef.current.onCloseRequest = () => {
      setAppState({ openSidebar: null });
    };
    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);
    headerPropsRef.current = updateObject(headerPropsRef.current, {
      docked,
      // explicit prop to rerender on update
      shouldRenderDockButton: !!onDock && docked != null
    });
    const islandRef = useRef27(null);
    useImperativeHandle3(ref, () => {
      return islandRef.current;
    });
    const editorInterface = useEditorInterface();
    const closeLibrary = useCallback15(() => {
      const isDialogOpen = !!document.querySelector(".Dialog");
      if (isDialogOpen) {
        return;
      }
      setAppState({ openSidebar: null });
    }, [setAppState]);
    useOutsideClick(
      islandRef,
      useCallback15(
        (event) => {
          if (event.target.closest(".sidebar-trigger")) {
            return;
          }
          if (!docked || !editorInterface.canFitSidebar) {
            closeLibrary();
          }
        },
        [closeLibrary, docked, editorInterface.canFitSidebar]
      )
    );
    useEffect32(() => {
      const handleKeyDown = (event) => {
        if (event.key === KEYS48.ESCAPE && (!docked || !editorInterface.canFitSidebar)) {
          closeLibrary();
        }
      };
      document.addEventListener(EVENT10.KEYDOWN, handleKeyDown);
      return () => {
        document.removeEventListener(EVENT10.KEYDOWN, handleKeyDown);
      };
    }, [closeLibrary, docked, editorInterface.canFitSidebar]);
    return /* @__PURE__ */ jsx106(
      Island,
      {
        ...rest,
        className: clsx48(
          CLASSES8.SIDEBAR,
          { "sidebar--docked": docked },
          className
        ),
        ref: islandRef,
        children: /* @__PURE__ */ jsx106(SidebarPropsContext.Provider, { value: headerPropsRef.current, children })
      }
    );
  }
);
SidebarInner.displayName = "SidebarInner";
var Sidebar = Object.assign(
  forwardRef4((props, ref) => {
    const appState = useUIAppState();
    const { onStateChange } = props;
    const refPrevOpenSidebar = useRef27(appState.openSidebar);
    useEffect32(() => {
      if (
        // closing sidebar
        (!appState.openSidebar && refPrevOpenSidebar?.current?.name === props.name || // opening current sidebar
        appState.openSidebar?.name === props.name && refPrevOpenSidebar?.current?.name !== props.name || // switching tabs or switching to a different sidebar
        refPrevOpenSidebar.current?.name === props.name) && appState.openSidebar !== refPrevOpenSidebar.current
      ) {
        onStateChange?.(
          appState.openSidebar?.name !== props.name ? null : appState.openSidebar
        );
      }
      refPrevOpenSidebar.current = appState.openSidebar;
    }, [appState.openSidebar, onStateChange, props.name]);
    const [mounted, setMounted] = useState31(false);
    useLayoutEffect6(() => {
      setMounted(true);
      return () => setMounted(false);
    }, []);
    const shouldRender = mounted && appState.openSidebar?.name === props.name;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ createElement(SidebarInner, { ...props, ref, key: props.name });
  }),
  {
    Header: SidebarHeader,
    TabTriggers: SidebarTabTriggers,
    TabTrigger: SidebarTabTrigger,
    Tabs: SidebarTabs,
    Tab: SidebarTab,
    Trigger: SidebarTrigger
  }
);
Sidebar.displayName = "Sidebar";

// components/main-menu/MainMenu.tsx
import { composeEventHandlers as composeEventHandlers3 } from "@excalidraw/common";

// components/UserList.tsx
import { Popover as Popover9 } from "radix-ui";
import clsx49 from "clsx";
import React35, { useLayoutEffect as useLayoutEffect7 } from "react";
import { supportsResizeObserver, isShallowEqual as isShallowEqual5 } from "@excalidraw/common";
import { Fragment as Fragment14, jsx as jsx107, jsxs as jsxs59 } from "react/jsx-runtime";
var DEFAULT_MAX_AVATARS = 4;
var SHOW_COLLABORATORS_FILTER_AT = 8;
var ConditionalTooltipWrapper = ({
  shouldWrap,
  children,
  username
}) => shouldWrap ? /* @__PURE__ */ jsx107(Tooltip, { label: username || "Unknown user", children }) : /* @__PURE__ */ jsx107(Fragment14, { children });
var renderCollaborator = ({
  actionManager,
  collaborator,
  socketId,
  withName = false,
  shouldWrapWithTooltip = false,
  isBeingFollowed
}) => {
  const data = {
    socketId,
    collaborator,
    withName,
    isBeingFollowed
  };
  const avatarJSX = actionManager.renderAction("goToCollaborator", data);
  return /* @__PURE__ */ jsx107(
    ConditionalTooltipWrapper,
    {
      username: collaborator.username,
      shouldWrap: shouldWrapWithTooltip,
      children: avatarJSX
    },
    socketId
  );
};
var collaboratorComparatorKeys = [
  "avatarUrl",
  "id",
  "socketId",
  "username",
  "isInCall",
  "isSpeaking",
  "isMuted"
];
var UserList = React35.memo(
  ({ className, mobile, collaborators, userToFollow }) => {
    const actionManager = useExcalidrawActionManager();
    const uniqueCollaboratorsMap = /* @__PURE__ */ new Map();
    collaborators.forEach((collaborator, socketId) => {
      const userId = collaborator.id || socketId;
      uniqueCollaboratorsMap.set(
        // filter on user id, else fall back on unique socketId
        userId,
        { ...collaborator, socketId }
      );
    });
    const uniqueCollaboratorsArray = Array.from(
      uniqueCollaboratorsMap.values()
    ).filter((collaborator) => collaborator.username?.trim());
    const [searchTerm, setSearchTerm] = React35.useState("");
    const filteredCollaborators = uniqueCollaboratorsArray.filter(
      (collaborator) => collaborator.username?.toLowerCase().includes(searchTerm)
    );
    const userListWrapper = React35.useRef(null);
    useLayoutEffect7(() => {
      if (userListWrapper.current) {
        const updateMaxAvatars = (width) => {
          const maxAvatars2 = Math.max(1, Math.min(8, Math.floor(width / 38)));
          setMaxAvatars(maxAvatars2);
        };
        updateMaxAvatars(userListWrapper.current.clientWidth);
        if (!supportsResizeObserver) {
          return;
        }
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const { width } = entry.contentRect;
            updateMaxAvatars(width);
          }
        });
        resizeObserver.observe(userListWrapper.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
    }, []);
    const [maxAvatars, setMaxAvatars] = React35.useState(DEFAULT_MAX_AVATARS);
    const firstNCollaborators = uniqueCollaboratorsArray.slice(
      0,
      maxAvatars - 1
    );
    const firstNAvatarsJSX = firstNCollaborators.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    );
    return mobile ? /* @__PURE__ */ jsx107("div", { className: clsx49("UserList UserList_mobile", className), children: uniqueCollaboratorsArray.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    ) }) : /* @__PURE__ */ jsx107("div", { className: "UserList__wrapper", ref: userListWrapper, children: /* @__PURE__ */ jsxs59(
      "div",
      {
        className: clsx49("UserList", className),
        style: { [`--max-avatars`]: maxAvatars },
        children: [
          firstNAvatarsJSX,
          uniqueCollaboratorsArray.length > maxAvatars - 1 && /* @__PURE__ */ jsxs59(Popover9.Root, { children: [
            /* @__PURE__ */ jsxs59(Popover9.Trigger, { className: "UserList__more", children: [
              "+",
              uniqueCollaboratorsArray.length - maxAvatars + 1
            ] }),
            /* @__PURE__ */ jsx107(
              Popover9.Content,
              {
                style: {
                  zIndex: 2,
                  width: "15rem",
                  textAlign: "left"
                },
                align: "end",
                sideOffset: 10,
                children: /* @__PURE__ */ jsxs59(Island, { padding: 2, children: [
                  uniqueCollaboratorsArray.length >= SHOW_COLLABORATORS_FILTER_AT && /* @__PURE__ */ jsx107(
                    QuickSearch,
                    {
                      placeholder: t("quickSearch.placeholder"),
                      onChange: setSearchTerm
                    }
                  ),
                  /* @__PURE__ */ jsx107(
                    ScrollableList,
                    {
                      className: "dropdown-menu UserList__collaborators",
                      placeholder: t("userList.empty"),
                      children: filteredCollaborators.length > 0 ? [
                        /* @__PURE__ */ jsx107("div", { className: "hint", children: t("userList.hint.text") }),
                        filteredCollaborators.map(
                          (collaborator) => renderCollaborator({
                            actionManager,
                            collaborator,
                            socketId: collaborator.socketId,
                            withName: true,
                            isBeingFollowed: collaborator.socketId === userToFollow
                          })
                        )
                      ] : []
                    }
                  ),
                  /* @__PURE__ */ jsx107(
                    Popover9.Arrow,
                    {
                      width: 20,
                      height: 10,
                      style: {
                        fill: "var(--popup-bg-color)",
                        filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
                      }
                    }
                  )
                ] })
              }
            )
          ] })
        ]
      }
    ) });
  },
  (prev, next) => {
    if (prev.collaborators.size !== next.collaborators.size || prev.mobile !== next.mobile || prev.className !== next.className || prev.userToFollow !== next.userToFollow) {
      return false;
    }
    const nextCollaboratorSocketIds = next.collaborators.keys();
    for (const [socketId, collaborator] of prev.collaborators) {
      const nextCollaborator = next.collaborators.get(socketId);
      if (!nextCollaborator || // this checks order of collaborators in the map is the same
      // as previous render
      socketId !== nextCollaboratorSocketIds.next().value || !isShallowEqual5(
        collaborator,
        nextCollaborator,
        collaboratorComparatorKeys
      )) {
        return false;
      }
    }
    return true;
  }
);

// components/hoc/withInternalFallback.tsx
import { useLayoutEffect as useLayoutEffect8, useRef as useRef28 } from "react";
import { jsx as jsx108 } from "react/jsx-runtime";
var withInternalFallback = (componentName, Component) => {
  const renderAtom = atom(0);
  const WrapperComponent = (props) => {
    const {
      tunnelsJotai: { useAtom: useAtom2 }
    } = useTunnels();
    const [, setCounter] = useAtom2(renderAtom);
    const metaRef = useRef28({
      // flag set on initial render to tell the fallback component to skip the
      // render until mount counter are initialized. This is because the counter
      // is initialized in an effect, and thus we could end rendering both
      // components at the same time until counter is initialized.
      preferHost: false,
      counter: 0
    });
    useLayoutEffect8(() => {
      const meta = metaRef.current;
      setCounter((c) => {
        const next = c + 1;
        meta.counter = next;
        return next;
      });
      return () => {
        setCounter((c) => {
          const next = c - 1;
          meta.counter = next;
          if (!next) {
            meta.preferHost = false;
          }
          return next;
        });
      };
    }, [setCounter]);
    if (!props.__fallback) {
      metaRef.current.preferHost = true;
    }
    if (
      // either before the counters are initialized
      !metaRef.current.counter && props.__fallback && metaRef.current.preferHost || // or after the counters are initialized, and both are rendered
      // (this is the default when host renders as well)
      metaRef.current.counter > 1 && props.__fallback
    ) {
      return null;
    }
    return /* @__PURE__ */ jsx108(Component, { ...props });
  };
  WrapperComponent.displayName = componentName;
  return WrapperComponent;
};

// components/main-menu/DefaultItems.tsx
var DefaultItems_exports = {};
__export(DefaultItems_exports, {
  ChangeCanvasBackground: () => ChangeCanvasBackground,
  ClearCanvas: () => ClearCanvas,
  CommandPalette: () => CommandPalette2,
  Export: () => Export,
  Help: () => Help,
  LiveCollaborationTrigger: () => LiveCollaborationTrigger,
  LoadScene: () => LoadScene,
  Preferences: () => Preferences,
  PreferencesToggleGridModeItem: () => PreferencesToggleGridModeItem,
  PreferencesToggleZenModeItem: () => PreferencesToggleZenModeItem,
  SaveAsImage: () => SaveAsImage,
  SaveToActiveFile: () => SaveToActiveFile,
  SearchMenu: () => SearchMenu,
  Socials: () => Socials,
  ToggleTheme: () => ToggleTheme
});
import clsx51 from "clsx";
import { THEME as THEME14 } from "@excalidraw/common";

// components/OverwriteConfirm/OverwriteConfirmState.ts
var overwriteConfirmStateAtom = atom({
  active: false
});
async function openConfirmModal({
  title,
  description,
  actionLabel,
  color
}) {
  return new Promise((resolve) => {
    editorJotaiStore.set(overwriteConfirmStateAtom, {
      active: true,
      onConfirm: () => resolve(true),
      onClose: () => resolve(false),
      onReject: () => resolve(false),
      title,
      description,
      actionLabel,
      color
    });
  });
}

// components/RadioGroup.tsx
import clsx50 from "clsx";
import { jsx as jsx109, jsxs as jsxs60 } from "react/jsx-runtime";
var RadioGroup = function({
  onChange,
  value,
  choices,
  name
}) {
  return /* @__PURE__ */ jsx109("div", { className: "RadioGroup", children: choices.map((choice) => /* @__PURE__ */ jsxs60(
    "div",
    {
      className: clsx50("RadioGroup__choice", {
        active: choice.value === value
      }),
      title: choice.ariaLabel,
      children: [
        /* @__PURE__ */ jsx109(
          "input",
          {
            name,
            type: "radio",
            checked: choice.value === value,
            onChange: () => onChange(choice.value),
            "aria-label": choice.ariaLabel
          }
        ),
        choice.label
      ]
    },
    String(choice.value)
  )) });
};

// components/dropdownMenu/DropdownMenuItemContentRadio.tsx
import { Fragment as Fragment15, jsx as jsx110, jsxs as jsxs61 } from "react/jsx-runtime";
var DropdownMenuItemContentRadio = ({
  value,
  shortcut,
  onChange,
  choices,
  children,
  name
}) => {
  const editorInterface = useEditorInterface();
  return /* @__PURE__ */ jsxs61(Fragment15, { children: [
    /* @__PURE__ */ jsxs61("div", { className: "dropdown-menu-item-base dropdown-menu-item-bare", children: [
      /* @__PURE__ */ jsx110("label", { className: "dropdown-menu-item__text", children }),
      /* @__PURE__ */ jsx110(
        RadioGroup,
        {
          name,
          value,
          onChange,
          choices
        }
      )
    ] }),
    shortcut && editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsx110("div", { className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned", children: shortcut })
  ] });
};
DropdownMenuItemContentRadio.displayName = "DropdownMenuItemContentRadio";
var DropdownMenuItemContentRadio_default = DropdownMenuItemContentRadio;

// components/main-menu/DefaultItems.tsx
import { Fragment as Fragment16, jsx as jsx111, jsxs as jsxs62 } from "react/jsx-runtime";
var LoadScene = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const elements = useExcalidrawElements();
  if (!actionManager.isActionEnabled(actionLoadScene)) {
    return null;
  }
  const handleSelect = async () => {
    if (!elements.length || await openConfirmModal({
      title: t2("overwriteConfirm.modal.loadFromFile.title"),
      actionLabel: t2("overwriteConfirm.modal.loadFromFile.button"),
      color: "warning",
      description: /* @__PURE__ */ jsx111(
        Trans_default,
        {
          i18nKey: "overwriteConfirm.modal.loadFromFile.description",
          bold: (text) => /* @__PURE__ */ jsx111("strong", { children: text }),
          br: () => /* @__PURE__ */ jsx111("br", {})
        }
      )
    })) {
      actionManager.executeAction(actionLoadScene);
    }
  };
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: LoadIcon,
      onSelect: handleSelect,
      "data-testid": "load-button",
      shortcut: getShortcutFromShortcutName("loadScene"),
      "aria-label": t2("buttons.load"),
      children: t2("buttons.load")
    }
  );
};
LoadScene.displayName = "LoadScene";
var SaveToActiveFile = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {
    return null;
  }
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      shortcut: getShortcutFromShortcutName("saveScene"),
      "data-testid": "save-button",
      onSelect: () => actionManager.executeAction(actionSaveToActiveFile),
      icon: save,
      "aria-label": `${t2("buttons.save")}`,
      children: `${t2("buttons.save")}`
    }
  );
};
SaveToActiveFile.displayName = "SaveToActiveFile";
var SaveAsImage = () => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: ExportImageIcon,
      "data-testid": "image-export-button",
      onSelect: () => setAppState({ openDialog: { name: "imageExport" } }),
      shortcut: getShortcutFromShortcutName("imageExport"),
      "aria-label": t2("buttons.exportImage"),
      children: t2("buttons.exportImage")
    }
  );
};
SaveAsImage.displayName = "SaveAsImage";
var CommandPalette2 = (opts) => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: boltIcon,
      "data-testid": "command-palette-button",
      onSelect: () => {
        trackEvent("command_palette", "open", "menu");
        setAppState({ openDialog: { name: "commandPalette" } });
      },
      shortcut: getShortcutFromShortcutName("commandPalette"),
      "aria-label": t2("commandPalette.title"),
      className: opts?.className,
      children: t2("commandPalette.title")
    }
  );
};
CommandPalette2.displayName = "CommandPalette";
var SearchMenu = (opts) => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: searchIcon,
      "data-testid": "search-menu-button",
      onSelect: () => {
        actionManager.executeAction(actionToggleSearchMenu);
      },
      shortcut: getShortcutFromShortcutName("searchMenu"),
      "aria-label": t2("search.title"),
      className: opts?.className,
      children: t2("search.title")
    }
  );
};
SearchMenu.displayName = "SearchMenu";
var Help = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      "data-testid": "help-menu-item",
      icon: HelpIcon,
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      "aria-label": t2("helpDialog.title"),
      children: t2("helpDialog.title")
    }
  );
};
Help.displayName = "Help";
var ClearCanvas = () => {
  const { t: t2 } = useI18n();
  const setActiveConfirmDialog = useSetAtom(activeConfirmDialogAtom);
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionClearCanvas)) {
    return null;
  }
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: TrashIcon,
      onSelect: () => setActiveConfirmDialog("clearCanvas"),
      "data-testid": "clear-canvas-button",
      "aria-label": t2("buttons.clearReset"),
      children: t2("buttons.clearReset")
    }
  );
};
ClearCanvas.displayName = "ClearCanvas";
var ToggleTheme = (props) => {
  const { t: t2 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const shortcut = getShortcutFromShortcutName("toggleTheme");
  if (!actionManager.isActionEnabled(actionToggleTheme)) {
    return null;
  }
  if (props?.allowSystemTheme) {
    return /* @__PURE__ */ jsx111(
      DropdownMenuItemContentRadio_default,
      {
        name: "theme",
        value: props.theme,
        onChange: (value) => props.onSelect(value),
        choices: [
          {
            value: THEME14.LIGHT,
            label: SunIcon,
            ariaLabel: `${t2("buttons.lightMode")} - ${shortcut}`
          },
          {
            value: THEME14.DARK,
            label: MoonIcon,
            ariaLabel: `${t2("buttons.darkMode")} - ${shortcut}`
          },
          {
            value: "system",
            label: DeviceDesktopIcon,
            ariaLabel: t2("buttons.systemMode")
          }
        ],
        children: t2("labels.theme")
      }
    );
  }
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      onSelect: (event) => {
        event.preventDefault();
        if (props?.onSelect) {
          props.onSelect(
            appState.theme === THEME14.DARK ? THEME14.LIGHT : THEME14.DARK
          );
        } else {
          return actionManager.executeAction(actionToggleTheme);
        }
      },
      icon: appState.theme === THEME14.DARK ? SunIcon : MoonIcon,
      "data-testid": "toggle-dark-mode",
      shortcut,
      "aria-label": appState.theme === THEME14.DARK ? t2("buttons.lightMode") : t2("buttons.darkMode"),
      children: appState.theme === THEME14.DARK ? t2("buttons.lightMode") : t2("buttons.darkMode")
    }
  );
};
ToggleTheme.displayName = "ToggleTheme";
var ChangeCanvasBackground = () => {
  const { t: t2 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const appProps = useAppProps();
  if (appState.viewModeEnabled || !appProps.UIOptions.canvasActions.changeViewBackgroundColor) {
    return null;
  }
  return /* @__PURE__ */ jsxs62("div", { style: { marginTop: "0.75rem" }, children: [
    /* @__PURE__ */ jsx111(
      "div",
      {
        "data-testid": "canvas-background-label",
        style: {
          fontSize: "0.875rem",
          marginBottom: "0.25rem",
          marginLeft: "0.5rem"
        },
        children: t2("labels.canvasBackground")
      }
    ),
    /* @__PURE__ */ jsx111("div", { style: { padding: "0 0.625rem" }, children: actionManager.renderAction("changeViewBackgroundColor") })
  ] });
};
ChangeCanvasBackground.displayName = "ChangeCanvasBackground";
var Export = () => {
  const { t: t2 } = useI18n();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      icon: ExportIcon,
      onSelect: () => {
        setAppState({ openDialog: { name: "jsonExport" } });
      },
      "data-testid": "json-export-button",
      "aria-label": t2("buttons.export"),
      children: t2("buttons.export")
    }
  );
};
Export.displayName = "Export";
var Socials = () => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsxs62(Fragment16, { children: [
    /* @__PURE__ */ jsx111(
      DropdownMenuItemLink_default,
      {
        icon: GithubIcon,
        href: "https://github.com/excalidraw/excalidraw",
        "aria-label": "GitHub",
        children: "GitHub"
      }
    ),
    /* @__PURE__ */ jsx111(
      DropdownMenuItemLink_default,
      {
        icon: XBrandIcon,
        href: "https://x.com/excalidraw",
        "aria-label": "X",
        children: t2("labels.followUs")
      }
    ),
    /* @__PURE__ */ jsx111(
      DropdownMenuItemLink_default,
      {
        icon: DiscordIcon,
        href: "https://discord.gg/UexuTaE",
        "aria-label": "Discord",
        children: t2("labels.discordChat")
      }
    )
  ] });
};
Socials.displayName = "Socials";
var LiveCollaborationTrigger = ({
  onSelect,
  isCollaborating
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItem_default,
    {
      "data-testid": "collab-button",
      icon: usersIcon,
      className: clsx51({
        "active-collab": isCollaborating
      }),
      onSelect,
      children: t2("labels.liveCollaboration")
    }
  );
};
LiveCollaborationTrigger.displayName = "LiveCollaborationTrigger";
var PreferencesToggleToolLockItem = () => {
  const { t: t2 } = useI18n();
  const app = useApp();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.activeTool.locked,
      shortcut: getShortcutFromShortcutName("toolLock"),
      onSelect: (event) => {
        app.toggleLock();
        event.preventDefault();
      },
      children: t2("labels.preferences_toolLock")
    }
  );
};
var PreferencesToggleSnapModeItem = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.objectsSnapModeEnabled,
      shortcut: getShortcutFromShortcutName("objectsSnapMode"),
      onSelect: (event) => {
        actionManager.executeAction(actionToggleObjectsSnapMode);
        event.preventDefault();
      },
      children: t2("buttons.objectsSnapMode")
    }
  );
};
var PreferencesToggleGridModeItem = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.gridModeEnabled,
      shortcut: getShortcutFromShortcutName("gridMode"),
      onSelect: (event) => {
        actionManager.executeAction(actionToggleGridMode);
        event.preventDefault();
      },
      children: t2("labels.toggleGrid")
    }
  );
};
var PreferencesToggleZenModeItem = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.zenModeEnabled,
      shortcut: getShortcutFromShortcutName("zenMode"),
      onSelect: (event) => {
        actionManager.executeAction(actionToggleZenMode);
        event.preventDefault();
      },
      children: t2("buttons.zenMode")
    }
  );
};
var PreferencesToggleViewModeItem = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.viewModeEnabled,
      shortcut: getShortcutFromShortcutName("viewMode"),
      onSelect: (event) => {
        actionManager.executeAction(actionToggleViewMode);
        event.preventDefault();
      },
      children: t2("labels.viewMode")
    }
  );
};
var PreferencesToggleElementPropertiesItem = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx111(
    DropdownMenuItemCheckbox_default,
    {
      checked: appState.stats.open,
      shortcut: getShortcutFromShortcutName("stats"),
      onSelect: (event) => {
        actionManager.executeAction(actionToggleStats);
        event.preventDefault();
      },
      children: t2("stats.fullTitle")
    }
  );
};
var Preferences = ({
  children,
  additionalItems
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsxs62(DropdownMenuSub_default, { children: [
    /* @__PURE__ */ jsx111(DropdownMenuSub_default.Trigger, { icon: settingsIcon, children: t2("labels.preferences") }),
    /* @__PURE__ */ jsxs62(DropdownMenuSub_default.Content, { className: "excalidraw-main-menu-preferences-submenu", children: [
      children || /* @__PURE__ */ jsxs62(Fragment16, { children: [
        /* @__PURE__ */ jsx111(PreferencesToggleToolLockItem, {}),
        /* @__PURE__ */ jsx111(PreferencesToggleSnapModeItem, {}),
        /* @__PURE__ */ jsx111(PreferencesToggleGridModeItem, {}),
        /* @__PURE__ */ jsx111(PreferencesToggleZenModeItem, {}),
        /* @__PURE__ */ jsx111(PreferencesToggleViewModeItem, {}),
        /* @__PURE__ */ jsx111(PreferencesToggleElementPropertiesItem, {})
      ] }),
      additionalItems
    ] })
  ] });
};
Preferences.ToggleToolLock = PreferencesToggleToolLockItem;
Preferences.ToggleSnapMode = PreferencesToggleSnapModeItem;
Preferences.ToggleGridMode = PreferencesToggleGridModeItem;
Preferences.ToggleZenMode = PreferencesToggleZenModeItem;
Preferences.ToggleViewMode = PreferencesToggleViewModeItem;
Preferences.ToggleElementProperties = PreferencesToggleElementPropertiesItem;
Preferences.displayName = "Preferences";

// components/main-menu/MainMenu.tsx
import { jsx as jsx112, jsxs as jsxs63 } from "react/jsx-runtime";
var MainMenu = Object.assign(
  withInternalFallback(
    "MainMenu",
    ({
      children,
      onSelect
    }) => {
      const { MainMenuTunnel } = useTunnels();
      const editorInterface = useEditorInterface();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      return /* @__PURE__ */ jsx112(MainMenuTunnel.In, { children: /* @__PURE__ */ jsxs63(DropdownMenu_default, { open: appState.openMenu === "canvas", children: [
        /* @__PURE__ */ jsx112(
          DropdownMenu_default.Trigger,
          {
            onToggle: () => {
              setAppState({
                openMenu: appState.openMenu === "canvas" ? null : "canvas",
                openPopup: null,
                openDialog: null
              });
            },
            "data-testid": "main-menu-trigger",
            className: "main-menu-trigger",
            children: HamburgerMenuIcon
          }
        ),
        /* @__PURE__ */ jsxs63(
          DropdownMenu_default.Content,
          {
            onClickOutside: () => setAppState({ openMenu: null }),
            onSelect: composeEventHandlers3(onSelect, () => {
              setAppState({ openMenu: null });
            }),
            className: "main-menu",
            align: "start",
            children: [
              children,
              editorInterface.formFactor === "phone" && appState.collaborators.size > 0 && /* @__PURE__ */ jsxs63("fieldset", { className: "UserList-Wrapper", children: [
                /* @__PURE__ */ jsx112("legend", { children: t("labels.collaborators") }),
                /* @__PURE__ */ jsx112(
                  UserList,
                  {
                    mobile: true,
                    collaborators: appState.collaborators,
                    userToFollow: appState.userToFollow?.socketId || null
                  }
                )
              ] })
            ]
          }
        )
      ] }) });
    }
  ),
  {
    Trigger: DropdownMenu_default.Trigger,
    Item: DropdownMenu_default.Item,
    ItemLink: DropdownMenu_default.ItemLink,
    ItemCustom: DropdownMenu_default.ItemCustom,
    Group: DropdownMenu_default.Group,
    Separator: DropdownMenu_default.Separator,
    Sub: DropdownMenuSub_default,
    DefaultItems: DefaultItems_exports
  }
);
var MainMenu_default = MainMenu;

// components/FilledButton.tsx
import clsx52 from "clsx";
import { forwardRef as forwardRef5, useState as useState32 } from "react";
import { isPromiseLike as isPromiseLike4 } from "@excalidraw/common";
import { jsx as jsx113, jsxs as jsxs64 } from "react/jsx-runtime";
var FilledButton = forwardRef5(
  ({
    children,
    icon,
    onClick,
    label,
    variant = "filled",
    color = "primary",
    size = "medium",
    fullWidth,
    className,
    status,
    disabled
  }, ref) => {
    const [isLoading, setIsLoading] = useState32(false);
    const _onClick = async (event) => {
      const ret = onClick?.(event);
      if (isPromiseLike4(ret)) {
        const timer = window.setTimeout(() => {
          setIsLoading(true);
        }, 50);
        try {
          await ret;
        } catch (error) {
          if (!(error instanceof AbortError)) {
            throw error;
          } else {
            console.warn(error);
          }
        } finally {
          clearTimeout(timer);
          setIsLoading(false);
        }
      }
    };
    const _status = isLoading ? "loading" : status;
    color = _status === "success" ? "success" : color;
    return /* @__PURE__ */ jsx113(
      "button",
      {
        className: clsx52(
          "ExcButton",
          `ExcButton--color-${color}`,
          `ExcButton--variant-${variant}`,
          `ExcButton--size-${size}`,
          `ExcButton--status-${_status}`,
          { "ExcButton--fullWidth": fullWidth },
          className
        ),
        onClick: _onClick,
        type: "button",
        "aria-label": label,
        ref,
        disabled: disabled || _status === "loading" || _status === "success",
        children: /* @__PURE__ */ jsxs64("div", { className: "ExcButton__contents", children: [
          _status === "loading" ? /* @__PURE__ */ jsx113(Spinner_default, { className: "ExcButton__statusIcon" }) : _status === "success" && /* @__PURE__ */ jsx113("div", { className: "ExcButton__statusIcon", children: tablerCheckIcon }),
          icon && /* @__PURE__ */ jsx113("div", { className: "ExcButton__icon", "aria-hidden": true, children: icon }),
          variant !== "icon" && (children ?? label)
        ] })
      }
    );
  }
);

// components/OverwriteConfirm/OverwriteConfirmActions.tsx
import { jsx as jsx114, jsxs as jsxs65 } from "react/jsx-runtime";
var Action = ({
  title,
  children,
  actionLabel,
  onClick
}) => {
  return /* @__PURE__ */ jsxs65("div", { className: "OverwriteConfirm__Actions__Action", children: [
    /* @__PURE__ */ jsx114("h4", { children: title }),
    /* @__PURE__ */ jsx114("div", { className: "OverwriteConfirm__Actions__Action__content", children }),
    /* @__PURE__ */ jsx114(
      FilledButton,
      {
        variant: "outlined",
        color: "muted",
        label: actionLabel,
        size: "large",
        fullWidth: true,
        onClick
      }
    )
  ] });
};
var ExportToImage = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx114(
    Action,
    {
      title: t2("overwriteConfirm.action.exportToImage.title"),
      actionLabel: t2("overwriteConfirm.action.exportToImage.button"),
      onClick: () => {
        actionManager.executeAction(actionChangeExportEmbedScene, "ui", true);
        setAppState({ openDialog: { name: "imageExport" } });
      },
      children: t2("overwriteConfirm.action.exportToImage.description")
    }
  );
};
var SaveToDisk = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx114(
    Action,
    {
      title: t2("overwriteConfirm.action.saveToDisk.title"),
      actionLabel: t2("overwriteConfirm.action.saveToDisk.button"),
      onClick: () => {
        actionManager.executeAction(actionSaveFileToDisk, "ui");
      },
      children: t2("overwriteConfirm.action.saveToDisk.description")
    }
  );
};
var Actions = Object.assign(
  ({ children }) => {
    return /* @__PURE__ */ jsx114("div", { className: "OverwriteConfirm__Actions", children });
  },
  {
    ExportToImage,
    SaveToDisk
  }
);

// components/OverwriteConfirm/OverwriteConfirm.tsx
import { jsx as jsx115, jsxs as jsxs66 } from "react/jsx-runtime";
var OverwriteConfirmDialog = Object.assign(
  withInternalFallback(
    "OverwriteConfirmDialog",
    ({ children }) => {
      const { OverwriteConfirmDialogTunnel } = useTunnels();
      const [overwriteConfirmState, setState] = useAtom(
        overwriteConfirmStateAtom
      );
      if (!overwriteConfirmState.active) {
        return null;
      }
      const handleClose = () => {
        overwriteConfirmState.onClose();
        setState((state) => ({ ...state, active: false }));
      };
      const handleConfirm = () => {
        overwriteConfirmState.onConfirm();
        setState((state) => ({ ...state, active: false }));
      };
      return /* @__PURE__ */ jsx115(OverwriteConfirmDialogTunnel.In, { children: /* @__PURE__ */ jsx115(Dialog, { onCloseRequest: handleClose, title: false, size: 916, children: /* @__PURE__ */ jsxs66("div", { className: "OverwriteConfirm", children: [
        /* @__PURE__ */ jsx115("h3", { children: overwriteConfirmState.title }),
        /* @__PURE__ */ jsxs66(
          "div",
          {
            className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`,
            children: [
              /* @__PURE__ */ jsx115("div", { className: "OverwriteConfirm__Description__icon", children: alertTriangleIcon }),
              /* @__PURE__ */ jsx115("div", { children: overwriteConfirmState.description }),
              /* @__PURE__ */ jsx115("div", { className: "OverwriteConfirm__Description__spacer" }),
              /* @__PURE__ */ jsx115(
                FilledButton,
                {
                  color: overwriteConfirmState.color,
                  size: "large",
                  label: overwriteConfirmState.actionLabel,
                  onClick: handleConfirm
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx115(Actions, { children })
      ] }) }) });
    }
  ),
  {
    Actions,
    Action
  }
);

// components/DefaultSidebar.tsx
import clsx54 from "clsx";
import {
  CANVAS_SEARCH_TAB as CANVAS_SEARCH_TAB3,
  DEFAULT_SIDEBAR as DEFAULT_SIDEBAR5,
  LIBRARY_SIDEBAR_TAB as LIBRARY_SIDEBAR_TAB2,
  composeEventHandlers as composeEventHandlers4
} from "@excalidraw/common";

// components/SearchMenu.tsx
import { round as round2 } from "@excalidraw/math";
import clsx53 from "clsx";
import debounce2 from "lodash.debounce";
import { Fragment as Fragment17, memo as memo4, useEffect as useEffect33, useMemo as useMemo8, useRef as useRef29, useState as useState33 } from "react";
import {
  CLASSES as CLASSES9,
  EVENT as EVENT11,
  FONT_FAMILY as FONT_FAMILY4,
  FRAME_STYLE as FRAME_STYLE3,
  getLineHeight as getLineHeight3
} from "@excalidraw/common";
import { isElementCompletelyInViewport } from "@excalidraw/element";
import { measureText as measureText5 } from "@excalidraw/element";
import {
  KEYS as KEYS49,
  randomInteger as randomInteger3,
  addEventListener as addEventListener2,
  getFontString as getFontString8
} from "@excalidraw/common";
import { newTextElement as newTextElement2 } from "@excalidraw/element";
import { isTextElement as isTextElement14, isFrameLikeElement as isFrameLikeElement10 } from "@excalidraw/element";
import { getDefaultFrameName } from "@excalidraw/element/frame";
import { Fragment as Fragment18, jsx as jsx116, jsxs as jsxs67 } from "react/jsx-runtime";
var searchQueryAtom = atom("");
var searchItemInFocusAtom = atom(null);
var SEARCH_DEBOUNCE = 350;
var SearchMenu2 = () => {
  const app = useApp();
  const setAppState = useExcalidrawSetAppState();
  const searchInputRef = useRef29(null);
  const [inputValue, setInputValue] = useAtom(searchQueryAtom);
  const searchQuery = inputValue.trim();
  const [isSearching, setIsSearching] = useState33(false);
  const [searchMatches, setSearchMatches] = useState33({
    nonce: null,
    items: []
  });
  const searchedQueryRef = useRef29(null);
  const lastSceneNonceRef = useRef29(void 0);
  const [focusIndex, setFocusIndex] = useAtom(searchItemInFocusAtom);
  const elementsMap = app.scene.getNonDeletedElementsMap();
  useEffect33(() => {
    if (isSearching) {
      return;
    }
    if (searchQuery !== searchedQueryRef.current || app.scene.getSceneNonce() !== lastSceneNonceRef.current) {
      searchedQueryRef.current = null;
      handleSearch(searchQuery, app, (matchItems, index) => {
        setSearchMatches({
          nonce: randomInteger3(),
          items: matchItems
        });
        searchedQueryRef.current = searchQuery;
        lastSceneNonceRef.current = app.scene.getSceneNonce();
        setAppState({
          searchMatches: matchItems.length ? {
            focusedId: null,
            matches: matchItems.map((searchMatch) => ({
              id: searchMatch.element.id,
              focus: false,
              matchedLines: searchMatch.matchedLines
            }))
          } : null
        });
      });
    }
  }, [
    isSearching,
    searchQuery,
    elementsMap,
    app,
    setAppState,
    setFocusIndex,
    lastSceneNonceRef
  ]);
  const goToNextItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return (focusIndex2 + 1) % searchMatches.items.length;
      });
    }
  };
  const goToPreviousItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return focusIndex2 - 1 < 0 ? searchMatches.items.length - 1 : focusIndex2 - 1;
      });
    }
  };
  useEffect33(() => {
    setAppState((state) => {
      if (!state.searchMatches) {
        return null;
      }
      const focusedId = focusIndex !== null ? state.searchMatches?.matches[focusIndex]?.id || null : null;
      return {
        searchMatches: {
          focusedId,
          matches: state.searchMatches.matches.map((match, index) => {
            if (index === focusIndex) {
              return { ...match, focus: true };
            }
            return { ...match, focus: false };
          })
        }
      };
    });
  }, [focusIndex, setAppState]);
  useEffect33(() => {
    if (searchMatches.items.length > 0 && focusIndex !== null) {
      const match = searchMatches.items[focusIndex];
      if (match) {
        const zoomValue = app.state.zoom.value;
        const matchAsElement = newTextElement2({
          text: match.searchQuery,
          x: match.element.x + (match.matchedLines[0]?.offsetX ?? 0),
          y: match.element.y + (match.matchedLines[0]?.offsetY ?? 0),
          width: match.matchedLines[0]?.width,
          height: match.matchedLines[0]?.height,
          fontSize: isFrameLikeElement10(match.element) ? FRAME_STYLE3.nameFontSize : match.element.fontSize,
          fontFamily: isFrameLikeElement10(match.element) ? FONT_FAMILY4.Assistant : match.element.fontFamily
        });
        const FONT_SIZE_LEGIBILITY_THRESHOLD = 14;
        const fontSize = matchAsElement.fontSize;
        const isTextTiny = fontSize * zoomValue < FONT_SIZE_LEGIBILITY_THRESHOLD;
        if (!isElementCompletelyInViewport(
          [matchAsElement],
          app.canvas.width / window.devicePixelRatio,
          app.canvas.height / window.devicePixelRatio,
          {
            offsetLeft: app.state.offsetLeft,
            offsetTop: app.state.offsetTop,
            scrollX: app.state.scrollX,
            scrollY: app.state.scrollY,
            zoom: app.state.zoom
          },
          app.scene.getNonDeletedElementsMap(),
          app.getEditorUIOffsets()
        ) || isTextTiny) {
          let zoomOptions;
          if (isTextTiny) {
            if (fontSize >= FONT_SIZE_LEGIBILITY_THRESHOLD) {
              zoomOptions = { fitToContent: true };
            } else {
              zoomOptions = {
                fitToViewport: true,
                // calculate zoom level to make the fontSize ~equal to FONT_SIZE_THRESHOLD, rounded to nearest 10%
                maxZoom: round2(FONT_SIZE_LEGIBILITY_THRESHOLD / fontSize, 1)
              };
            }
          } else {
            zoomOptions = { fitToContent: true };
          }
          app.scrollToContent(matchAsElement, {
            animate: true,
            duration: 300,
            ...zoomOptions,
            canvasOffsets: app.getEditorUIOffsets()
          });
        }
      }
    }
  }, [focusIndex, searchMatches, app]);
  useEffect33(() => {
    return () => {
      setFocusIndex(null);
      searchedQueryRef.current = null;
      lastSceneNonceRef.current = void 0;
      setAppState({
        searchMatches: null
      });
      setIsSearching(false);
    };
  }, [setAppState, setFocusIndex]);
  const stableState = useStable({
    goToNextItem,
    goToPreviousItem,
    searchMatches
  });
  useEffect33(() => {
    const eventHandler = (event) => {
      if (event.key === KEYS49.ESCAPE && !app.state.openDialog && !app.state.openPopup) {
        event.preventDefault();
        event.stopPropagation();
        setAppState({
          openSidebar: null
        });
        return;
      }
      if (event[KEYS49.CTRL_OR_CMD] && event.key === KEYS49.F) {
        event.preventDefault();
        event.stopPropagation();
        if (app.state.openDialog) {
          return;
        }
        if (!searchInputRef.current?.matches(":focus")) {
          if (app.state.openDialog) {
            setAppState({
              openDialog: null
            });
          }
          searchInputRef.current?.focus();
          searchInputRef.current?.select();
        }
      }
      if (event.target instanceof HTMLElement && event.target.closest(".layer-ui__search")) {
        if (stableState.searchMatches.items.length) {
          if (event.key === KEYS49.ENTER) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
          if (event.key === KEYS49.ARROW_UP) {
            event.stopPropagation();
            stableState.goToPreviousItem();
          } else if (event.key === KEYS49.ARROW_DOWN) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
        }
      }
    };
    return addEventListener2(window, EVENT11.KEYDOWN, eventHandler, {
      capture: true,
      passive: false
    });
  }, [setAppState, stableState, app]);
  const matchCount = `${searchMatches.items.length} ${searchMatches.items.length === 1 ? t("search.singleResult") : t("search.multipleResults")}`;
  return /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search", children: [
    /* @__PURE__ */ jsx116("div", { className: "layer-ui__search-header", children: /* @__PURE__ */ jsx116(
      TextField,
      {
        className: CLASSES9.SEARCH_MENU_INPUT_WRAPPER,
        value: inputValue,
        ref: searchInputRef,
        placeholder: t("search.placeholder"),
        icon: searchIcon,
        onChange: (value) => {
          setInputValue(value);
          setIsSearching(true);
          const searchQuery2 = value.trim();
          handleSearch(searchQuery2, app, (matchItems, index) => {
            setSearchMatches({
              nonce: randomInteger3(),
              items: matchItems
            });
            setFocusIndex(index);
            searchedQueryRef.current = searchQuery2;
            lastSceneNonceRef.current = app.scene.getSceneNonce();
            setAppState({
              searchMatches: matchItems.length ? {
                focusedId: null,
                matches: matchItems.map((searchMatch) => ({
                  id: searchMatch.element.id,
                  focus: false,
                  matchedLines: searchMatch.matchedLines
                }))
              } : null
            });
            setIsSearching(false);
          });
        },
        selectOnRender: true
      }
    ) }),
    /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search-count", children: [
      searchMatches.items.length > 0 && /* @__PURE__ */ jsxs67(Fragment18, { children: [
        focusIndex !== null && focusIndex > -1 ? /* @__PURE__ */ jsxs67("div", { children: [
          focusIndex + 1,
          " / ",
          matchCount
        ] }) : /* @__PURE__ */ jsx116("div", { children: matchCount }),
        /* @__PURE__ */ jsxs67("div", { className: "result-nav", children: [
          /* @__PURE__ */ jsx116(
            Button,
            {
              onSelect: () => {
                goToNextItem();
              },
              className: "result-nav-btn",
              children: collapseDownIcon
            }
          ),
          /* @__PURE__ */ jsx116(
            Button,
            {
              onSelect: () => {
                goToPreviousItem();
              },
              className: "result-nav-btn",
              children: upIcon
            }
          )
        ] })
      ] }),
      searchMatches.items.length === 0 && searchQuery && searchedQueryRef.current && /* @__PURE__ */ jsx116("div", { style: { margin: "1rem auto" }, children: t("search.noMatch") })
    ] }),
    /* @__PURE__ */ jsx116(
      MatchList,
      {
        matches: searchMatches,
        onItemClick: setFocusIndex,
        focusIndex,
        searchQuery
      }
    )
  ] });
};
var ListItem = (props) => {
  const preview = [
    props.preview.moreBefore ? "..." : "",
    props.preview.previewText.slice(0, props.preview.indexInSearchQuery),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery,
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.moreAfter ? "..." : ""
  ];
  return /* @__PURE__ */ jsx116(
    "div",
    {
      tabIndex: -1,
      className: clsx53("layer-ui__result-item", {
        active: props.highlighted
      }),
      onClick: props.onClick,
      ref: (ref) => {
        if (props.highlighted) {
          ref?.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      },
      children: /* @__PURE__ */ jsx116("div", { className: "preview-text", children: preview.flatMap((text, idx) => /* @__PURE__ */ jsx116(Fragment17, { children: idx === 2 ? /* @__PURE__ */ jsx116("b", { children: text }) : text }, idx)) })
    }
  );
};
var MatchListBase = (props) => {
  const frameNameMatches = useMemo8(
    () => props.matches.items.filter((match) => isFrameLikeElement10(match.element)),
    [props.matches]
  );
  const textMatches = useMemo8(
    () => props.matches.items.filter((match) => isTextElement14(match.element)),
    [props.matches]
  );
  return /* @__PURE__ */ jsxs67("div", { children: [
    frameNameMatches.length > 0 && /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search-result-container", children: [
      /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search-result-title", children: [
        /* @__PURE__ */ jsx116("div", { className: "title-icon", children: frameToolIcon }),
        /* @__PURE__ */ jsx116("div", { children: t("search.frames") })
      ] }),
      frameNameMatches.map((searchMatch, index) => /* @__PURE__ */ jsx116(
        ListItem,
        {
          searchQuery: props.searchQuery,
          preview: searchMatch.preview,
          highlighted: index === props.focusIndex,
          onClick: () => props.onItemClick(index)
        },
        searchMatch.element.id + searchMatch.index
      )),
      textMatches.length > 0 && /* @__PURE__ */ jsx116("div", { className: "layer-ui__divider" })
    ] }),
    textMatches.length > 0 && /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search-result-container", children: [
      /* @__PURE__ */ jsxs67("div", { className: "layer-ui__search-result-title", children: [
        /* @__PURE__ */ jsx116("div", { className: "title-icon", children: TextIcon }),
        /* @__PURE__ */ jsx116("div", { children: t("search.texts") })
      ] }),
      textMatches.map((searchMatch, index) => /* @__PURE__ */ jsx116(
        ListItem,
        {
          searchQuery: props.searchQuery,
          preview: searchMatch.preview,
          highlighted: index + frameNameMatches.length === props.focusIndex,
          onClick: () => props.onItemClick(index + frameNameMatches.length)
        },
        searchMatch.element.id + searchMatch.index
      ))
    ] })
  ] });
};
var areEqual = (prevProps, nextProps) => {
  return prevProps.matches.nonce === nextProps.matches.nonce && prevProps.focusIndex === nextProps.focusIndex;
};
var MatchList = memo4(MatchListBase, areEqual);
var getMatchPreview = (text, index, searchQuery) => {
  const WORDS_BEFORE = 2;
  const WORDS_AFTER = 5;
  const substrBeforeQuery = text.slice(0, index);
  const wordsBeforeQuery = substrBeforeQuery.split(/\s+/);
  const isQueryCompleteBefore = substrBeforeQuery.endsWith(" ");
  const startWordIndex = wordsBeforeQuery.length - WORDS_BEFORE - 1 - (isQueryCompleteBefore ? 0 : 1);
  let wordsBeforeAsString = wordsBeforeQuery.slice(startWordIndex <= 0 ? 0 : startWordIndex).join(" ") + (isQueryCompleteBefore ? " " : "");
  const MAX_ALLOWED_CHARS = 20;
  wordsBeforeAsString = wordsBeforeAsString.length > MAX_ALLOWED_CHARS ? wordsBeforeAsString.slice(-MAX_ALLOWED_CHARS) : wordsBeforeAsString;
  const substrAfterQuery = text.slice(index + searchQuery.length);
  const wordsAfter = substrAfterQuery.split(/\s+/);
  const isQueryCompleteAfter = !substrAfterQuery.startsWith(" ");
  const numberOfWordsToTake = isQueryCompleteAfter ? WORDS_AFTER + 1 : WORDS_AFTER;
  const wordsAfterAsString = (isQueryCompleteAfter ? "" : " ") + wordsAfter.slice(0, numberOfWordsToTake).join(" ");
  return {
    indexInSearchQuery: wordsBeforeAsString.length,
    previewText: wordsBeforeAsString + searchQuery + wordsAfterAsString,
    moreBefore: startWordIndex > 0,
    moreAfter: wordsAfter.length > numberOfWordsToTake
  };
};
var normalizeWrappedText = (wrappedText, originalText) => {
  const wrappedLines = wrappedText.split("\n");
  const normalizedLines = [];
  let originalIndex = 0;
  for (let i = 0; i < wrappedLines.length; i++) {
    let currentLine = wrappedLines[i];
    const nextLine = wrappedLines[i + 1];
    if (nextLine) {
      const nextLineIndexInOriginal = originalText.indexOf(
        nextLine,
        originalIndex
      );
      if (nextLineIndexInOriginal > currentLine.length + originalIndex) {
        let j = nextLineIndexInOriginal - (currentLine.length + originalIndex);
        while (j > 0) {
          currentLine += " ";
          j--;
        }
      }
    }
    normalizedLines.push(currentLine);
    originalIndex = originalIndex + currentLine.length;
  }
  return normalizedLines.join("\n");
};
var getMatchedLines = (textElement, searchQuery, index) => {
  const normalizedText = normalizeWrappedText(
    textElement.text,
    textElement.originalText
  );
  const lines = normalizedText.split("\n");
  const lineIndexRanges = [];
  let currentIndex = 0;
  let lineNumber = 0;
  for (const line of lines) {
    const startIndex2 = currentIndex;
    const endIndex = startIndex2 + line.length - 1;
    lineIndexRanges.push({
      line,
      startIndex: startIndex2,
      endIndex,
      lineNumber
    });
    currentIndex = endIndex + 1;
    lineNumber++;
  }
  let startIndex = index;
  let remainingQuery = textElement.originalText.slice(
    index,
    index + searchQuery.length
  );
  const matchedLines = [];
  for (const lineIndexRange of lineIndexRanges) {
    if (remainingQuery === "") {
      break;
    }
    if (startIndex >= lineIndexRange.startIndex && startIndex <= lineIndexRange.endIndex) {
      const matchCapacity = lineIndexRange.endIndex + 1 - startIndex;
      const textToStart = lineIndexRange.line.slice(
        0,
        startIndex - lineIndexRange.startIndex
      );
      const matchedWord = remainingQuery.slice(0, matchCapacity);
      remainingQuery = remainingQuery.slice(matchCapacity);
      const offset = measureText5(
        textToStart,
        getFontString8(textElement),
        textElement.lineHeight
      );
      if (textToStart === "") {
        offset.width = 0;
      }
      if (textElement.textAlign !== "left" && lineIndexRange.line.length > 0) {
        const lineLength = measureText5(
          lineIndexRange.line,
          getFontString8(textElement),
          textElement.lineHeight
        );
        const spaceToStart = textElement.textAlign === "center" ? (textElement.width - lineLength.width) / 2 : textElement.width - lineLength.width;
        offset.width += spaceToStart;
      }
      const { width, height } = measureText5(
        matchedWord,
        getFontString8(textElement),
        textElement.lineHeight
      );
      const offsetX = offset.width;
      const offsetY = lineIndexRange.lineNumber * offset.height;
      matchedLines.push({
        offsetX,
        offsetY,
        width,
        height,
        showOnCanvas: true
      });
      startIndex += matchCapacity;
    }
  }
  return matchedLines;
};
var getMatchInFrame = (frame, searchQuery, index, zoomValue) => {
  const text = frame.name ?? getDefaultFrameName(frame);
  const matchedText = text.slice(index, index + searchQuery.length);
  const prefixText = text.slice(0, index);
  const font = getFontString8({
    fontSize: FRAME_STYLE3.nameFontSize,
    fontFamily: FONT_FAMILY4.Assistant
  });
  const lineHeight = getLineHeight3(FONT_FAMILY4.Assistant);
  const offset = measureText5(prefixText, font, lineHeight);
  if (prefixText === "") {
    offset.width = 0;
  }
  const matchedMetrics = measureText5(matchedText, font, lineHeight);
  const offsetX = offset.width;
  const offsetY = -offset.height - FRAME_STYLE3.strokeWidth;
  const width = matchedMetrics.width;
  return [
    {
      offsetX,
      offsetY,
      width,
      height: matchedMetrics.height,
      showOnCanvas: offsetX + width <= frame.width * zoomValue
    }
  ];
};
var escapeSpecialCharacters = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&");
};
var handleSearch = debounce2(
  (searchQuery, app, cb) => {
    if (!searchQuery || searchQuery === "") {
      cb([], null);
      return;
    }
    const elements = app.scene.getNonDeletedElements();
    const texts = elements.filter(
      (el) => isTextElement14(el)
    );
    const frames = elements.filter(
      (el) => isFrameLikeElement10(el)
    );
    texts.sort((a, b) => a.y - b.y);
    frames.sort((a, b) => a.y - b.y);
    const textMatches = [];
    const regex = new RegExp(escapeSpecialCharacters(searchQuery), "gi");
    for (const textEl of texts) {
      let match = null;
      const text = textEl.originalText;
      while ((match = regex.exec(text)) !== null) {
        const preview = getMatchPreview(text, match.index, searchQuery);
        const matchedLines = getMatchedLines(textEl, searchQuery, match.index);
        if (matchedLines.length > 0) {
          textMatches.push({
            element: textEl,
            searchQuery,
            preview,
            index: match.index,
            matchedLines
          });
        }
      }
    }
    const frameMatches = [];
    for (const frame of frames) {
      let match = null;
      const name = frame.name ?? getDefaultFrameName(frame);
      while ((match = regex.exec(name)) !== null) {
        const preview = getMatchPreview(name, match.index, searchQuery);
        const matchedLines = getMatchInFrame(
          frame,
          searchQuery,
          match.index,
          app.state.zoom.value
        );
        if (matchedLines.length > 0) {
          frameMatches.push({
            element: frame,
            searchQuery,
            preview,
            index: match.index,
            matchedLines
          });
        }
      }
    }
    const visibleIds = new Set(
      app.visibleElements.map((visibleElement) => visibleElement.id)
    );
    const matchItems = [...frameMatches, ...textMatches];
    const focusIndex = matchItems.findIndex(
      (matchItem) => visibleIds.has(matchItem.element.id)
    ) ?? null;
    cb(matchItems, focusIndex);
  },
  SEARCH_DEBOUNCE
);

// components/DefaultSidebar.tsx
import { jsx as jsx117, jsxs as jsxs68 } from "react/jsx-runtime";
import { createElement as createElement2 } from "react";
var DefaultSidebarTrigger = withInternalFallback(
  "DefaultSidebarTrigger",
  (props) => {
    const { DefaultSidebarTriggerTunnel } = useTunnels();
    return /* @__PURE__ */ jsx117(DefaultSidebarTriggerTunnel.In, { children: /* @__PURE__ */ jsx117(
      Sidebar.Trigger,
      {
        ...props,
        className: "default-sidebar-trigger",
        name: DEFAULT_SIDEBAR5.name
      }
    ) });
  }
);
DefaultSidebarTrigger.displayName = "DefaultSidebarTrigger";
var DefaultTabTriggers = ({ children }) => {
  const { DefaultSidebarTabTriggersTunnel } = useTunnels();
  return /* @__PURE__ */ jsx117(DefaultSidebarTabTriggersTunnel.In, { children });
};
DefaultTabTriggers.displayName = "DefaultTabTriggers";
var DefaultSidebar = Object.assign(
  withInternalFallback(
    "DefaultSidebar",
    ({
      children,
      className,
      onDock,
      docked,
      ...rest
    }) => {
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const { DefaultSidebarTabTriggersTunnel } = useTunnels();
      const isForceDocked = appState.openSidebar?.tab === CANVAS_SEARCH_TAB3;
      return /* @__PURE__ */ createElement2(
        Sidebar,
        {
          ...rest,
          name: "default",
          key: "default",
          className: clsx54("default-sidebar", className),
          docked: isForceDocked || (docked ?? appState.defaultSidebarDockedPreference),
          onDock: (
            // `onDock=false` disables docking.
            // if `docked` passed, but no onDock passed, disable manual docking.
            isForceDocked || onDock === false || !onDock && docked != null ? void 0 : (
              // compose to allow the host app to listen on default behavior
              composeEventHandlers4(onDock, (docked2) => {
                setAppState({ defaultSidebarDockedPreference: docked2 });
              })
            )
          )
        },
        /* @__PURE__ */ jsxs68(Sidebar.Tabs, { children: [
          /* @__PURE__ */ jsx117(Sidebar.Header, { children: /* @__PURE__ */ jsxs68(Sidebar.TabTriggers, { children: [
            /* @__PURE__ */ jsx117(Sidebar.TabTrigger, { tab: CANVAS_SEARCH_TAB3, children: searchIcon }),
            /* @__PURE__ */ jsx117(Sidebar.TabTrigger, { tab: LIBRARY_SIDEBAR_TAB2, children: LibraryIcon }),
            /* @__PURE__ */ jsx117(DefaultSidebarTabTriggersTunnel.Out, {})
          ] }) }),
          /* @__PURE__ */ jsx117(Sidebar.Tab, { tab: LIBRARY_SIDEBAR_TAB2, children: /* @__PURE__ */ jsx117(LibraryMenu, {}) }),
          /* @__PURE__ */ jsx117(Sidebar.Tab, { tab: CANVAS_SEARCH_TAB3, children: /* @__PURE__ */ jsx117(SearchMenu2, {}) }),
          children
        ] })
      );
    }
  ),
  {
    Trigger: DefaultSidebarTrigger,
    TabTriggers: DefaultTabTriggers
  }
);

// components/TTDDialog/TTDDialog.tsx
import { useEffect as useEffect40, useState as useState37 } from "react";

// components/TTDDialog/MermaidToExcalidraw.tsx
import { useState as useState34, useRef as useRef31, useEffect as useEffect35, useDeferredValue } from "react";
import { EDITOR_LS_KEYS as EDITOR_LS_KEYS3, debounce as debounce3, isDevEnv as isDevEnv8 } from "@excalidraw/common";

// components/TTDDialog/TTDDialogInput.tsx
import { useEffect as useEffect34, useRef as useRef30 } from "react";
import { EVENT as EVENT12, KEYS as KEYS50 } from "@excalidraw/common";
import { jsx as jsx118 } from "react/jsx-runtime";
var TTDDialogInput = ({
  input,
  placeholder,
  onChange,
  onKeyboardSubmit
}) => {
  const ref = useRef30(null);
  const callbackRef = useRef30(onKeyboardSubmit);
  callbackRef.current = onKeyboardSubmit;
  useEffect34(() => {
    if (!callbackRef.current) {
      return;
    }
    const textarea = ref.current;
    if (textarea) {
      const handleKeyDown = (event) => {
        if (event[KEYS50.CTRL_OR_CMD] && event.key === KEYS50.ENTER) {
          event.preventDefault();
          callbackRef.current?.();
        }
      };
      textarea.focus();
      textarea.addEventListener(EVENT12.KEYDOWN, handleKeyDown);
      return () => {
        textarea.removeEventListener(EVENT12.KEYDOWN, handleKeyDown);
      };
    }
  }, []);
  return /* @__PURE__ */ jsx118(
    "textarea",
    {
      className: "ttd-dialog-input",
      onChange,
      value: input,
      placeholder,
      ref
    }
  );
};

// components/TTDDialog/TTDDialogOutput.tsx
import clsx55 from "clsx";
import { jsx as jsx119, jsxs as jsxs69 } from "react/jsx-runtime";
var TTDDialogOutput = ({
  error,
  canvasRef,
  loaded,
  hideErrorDetails
}) => {
  return /* @__PURE__ */ jsxs69(
    "div",
    {
      className: `ttd-dialog-output-wrapper ${error ? "ttd-dialog-output-wrapper--error" : ""}`,
      children: [
        error && /* @__PURE__ */ jsx119(
          "div",
          {
            "data-testid": "ttd-dialog-output-error",
            className: "ttd-dialog-output-error",
            children: /* @__PURE__ */ jsxs69("div", { className: "ttd-dialog-output-error-content", children: [
              /* @__PURE__ */ jsx119("div", { className: "ttd-dialog-output-error-icon", children: alertTriangleIcon }),
              /* @__PURE__ */ jsx119("div", { className: "ttd-dialog-output-error-title", children: t("ttd.error") }),
              /* @__PURE__ */ jsx119("div", { className: "ttd-dialog-output-error-message", children: hideErrorDetails ? t("chat.errors.mermaidParseError") : error.message })
            ] })
          },
          "error"
        ),
        loaded ? /* @__PURE__ */ jsx119(
          "div",
          {
            className: clsx55("ttd-dialog-output-canvas-container", {
              invisible: !!error
            }),
            children: /* @__PURE__ */ jsx119("div", { ref: canvasRef, className: "ttd-dialog-output-canvas-content" })
          },
          "canvas"
        ) : /* @__PURE__ */ jsx119(Spinner_default, { size: "2rem" })
      ]
    }
  );
};

// components/TTDDialog/TTDDialogPanel.tsx
import clsx56 from "clsx";
import { Fragment as Fragment19 } from "react";
import { jsx as jsx120, jsxs as jsxs70 } from "react/jsx-runtime";
var TTDDialogPanel = ({
  label,
  children,
  panelActions = [],
  onTextSubmitInProgess,
  renderTopRight,
  renderSubmitShortcut,
  className,
  panelActionJustifyContent = "flex-start"
}) => {
  const renderPanelAction = (panelAction) => {
    if (panelAction?.variant === "link") {
      return /* @__PURE__ */ jsxs70(
        "button",
        {
          className: clsx56(
            "ttd-dialog-panel-action-link",
            panelAction.className
          ),
          onClick: panelAction.action,
          disabled: panelAction?.disabled || onTextSubmitInProgess,
          type: "button",
          children: [
            panelAction.label,
            panelAction.icon && /* @__PURE__ */ jsx120("span", { className: "ttd-dialog-panel-action-link__icon", children: panelAction.icon })
          ]
        }
      );
    }
    if (panelAction?.variant === "button") {
      return /* @__PURE__ */ jsxs70(
        Button,
        {
          className: clsx56("ttd-dialog-panel-button", panelAction.className),
          onSelect: panelAction.action ? panelAction.action : () => {
          },
          disabled: panelAction?.disabled || onTextSubmitInProgess,
          children: [
            /* @__PURE__ */ jsxs70("div", { className: clsx56({ invisible: onTextSubmitInProgess }), children: [
              panelAction?.label,
              panelAction?.icon && /* @__PURE__ */ jsx120("span", { children: panelAction.icon })
            ] }),
            onTextSubmitInProgess && /* @__PURE__ */ jsx120(Spinner_default, {})
          ]
        }
      );
    }
    if (panelAction?.variant === "rateLimit") {
      return /* @__PURE__ */ jsx120(
        "div",
        {
          className: clsx56(
            "ttd-dialog-panel__rate-limit",
            panelAction.className
          ),
          children: panelAction.label
        }
      );
    }
  };
  return /* @__PURE__ */ jsxs70("div", { className: clsx56("ttd-dialog-panel", className), children: [
    (label || renderTopRight) && /* @__PURE__ */ jsxs70("div", { className: "ttd-dialog-panel__header", children: [
      typeof label === "string" ? /* @__PURE__ */ jsx120("label", { children: label }) : label,
      renderTopRight?.()
    ] }),
    children,
    /* @__PURE__ */ jsxs70(
      "div",
      {
        className: clsx56("ttd-dialog-panel-button-container", {
          invisible: !panelActions.length
        }),
        style: {
          justifyContent: panelActionJustifyContent
        },
        children: [
          panelActions.filter(Boolean).map((panelAction) => /* @__PURE__ */ jsx120(Fragment19, { children: renderPanelAction(panelAction) }, panelAction.label)),
          !onTextSubmitInProgess && renderSubmitShortcut?.()
        ]
      }
    )
  ] });
};

// components/TTDDialog/TTDDialogPanels.tsx
import { jsx as jsx121 } from "react/jsx-runtime";
var TTDDialogPanels = ({ children }) => {
  return /* @__PURE__ */ jsx121("div", { className: "ttd-dialog-panels", children });
};

// components/TTDDialog/TTDDialogSubmitShortcut.tsx
import { jsx as jsx122, jsxs as jsxs71 } from "react/jsx-runtime";
var TTDDialogSubmitShortcut = () => {
  return /* @__PURE__ */ jsxs71("div", { className: "ttd-dialog-submit-shortcut", children: [
    /* @__PURE__ */ jsx122("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("CtrlOrCmd") }),
    /* @__PURE__ */ jsx122("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("Enter") })
  ] });
};

// components/TTDDialog/common.ts
import { DEFAULT_EXPORT_PADDING as DEFAULT_EXPORT_PADDING3, EDITOR_LS_KEYS as EDITOR_LS_KEYS2 } from "@excalidraw/common";
var resetPreview = ({
  canvasRef,
  setError
}) => {
  const canvasNode = canvasRef.current;
  if (!canvasNode) {
    return;
  }
  const parent = canvasNode.parentElement;
  if (!parent) {
    return;
  }
  parent.style.background = "";
  setError(null);
  canvasNode.replaceChildren();
};
var convertMermaidToExcalidraw = async ({
  canvasRef,
  mermaidToExcalidrawLib,
  mermaidDefinition,
  setError,
  data,
  theme
}) => {
  const canvasNode = canvasRef.current;
  const parent = canvasNode?.parentElement;
  if (!canvasNode || !parent) {
    return { success: false };
  }
  if (!mermaidDefinition) {
    resetPreview({ canvasRef, setError });
    return { success: false };
  }
  let ret;
  try {
    const api = await mermaidToExcalidrawLib.api;
    try {
      try {
        ret = await api.parseMermaidToExcalidraw(mermaidDefinition);
      } catch (err) {
        ret = await api.parseMermaidToExcalidraw(
          mermaidDefinition.replace(/"/g, "'")
        );
      }
    } catch (err) {
      return { success: false, error: err };
    }
    const { elements, files } = ret;
    setError(null);
    data.current = {
      elements: convertToExcalidrawElements(elements, {
        regenerateIds: true
      }),
      files
    };
    const canvas = await exportToCanvas2({
      elements: data.current.elements,
      files: data.current.files,
      exportPadding: DEFAULT_EXPORT_PADDING3,
      maxWidthOrHeight: Math.max(parent.offsetWidth, parent.offsetHeight) * window.devicePixelRatio,
      appState: {
        exportWithDarkMode: theme === THEME15.DARK
      }
    });
    parent.style.background = "var(--default-bg-color)";
    canvasNode.replaceChildren(canvas);
    return { success: true };
  } catch (err) {
    parent.style.background = "var(--default-bg-color)";
    if (mermaidDefinition) {
      setError(err);
    }
    return { success: false, error: err };
  }
};
var saveMermaidDataToStorage = (mermaidDefinition) => {
  EditorLocalStorage.set(
    EDITOR_LS_KEYS2.MERMAID_TO_EXCALIDRAW,
    mermaidDefinition
  );
};
var insertToEditor = ({
  app,
  data,
  text,
  shouldSaveMermaidDataToStorage
}) => {
  const { elements: newElements, files } = data.current;
  if (!newElements.length) {
    return;
  }
  app.addElementsFromPasteOrLibrary({
    elements: newElements,
    files,
    position: "center",
    fitToContent: true
  });
  app.setOpenDialog(null);
  if (shouldSaveMermaidDataToStorage && text) {
    saveMermaidDataToStorage(text);
  }
};

// components/TTDDialog/MermaidToExcalidraw.tsx
import { Fragment as Fragment20, jsx as jsx123, jsxs as jsxs72 } from "react/jsx-runtime";
var MERMAID_EXAMPLE = "flowchart TD\n A[Christmas] -->|Get money| B(Go shopping)\n B --> C{Let me think}\n C -->|One| D[Laptop]\n C -->|Two| E[iPhone]\n C -->|Three| F[Car]";
var debouncedSaveMermaidDefinition = debounce3(saveMermaidDataToStorage, 300);
var MermaidToExcalidraw = ({
  mermaidToExcalidrawLib,
  isActive
}) => {
  const [text, setText] = useState34(
    () => EditorLocalStorage.get(EDITOR_LS_KEYS3.MERMAID_TO_EXCALIDRAW) || MERMAID_EXAMPLE
  );
  const deferredText = useDeferredValue(text.trim());
  const [error, setError] = useState34(null);
  const canvasRef = useRef31(null);
  const data = useRef31({ elements: [], files: null });
  const app = useApp();
  const { theme } = useUIAppState();
  useEffect35(() => {
    const doRender = async () => {
      try {
        if (!deferredText) {
          resetPreview({ canvasRef, setError });
          return;
        }
        const result = await convertMermaidToExcalidraw({
          canvasRef,
          data,
          mermaidToExcalidrawLib,
          setError,
          mermaidDefinition: deferredText,
          theme
        });
        if (!result.success) {
          const err = result.error ?? new Error("Invalid mermaid definition");
          setError(err);
        }
      } catch (err) {
        if (isDevEnv8()) {
          console.error("Failed to parse mermaid definition", err);
        }
      }
    };
    if (isActive) {
      doRender();
      debouncedSaveMermaidDefinition(deferredText);
    }
  }, [deferredText, mermaidToExcalidrawLib, isActive, theme]);
  useEffect35(
    () => () => {
      debouncedSaveMermaidDefinition.flush();
    },
    []
  );
  const onInsertToEditor = () => {
    insertToEditor({
      app,
      data,
      text,
      shouldSaveMermaidDataToStorage: true
    });
  };
  return /* @__PURE__ */ jsxs72(Fragment20, { children: [
    /* @__PURE__ */ jsx123("div", { className: "ttd-dialog-desc", children: /* @__PURE__ */ jsx123(
      Trans_default,
      {
        i18nKey: "mermaid.description",
        flowchartLink: (el) => /* @__PURE__ */ jsx123("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: el }),
        sequenceLink: (el) => /* @__PURE__ */ jsx123("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: el }),
        classLink: (el) => /* @__PURE__ */ jsx123("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: el })
      }
    ) }),
    /* @__PURE__ */ jsxs72(TTDDialogPanels, { children: [
      /* @__PURE__ */ jsx123(TTDDialogPanel, { children: /* @__PURE__ */ jsx123(
        TTDDialogInput,
        {
          input: text,
          placeholder: t("mermaid.inputPlaceholder"),
          onChange: (event) => setText(event.target.value),
          onKeyboardSubmit: () => {
            onInsertToEditor();
          }
        }
      ) }),
      /* @__PURE__ */ jsx123(
        TTDDialogPanel,
        {
          panelActions: [
            {
              action: () => {
                onInsertToEditor();
              },
              label: t("mermaid.button"),
              icon: ArrowRightIcon,
              variant: "button"
            }
          ],
          renderSubmitShortcut: () => /* @__PURE__ */ jsx123(TTDDialogSubmitShortcut, {}),
          children: /* @__PURE__ */ jsx123(
            TTDDialogOutput,
            {
              canvasRef,
              loaded: mermaidToExcalidrawLib.loaded,
              error
            }
          )
        }
      )
    ] })
  ] });
};
var MermaidToExcalidraw_default = MermaidToExcalidraw;

// components/TTDDialog/TextToDiagram.tsx
import { useRef as useRef36 } from "react";

// components/TTDDialog/Chat/ChatInterface.tsx
import { useRef as useRef32, useEffect as useEffect37, useLayoutEffect as useLayoutEffect9 } from "react";
import { KEYS as KEYS51 } from "@excalidraw/common";

// components/TTDDialog/TTDWelcomeMessage.tsx
import { jsx as jsx124, jsxs as jsxs73 } from "react/jsx-runtime";
var TTDWelcomeMessage = () => {
  return /* @__PURE__ */ jsxs73("div", { className: "chat-interface__welcome-screen__welcome-message", children: [
    /* @__PURE__ */ jsx124("h3", { children: t("chat.placeholder.title") }),
    /* @__PURE__ */ jsx124("p", { children: t("chat.placeholder.description") }),
    /* @__PURE__ */ jsx124("p", { children: t("chat.placeholder.hint") })
  ] });
};

// components/TTDDialog/Chat/ChatMessage.tsx
import clsx57 from "clsx";
import { useState as useState35, useEffect as useEffect36 } from "react";
import { Fragment as Fragment21, jsx as jsx125, jsxs as jsxs74 } from "react/jsx-runtime";
var ChatMessage = ({
  message,
  onMermaidTabClick,
  onAiRepairClick,
  onDeleteMessage,
  onInsertMessage,
  onRetry,
  rateLimitRemaining,
  isLastMessage,
  renderWarning,
  allowFixingParseError
}) => {
  const [canRetry, setCanRetry] = useState35(false);
  useEffect36(() => {
    if (!message.error || !isLastMessage) {
      return;
    }
    if (message.error && !message.lastAttemptAt) {
      setCanRetry(true);
      return;
    }
    const timeSinceLastAttempt = Date.now() - message.lastAttemptAt;
    const remainingTime = Math.max(0, 5e3 - timeSinceLastAttempt);
    if (remainingTime === 0) {
      setCanRetry(true);
      return;
    }
    setCanRetry(false);
    const timer = setTimeout(() => {
      setCanRetry(true);
    }, remainingTime);
    return () => clearTimeout(timer);
  }, [message.error, message.lastAttemptAt, isLastMessage]);
  const formatTime = (date) => {
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  };
  if (message.type === "warning") {
    const customOverride = renderWarning?.(message);
    return /* @__PURE__ */ jsx125("div", { className: "chat-message chat-message--system", children: /* @__PURE__ */ jsxs74("div", { className: "chat-message__content", children: [
      /* @__PURE__ */ jsxs74("div", { className: "chat-message__header", children: [
        /* @__PURE__ */ jsx125("span", { className: "chat-message__role", children: t("chat.role.system") }),
        /* @__PURE__ */ jsx125("span", { className: "chat-message__timestamp", children: formatTime(message.timestamp) })
      ] }),
      /* @__PURE__ */ jsx125("div", { className: "chat-message__body", children: /* @__PURE__ */ jsx125("div", { className: "chat-message__text", children: customOverride ? customOverride : message.warningType === "messageLimitExceeded" ? /* @__PURE__ */ jsxs74(Fragment21, { children: [
        t("chat.rateLimit.messageLimit"),
        /* @__PURE__ */ jsx125("div", { style: { marginTop: "10px" }, children: /* @__PURE__ */ jsx125(
          FilledButton,
          {
            onClick: () => {
              window.open(
                `${define_import_meta_env_default.VITE_APP_PLUS_LP}/plus?utm_source=excalidraw&utm_medium=app&utm_content=ttdChatBanner#excalidraw-redirect`,
                "_blank",
                "noopener"
              );
            },
            children: t("chat.upsellBtnLabel")
          }
        ) })
      ] }) : t("chat.rateLimit.generalRateLimit") }) })
    ] }) });
  }
  return /* @__PURE__ */ jsxs74("div", { className: `chat-message chat-message--${message.type}`, children: [
    /* @__PURE__ */ jsxs74("div", { className: "chat-message__content", children: [
      /* @__PURE__ */ jsxs74("div", { className: "chat-message__header", children: [
        /* @__PURE__ */ jsx125("span", { className: "chat-message__role", children: message.type === "user" ? t("chat.role.user") : t("chat.role.assistant") }),
        /* @__PURE__ */ jsx125("span", { className: "chat-message__timestamp", children: formatTime(message.timestamp) })
      ] }),
      /* @__PURE__ */ jsx125("div", { className: "chat-message__body", children: message.error ? /* @__PURE__ */ jsxs74(Fragment21, { children: [
        /* @__PURE__ */ jsx125("div", { className: "chat-message__error", children: message.content }),
        message.errorType !== "parse" && /* @__PURE__ */ jsxs74("div", { className: "chat-message__error_message", children: [
          "Error: ",
          message.error || t("chat.errors.generationFailed")
        ] }),
        message.errorType === "parse" && allowFixingParseError && /* @__PURE__ */ jsxs74("div", { className: "chat-message__error_message", children: [
          /* @__PURE__ */ jsx125("p", { children: t("chat.errors.invalidDiagram") }),
          /* @__PURE__ */ jsxs74("div", { className: "chat-message__error-actions", children: [
            onMermaidTabClick && /* @__PURE__ */ jsx125(
              "button",
              {
                className: "chat-message__error-link",
                onClick: () => onMermaidTabClick(message),
                type: "button",
                children: t("chat.errors.fixInMermaid")
              }
            ),
            onAiRepairClick && /* @__PURE__ */ jsx125(
              "button",
              {
                className: "chat-message__error-link",
                onClick: () => onAiRepairClick(message),
                disabled: rateLimitRemaining === 0,
                type: "button",
                children: t("chat.errors.aiRepair")
              }
            )
          ] })
        ] })
      ] }) : /* @__PURE__ */ jsxs74("div", { className: "chat-message__text", children: [
        message.content,
        message.isGenerating && /* @__PURE__ */ jsx125("span", { className: "chat-message__cursor", children: "\u258B" })
      ] }) })
    ] }),
    message.type === "assistant" && !message.isGenerating && /* @__PURE__ */ jsxs74("div", { className: "chat-message__actions", children: [
      !message.error && onInsertMessage && /* @__PURE__ */ jsx125(
        "button",
        {
          className: "chat-message__action",
          onClick: () => onInsertMessage(message),
          type: "button",
          "aria-label": t("chat.insert"),
          title: t("chat.insert"),
          children: stackPushIcon
        }
      ),
      onMermaidTabClick && message.content && /* @__PURE__ */ jsx125(
        "button",
        {
          className: "chat-message__action",
          onClick: () => onMermaidTabClick(message),
          type: "button",
          "aria-label": t("chat.viewAsMermaid"),
          title: t("chat.viewAsMermaid"),
          children: codeIcon
        }
      ),
      onDeleteMessage && message.errorType !== "network" && /* @__PURE__ */ jsx125(
        "button",
        {
          className: "chat-message__action chat-message__action--danger",
          onClick: () => onDeleteMessage(message.id),
          type: "button",
          "aria-label": t("chat.deleteMessage"),
          title: t("chat.deleteMessage"),
          children: TrashIcon
        }
      ),
      message.errorType === "network" && onRetry && isLastMessage && /* @__PURE__ */ jsx125(
        "button",
        {
          className: clsx57("chat-message__action", { invisible: !canRetry }),
          onClick: () => onRetry(message),
          type: "button",
          "aria-label": t("chat.retry"),
          title: t("chat.retry"),
          children: RetryIcon
        }
      )
    ] })
  ] });
};

// components/TTDDialog/Chat/ChatInterface.tsx
import { jsx as jsx126, jsxs as jsxs75 } from "react/jsx-runtime";
var ChatInterface = ({
  chatId,
  messages,
  currentPrompt,
  onPromptChange,
  onGenerate,
  isGenerating,
  rateLimits,
  onAbort,
  onMermaidTabClick,
  onAiRepairClick,
  onDeleteMessage,
  onInsertMessage,
  onRetry,
  renderWelcomeScreen,
  renderWarning
}) => {
  const messagesEndRef = useRef32(null);
  const textareaRef = useRef32(null);
  useLayoutEffect9(() => {
    messagesEndRef.current?.scrollIntoView();
  }, [messages]);
  useEffect37(() => {
    if (textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [chatId]);
  const handleInputChange = (event) => {
    const value = event.target.value;
    onPromptChange(value);
  };
  const handleSubmit = () => {
    if (isGenerating && onAbort) {
      onAbort();
      return;
    }
    const trimmedPrompt = currentPrompt.trim();
    if (!trimmedPrompt) {
      return;
    }
    onGenerate({ prompt: trimmedPrompt });
    onPromptChange("");
  };
  const handleKeyDown = (event) => {
    if (event.key === KEYS51.ENTER && !event.shiftKey) {
      event.preventDefault();
      if (!isGenerating) {
        handleSubmit();
      }
    }
  };
  const canSend = currentPrompt.trim().length > 3 && !isGenerating && (rateLimits?.rateLimitRemaining ?? 1) > 0;
  const canStop = isGenerating && !!onAbort;
  const onInput = (ev) => {
    const target = ev.target;
    target.style.height = "auto";
    target.style.height = `${Math.min(target.scrollHeight, 120)}px`;
  };
  return /* @__PURE__ */ jsxs75("div", { className: "chat-interface", children: [
    /* @__PURE__ */ jsxs75("div", { className: "chat-interface__messages", children: [
      messages.length === 0 ? /* @__PURE__ */ jsx126("div", { className: "chat-interface__welcome-screen", children: renderWelcomeScreen ? renderWelcomeScreen({ rateLimits: rateLimits ?? null }) : /* @__PURE__ */ jsx126(TTDWelcomeMessage, {}) }) : messages.map((message, index) => /* @__PURE__ */ jsx126(
        ChatMessage,
        {
          message,
          onMermaidTabClick,
          onAiRepairClick,
          onDeleteMessage,
          onInsertMessage,
          onRetry,
          rateLimitRemaining: rateLimits?.rateLimitRemaining,
          isLastMessage: index === messages.length - 1,
          renderWarning,
          allowFixingParseError: message.errorType === "parse" && index === messages.length - 1
        },
        message.id
      )),
      /* @__PURE__ */ jsx126("div", { ref: messagesEndRef, id: "messages-end" })
    ] }),
    /* @__PURE__ */ jsx126("div", { className: "chat-interface__input-container", children: /* @__PURE__ */ jsx126("div", { className: "chat-interface__input-outer", children: /* @__PURE__ */ jsxs75(
      "div",
      {
        className: "chat-interface__input-wrapper",
        style: {
          borderColor: isGenerating ? "var(--dialog-border-color)" : void 0
        },
        children: [
          /* @__PURE__ */ jsx126(
            "textarea",
            {
              ref: textareaRef,
              autoFocus: true,
              className: "chat-interface__input",
              value: currentPrompt,
              onChange: handleInputChange,
              onKeyDown: handleKeyDown,
              placeholder: isGenerating ? t("chat.generating") : rateLimits?.rateLimitRemaining === 0 ? t("chat.rateLimit.messageLimitInputPlaceholder") : messages.length > 0 ? t("chat.inputPlaceholderWithMessages") : t("chat.inputPlaceholder", { shortcut: "Shift + Enter" }),
              disabled: rateLimits?.rateLimitRemaining === 0,
              rows: 1,
              cols: 30,
              onInput
            }
          ),
          /* @__PURE__ */ jsx126(
            "button",
            {
              className: "chat-interface__send-button",
              onClick: handleSubmit,
              disabled: !canSend && !canStop,
              type: "button",
              children: /* @__PURE__ */ jsx126(
                InlineIcon,
                {
                  size: "1.5em",
                  icon: isGenerating ? stop : ArrowRightIcon
                }
              )
            }
          )
        ]
      }
    ) }) })
  ] });
};

// components/TTDDialog/TTDContext.tsx
import { randomId as randomId6 } from "@excalidraw/common";
var rateLimitsAtom = atom(null);
var showPreviewAtom = atom(false);
var errorAtom = atom(null);
var chatHistoryAtom = atom({
  id: randomId6(),
  messages: [],
  currentPrompt: ""
});

// components/TTDDialog/utils/chat.ts
import { findLastIndex, randomId as randomId7 } from "@excalidraw/common";
var updateAssistantContent = (chatHistory, payload) => {
  const { messages } = chatHistory;
  const lastAssistantIndex = findLastIndex(
    messages,
    (msg) => msg.type === "assistant"
  );
  if (lastAssistantIndex === -1) {
    return chatHistory;
  }
  const lastMessage = messages[lastAssistantIndex];
  const updatedMessages = messages.slice();
  updatedMessages[lastAssistantIndex] = {
    ...lastMessage,
    ...payload
  };
  return {
    ...chatHistory,
    messages: updatedMessages
  };
};
var getLastAssistantMessage = (chatHistory) => {
  const { messages } = chatHistory;
  const lastAssistantIndex = findLastIndex(
    messages,
    (msg) => msg.type === "assistant"
  );
  return messages[lastAssistantIndex];
};
var addMessages = (chatHistory, messages) => {
  const newMessages = messages.map((message) => ({
    ...message,
    id: randomId7(),
    timestamp: /* @__PURE__ */ new Date()
  }));
  return {
    ...chatHistory,
    messages: [...chatHistory.messages, ...newMessages]
  };
};
var removeLastAssistantMessage = (chatHistory) => {
  const lastMsgIdx = findLastIndex(
    chatHistory.messages ?? [],
    (msg) => msg.type === "assistant"
  );
  if (lastMsgIdx !== -1) {
    return {
      ...chatHistory,
      messages: chatHistory.messages.filter((_, idx) => idx !== lastMsgIdx)
    };
  }
  return chatHistory;
};
var getMessagesForLLM = (chatHistory) => {
  const messages = [];
  for (const msg of chatHistory.messages) {
    if (msg.content && (msg.type === "user" || msg.type === "assistant")) {
      messages.push({
        role: msg.type,
        content: msg.content
      });
    }
  }
  return messages;
};

// components/TTDDialog/Chat/useChatAgent.ts
var useChatAgent = () => {
  const [chatHistory, setChatHistory] = useAtom(chatHistoryAtom);
  const addUserMessage = (content) => {
    setChatHistory(
      (prev) => addMessages(prev, [
        {
          type: "user",
          content
        }
      ])
    );
  };
  const addAssistantMessage = () => {
    setChatHistory(
      (prev) => addMessages(prev, [
        {
          type: "assistant",
          content: "",
          isGenerating: true
        }
      ])
    );
  };
  const setLastRetryAttempt = () => {
    setChatHistory(
      (prev) => updateAssistantContent(prev, {
        lastAttemptAt: Date.now()
      })
    );
  };
  const setAssistantError = (errorMessage, errorType = "other", errorDetails) => {
    const serializedErrorDetails = errorDetails ? JSON.stringify({
      name: errorDetails instanceof Error ? errorDetails.name : "Error",
      message: errorDetails instanceof Error ? errorDetails.message : String(errorDetails),
      stack: errorDetails instanceof Error ? errorDetails.stack : void 0
    }) : void 0;
    setChatHistory(
      (prev) => updateAssistantContent(prev, {
        isGenerating: false,
        error: errorMessage,
        errorType,
        errorDetails: serializedErrorDetails
      })
    );
  };
  return {
    addUserMessage,
    addAssistantMessage,
    setAssistantError,
    chatHistory,
    setChatHistory,
    setLastRetryAttempt
  };
};

// components/TTDDialog/useTTDChatStorage.ts
import { useCallback as useCallback16, useEffect as useEffect38, useRef as useRef33 } from "react";
import { randomId as randomId8 } from "@excalidraw/common";
var generateChatTitle = (firstMessage) => {
  const trimmed = firstMessage.trim();
  if (trimmed.length <= 50) {
    return trimmed;
  }
  return `${trimmed.substring(0, 47)}...`;
};
var savedChatsAtom = atom([]);
var isLoadingChatsAtom = atom(false);
var chatsLoadedAtom = atom(false);
var useTTDChatStorage = ({
  persistenceAdapter
}) => {
  const [chatHistory] = useAtom(chatHistoryAtom);
  const [savedChats, setSavedChats] = useAtom(savedChatsAtom);
  const [isLoading, setIsLoading] = useAtom(isLoadingChatsAtom);
  const [chatsLoaded, setChatsLoaded] = useAtom(chatsLoadedAtom);
  const savedChatsRef = useRef33(savedChats);
  savedChatsRef.current = savedChats;
  const lastMessageInHistory = chatHistory?.messages[chatHistory?.messages.length - 1];
  const loadChats = useCallback16(async () => {
    if (chatsLoaded || isLoading) {
      return;
    }
    setIsLoading(true);
    try {
      const chats = await persistenceAdapter.loadChats();
      setSavedChats(chats);
      setChatsLoaded(true);
    } catch (error) {
      console.warn("Failed to load chats:", error);
      setSavedChats([]);
      setChatsLoaded(true);
    } finally {
      setIsLoading(false);
    }
  }, [
    chatsLoaded,
    isLoading,
    setSavedChats,
    setIsLoading,
    setChatsLoaded,
    persistenceAdapter
  ]);
  useEffect38(() => {
    loadChats();
  }, []);
  const saveCurrentChat = useCallback16(async () => {
    if (chatHistory.messages.length === 0) {
      return;
    }
    const firstUserMessage = chatHistory.messages.find(
      (msg) => msg.type === "user"
    );
    if (!firstUserMessage || typeof firstUserMessage.content !== "string") {
      return;
    }
    const title = generateChatTitle(firstUserMessage.content);
    const currentSavedChats = savedChatsRef.current;
    const existingChat = currentSavedChats.find(
      (chat) => chat.id === chatHistory.id
    );
    const messagesChanged = !existingChat || existingChat.messages.length !== chatHistory.messages.length || existingChat.messages.some(
      (msg, i) => msg.id !== chatHistory.messages[i]?.id || msg.content !== chatHistory.messages[i]?.content
    );
    const chatToSave = {
      id: chatHistory.id,
      title,
      messages: chatHistory.messages.filter((msg) => msg.type === "user" || msg.type === "assistant").map((msg) => ({
        ...msg,
        timestamp: msg.timestamp instanceof Date ? msg.timestamp : new Date(msg.timestamp)
      })),
      currentPrompt: chatHistory.currentPrompt,
      timestamp: messagesChanged ? Date.now() : existingChat?.timestamp ?? Date.now()
    };
    const updatedChats = [
      ...currentSavedChats.filter((chat) => chat.id !== chatHistory.id),
      chatToSave
    ].sort((a, b) => b.timestamp - a.timestamp).slice(0, 10);
    setSavedChats(updatedChats);
    try {
      await persistenceAdapter.saveChats(updatedChats);
    } catch (error) {
      console.warn("Failed to save chats:", error);
    }
  }, [chatHistory, setSavedChats, persistenceAdapter]);
  useEffect38(() => {
    if (!lastMessageInHistory?.isGenerating) {
      saveCurrentChat();
    }
  }, [
    chatHistory.messages?.length,
    lastMessageInHistory?.id,
    lastMessageInHistory?.isGenerating
  ]);
  const deleteChat = useCallback16(
    async (chatId) => {
      const updatedChats = savedChatsRef.current.filter(
        (chat) => chat.id !== chatId
      );
      setSavedChats(updatedChats);
      try {
        await persistenceAdapter.saveChats(updatedChats);
      } catch (error) {
        console.warn("Failed to save after delete:", error);
      }
      return updatedChats;
    },
    [setSavedChats, persistenceAdapter]
  );
  const restoreChat = useCallback16((chat) => {
    return chat;
  }, []);
  const createNewChatId = useCallback16(async () => {
    await saveCurrentChat();
    return randomId8();
  }, [saveCurrentChat]);
  return {
    savedChats,
    saveCurrentChat,
    deleteChat,
    restoreChat,
    createNewChatId
  };
};

// components/TTDDialog/hooks/useMermaidRenderer.ts
import { useCallback as useCallback17, useEffect as useEffect39, useMemo as useMemo9, useRef as useRef34 } from "react";

// components/TTDDialog/utils/mermaidValidation.ts
var isValidMermaidSyntax = (content) => {
  const trimmed = content.trim();
  if (!trimmed) {
    return false;
  }
  const openBrackets = (trimmed.match(/\[/g) || []).length;
  const closeBrackets = (trimmed.match(/\]/g) || []).length;
  const openBraces = (trimmed.match(/\{/g) || []).length;
  const closeBraces = (trimmed.match(/\}/g) || []).length;
  const openParens = (trimmed.match(/\(/g) || []).length;
  const closeParens = (trimmed.match(/\)/g) || []).length;
  if (openBrackets !== closeBrackets || openBraces !== closeBraces || openParens !== closeParens) {
    return false;
  }
  const lastLine = trimmed.split("\n").pop()?.trim() || "";
  const incompletePatterns = [
    /-->$/,
    /--$/,
    /-\.$/,
    /==>$/,
    /==$/,
    /~~$/,
    /::$/,
    /:$/,
    /\|$/,
    /&$/
  ];
  if (incompletePatterns.some((pattern) => pattern.test(lastLine))) {
    return false;
  }
  return true;
};

// components/TTDDialog/hooks/useMermaidRenderer.ts
var FAST_THROTTLE_DELAY = 300;
var SLOW_THROTTLE_DELAY = 3e3;
var RENDER_SPEED_THRESHOLD = 100;
var PARSE_FAIL_DELAY = 100;
var useMermaidRenderer = ({
  mermaidToExcalidrawLib,
  canvasRef
}) => {
  const [chatHistory] = useAtom(chatHistoryAtom);
  const [, setError] = useAtom(errorAtom);
  const [showPreview, setShowPreview] = useAtom(showPreviewAtom);
  const isRenderingRef = useRef34(false);
  const lastAssistantMessage = useMemo9(
    () => getLastAssistantMessage(chatHistory),
    [chatHistory]
  );
  const lastAssistantMessageRef = useRef34(lastAssistantMessage);
  useEffect39(() => {
    lastAssistantMessageRef.current = lastAssistantMessage;
  }, [lastAssistantMessage]);
  const data = useRef34({
    elements: [],
    files: null
  });
  const lastRenderTimeRef = useRef34(0);
  const pendingContentRef = useRef34(null);
  const hasErrorOffsetRef = useRef34(false);
  const currentThrottleDelayRef = useRef34(FAST_THROTTLE_DELAY);
  const { theme } = useUIAppState();
  const renderMermaid = useCallback17(
    async (mermaidDefinition) => {
      if (!mermaidDefinition.trim() || !mermaidToExcalidrawLib.loaded) {
        return false;
      }
      if (isRenderingRef.current) {
        return false;
      }
      isRenderingRef.current = true;
      const renderStartTime = performance.now();
      const result = await convertMermaidToExcalidraw({
        canvasRef,
        data,
        mermaidToExcalidrawLib,
        setError,
        mermaidDefinition,
        theme
      });
      const renderDuration = performance.now() - renderStartTime;
      if (renderDuration < RENDER_SPEED_THRESHOLD) {
        currentThrottleDelayRef.current = FAST_THROTTLE_DELAY;
      } else {
        currentThrottleDelayRef.current = SLOW_THROTTLE_DELAY;
      }
      isRenderingRef.current = false;
      return result.success;
    },
    [canvasRef, mermaidToExcalidrawLib, setError, theme]
  );
  const throttledRenderMermaid = useMemo9(() => {
    const fn = async (content) => {
      const now = Date.now();
      const timeSinceLastRender = now - lastRenderTimeRef.current;
      const throttleDelay = currentThrottleDelayRef.current;
      if (!isValidMermaidSyntax(content)) {
        if (!hasErrorOffsetRef.current) {
          lastRenderTimeRef.current = Math.max(
            lastRenderTimeRef.current,
            now - throttleDelay + PARSE_FAIL_DELAY
          );
          hasErrorOffsetRef.current = true;
        }
        pendingContentRef.current = content;
        return;
      }
      hasErrorOffsetRef.current = false;
      if (timeSinceLastRender < throttleDelay) {
        pendingContentRef.current = content;
        return;
      }
      pendingContentRef.current = null;
      const success = await renderMermaid(content);
      lastRenderTimeRef.current = Date.now();
      if (!success) {
        lastRenderTimeRef.current = lastRenderTimeRef.current - throttleDelay + PARSE_FAIL_DELAY;
        hasErrorOffsetRef.current = true;
      }
    };
    fn.flush = async () => {
      if (pendingContentRef.current) {
        const content = pendingContentRef.current;
        pendingContentRef.current = null;
        await renderMermaid(content);
        lastRenderTimeRef.current = Date.now();
      }
    };
    fn.cancel = () => {
      pendingContentRef.current = null;
    };
    return fn;
  }, [renderMermaid]);
  const resetThrottleState = useCallback17(() => {
    lastRenderTimeRef.current = 0;
    pendingContentRef.current = null;
    hasErrorOffsetRef.current = false;
    currentThrottleDelayRef.current = FAST_THROTTLE_DELAY;
  }, []);
  useEffect39(() => {
    if (lastAssistantMessage?.content && lastAssistantMessage?.isGenerating) {
      throttledRenderMermaid(lastAssistantMessage.content);
    } else if (!lastAssistantMessage?.isGenerating) {
      throttledRenderMermaid.flush();
      resetThrottleState();
      if (lastAssistantMessage?.content) {
        throttledRenderMermaid(lastAssistantMessage.content);
      }
    }
  }, [
    resetThrottleState,
    throttledRenderMermaid,
    lastAssistantMessage?.isGenerating,
    lastAssistantMessage?.content
  ]);
  useEffect39(() => {
    const msg = lastAssistantMessageRef.current;
    if (!msg?.content || msg.error) {
      return;
    }
    if (!showPreview) {
      return;
    }
    renderMermaid(msg.content);
  }, [chatHistory?.id, renderMermaid, showPreview]);
  useEffect39(() => {
    if (!chatHistory.messages?.filter((msg) => msg.type === "assistant").length) {
      const canvasNode = canvasRef.current;
      if (canvasNode) {
        const parent = canvasNode.parentElement;
        if (parent) {
          parent.style.background = "";
          canvasNode.replaceChildren();
        }
      }
      setShowPreview(false);
    } else if (!showPreview) {
      setShowPreview(true);
    }
  }, [chatHistory.messages, setShowPreview, canvasRef, showPreview]);
  return {
    data
  };
};

// components/TTDDialog/hooks/useTextGeneration.ts
import { useRef as useRef35 } from "react";
import { parseMermaidToExcalidraw } from "@excalidraw/mermaid-to-excalidraw";
import { isFiniteNumber } from "@excalidraw/math";
var MIN_PROMPT_LENGTH = 3;
var MAX_PROMPT_LENGTH = 1e4;
var useTextGeneration = ({
  onTextSubmit
}) => {
  const [, setError] = useAtom(errorAtom);
  const [rateLimits, setRateLimits] = useAtom(rateLimitsAtom);
  const [chatHistory, setChatHistory] = useAtom(chatHistoryAtom);
  const { addUserMessage, addAssistantMessage, setAssistantError } = useChatAgent();
  const streamingAbortControllerRef = useRef35(null);
  const validatePrompt = (prompt) => {
    if (prompt.length > MAX_PROMPT_LENGTH || prompt.length < MIN_PROMPT_LENGTH || rateLimits?.rateLimitRemaining === 0) {
      if (prompt.length < MIN_PROMPT_LENGTH) {
        setError(
          new Error(
            t("chat.errors.promptTooShort", { min: MIN_PROMPT_LENGTH })
          )
        );
      }
      if (prompt.length > MAX_PROMPT_LENGTH) {
        setError(
          new Error(t("chat.errors.promptTooLong", { max: MAX_PROMPT_LENGTH }))
        );
      }
      return false;
    }
    return true;
  };
  const onGenerate = async ({
    prompt,
    isRepairFlow = false
  }) => {
    if (!validatePrompt(prompt)) {
      return;
    }
    if (streamingAbortControllerRef.current) {
      streamingAbortControllerRef.current.abort();
    }
    setError(null);
    const abortController = new AbortController();
    streamingAbortControllerRef.current = abortController;
    if (!isRepairFlow) {
      addUserMessage(prompt);
      addAssistantMessage();
    } else {
      setChatHistory(
        (prev) => updateAssistantContent(prev, {
          isGenerating: true,
          content: "",
          error: void 0,
          errorType: void 0,
          errorDetails: void 0
        })
      );
    }
    try {
      trackEvent("ai", "generate", "ttd");
      const previousMessages = getMessagesForLLM(chatHistory);
      const messages = [
        ...previousMessages.slice(-3),
        { role: "user", content: prompt }
      ];
      const { generatedResponse, error, rateLimit, rateLimitRemaining } = await onTextSubmit({
        messages,
        onStreamCreated: () => {
          if (isRepairFlow) {
            setChatHistory(
              (prev) => updateAssistantContent(prev, {
                content: "",
                error: "",
                isGenerating: true
              })
            );
          }
        },
        onChunk: (chunk2) => {
          setChatHistory((prev) => {
            const lastAssistantMessage = getLastAssistantMessage(prev);
            return updateAssistantContent(prev, {
              content: lastAssistantMessage.content + chunk2
            });
          });
        },
        signal: abortController.signal
      });
      setChatHistory(
        (prev) => updateAssistantContent(prev, {
          isGenerating: false
        })
      );
      if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {
        setRateLimits({ rateLimit, rateLimitRemaining });
      }
      if (error?.status === 429 || rateLimitRemaining === 0) {
        setChatHistory((chatHistory2) => {
          if (error?.status === 429) {
            chatHistory2 = removeLastAssistantMessage(chatHistory2);
          }
          chatHistory2 = {
            ...chatHistory2,
            messages: chatHistory2.messages.filter(
              (msg) => msg.type !== "warning" || msg.warningType === "rateLimitExceeded" || msg.warningType === "messageLimitExceeded"
            )
          };
          const messages2 = addMessages(chatHistory2, [
            {
              type: "warning",
              warningType: rateLimitRemaining === 0 ? "messageLimitExceeded" : "rateLimitExceeded"
            }
          ]);
          return messages2;
        });
      }
      if (error) {
        const isAborted = error.name === "AbortError" || error.message === "Aborted" || abortController.signal.aborted;
        if (isAborted) {
          return;
        }
        const _error = new Error(
          error.message || t("chat.errors.requestFailed")
        );
        if (error.status !== 429) {
          setAssistantError(_error.message, "network");
        }
        setError(_error);
        return;
      }
      try {
        await parseMermaidToExcalidraw(generatedResponse ?? "");
        trackEvent("ai", "mermaid parse success", "ttd");
      } catch (error2) {
        trackEvent("ai", "mermaid parse failed", "ttd");
        const _error = new Error(
          error2.message || t("chat.errors.mermaidParseError")
        );
        setAssistantError(_error.message, "parse");
        setError(_error);
      }
    } catch (error) {
      const _error = new Error(
        error.message || t("chat.errors.generationFailed")
      );
      setAssistantError(_error.message, "other");
      setError(_error);
    } finally {
      streamingAbortControllerRef.current = null;
    }
  };
  const handleAbort = () => {
    if (streamingAbortControllerRef.current) {
      streamingAbortControllerRef.current.abort();
    }
  };
  return {
    onGenerate,
    handleAbort
  };
};

// components/TTDDialog/hooks/useChatManagement.ts
import { useCallback as useCallback18, useState as useState36 } from "react";
var useChatManagement = ({
  persistenceAdapter
}) => {
  const setError = useSetAtom(errorAtom);
  const [chatHistory, setChatHistory] = useAtom(chatHistoryAtom);
  const [isMenuOpen, setIsMenuOpen] = useState36(false);
  const { restoreChat, deleteChat, createNewChatId } = useTTDChatStorage({
    persistenceAdapter
  });
  const applyChatToState = useCallback18(
    (chat) => {
      const restoredMessages = chat.messages.map((msg) => ({
        ...msg,
        timestamp: msg.timestamp instanceof Date ? msg.timestamp : new Date(msg.timestamp)
      }));
      const history = {
        id: chat.id,
        messages: restoredMessages,
        currentPrompt: ""
      };
      const lastAssistantMsg = getLastAssistantMessage(history);
      setError(
        lastAssistantMsg?.error ? new Error(lastAssistantMsg?.error) : null
      );
      setChatHistory(history);
    },
    [setError, setChatHistory]
  );
  const resetChatState = useCallback18(async () => {
    const newSessionId = await createNewChatId();
    setChatHistory({
      id: newSessionId,
      messages: [],
      currentPrompt: ""
    });
    setError(null);
  }, [createNewChatId, setChatHistory, setError]);
  const onRestoreChat = useCallback18(
    (chat) => {
      const restoredChat = restoreChat(chat);
      applyChatToState(restoredChat);
      setIsMenuOpen(false);
    },
    [restoreChat, applyChatToState]
  );
  const handleDeleteChat = useCallback18(
    async (chatId, event) => {
      event.stopPropagation();
      const isDeletingActiveChat = chatId === chatHistory.id;
      const updatedChats = await deleteChat(chatId);
      if (isDeletingActiveChat) {
        if (updatedChats.length > 0) {
          const nextChat = updatedChats[0];
          applyChatToState(nextChat);
        } else {
          await resetChatState();
        }
      }
    },
    [chatHistory.id, deleteChat, applyChatToState, resetChatState]
  );
  const handleNewChat = useCallback18(async () => {
    await resetChatState();
    setIsMenuOpen(false);
  }, [resetChatState]);
  const handleMenuToggle = useCallback18(() => {
    setIsMenuOpen((prev) => !prev);
  }, []);
  const handleMenuClose = useCallback18(() => {
    setIsMenuOpen(false);
  }, []);
  return {
    isMenuOpen,
    onRestoreChat,
    handleDeleteChat,
    handleNewChat,
    handleMenuToggle,
    handleMenuClose
  };
};

// components/TTDDialog/Chat/ChatHistoryMenu.tsx
import clsx58 from "clsx";
import { Fragment as Fragment22, jsx as jsx127, jsxs as jsxs76 } from "react/jsx-runtime";
var ChatHistoryMenu = ({
  isOpen,
  onToggle,
  onClose,
  onNewChat,
  onRestoreChat,
  onDeleteChat,
  isNewChatBtnVisible,
  savedChats,
  activeSessionId,
  disabled
}) => {
  return /* @__PURE__ */ jsxs76("div", { className: "ttd-chat-history-menu", children: [
    isNewChatBtnVisible && /* @__PURE__ */ jsx127(FilledButton, { onClick: onNewChat, disabled, children: t("chat.newChat") }),
    savedChats.length > 0 && /* @__PURE__ */ jsx127("div", { className: "ttd-dialog-panel__menu-wrapper", children: /* @__PURE__ */ jsxs76(DropdownMenu_default, { open: isOpen, children: [
      /* @__PURE__ */ jsx127(
        DropdownMenu_default.Trigger,
        {
          onToggle,
          className: "ttd-dialog-menu-trigger",
          disabled,
          title: t("chat.menu"),
          "aria-label": t("chat.menu"),
          children: historyIcon
        }
      ),
      /* @__PURE__ */ jsx127(DropdownMenu_default.Content, { onClickOutside: onClose, onSelect: onClose, children: /* @__PURE__ */ jsx127(Fragment22, { children: savedChats.map((chat) => /* @__PURE__ */ jsxs76(
        DropdownMenu_default.ItemCustom,
        {
          className: clsx58("ttd-chat-menu-item", {
            "ttd-chat-menu-item--active": chat.id === activeSessionId
          }),
          onClick: () => {
            onRestoreChat(chat);
          },
          children: [
            /* @__PURE__ */ jsx127("span", { className: "ttd-chat-menu-item__title", children: chat.title }),
            /* @__PURE__ */ jsx127(
              "button",
              {
                className: "ttd-chat-menu-item__delete",
                onClick: (e) => onDeleteChat(chat.id, e),
                title: t("chat.deleteChat"),
                "aria-label": t("chat.deleteChat"),
                type: "button",
                children: TrashIcon
              }
            )
          ]
        },
        chat.id
      )) }) })
    ] }) })
  ] });
};

// components/TTDDialog/Chat/TTDChatPanel.tsx
import { jsx as jsx128, jsxs as jsxs77 } from "react/jsx-runtime";
var TTDChatPanel = ({
  chatId,
  messages,
  currentPrompt,
  onPromptChange,
  onGenerate,
  isGenerating,
  generatedResponse,
  isMenuOpen,
  onMenuToggle,
  onMenuClose,
  onNewChat,
  onRestoreChat,
  onDeleteChat,
  savedChats,
  activeSessionId,
  onAbort,
  onMermaidTabClick,
  onAiRepairClick,
  onDeleteMessage,
  onInsertMessage,
  onRetry,
  onViewAsMermaid,
  renderWelcomeScreen,
  renderWarning
}) => {
  const [rateLimits] = useAtom(rateLimitsAtom);
  const getPanelActions = () => {
    const actions3 = [];
    if (rateLimits) {
      actions3.push({
        label: t("chat.rateLimitRemaining", {
          count: rateLimits.rateLimitRemaining
        }),
        variant: "rateLimit",
        className: rateLimits.rateLimitRemaining < 5 ? "ttd-dialog-panel__rate-limit--danger" : ""
      });
    }
    if (generatedResponse) {
      actions3.push({
        action: onViewAsMermaid,
        label: t("chat.viewAsMermaid"),
        icon: /* @__PURE__ */ jsx128(InlineIcon, { icon: ArrowRightIcon }),
        variant: "link"
      });
    }
    return actions3;
  };
  const actions2 = getPanelActions();
  const getPanelActionFlexProp = () => {
    if (actions2.length === 2) {
      return "space-between";
    }
    if (actions2.length === 1 && actions2[0].variant === "rateLimit") {
      return "flex-start";
    }
    return "flex-end";
  };
  return /* @__PURE__ */ jsx128(
    TTDDialogPanel,
    {
      label: /* @__PURE__ */ jsxs77("div", { className: "ttd-dialog-panel__label-wrapper", children: [
        /* @__PURE__ */ jsx128("div", { className: "ttd-dialog-panel__label-group" }),
        /* @__PURE__ */ jsx128("div", { className: "ttd-dialog-panel__header-right", children: /* @__PURE__ */ jsx128(
          ChatHistoryMenu,
          {
            isNewChatBtnVisible: !!messages.length,
            isOpen: isMenuOpen,
            onToggle: onMenuToggle,
            onClose: onMenuClose,
            onNewChat,
            onRestoreChat,
            onDeleteChat,
            savedChats,
            activeSessionId,
            disabled: isGenerating
          }
        ) })
      ] }),
      className: "ttd-dialog-chat-panel",
      panelActionJustifyContent: getPanelActionFlexProp(),
      panelActions: actions2,
      children: /* @__PURE__ */ jsx128(
        ChatInterface,
        {
          chatId,
          messages,
          currentPrompt,
          onPromptChange,
          onGenerate,
          isGenerating,
          generatedResponse,
          onAbort,
          onMermaidTabClick,
          onAiRepairClick,
          onDeleteMessage,
          onInsertMessage,
          onRetry,
          rateLimits,
          renderWelcomeScreen,
          renderWarning
        }
      )
    }
  );
};

// components/TTDDialog/TTDPreviewPanel.tsx
import { jsx as jsx129 } from "react/jsx-runtime";
var TTDPreviewPanel = ({
  canvasRef,
  error,
  loaded,
  onInsert,
  hideErrorDetails
}) => {
  const actions2 = [
    {
      action: onInsert,
      label: t("chat.insert"),
      icon: ArrowRightIcon,
      variant: "button"
    }
  ];
  return /* @__PURE__ */ jsx129(
    TTDDialogPanel,
    {
      panelActionJustifyContent: "flex-end",
      panelActions: actions2,
      className: "ttd-dialog-preview-panel",
      children: /* @__PURE__ */ jsx129(
        TTDDialogOutput,
        {
          canvasRef,
          error,
          loaded,
          hideErrorDetails
        }
      )
    }
  );
};

// components/TTDDialog/TextToDiagram.tsx
import { jsx as jsx130, jsxs as jsxs78 } from "react/jsx-runtime";
var TextToDiagramContent = ({
  mermaidToExcalidrawLib,
  onTextSubmit,
  renderWelcomeScreen,
  renderWarning,
  persistenceAdapter
}) => {
  const app = useApp();
  const setAppState = useExcalidrawSetAppState();
  const canvasRef = useRef36(null);
  const [error, setError] = useAtom(errorAtom);
  const [chatHistory, setChatHistory] = useAtom(chatHistoryAtom);
  const showPreview = useAtomValue(showPreviewAtom);
  const { savedChats } = useTTDChatStorage({ persistenceAdapter });
  const lastAssistantMessage = getLastAssistantMessage(chatHistory);
  const { setLastRetryAttempt } = useChatAgent();
  const { data } = useMermaidRenderer({
    canvasRef,
    mermaidToExcalidrawLib
  });
  const { onGenerate, handleAbort } = useTextGeneration({
    onTextSubmit
  });
  const {
    isMenuOpen,
    onRestoreChat,
    handleDeleteChat,
    handleNewChat,
    handleMenuToggle,
    handleMenuClose
  } = useChatManagement({ persistenceAdapter });
  const onViewAsMermaid = () => {
    if (typeof lastAssistantMessage?.content === "string") {
      saveMermaidDataToStorage(lastAssistantMessage.content);
      setAppState({
        openDialog: { name: "ttd", tab: "mermaid" }
      });
    }
  };
  const handleMermaidTabClick = (message) => {
    const mermaidContent = message.content || "";
    if (mermaidContent) {
      saveMermaidDataToStorage(mermaidContent);
      setAppState({
        openDialog: { name: "ttd", tab: "mermaid" }
      });
    }
  };
  const handleInsertMessage = async (message) => {
    const mermaidContent = message.content || "";
    if (!mermaidContent.trim() || !mermaidToExcalidrawLib.loaded) {
      return;
    }
    const tempDataRef = {
      current: {
        elements: [],
        files: null
      }
    };
    const result = await convertMermaidToExcalidraw({
      canvasRef,
      data: tempDataRef,
      mermaidToExcalidrawLib,
      setError,
      mermaidDefinition: mermaidContent,
      theme: app.state.theme
    });
    if (result.success) {
      insertToEditor({
        app,
        data: tempDataRef,
        text: mermaidContent,
        shouldSaveMermaidDataToStorage: true
      });
    }
  };
  const handleAiRepairClick = async (message) => {
    const mermaidContent = message.content || "";
    const errorMessage = message.error || "";
    if (!mermaidContent) {
      return;
    }
    const repairPrompt = `Fix the error in this Mermaid diagram. The diagram is:

\`\`\`mermaid
${mermaidContent}
\`\`\`

The exception/error is: ${errorMessage}

Please fix the Mermaid syntax and regenerate a valid diagram.`;
    await onGenerate({ prompt: repairPrompt, isRepairFlow: true });
  };
  const handleRetry = async (message) => {
    const messageIndex = chatHistory.messages.findIndex(
      (msg) => msg.id === message.id
    );
    if (messageIndex > 0) {
      const previousMessage = chatHistory.messages[messageIndex - 1];
      if (previousMessage.type === "user" && typeof previousMessage.content === "string") {
        setLastRetryAttempt();
        await onGenerate({
          prompt: previousMessage.content,
          isRepairFlow: true
        });
      }
    }
  };
  const handleInsertToEditor = () => {
    insertToEditor({ app, data });
  };
  const handleDeleteMessage = (messageId) => {
    const assistantMessageIndex = chatHistory.messages.findIndex(
      (msg) => msg.id === messageId && msg.type === "assistant"
    );
    const remainingMessages = chatHistory.messages.slice(
      0,
      assistantMessageIndex - 1
    );
    setChatHistory({
      ...chatHistory,
      messages: remainingMessages
    });
  };
  const handlePromptChange = (newPrompt) => {
    setChatHistory((prev) => ({
      ...prev,
      currentPrompt: newPrompt
    }));
  };
  return /* @__PURE__ */ jsxs78(
    "div",
    {
      className: `ttd-dialog-layout ${showPreview ? "ttd-dialog-layout--split" : "ttd-dialog-layout--chat-only"}`,
      children: [
        /* @__PURE__ */ jsx130(
          TTDChatPanel,
          {
            chatId: chatHistory.id,
            messages: chatHistory.messages,
            currentPrompt: chatHistory.currentPrompt,
            onPromptChange: handlePromptChange,
            onGenerate,
            isGenerating: lastAssistantMessage?.isGenerating ?? false,
            generatedResponse: lastAssistantMessage?.content,
            isMenuOpen,
            onMenuToggle: handleMenuToggle,
            onMenuClose: handleMenuClose,
            onNewChat: handleNewChat,
            onRestoreChat,
            onDeleteChat: handleDeleteChat,
            savedChats,
            activeSessionId: chatHistory.id,
            onAbort: handleAbort,
            onMermaidTabClick: handleMermaidTabClick,
            onAiRepairClick: handleAiRepairClick,
            onDeleteMessage: handleDeleteMessage,
            onInsertMessage: handleInsertMessage,
            onRetry: handleRetry,
            onViewAsMermaid,
            renderWarning,
            renderWelcomeScreen
          }
        ),
        showPreview && /* @__PURE__ */ jsx130(
          TTDPreviewPanel,
          {
            canvasRef,
            hideErrorDetails: lastAssistantMessage?.errorType === "parse",
            error,
            loaded: mermaidToExcalidrawLib.loaded,
            onInsert: handleInsertToEditor
          }
        )
      ]
    }
  );
};
var TextToDiagram = ({
  mermaidToExcalidrawLib,
  onTextSubmit,
  renderWelcomeScreen,
  renderWarning,
  persistenceAdapter
}) => {
  return /* @__PURE__ */ jsx130(
    TextToDiagramContent,
    {
      mermaidToExcalidrawLib,
      onTextSubmit,
      renderWelcomeScreen,
      renderWarning,
      persistenceAdapter
    }
  );
};
var TextToDiagram_default = TextToDiagram;

// components/TTDDialog/TTDDialogTabs.tsx
import { Tabs as RadixTabs5 } from "radix-ui";
import { useRef as useRef37 } from "react";
import { isMemberOf as isMemberOf2 } from "@excalidraw/common";
import { jsx as jsx131 } from "react/jsx-runtime";
var TTDDialogTabs = (props) => {
  const setAppState = useExcalidrawSetAppState();
  const rootRef = useRef37(null);
  const minHeightRef = useRef37(0);
  return /* @__PURE__ */ jsx131(
    RadixTabs5.Root,
    {
      ref: rootRef,
      className: "ttd-dialog-tabs-root",
      value: props.tab,
      onValueChange: (tab) => {
        if (!tab) {
          return;
        }
        const modalContentNode = rootRef.current?.closest(".Modal__content");
        if (modalContentNode) {
          const currHeight = modalContentNode.offsetHeight || 0;
          if (currHeight > minHeightRef.current) {
            minHeightRef.current = currHeight;
            modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;
          }
        }
        if (props.dialog === "ttd" && isMemberOf2(["text-to-diagram", "mermaid"], tab)) {
          setAppState({
            openDialog: { name: props.dialog, tab }
          });
        }
      },
      children: props.children
    }
  );
};
TTDDialogTabs.displayName = "TTDDialogTabs";
var TTDDialogTabs_default = TTDDialogTabs;

// components/TTDDialog/TTDDialogTabTriggers.tsx
import { Tabs as RadixTabs6 } from "radix-ui";
import { jsx as jsx132 } from "react/jsx-runtime";
var TTDDialogTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx132(RadixTabs6.List, { className: "ttd-dialog-triggers", ...rest, children });
};
TTDDialogTabTriggers.displayName = "TTDDialogTabTriggers";

// components/TTDDialog/TTDDialogTabTrigger.tsx
import { Tabs as RadixTabs7 } from "radix-ui";
import { jsx as jsx133 } from "react/jsx-runtime";
var TTDDialogTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ jsx133(RadixTabs7.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx133("button", { type: "button", className: "ttd-dialog-tab-trigger", ...rest, children }) });
};
TTDDialogTabTrigger.displayName = "TTDDialogTabTrigger";

// components/TTDDialog/TTDDialogTab.tsx
import { Tabs as RadixTabs8 } from "radix-ui";
import { jsx as jsx134 } from "react/jsx-runtime";
var TTDDialogTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx134(RadixTabs8.Content, { ...rest, value: tab, children });
};
TTDDialogTab.displayName = "TTDDialogTab";

// components/TTDDialog/TTDDialog.tsx
import { jsx as jsx135, jsxs as jsxs79 } from "react/jsx-runtime";
var TTDDialog = (props) => {
  const appState = useUIAppState();
  if (appState.openDialog?.name !== "ttd") {
    return null;
  }
  return /* @__PURE__ */ jsx135(TTDDialogBase, { ...props, tab: appState.openDialog.tab });
};
TTDDialog.WelcomeMessage = TTDWelcomeMessage;
var TTDDialogBase = withInternalFallback(
  "TTDDialogBase",
  ({
    tab,
    ...rest
  }) => {
    const app = useApp();
    const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] = useState37({
      loaded: false,
      api: import("@excalidraw/mermaid-to-excalidraw")
    });
    useEffect40(() => {
      const fn = async () => {
        await mermaidToExcalidrawLib.api;
        setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));
      };
      fn();
    }, [mermaidToExcalidrawLib.api]);
    return /* @__PURE__ */ jsx135(
      Dialog,
      {
        className: "ttd-dialog",
        onCloseRequest: () => {
          app.setOpenDialog(null);
        },
        size: 1520,
        title: false,
        ...rest,
        autofocus: false,
        children: /* @__PURE__ */ jsxs79(TTDDialogTabs_default, { dialog: "ttd", tab, children: [
          "__fallback" in rest && rest.__fallback ? /* @__PURE__ */ jsx135("p", { className: "dialog-mermaid-title", children: t("mermaid.title") }) : /* @__PURE__ */ jsxs79(TTDDialogTabTriggers, { children: [
            /* @__PURE__ */ jsx135(TTDDialogTabTrigger, { tab: "text-to-diagram", children: /* @__PURE__ */ jsxs79("div", { className: "ttd-dialog-tab-trigger__content", children: [
              t("labels.textToDiagram"),
              /* @__PURE__ */ jsx135("div", { className: "ttd-dialog-tab-trigger__badge", children: t("chat.aiBeta") })
            ] }) }),
            /* @__PURE__ */ jsx135(TTDDialogTabTrigger, { tab: "mermaid", children: t("mermaid.label") })
          ] }),
          !("__fallback" in rest) && /* @__PURE__ */ jsx135(TTDDialogTab, { className: "ttd-dialog-content", tab: "text-to-diagram", children: /* @__PURE__ */ jsx135(
            TextToDiagram_default,
            {
              mermaidToExcalidrawLib,
              onTextSubmit: rest.onTextSubmit,
              renderWelcomeScreen: rest.renderWelcomeScreen,
              renderWarning: rest.renderWarning,
              persistenceAdapter: rest.persistenceAdapter
            }
          ) }),
          /* @__PURE__ */ jsx135(TTDDialogTab, { className: "ttd-dialog-content", tab: "mermaid", children: /* @__PURE__ */ jsx135(
            MermaidToExcalidraw_default,
            {
              mermaidToExcalidrawLib,
              isActive: tab === "mermaid"
            }
          ) })
        ] })
      }
    );
  }
);

// components/ElementLinkDialog.tsx
import { useCallback as useCallback19, useEffect as useEffect41, useState as useState38 } from "react";
import { normalizeLink as normalizeLink2, KEYS as KEYS52 } from "@excalidraw/common";
import {
  defaultGetElementLinkFromSelection as defaultGetElementLinkFromSelection2,
  getLinkIdAndTypeFromSelection as getLinkIdAndTypeFromSelection2
} from "@excalidraw/element";
import { jsx as jsx136, jsxs as jsxs80 } from "react/jsx-runtime";
var ElementLinkDialog = ({
  sourceElementId,
  onClose,
  appState,
  scene,
  generateLinkForSelection = defaultGetElementLinkFromSelection2
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const originalLink = elementsMap.get(sourceElementId)?.link ?? null;
  const [nextLink, setNextLink] = useState38(originalLink);
  const [linkEdited, setLinkEdited] = useState38(false);
  useEffect41(() => {
    const selectedElements = getSelectedElements(elementsMap, appState);
    let nextLink2 = originalLink;
    if (selectedElements.length > 0 && generateLinkForSelection) {
      const idAndType = getLinkIdAndTypeFromSelection2(
        selectedElements,
        appState
      );
      if (idAndType) {
        nextLink2 = normalizeLink2(
          generateLinkForSelection(idAndType.id, idAndType.type)
        );
      }
    }
    setNextLink(nextLink2);
  }, [
    elementsMap,
    appState,
    appState.selectedElementIds,
    originalLink,
    generateLinkForSelection
  ]);
  const handleConfirm = useCallback19(() => {
    if (nextLink && nextLink !== elementsMap.get(sourceElementId)?.link) {
      const elementToLink = elementsMap.get(sourceElementId);
      elementToLink && scene.mutateElement(elementToLink, {
        link: nextLink
      });
    }
    if (!nextLink && linkEdited && sourceElementId) {
      const elementToLink = elementsMap.get(sourceElementId);
      elementToLink && scene.mutateElement(elementToLink, {
        link: null
      });
    }
    onClose?.();
  }, [sourceElementId, nextLink, elementsMap, linkEdited, scene, onClose]);
  useEffect41(() => {
    const handleKeyDown = (event) => {
      if (appState.openDialog?.name === "elementLinkSelector" && event.key === KEYS52.ENTER) {
        handleConfirm();
      }
      if (appState.openDialog?.name === "elementLinkSelector" && event.key === KEYS52.ESCAPE) {
        onClose?.();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [appState, onClose, handleConfirm]);
  return /* @__PURE__ */ jsxs80("div", { className: "ElementLinkDialog", children: [
    /* @__PURE__ */ jsxs80("div", { className: "ElementLinkDialog__header", children: [
      /* @__PURE__ */ jsx136("h2", { children: t("elementLink.title") }),
      /* @__PURE__ */ jsx136("p", { children: t("elementLink.desc") })
    ] }),
    /* @__PURE__ */ jsxs80("div", { className: "ElementLinkDialog__input", children: [
      /* @__PURE__ */ jsx136(
        TextField,
        {
          value: nextLink ?? "",
          onChange: (value) => {
            if (!linkEdited) {
              setLinkEdited(true);
            }
            setNextLink(value);
          },
          onKeyDown: (event) => {
            if (event.key === KEYS52.ENTER) {
              handleConfirm();
            }
          },
          className: "ElementLinkDialog__input-field",
          selectOnRender: true
        }
      ),
      originalLink && nextLink && /* @__PURE__ */ jsx136(
        ToolButton,
        {
          type: "button",
          title: t("buttons.remove"),
          "aria-label": t("buttons.remove"),
          label: t("buttons.remove"),
          onClick: () => {
            setNextLink(null);
            setLinkEdited(true);
          },
          className: "ElementLinkDialog__remove",
          icon: TrashIcon
        }
      )
    ] }),
    /* @__PURE__ */ jsxs80("div", { className: "ElementLinkDialog__actions", children: [
      /* @__PURE__ */ jsx136(
        DialogActionButton_default,
        {
          label: t("buttons.cancel"),
          onClick: () => {
            onClose?.();
          },
          style: {
            marginRight: 10
          }
        }
      ),
      /* @__PURE__ */ jsx136(
        DialogActionButton_default,
        {
          label: t("buttons.confirm"),
          onClick: handleConfirm,
          actionType: "primary"
        }
      )
    ] })
  ] });
};
var ElementLinkDialog_default = ElementLinkDialog;

// components/ErrorDialog.tsx
import React40, { useState as useState39 } from "react";
import { Fragment as Fragment23, jsx as jsx137 } from "react/jsx-runtime";
var ErrorDialog = ({
  children,
  onClose
}) => {
  const [modalIsShown, setModalIsShown] = useState39(!!children);
  const { container: excalidrawContainer } = useExcalidrawContainer();
  const handleClose = React40.useCallback(() => {
    setModalIsShown(false);
    if (onClose) {
      onClose();
    }
    excalidrawContainer?.focus();
  }, [onClose, excalidrawContainer]);
  return /* @__PURE__ */ jsx137(Fragment23, { children: modalIsShown && /* @__PURE__ */ jsx137(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("errorDialog.title"),
      children: /* @__PURE__ */ jsx137("div", { style: { whiteSpace: "pre-wrap" }, children })
    }
  ) });
};

// components/HelpDialog.tsx
import React41 from "react";
import { isDarwin as isDarwin4, isFirefox as isFirefox3, isWindows as isWindows2 } from "@excalidraw/common";
import { KEYS as KEYS53 } from "@excalidraw/common";
import { Fragment as Fragment24, jsx as jsx138, jsxs as jsxs81 } from "react/jsx-runtime";
var Header = () => /* @__PURE__ */ jsxs81("div", { className: "HelpDialog__header", children: [
  /* @__PURE__ */ jsxs81(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://docs.excalidraw.com",
      target: "_blank",
      rel: "noopener",
      children: [
        /* @__PURE__ */ jsx138("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon }),
        t("helpDialog.documentation")
      ]
    }
  ),
  /* @__PURE__ */ jsxs81(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://plus.excalidraw.com/blog",
      target: "_blank",
      rel: "noopener",
      children: [
        /* @__PURE__ */ jsx138("div", { className: "HelpDialog__link-icon", children: ExternalLinkIcon }),
        t("helpDialog.blog")
      ]
    }
  ),
  /* @__PURE__ */ jsxs81(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://github.com/excalidraw/excalidraw/issues",
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        /* @__PURE__ */ jsx138("div", { className: "HelpDialog__link-icon", children: GithubIcon }),
        t("helpDialog.github")
      ]
    }
  ),
  /* @__PURE__ */ jsxs81(
    "a",
    {
      className: "HelpDialog__btn",
      href: "https://youtube.com/@excalidraw",
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        /* @__PURE__ */ jsx138("div", { className: "HelpDialog__link-icon", children: youtubeIcon }),
        "YouTube"
      ]
    }
  )
] });
var Section2 = (props) => /* @__PURE__ */ jsxs81(Fragment24, { children: [
  /* @__PURE__ */ jsx138("h3", { children: props.title }),
  /* @__PURE__ */ jsx138("div", { className: "HelpDialog__islands-container", children: props.children })
] });
var ShortcutIsland = (props) => /* @__PURE__ */ jsxs81("div", { className: `HelpDialog__island ${props.className}`, children: [
  /* @__PURE__ */ jsx138("h4", { className: "HelpDialog__island-title", children: props.caption }),
  /* @__PURE__ */ jsx138("div", { className: "HelpDialog__island-content", children: props.children })
] });
function* intersperse(as, delim) {
  let first = true;
  for (const x of as) {
    if (!first) {
      yield delim;
    }
    first = false;
    yield x;
  }
}
var upperCaseSingleChars = (str) => {
  return str.replace(/\b[a-z]\b/, (c) => c.toUpperCase());
};
var Shortcut = ({
  label,
  shortcuts,
  isOr = true
}) => {
  const splitShortcutKeys = shortcuts.map((shortcut) => {
    const keys = shortcut.endsWith("++") ? [...shortcut.slice(0, -2).split("+"), "+"] : shortcut.split("+");
    return keys.map((key) => /* @__PURE__ */ jsx138(ShortcutKey, { children: upperCaseSingleChars(key) }, key));
  });
  return /* @__PURE__ */ jsxs81("div", { className: "HelpDialog__shortcut", children: [
    /* @__PURE__ */ jsx138("div", { children: label }),
    /* @__PURE__ */ jsx138("div", { className: "HelpDialog__key-container", children: [...intersperse(splitShortcutKeys, isOr ? t("helpDialog.or") : null)] })
  ] });
};
var ShortcutKey = (props) => /* @__PURE__ */ jsx138("kbd", { className: "HelpDialog__key", ...props });
var HelpDialog = ({ onClose }) => {
  const handleClose = React41.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  return /* @__PURE__ */ jsx138(Fragment24, { children: /* @__PURE__ */ jsxs81(
    Dialog,
    {
      onCloseRequest: handleClose,
      title: t("helpDialog.title"),
      className: "HelpDialog",
      children: [
        /* @__PURE__ */ jsx138(Header, {}),
        /* @__PURE__ */ jsxs81(Section2, { title: t("helpDialog.shortcuts"), children: [
          /* @__PURE__ */ jsxs81(
            ShortcutIsland,
            {
              className: "HelpDialog__island--tools",
              caption: t("helpDialog.tools"),
              children: [
                /* @__PURE__ */ jsx138(Shortcut, { label: t("toolBar.hand"), shortcuts: [KEYS53.H] }),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.selection"),
                    shortcuts: [KEYS53.V, KEYS53["1"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.rectangle"),
                    shortcuts: [KEYS53.R, KEYS53["2"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.diamond"),
                    shortcuts: [KEYS53.D, KEYS53["3"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.ellipse"),
                    shortcuts: [KEYS53.O, KEYS53["4"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.arrow"),
                    shortcuts: [KEYS53.A, KEYS53["5"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.line"),
                    shortcuts: [KEYS53.L, KEYS53["6"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.freedraw"),
                    shortcuts: [KEYS53.P, KEYS53["7"]]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.text"),
                    shortcuts: [KEYS53.T, KEYS53["8"]]
                  }
                ),
                /* @__PURE__ */ jsx138(Shortcut, { label: t("toolBar.image"), shortcuts: [KEYS53["9"]] }),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.eraser"),
                    shortcuts: [KEYS53.E, KEYS53["0"]]
                  }
                ),
                /* @__PURE__ */ jsx138(Shortcut, { label: t("toolBar.frame"), shortcuts: [KEYS53.F] }),
                /* @__PURE__ */ jsx138(Shortcut, { label: t("toolBar.laser"), shortcuts: [KEYS53.K] }),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.eyeDropper"),
                    shortcuts: [KEYS53.I, "Shift+S", "Shift+G"]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.editLineArrowPoints"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Enter")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.editText"),
                    shortcuts: [getShortcutKey("Enter")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.textNewLine"),
                    shortcuts: [
                      getShortcutKey("Enter"),
                      getShortcutKey("Shift+Enter")
                    ]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.textFinish"),
                    shortcuts: [
                      getShortcutKey("Esc"),
                      getShortcutKey("CtrlOrCmd+Enter")
                    ]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.curvedArrow"),
                    shortcuts: [
                      "A",
                      t("helpDialog.click"),
                      t("helpDialog.click"),
                      t("helpDialog.click")
                    ],
                    isOr: false
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.curvedLine"),
                    shortcuts: [
                      "L",
                      t("helpDialog.click"),
                      t("helpDialog.click"),
                      t("helpDialog.click")
                    ],
                    isOr: false
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.cropStart"),
                    shortcuts: [t("helpDialog.doubleClick"), getShortcutKey("Enter")],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.cropFinish"),
                    shortcuts: [getShortcutKey("Enter"), getShortcutKey("Escape")],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ jsx138(Shortcut, { label: t("toolBar.lock"), shortcuts: [KEYS53.Q] }),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.preventBinding"),
                    shortcuts: [getShortcutKey("CtrlOrCmd")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.link"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+K")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("toolBar.convertElementType"),
                    shortcuts: ["Tab", "Shift+Tab"],
                    isOr: true
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxs81(
            ShortcutIsland,
            {
              className: "HelpDialog__island--view",
              caption: t("helpDialog.view"),
              children: [
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.zoomIn"),
                    shortcuts: [getShortcutKey("CtrlOrCmd++")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.zoomOut"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+-")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.resetZoom"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+0")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.zoomToFit"),
                    shortcuts: ["Shift+1"]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.zoomToSelection"),
                    shortcuts: ["Shift+2"]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.movePageUpDown"),
                    shortcuts: ["PgUp/PgDn"]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.movePageLeftRight"),
                    shortcuts: ["Shift+PgUp/PgDn"]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.zenMode"),
                    shortcuts: [getShortcutKey("Alt+Z")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.objectsSnapMode"),
                    shortcuts: [getShortcutKey("Alt+S")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.toggleGrid"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+'")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.viewMode"),
                    shortcuts: [getShortcutKey("Alt+R")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.toggleTheme"),
                    shortcuts: [getShortcutKey("Alt+Shift+D")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("stats.fullTitle"),
                    shortcuts: [getShortcutKey("Alt+/")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("search.title"),
                    shortcuts: [getShortcutFromShortcutName("searchMenu")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("commandPalette.title"),
                    shortcuts: isFirefox3 ? [getShortcutFromShortcutName("commandPalette")] : [
                      getShortcutFromShortcutName("commandPalette"),
                      getShortcutFromShortcutName("commandPalette", 1)
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxs81(
            ShortcutIsland,
            {
              className: "HelpDialog__island--editor",
              caption: t("helpDialog.editor"),
              children: [
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.createFlowchart"),
                    shortcuts: [getShortcutKey(`CtrlOrCmd+Arrow Key`)],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.navigateFlowchart"),
                    shortcuts: [getShortcutKey(`Alt+Arrow Key`)],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.moveCanvas"),
                    shortcuts: [
                      getShortcutKey(`Space+${t("helpDialog.drag")}`),
                      getShortcutKey(`Wheel+${t("helpDialog.drag")}`)
                    ],
                    isOr: true
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.clearReset"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Delete")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.delete"),
                    shortcuts: [getShortcutKey("Delete")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.cut"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+X")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.copy"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+C")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.paste"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+V")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.pasteAsPlaintext"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+V")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.selectAll"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+A")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.multiSelect"),
                    shortcuts: [getShortcutKey(`Shift+${t("helpDialog.click")}`)]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.deepSelect"),
                    shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.click")}`)]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.deepBoxSelect"),
                    shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.drag")}`)]
                  }
                ),
                (probablySupportsClipboardBlob || isFirefox3) && /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.copyAsPng"),
                    shortcuts: [getShortcutKey("Shift+Alt+C")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.copyStyles"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Alt+C")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.pasteStyles"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Alt+V")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.sendToBack"),
                    shortcuts: [
                      isDarwin4 ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
                    ]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.bringToFront"),
                    shortcuts: [
                      isDarwin4 ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
                    ]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.sendBackward"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+[")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.bringForward"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+]")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.alignTop"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Up")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.alignBottom"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Down")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.alignLeft"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Left")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.alignRight"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Right")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.duplicateSelection"),
                    shortcuts: [
                      getShortcutKey("CtrlOrCmd+D"),
                      getShortcutKey(`Alt+${t("helpDialog.drag")}`)
                    ]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("helpDialog.toggleElementLock"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+L")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.undo"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Z")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("buttons.redo"),
                    shortcuts: isWindows2 ? [
                      getShortcutKey("CtrlOrCmd+Y"),
                      getShortcutKey("CtrlOrCmd+Shift+Z")
                    ] : [getShortcutKey("CtrlOrCmd+Shift+Z")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.group"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+G")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.ungroup"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+G")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.flipHorizontal"),
                    shortcuts: [getShortcutKey("Shift+H")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.flipVertical"),
                    shortcuts: [getShortcutKey("Shift+V")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.showStroke"),
                    shortcuts: [getShortcutKey("S")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.showBackground"),
                    shortcuts: [getShortcutKey("G")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.showFonts"),
                    shortcuts: [getShortcutKey("Shift+F")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.decreaseFontSize"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+<")]
                  }
                ),
                /* @__PURE__ */ jsx138(
                  Shortcut,
                  {
                    label: t("labels.increaseFontSize"),
                    shortcuts: [getShortcutKey("CtrlOrCmd+Shift+>")]
                  }
                )
              ]
            }
          )
        ] })
      ]
    }
  ) });
};

// components/ImageExportDialog.tsx
import { useEffect as useEffect42, useRef as useRef39, useState as useState41 } from "react";
import {
  DEFAULT_EXPORT_PADDING as DEFAULT_EXPORT_PADDING4,
  EXPORT_IMAGE_TYPES,
  isFirefox as isFirefox4,
  EXPORT_SCALES as EXPORT_SCALES2,
  cloneJSON as cloneJSON3
} from "@excalidraw/common";

// hooks/useCopiedIndicator.ts
import { useCallback as useCallback20, useRef as useRef38, useState as useState40 } from "react";
var TIMEOUT = 2e3;
var useCopyStatus = () => {
  const [copyStatus, setCopyStatus] = useState40(null);
  const timeoutRef = useRef38(0);
  const onCopy = () => {
    clearTimeout(timeoutRef.current);
    setCopyStatus("success");
    timeoutRef.current = window.setTimeout(() => {
      setCopyStatus(null);
    }, TIMEOUT);
  };
  const resetCopyStatus = useCallback20(() => {
    setCopyStatus(null);
  }, []);
  return {
    copyStatus,
    resetCopyStatus,
    onCopy
  };
};

// components/Switch.tsx
import clsx59 from "clsx";
import { jsx as jsx139 } from "react/jsx-runtime";
var Switch = ({
  title,
  name,
  checked,
  onChange,
  disabled = false
}) => {
  return /* @__PURE__ */ jsx139("div", { className: clsx59("Switch", { toggled: checked, disabled }), children: /* @__PURE__ */ jsx139(
    "input",
    {
      name,
      id: name,
      title,
      type: "checkbox",
      checked,
      disabled,
      onChange: () => onChange(!checked),
      onKeyDown: (event) => {
        if (event.key === " ") {
          onChange(!checked);
        }
      }
    }
  ) });
};

// components/ImageExportDialog.tsx
import { jsx as jsx140, jsxs as jsxs82 } from "react/jsx-runtime";
var ErrorCanvasPreview = () => {
  return /* @__PURE__ */ jsxs82("div", { children: [
    /* @__PURE__ */ jsx140("h3", { children: t("canvasError.cannotShowPreview") }),
    /* @__PURE__ */ jsx140("p", { children: /* @__PURE__ */ jsx140("span", { children: t("canvasError.canvasTooBig") }) }),
    /* @__PURE__ */ jsxs82("em", { children: [
      "(",
      t("canvasError.canvasTooBigTip"),
      ")"
    ] })
  ] });
};
var ImageExportModal = ({
  appStateSnapshot,
  elementsSnapshot,
  files,
  actionManager,
  onExportImage,
  name
}) => {
  const hasSelection = isSomeElementSelected(
    elementsSnapshot,
    appStateSnapshot
  );
  const [projectName, setProjectName] = useState41(name);
  const [exportSelectionOnly, setExportSelectionOnly] = useState41(hasSelection);
  const [exportWithBackground, setExportWithBackground] = useState41(
    appStateSnapshot.exportBackground
  );
  const [exportDarkMode, setExportDarkMode] = useState41(
    appStateSnapshot.exportWithDarkMode
  );
  const [embedScene, setEmbedScene] = useState41(
    appStateSnapshot.exportEmbedScene
  );
  const [exportScale, setExportScale] = useState41(appStateSnapshot.exportScale);
  const previewRef = useRef39(null);
  const [renderError, setRenderError] = useState41(null);
  const { onCopy, copyStatus, resetCopyStatus } = useCopyStatus();
  useEffect42(() => {
    resetCopyStatus();
  }, [
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene,
    resetCopyStatus
  ]);
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elementsSnapshot,
    appStateSnapshot,
    exportSelectionOnly
  );
  useEffect42(() => {
    const previewNode = previewRef.current;
    if (!previewNode) {
      return;
    }
    const maxWidth = previewNode.offsetWidth;
    const maxHeight = previewNode.offsetHeight;
    if (!maxWidth) {
      return;
    }
    exportToCanvas2({
      elements: exportedElements,
      appState: {
        ...appStateSnapshot,
        name: projectName,
        exportBackground: exportWithBackground,
        exportWithDarkMode: exportDarkMode,
        exportScale,
        exportEmbedScene: embedScene
      },
      files,
      exportPadding: DEFAULT_EXPORT_PADDING4,
      maxWidthOrHeight: Math.max(maxWidth, maxHeight),
      exportingFrame
    }).then((canvas) => {
      setRenderError(null);
      return canvasToBlob(canvas).then(() => {
        previewNode.replaceChildren(canvas);
      }).catch((e) => {
        if (e.name === "CANVAS_POSSIBLY_TOO_BIG") {
          throw new Error(t("canvasError.canvasTooBig"));
        }
        throw e;
      });
    }).catch((error) => {
      console.error(error);
      setRenderError(error);
    });
  }, [
    appStateSnapshot,
    files,
    exportedElements,
    exportingFrame,
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene
  ]);
  return /* @__PURE__ */ jsxs82("div", { className: "ImageExportModal", children: [
    /* @__PURE__ */ jsx140("h3", { children: t("imageExportDialog.header") }),
    /* @__PURE__ */ jsxs82("div", { className: "ImageExportModal__preview", children: [
      /* @__PURE__ */ jsx140("div", { className: "ImageExportModal__preview__canvas", ref: previewRef, children: renderError && /* @__PURE__ */ jsx140(ErrorCanvasPreview, {}) }),
      /* @__PURE__ */ jsx140("div", { className: "ImageExportModal__preview__filename", children: !nativeFileSystemSupported && /* @__PURE__ */ jsx140(
        "input",
        {
          type: "text",
          className: "TextInput",
          value: projectName,
          style: { width: "30ch" },
          onChange: (event) => {
            setProjectName(event.target.value);
            actionManager.executeAction(
              actionChangeProjectName,
              "ui",
              event.target.value
            );
          }
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxs82("div", { className: "ImageExportModal__settings", children: [
      /* @__PURE__ */ jsx140("h3", { children: t("imageExportDialog.header") }),
      hasSelection && /* @__PURE__ */ jsx140(
        ExportSetting,
        {
          label: t("imageExportDialog.label.onlySelected"),
          name: "exportOnlySelected",
          children: /* @__PURE__ */ jsx140(
            Switch,
            {
              name: "exportOnlySelected",
              checked: exportSelectionOnly,
              onChange: (checked) => {
                setExportSelectionOnly(checked);
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx140(
        ExportSetting,
        {
          label: t("imageExportDialog.label.withBackground"),
          name: "exportBackgroundSwitch",
          children: /* @__PURE__ */ jsx140(
            Switch,
            {
              name: "exportBackgroundSwitch",
              checked: exportWithBackground,
              onChange: (checked) => {
                setExportWithBackground(checked);
                actionManager.executeAction(
                  actionChangeExportBackground,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx140(
        ExportSetting,
        {
          label: t("imageExportDialog.label.darkMode"),
          name: "exportDarkModeSwitch",
          children: /* @__PURE__ */ jsx140(
            Switch,
            {
              name: "exportDarkModeSwitch",
              checked: exportDarkMode,
              onChange: (checked) => {
                setExportDarkMode(checked);
                actionManager.executeAction(
                  actionExportWithDarkMode,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx140(
        ExportSetting,
        {
          label: t("imageExportDialog.label.embedScene"),
          tooltip: t("imageExportDialog.tooltip.embedScene"),
          name: "exportEmbedSwitch",
          children: /* @__PURE__ */ jsx140(
            Switch,
            {
              name: "exportEmbedSwitch",
              checked: embedScene,
              onChange: (checked) => {
                setEmbedScene(checked);
                actionManager.executeAction(
                  actionChangeExportEmbedScene,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx140(
        ExportSetting,
        {
          label: t("imageExportDialog.label.scale"),
          name: "exportScale",
          children: /* @__PURE__ */ jsx140(
            RadioGroup,
            {
              name: "exportScale",
              value: exportScale,
              onChange: (scale) => {
                setExportScale(scale);
                actionManager.executeAction(actionChangeExportScale, "ui", scale);
              },
              choices: EXPORT_SCALES2.map((scale) => ({
                value: scale,
                label: `${scale}\xD7`
              }))
            }
          )
        }
      ),
      /* @__PURE__ */ jsxs82("div", { className: "ImageExportModal__settings__buttons", children: [
        /* @__PURE__ */ jsx140(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToPng"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToPng")
          }
        ),
        /* @__PURE__ */ jsx140(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToSvg"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToSvg")
          }
        ),
        (probablySupportsClipboardBlob || isFirefox4) && /* @__PURE__ */ jsx140(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.copyPngToClipboard"),
            status: copyStatus,
            onClick: async () => {
              await onExportImage(
                EXPORT_IMAGE_TYPES.clipboard,
                exportedElements,
                {
                  exportingFrame
                }
              );
              onCopy();
            },
            icon: copyIcon,
            children: t("imageExportDialog.button.copyPngToClipboard")
          }
        )
      ] })
    ] })
  ] });
};
var ExportSetting = ({
  label,
  children,
  tooltip,
  name
}) => {
  return /* @__PURE__ */ jsxs82("div", { className: "ImageExportModal__settings__setting", title: label, children: [
    /* @__PURE__ */ jsxs82(
      "label",
      {
        htmlFor: name,
        className: "ImageExportModal__settings__setting__label",
        children: [
          label,
          tooltip && /* @__PURE__ */ jsx140(Tooltip, { label: tooltip, long: true, children: helpIcon })
        ]
      }
    ),
    /* @__PURE__ */ jsx140("div", { className: "ImageExportModal__settings__setting__content", children })
  ] });
};
var ImageExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  onExportImage,
  onCloseRequest,
  name
}) => {
  const [{ appStateSnapshot, elementsSnapshot }] = useState41(() => {
    return {
      appStateSnapshot: cloneJSON3(appState),
      elementsSnapshot: cloneJSON3(elements)
    };
  });
  return /* @__PURE__ */ jsx140(Dialog, { onCloseRequest, size: "wide", title: false, children: /* @__PURE__ */ jsx140(
    ImageExportModal,
    {
      elementsSnapshot,
      appStateSnapshot,
      files,
      actionManager,
      onExportImage,
      name
    }
  ) });
};

// components/JSONExportDialog.tsx
import React43 from "react";
import { getFrame } from "@excalidraw/common";

// components/Card.tsx
import { jsx as jsx141 } from "react/jsx-runtime";
var COLOR_MAP = {
  primary: {
    base: "var(--color-primary)",
    darker: "var(--color-primary-darker)",
    darkest: "var(--color-primary-darkest)"
  },
  lime: {
    base: "#74b816",
    // open-color lime[7]
    darker: "#66a80f",
    // open-color lime[8]
    darkest: "#5c940d"
    // open-color lime[9]
  },
  pink: {
    base: "#d6336c",
    // open-color pink[7]
    darker: "#c2255c",
    // open-color pink[8]
    darkest: "#a61e4d"
    // open-color pink[9]
  }
};
var Card = ({ children, color }) => {
  return /* @__PURE__ */ jsx141(
    "div",
    {
      className: "Card",
      style: {
        ["--card-color"]: COLOR_MAP[color].base,
        ["--card-color-darker"]: COLOR_MAP[color].darker,
        ["--card-color-darkest"]: COLOR_MAP[color].darkest
      },
      children
    }
  );
};

// components/JSONExportDialog.tsx
import { Fragment as Fragment25, jsx as jsx142, jsxs as jsxs83 } from "react/jsx-runtime";
var JSONExportModal = ({
  elements,
  appState,
  setAppState,
  files,
  actionManager,
  exportOpts,
  canvas,
  onCloseRequest
}) => {
  const { onExportToBackend } = exportOpts;
  return /* @__PURE__ */ jsx142("div", { className: "ExportDialog ExportDialog--json", children: /* @__PURE__ */ jsxs83("div", { className: "ExportDialog-cards", children: [
    exportOpts.saveFileToDisk && /* @__PURE__ */ jsxs83(Card, { color: "lime", children: [
      /* @__PURE__ */ jsx142("div", { className: "Card-icon", children: exportToFileIcon }),
      /* @__PURE__ */ jsx142("h2", { children: t("exportDialog.disk_title") }),
      /* @__PURE__ */ jsxs83("div", { className: "Card-details", children: [
        t("exportDialog.disk_details"),
        !nativeFileSystemSupported && actionManager.renderAction("changeProjectName")
      ] }),
      /* @__PURE__ */ jsx142(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.disk_button"),
          "aria-label": t("exportDialog.disk_button"),
          showAriaLabel: true,
          onClick: () => {
            actionManager.executeAction(actionSaveFileToDisk, "ui");
          }
        }
      )
    ] }),
    onExportToBackend && /* @__PURE__ */ jsxs83(Card, { color: "pink", children: [
      /* @__PURE__ */ jsx142("div", { className: "Card-icon", children: LinkIcon }),
      /* @__PURE__ */ jsx142("h2", { children: t("exportDialog.link_title") }),
      /* @__PURE__ */ jsx142("div", { className: "Card-details", children: t("exportDialog.link_details") }),
      /* @__PURE__ */ jsx142(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.link_button"),
          "aria-label": t("exportDialog.link_button"),
          showAriaLabel: true,
          onClick: async () => {
            try {
              trackEvent("export", "link", `ui (${getFrame()})`);
              await onExportToBackend(elements, appState, files);
              onCloseRequest();
            } catch (error) {
              setAppState({ errorMessage: error.message });
            }
          }
        }
      )
    ] }),
    exportOpts.renderCustomUI && exportOpts.renderCustomUI(elements, appState, files, canvas)
  ] }) });
};
var JSONExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  exportOpts,
  canvas,
  setAppState
}) => {
  const handleClose = React43.useCallback(() => {
    setAppState({ openDialog: null });
  }, [setAppState]);
  return /* @__PURE__ */ jsx142(Fragment25, { children: appState.openDialog?.name === "jsonExport" && /* @__PURE__ */ jsx142(Dialog, { onCloseRequest: handleClose, title: t("buttons.export"), children: /* @__PURE__ */ jsx142(
    JSONExportModal,
    {
      elements,
      appState,
      setAppState,
      files,
      actionManager,
      onCloseRequest: handleClose,
      exportOpts,
      canvas
    }
  ) }) });
};

// components/LayerUI.tsx
import { Fragment as Fragment26, jsx as jsx143, jsxs as jsxs84 } from "react/jsx-runtime";
var DefaultMainMenu = ({ UIOptions }) => {
  return /* @__PURE__ */ jsxs84(MainMenu_default, { __fallback: true, children: [
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.LoadScene, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.SaveToActiveFile, {}),
    UIOptions.canvasActions.export && /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.Export, {}),
    UIOptions.canvasActions.saveAsImage && /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.SaveAsImage, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.SearchMenu, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.Help, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.ClearCanvas, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.Separator, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.Group, { title: "Excalidraw links", children: /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.Socials, {}) }),
    /* @__PURE__ */ jsx143(MainMenu_default.Separator, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.ToggleTheme, {}),
    /* @__PURE__ */ jsx143(MainMenu_default.DefaultItems.ChangeCanvasBackground, {})
  ] });
};
var DefaultOverwriteConfirmDialog = () => {
  return /* @__PURE__ */ jsxs84(OverwriteConfirmDialog, { __fallback: true, children: [
    /* @__PURE__ */ jsx143(OverwriteConfirmDialog.Actions.SaveToDisk, {}),
    /* @__PURE__ */ jsx143(OverwriteConfirmDialog.Actions.ExportToImage, {})
  ] });
};
var LayerUI = ({
  actionManager,
  appState,
  files,
  setAppState,
  elements,
  canvas,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  showExitZenModeBtn,
  renderTopLeftUI,
  renderTopRightUI,
  renderCustomStats,
  UIOptions,
  onExportImage,
  renderWelcomeScreen,
  children,
  app,
  isCollaborating,
  generateLinkForSelection
}) => {
  const editorInterface = useEditorInterface();
  const stylesPanelMode = useStylesPanelMode();
  const isCompactStylesPanel = stylesPanelMode === "compact";
  const tunnels = useInitializeTunnels();
  const spacing = isCompactStylesPanel ? {
    menuTopGap: 4,
    toolbarColGap: 4,
    toolbarRowGap: 1,
    toolbarInnerRowGap: 0.5,
    islandPadding: 1,
    collabMarginLeft: 8
  } : {
    menuTopGap: 6,
    toolbarColGap: 4,
    toolbarRowGap: 1,
    toolbarInnerRowGap: 1,
    islandPadding: 1,
    collabMarginLeft: 8
  };
  const TunnelsJotaiProvider = tunnels.tunnelsJotai.Provider;
  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);
  const renderJSONExportDialog = () => {
    if (!UIOptions.canvasActions.export) {
      return null;
    }
    return /* @__PURE__ */ jsx143(
      JSONExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        exportOpts: UIOptions.canvasActions.export,
        canvas,
        setAppState
      }
    );
  };
  const renderImageExportDialog = () => {
    if (!UIOptions.canvasActions.saveAsImage || appState.openDialog?.name !== "imageExport") {
      return null;
    }
    return /* @__PURE__ */ jsx143(
      ImageExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        onExportImage,
        onCloseRequest: () => setAppState({ openDialog: null }),
        name: app.getName()
      }
    );
  };
  const renderCanvasActions = () => /* @__PURE__ */ jsxs84("div", { style: { position: "relative" }, children: [
    /* @__PURE__ */ jsx143(tunnels.MainMenuTunnel.Out, {}),
    renderWelcomeScreen && /* @__PURE__ */ jsx143(tunnels.WelcomeScreenMenuHintTunnel.Out, {})
  ] });
  const renderSelectedShapeActions = () => {
    const isCompactMode = isCompactStylesPanel;
    return /* @__PURE__ */ jsx143(
      Section,
      {
        heading: "selectedShapeActions",
        className: clsx60("selected-shape-actions zen-mode-transition", {
          "transition-left": appState.zenModeEnabled
        }),
        children: isCompactMode ? /* @__PURE__ */ jsx143(
          Island,
          {
            className: clsx60("compact-shape-actions-island"),
            padding: 0,
            style: {
              // we want to make sure this doesn't overflow so subtracting the
              // approximate height of hamburgerMenu + footer
              maxHeight: `${appState.height - 166}px`,
              marginLeft: -12
            },
            children: /* @__PURE__ */ jsx143(
              CompactShapeActions,
              {
                appState,
                elementsMap: app.scene.getNonDeletedElementsMap(),
                renderAction: actionManager.renderAction,
                app,
                setAppState
              }
            )
          }
        ) : /* @__PURE__ */ jsx143(
          Island,
          {
            className: CLASSES10.SHAPE_ACTIONS_MENU,
            padding: 2,
            style: {
              // we want to make sure this doesn't overflow so subtracting the
              // approximate height of hamburgerMenu + footer
              maxHeight: `${appState.height - 166}px`
            },
            children: /* @__PURE__ */ jsx143(
              SelectedShapeActions,
              {
                appState,
                elementsMap: app.scene.getNonDeletedElementsMap(),
                renderAction: actionManager.renderAction,
                app
              }
            )
          }
        )
      }
    );
  };
  const renderFixedSideContainer = () => {
    const shouldRenderSelectedShapeActions = showSelectedShapeActions(
      appState,
      elements
    );
    const shouldShowStats = appState.stats.open && !appState.zenModeEnabled && !appState.viewModeEnabled && appState.openDialog?.name !== "elementLinkSelector";
    return /* @__PURE__ */ jsx143(FixedSideContainer, { side: "top", children: /* @__PURE__ */ jsxs84("div", { className: "App-menu App-menu_top", children: [
      /* @__PURE__ */ jsx143(
        "div",
        {
          className: clsx60(
            "layer-ui__wrapper__top-right zen-mode-transition",
            {
              "transition-right": appState.zenModeEnabled,
              "layer-ui__wrapper__top-right--compact": isCompactStylesPanel
            }
          )
        }
      ),
      /* @__PURE__ */ jsxs84(
        Stack_default.Col,
        {
          gap: spacing.menuTopGap,
          className: clsx60("App-menu_top__right"),
          style: {
            width: "36px"
          },
          children: [
            renderCanvasActions(),
            /* @__PURE__ */ jsx143(
              "div",
              {
                className: clsx60("selected-shape-actions-container", {
                  "selected-shape-actions-container--compact": isCompactStylesPanel
                }),
                children: shouldRenderSelectedShapeActions && renderSelectedShapeActions()
              }
            )
          ]
        }
      )
    ] }) });
  };
  const renderSidebars = () => {
    return /* @__PURE__ */ jsx143(
      DefaultSidebar,
      {
        __fallback: true,
        onDock: (docked) => {
          trackEvent(
            "sidebar",
            `toggleDock (${docked ? "dock" : "undock"})`,
            `(${editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
          );
        }
      }
    );
  };
  const isSidebarDocked = useAtomValue(isSidebarDockedAtom);
  const layerUIJSX = /* @__PURE__ */ jsxs84(Fragment26, { children: [
    children,
    /* @__PURE__ */ jsx143(DefaultMainMenu, { UIOptions }),
    /* @__PURE__ */ jsx143(
      DefaultSidebar.Trigger,
      {
        __fallback: true,
        icon: sidebarRightIcon,
        title: capitalizeString6(t("toolBar.library")),
        onToggle: (open) => {
          if (open) {
            trackEvent(
              "sidebar",
              `${DEFAULT_SIDEBAR6.name} (open)`,
              `button (${editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
            );
          }
        },
        tab: DEFAULT_SIDEBAR6.defaultTab
      }
    ),
    /* @__PURE__ */ jsx143(DefaultOverwriteConfirmDialog, {}),
    appState.openDialog?.name === "ttd" && /* @__PURE__ */ jsx143(TTDDialog, { __fallback: true }),
    appState.isLoading && /* @__PURE__ */ jsx143(LoadingMessage, { delay: 250 }),
    appState.errorMessage && /* @__PURE__ */ jsx143(ErrorDialog, { onClose: () => setAppState({ errorMessage: null }), children: appState.errorMessage }),
    eyeDropperState && editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsx143(
      EyeDropper,
      {
        colorPickerType: eyeDropperState.colorPickerType,
        onCancel: () => {
          setEyeDropperState(null);
        },
        onChange: (colorPickerType, color, selectedElements, { altKey }) => {
          if (colorPickerType !== "elementBackground" && colorPickerType !== "elementStroke") {
            return;
          }
          if (selectedElements.length) {
            for (const element of selectedElements) {
              mutateElement5(element, arrayToMap24(elements), {
                [altKey && eyeDropperState.swapPreviewOnAlt ? colorPickerType === "elementBackground" ? "strokeColor" : "backgroundColor" : colorPickerType === "elementBackground" ? "backgroundColor" : "strokeColor"]: color
              });
              ShapeCache3.delete(element);
            }
            app.scene.triggerUpdate();
          } else if (colorPickerType === "elementBackground") {
            setAppState({
              currentItemBackgroundColor: color
            });
          } else {
            setAppState({ currentItemStrokeColor: color });
          }
        },
        onSelect: (color, event) => {
          setEyeDropperState((state) => {
            return state?.keepOpenOnAlt && event.altKey ? state : null;
          });
          eyeDropperState?.onSelect?.(color, event);
        }
      }
    ),
    appState.openDialog?.name === "help" && /* @__PURE__ */ jsx143(
      HelpDialog,
      {
        onClose: () => {
          setAppState({ openDialog: null });
        }
      }
    ),
    /* @__PURE__ */ jsx143(ActiveConfirmDialog, {}),
    appState.openDialog?.name === "elementLinkSelector" && /* @__PURE__ */ jsx143(
      ElementLinkDialog_default,
      {
        sourceElementId: appState.openDialog.sourceElementId,
        onClose: () => {
          setAppState({
            openDialog: null
          });
        },
        scene: app.scene,
        appState,
        generateLinkForSelection
      }
    ),
    /* @__PURE__ */ jsx143(tunnels.OverwriteConfirmDialogTunnel.Out, {}),
    renderImageExportDialog(),
    renderJSONExportDialog(),
    appState.pasteDialog.shown && /* @__PURE__ */ jsx143(
      PasteChartDialog,
      {
        setAppState,
        appState,
        onClose: () => setAppState({
          pasteDialog: { shown: false, data: null }
        })
      }
    ),
    editorInterface.formFactor === "phone" && /* @__PURE__ */ jsx143(
      MobileMenu,
      {
        app,
        appState,
        elements,
        actionManager,
        renderJSONExportDialog,
        renderImageExportDialog,
        setAppState,
        onHandToolToggle,
        onPenModeToggle,
        renderTopLeftUI,
        renderTopRightUI,
        renderSidebars,
        renderWelcomeScreen,
        UIOptions
      }
    ),
    editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsxs84(Fragment26, { children: [
      /* @__PURE__ */ jsxs84(
        "div",
        {
          className: "layer-ui__wrapper",
          style: appState.openSidebar && isSidebarDocked && editorInterface.canFitSidebar ? { width: `calc(100% - var(--right-sidebar-width))` } : {},
          children: [
            renderWelcomeScreen && /* @__PURE__ */ jsx143(tunnels.WelcomeScreenCenterTunnel.Out, {}),
            renderFixedSideContainer(),
            /* @__PURE__ */ jsx143(
              Footer_default,
              {
                appState,
                actionManager,
                showExitZenModeBtn,
                renderWelcomeScreen,
                setAppState,
                onLockToggle,
                onHandToolToggle,
                onPenModeToggle,
                UIOptions,
                app,
                isCollaborating,
                editorInterface,
                spacing,
                isCompactStylesPanel
              }
            ),
            appState.scrolledOutside && /* @__PURE__ */ jsx143(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ]
        }
      ),
      renderSidebars()
    ] })
  ] });
  return /* @__PURE__ */ jsx143(UIAppStateContext.Provider, { value: appState, children: /* @__PURE__ */ jsx143(TunnelsJotaiProvider, { children: /* @__PURE__ */ jsx143(TunnelsContext.Provider, { value: tunnels, children: layerUIJSX }) }) });
};
var stripIrrelevantAppStateProps = (appState) => {
  const { startBoundElement, cursorButton, scrollX, scrollY, ...ret } = appState;
  return ret;
};
var areEqual2 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;
  const { canvas: _nC, appState: nextAppState, ...next } = nextProps;
  return isShallowEqual6(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the UI-relevant props
    stripIrrelevantAppStateProps(prevAppState),
    stripIrrelevantAppStateProps(nextAppState),
    {
      selectedElementIds: isShallowEqual6,
      selectedGroupIds: isShallowEqual6
    }
  ) && isShallowEqual6(prev, next);
};
var LayerUI_default = React44.memo(LayerUI, areEqual2);

// components/MagicButton.tsx
import clsx61 from "clsx";
import { jsx as jsx144, jsxs as jsxs85 } from "react/jsx-runtime";
var DEFAULT_SIZE3 = "small";
var ElementCanvasButton = (props) => {
  return /* @__PURE__ */ jsxs85(
    "label",
    {
      className: clsx61(
        "ToolIcon ToolIcon__MagicButton",
        `ToolIcon_size_${DEFAULT_SIZE3}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx144(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ jsx144("div", { className: "ToolIcon__icon", children: props.icon })
      ]
    }
  );
};

// components/SVGLayer.tsx
import { useEffect as useEffect43, useRef as useRef40 } from "react";
import { jsx as jsx145 } from "react/jsx-runtime";
var SVGLayer = ({ trails }) => {
  const svgRef = useRef40(null);
  useEffect43(() => {
    if (svgRef.current) {
      for (const trail of trails) {
        trail.start(svgRef.current);
      }
    }
    return () => {
      for (const trail of trails) {
        trail.stop();
      }
    };
  }, trails);
  return /* @__PURE__ */ jsx145("div", { className: "SVGLayer", children: /* @__PURE__ */ jsx145("svg", { ref: svgRef }) });
};

// components/canvases/InteractiveCanvas.tsx
import React45, { useEffect as useEffect44, useRef as useRef41 } from "react";
import {
  COLOR_PALETTE as COLOR_PALETTE7,
  CURSOR_TYPE as CURSOR_TYPE3,
  isShallowEqual as isShallowEqual7,
  sceneCoordsToViewportCoords as sceneCoordsToViewportCoords6
} from "@excalidraw/common";

// renderer/animation.ts
var _AnimationController = class _AnimationController {
  static start(key, animation) {
    const initialState = animation({
      deltaTime: 0,
      state: void 0
    });
    if (initialState) {
      _AnimationController.animations.set(key, {
        animation,
        lastTime: 0,
        state: initialState
      });
      if (!_AnimationController.isRunning) {
        _AnimationController.isRunning = true;
        if (isRenderThrottlingEnabled()) {
          requestAnimationFrame(_AnimationController.tick);
        } else {
          setTimeout(_AnimationController.tick, 0);
        }
      }
    }
  }
  static tick() {
    if (_AnimationController.animations.size > 0) {
      for (const [key, animation] of _AnimationController.animations) {
        const now = performance.now();
        const deltaTime = animation.lastTime === 0 ? 0 : now - animation.lastTime;
        const state = animation.animation({
          deltaTime,
          state: animation.state
        });
        if (!state) {
          _AnimationController.animations.delete(key);
          if (_AnimationController.animations.size === 0) {
            _AnimationController.isRunning = false;
            return;
          }
        } else {
          animation.lastTime = now;
          animation.state = state;
        }
      }
      if (isRenderThrottlingEnabled()) {
        requestAnimationFrame(_AnimationController.tick);
      } else {
        setTimeout(_AnimationController.tick, 0);
      }
    }
  }
  static running(key) {
    return _AnimationController.animations.has(key);
  }
  static cancel(key) {
    _AnimationController.animations.delete(key);
  }
};
__publicField(_AnimationController, "isRunning", false);
__publicField(_AnimationController, "animations", /* @__PURE__ */ new Map());
var AnimationController = _AnimationController;

// renderer/interactiveScene.ts
import {
  clamp as clamp5,
  pointFrom as pointFrom25,
  pointsEqual as pointsEqual8,
  bezierEquation as bezierEquation2,
  pointRotateRads as pointRotateRads17
} from "@excalidraw/math";
import {
  applyDarkModeFilter as applyDarkModeFilter4,
  arrayToMap as arrayToMap25,
  BIND_MODE_TIMEOUT,
  DEFAULT_TRANSFORM_HANDLE_SPACING,
  FRAME_STYLE as FRAME_STYLE4,
  getFeatureFlag as getFeatureFlag3,
  invariant as invariant15,
  THEME as THEME17
} from "@excalidraw/common";
import {
  deconstructDiamondElement as deconstructDiamondElement2,
  deconstructRectanguloidElement as deconstructRectanguloidElement2,
  elementCenterPoint as elementCenterPoint2,
  getDiamondBaseCorners,
  FOCUS_POINT_SIZE as FOCUS_POINT_SIZE2,
  getOmitSidesForEditorInterface,
  getTransformHandles,
  getTransformHandlesFromCoords,
  hasBoundingBox,
  hitElementItself as hitElementItself2,
  isArrowElement as isArrowElement11,
  isBindableElement as isBindableElement2,
  isElbowArrow as isElbowArrow8,
  isFrameLikeElement as isFrameLikeElement11,
  isImageElement as isImageElement5,
  isLinearElement as isLinearElement11,
  isLineElement as isLineElement7,
  isTextElement as isTextElement15,
  LinearElementEditor as LinearElementEditor10,
  headingForPoint as headingForPoint2,
  compareHeading as compareHeading2,
  HEADING_RIGHT as HEADING_RIGHT2,
  HEADING_DOWN as HEADING_DOWN2,
  HEADING_LEFT as HEADING_LEFT2,
  HEADING_UP as HEADING_UP2
} from "@excalidraw/element";
import { renderSelectionElement } from "@excalidraw/element";
import {
  getElementsInGroup as getElementsInGroup6,
  getSelectedGroupIds as getSelectedGroupIds2,
  isSelectedViaGroup,
  selectGroupsFromGivenElements as selectGroupsFromGivenElements3
} from "@excalidraw/element";
import { getCommonBounds as getCommonBounds6, getElementAbsoluteCoords as getElementAbsoluteCoords8 } from "@excalidraw/element";
import {
  getGlobalFixedPointForBindableElement as getGlobalFixedPointForBindableElement2,
  isFocusPointVisible
} from "@excalidraw/element";

// renderer/renderSnaps.ts
import { pointFrom as pointFrom24 } from "@excalidraw/math";
import { THEME as THEME16 } from "@excalidraw/common";
var SNAP_COLOR_LIGHT = "#ff6b6b";
var SNAP_COLOR_DARK = "#ff0000";
var SNAP_WIDTH = 1;
var SNAP_CROSS_SIZE = 2;
var renderSnaps = (context, appState) => {
  if (!appState.snapLines.length) {
    return;
  }
  const snapColor = appState.theme === THEME16.LIGHT || appState.zenModeEnabled ? SNAP_COLOR_LIGHT : SNAP_COLOR_DARK;
  const snapWidth = (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  for (const snapLine of appState.snapLines) {
    if (snapLine.type === "pointer") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointerSnapLine(snapLine, context, appState);
    } else if (snapLine.type === "gap") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawGapLine(
        snapLine.points[0],
        snapLine.points[1],
        snapLine.direction,
        appState,
        context
      );
    } else if (snapLine.type === "points") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointsSnapLine(snapLine, context, appState);
    }
  }
  context.restore();
};
var drawPointsSnapLine = (pointSnapLine, context, appState) => {
  if (!appState.zenModeEnabled) {
    const firstPoint = pointSnapLine.points[0];
    const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];
    drawLine(firstPoint, lastPoint, context);
  }
  for (const point of pointSnapLine.points) {
    drawCross(point, appState, context);
  }
};
var drawPointerSnapLine = (pointerSnapLine, context, appState) => {
  drawCross(pointerSnapLine.points[0], appState, context);
  if (!appState.zenModeEnabled) {
    drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);
  }
};
var drawCross = ([x, y], appState, context) => {
  context.save();
  const size = (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) / appState.zoom.value;
  context.beginPath();
  context.moveTo(x - size, y - size);
  context.lineTo(x + size, y + size);
  context.moveTo(x + size, y - size);
  context.lineTo(x - size, y + size);
  context.stroke();
  context.restore();
};
var drawLine = (from, to, context) => {
  context.beginPath();
  context.lineTo(from[0], from[1]);
  context.lineTo(to[0], to[1]);
  context.stroke();
};
var drawGapLine = (from, to, direction, appState, context) => {
  const FULL = 8 / appState.zoom.value;
  const HALF = FULL / 2;
  const QUARTER = FULL / 4;
  if (direction === "horizontal") {
    const halfPoint = [(from[0] + to[0]) / 2, from[1]];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom24(from[0], from[1] - FULL),
        pointFrom24(from[0], from[1] + FULL),
        context
      );
    }
    drawLine(
      pointFrom24(halfPoint[0] - QUARTER, halfPoint[1] - HALF),
      pointFrom24(halfPoint[0] - QUARTER, halfPoint[1] + HALF),
      context
    );
    drawLine(
      pointFrom24(halfPoint[0] + QUARTER, halfPoint[1] - HALF),
      pointFrom24(halfPoint[0] + QUARTER, halfPoint[1] + HALF),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom24(to[0], to[1] - FULL),
        pointFrom24(to[0], to[1] + FULL),
        context
      );
      drawLine(from, to, context);
    }
  } else {
    const halfPoint = [from[0], (from[1] + to[1]) / 2];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom24(from[0] - FULL, from[1]),
        pointFrom24(from[0] + FULL, from[1]),
        context
      );
    }
    drawLine(
      pointFrom24(halfPoint[0] - HALF, halfPoint[1] - QUARTER),
      pointFrom24(halfPoint[0] + HALF, halfPoint[1] - QUARTER),
      context
    );
    drawLine(
      pointFrom24(halfPoint[0] - HALF, halfPoint[1] + QUARTER),
      pointFrom24(halfPoint[0] + HALF, halfPoint[1] + QUARTER),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom24(to[0] - FULL, to[1]),
        pointFrom24(to[0] + FULL, to[1]),
        context
      );
      drawLine(from, to, context);
    }
  }
};

// renderer/interactiveScene.ts
var renderElbowArrowMidPointHighlight = (context, appState) => {
  invariant15(appState.selectedLinearElement, "selectedLinearElement is null");
  const { segmentMidPointHoveredCoords } = appState.selectedLinearElement;
  invariant15(segmentMidPointHoveredCoords, "midPointCoords is null");
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(segmentMidPointHoveredCoords, context, appState);
  context.restore();
};
var renderLinearElementPointHighlight = (context, appState, elementsMap) => {
  const { elementId, hoverPointIndex } = appState.selectedLinearElement;
  if (appState.selectedLinearElement?.isEditing && appState.selectedLinearElement?.selectedPointsIndices?.includes(
    hoverPointIndex
  )) {
    return;
  }
  if (appState.selectedLinearElement?.isDragging) {
    return;
  }
  const element = LinearElementEditor10.getElement(elementId, elementsMap);
  if (!element) {
    return;
  }
  const point = LinearElementEditor10.getPointAtIndexGlobalCoordinates(
    element,
    hoverPointIndex,
    elementsMap
  );
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(point, context, appState);
  context.restore();
};
var highlightPoint = (point, context, appState) => {
  context.fillStyle = "rgba(105, 101, 219, 0.4)";
  fillCircle(
    context,
    point[0],
    point[1],
    LinearElementEditor10.POINT_HANDLE_SIZE / appState.zoom.value,
    false
  );
};
var renderFocusPointHighlight = (context, appState, focusPoint) => {
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(focusPoint, context, appState);
  context.restore();
};
var renderSingleLinearPoint = (context, appState, point, radius, isSelected, isPhantomPoint, isOverlappingPoint) => {
  context.strokeStyle = "#5e5ad8";
  context.setLineDash([]);
  context.fillStyle = "rgba(255, 255, 255, 0.9)";
  if (isSelected) {
    context.fillStyle = "rgba(134, 131, 226, 0.9)";
  } else if (isPhantomPoint) {
    context.fillStyle = "rgba(177, 151, 252, 0.7)";
  }
  fillCircle(
    context,
    point[0],
    point[1],
    (isOverlappingPoint ? radius * (appState.selectedLinearElement?.isEditing ? 1.5 : 2) : radius) / appState.zoom.value,
    !isPhantomPoint,
    !isOverlappingPoint || isSelected
  );
};
var renderBindingHighlightForBindableElement_simple = (context, suggestedBinding, elementsMap, appState, pointerCoords) => {
  const enclosingFrame = suggestedBinding.element.frameId && elementsMap.get(suggestedBinding.element.frameId);
  if (enclosingFrame && isFrameLikeElement11(enclosingFrame)) {
    context.translate(enclosingFrame.x, enclosingFrame.y);
    context.beginPath();
    if (FRAME_STYLE4.radius && context.roundRect) {
      context.roundRect(
        -1,
        -1,
        enclosingFrame.width + 1,
        enclosingFrame.height + 1,
        FRAME_STYLE4.radius / appState.zoom.value
      );
    } else {
      context.rect(-1, -1, enclosingFrame.width + 1, enclosingFrame.height + 1);
    }
    context.clip();
    context.translate(-enclosingFrame.x, -enclosingFrame.y);
  }
  switch (suggestedBinding.element.type) {
    case "magicframe":
    case "frame":
      context.save();
      context.translate(suggestedBinding.element.x, suggestedBinding.element.y);
      context.lineWidth = FRAME_STYLE4.strokeWidth / appState.zoom.value;
      context.strokeStyle = appState.theme === THEME17.DARK ? `rgba(3, 93, 161, 1)` : `rgba(106, 189, 252, 1)`;
      if (FRAME_STYLE4.radius && context.roundRect) {
        context.beginPath();
        context.roundRect(
          0,
          0,
          suggestedBinding.element.width,
          suggestedBinding.element.height,
          FRAME_STYLE4.radius / appState.zoom.value
        );
        context.stroke();
        context.closePath();
      } else {
        context.strokeRect(
          0,
          0,
          suggestedBinding.element.width,
          suggestedBinding.element.height
        );
      }
      context.restore();
      break;
    default:
      context.save();
      const center = elementCenterPoint2(suggestedBinding.element, elementsMap);
      context.translate(center[0], center[1]);
      context.rotate(suggestedBinding.element.angle);
      context.translate(-center[0], -center[1]);
      context.translate(suggestedBinding.element.x, suggestedBinding.element.y);
      context.lineWidth = clamp5(1.75, suggestedBinding.element.strokeWidth, 4) / Math.max(0.25, appState.zoom.value);
      context.strokeStyle = appState.theme === THEME17.DARK ? `rgba(3, 93, 161, 1)` : `rgba(106, 189, 252, 1)`;
      switch (suggestedBinding.element.type) {
        case "ellipse":
          context.beginPath();
          context.ellipse(
            suggestedBinding.element.width / 2,
            suggestedBinding.element.height / 2,
            suggestedBinding.element.width / 2,
            suggestedBinding.element.height / 2,
            0,
            0,
            2 * Math.PI
          );
          context.closePath();
          context.stroke();
          break;
        case "diamond":
          {
            const [segments, curves] = deconstructDiamondElement2(
              suggestedBinding.element
            );
            segments.forEach((segment) => {
              context.beginPath();
              context.moveTo(
                segment[0][0] - suggestedBinding.element.x,
                segment[0][1] - suggestedBinding.element.y
              );
              context.lineTo(
                segment[1][0] - suggestedBinding.element.x,
                segment[1][1] - suggestedBinding.element.y
              );
              context.stroke();
            });
            curves.forEach((curve3) => {
              const [start2, control1, control2, end] = curve3;
              context.beginPath();
              context.moveTo(
                start2[0] - suggestedBinding.element.x,
                start2[1] - suggestedBinding.element.y
              );
              context.bezierCurveTo(
                control1[0] - suggestedBinding.element.x,
                control1[1] - suggestedBinding.element.y,
                control2[0] - suggestedBinding.element.x,
                control2[1] - suggestedBinding.element.y,
                end[0] - suggestedBinding.element.x,
                end[1] - suggestedBinding.element.y
              );
              context.stroke();
            });
          }
          break;
        default:
          {
            const [segments, curves] = deconstructRectanguloidElement2(
              suggestedBinding.element
            );
            segments.forEach((segment) => {
              context.beginPath();
              context.moveTo(
                segment[0][0] - suggestedBinding.element.x,
                segment[0][1] - suggestedBinding.element.y
              );
              context.lineTo(
                segment[1][0] - suggestedBinding.element.x,
                segment[1][1] - suggestedBinding.element.y
              );
              context.stroke();
            });
            curves.forEach((curve3) => {
              const [start2, control1, control2, end] = curve3;
              context.beginPath();
              context.moveTo(
                start2[0] - suggestedBinding.element.x,
                start2[1] - suggestedBinding.element.y
              );
              context.bezierCurveTo(
                control1[0] - suggestedBinding.element.x,
                control1[1] - suggestedBinding.element.y,
                control2[0] - suggestedBinding.element.x,
                control2[1] - suggestedBinding.element.y,
                end[0] - suggestedBinding.element.x,
                end[1] - suggestedBinding.element.y
              );
              context.stroke();
            });
          }
          break;
      }
      context.restore();
      break;
  }
  if (isFrameLikeElement11(suggestedBinding.element) || isBindableElement2(suggestedBinding.element)) {
    const linearElement = appState.selectedLinearElement;
    const arrow = linearElement?.elementId && LinearElementEditor10.getElement(linearElement?.elementId, elementsMap);
    const insideBindable = pointerCoords && arrow && hitElementItself2({
      point: pointerCoords,
      element: suggestedBinding.element,
      elementsMap,
      threshold: 0,
      overrideShouldTestInside: true
    });
    if (!insideBindable || isElbowArrow8(arrow)) {
      context.save();
      context.translate(suggestedBinding.element.x, suggestedBinding.element.y);
      const midpointRadius = 5 / appState.zoom.value;
      const center = elementCenterPoint2(suggestedBinding.element, elementsMap);
      let midpoints;
      if (suggestedBinding.element.type === "diamond") {
        const center2 = elementCenterPoint2(
          suggestedBinding.element,
          elementsMap
        );
        midpoints = getDiamondBaseCorners(suggestedBinding.element).map(
          (curve3) => {
            const point = bezierEquation2(curve3, 0.5);
            const rotatedPoint = pointRotateRads17(
              point,
              center2,
              suggestedBinding.element.angle
            );
            return pointFrom25(
              rotatedPoint[0] - suggestedBinding.element.x,
              rotatedPoint[1] - suggestedBinding.element.y
            );
          }
        );
      } else {
        const basePoints = [
          {
            x: suggestedBinding.element.width,
            y: suggestedBinding.element.height / 2
          },
          // RIGHT
          {
            x: suggestedBinding.element.width / 2,
            y: suggestedBinding.element.height
          },
          // BOTTOM
          { x: 0, y: suggestedBinding.element.height / 2 },
          // LEFT
          { x: suggestedBinding.element.width / 2, y: 0 }
          // TOP
        ];
        midpoints = basePoints.map((point) => {
          const globalPoint = pointFrom25(
            point.x + suggestedBinding.element.x,
            point.y + suggestedBinding.element.y
          );
          const rotatedPoint = pointRotateRads17(
            globalPoint,
            center,
            suggestedBinding.element.angle
          );
          return pointFrom25(
            rotatedPoint[0] - suggestedBinding.element.x,
            rotatedPoint[1] - suggestedBinding.element.y
          );
        });
      }
      const highlightedPoint = suggestedBinding.midPoint && pointFrom25(
        suggestedBinding.midPoint[0] - suggestedBinding.element.x,
        suggestedBinding.midPoint[1] - suggestedBinding.element.y
      );
      const target = [HEADING_RIGHT2, HEADING_DOWN2, HEADING_LEFT2, HEADING_UP2];
      midpoints.forEach((midpoint, idx) => {
        const isHighlighted = highlightedPoint && compareHeading2(
          headingForPoint2(
            pointRotateRads17(
              pointFrom25(
                highlightedPoint[0] + suggestedBinding.element.x,
                highlightedPoint[1] + suggestedBinding.element.y
              ),
              center,
              suggestedBinding.element.angle
            ),
            center
          ),
          target[idx]
        );
        if (!isHighlighted) {
          context.fillStyle = appState.theme === THEME17.DARK ? `rgba(0, 0, 0, 0.5)` : `rgba(65, 65, 65, 0.4)`;
          context.beginPath();
          context.arc(midpoint[0], midpoint[1], midpointRadius, 0, 2 * Math.PI);
          context.fill();
        } else {
          context.fillStyle = appState.theme === THEME17.DARK ? `rgba(3, 93, 161, 1)` : `rgba(106, 189, 252, 1)`;
          context.beginPath();
          context.arc(midpoint[0], midpoint[1], midpointRadius, 0, 2 * Math.PI);
          context.fill();
        }
      });
      context.restore();
    }
  }
};
var renderBindingHighlightForBindableElement_complex = (app, context, element, allElementsMap, appState, deltaTime, state) => {
  const countdownInProgress = app.state.bindMode === "orbit" && app.bindModeHandler !== null;
  const remainingTime = BIND_MODE_TIMEOUT - (state?.runtime ?? (countdownInProgress ? 0 : BIND_MODE_TIMEOUT));
  const opacity = clamp5(1 / BIND_MODE_TIMEOUT * remainingTime, 1e-4, 1);
  const offset = element.strokeWidth / 2;
  const enclosingFrame = element.frameId && allElementsMap.get(element.frameId);
  if (enclosingFrame && isFrameLikeElement11(enclosingFrame)) {
    context.translate(enclosingFrame.x, enclosingFrame.y);
    context.beginPath();
    if (FRAME_STYLE4.radius && context.roundRect) {
      context.roundRect(
        -1,
        -1,
        enclosingFrame.width + 1,
        enclosingFrame.height + 1,
        FRAME_STYLE4.radius / appState.zoom.value
      );
    } else {
      context.rect(-1, -1, enclosingFrame.width + 1, enclosingFrame.height + 1);
    }
    context.clip();
    context.translate(-enclosingFrame.x, -enclosingFrame.y);
  }
  switch (element.type) {
    case "magicframe":
    case "frame":
      break;
    default:
      context.save();
      const center = elementCenterPoint2(element, allElementsMap);
      const cx = center[0] + appState.scrollX;
      const cy = center[1] + appState.scrollY;
      context.translate(cx, cy);
      context.rotate(element.angle);
      context.translate(-cx, -cy);
      context.translate(
        element.x + appState.scrollX - offset,
        element.y + appState.scrollY - offset
      );
      context.lineWidth = clamp5(2.5, element.strokeWidth * 1.75, 4) / Math.max(0.25, appState.zoom.value);
      context.strokeStyle = appState.theme === THEME17.DARK ? `rgba(3, 93, 161, ${opacity / 2})` : `rgba(106, 189, 252, ${opacity / 2})`;
      switch (element.type) {
        case "ellipse":
          context.beginPath();
          context.ellipse(
            (element.width + offset * 2) / 2,
            (element.height + offset * 2) / 2,
            (element.width + offset * 2) / 2,
            (element.height + offset * 2) / 2,
            0,
            0,
            2 * Math.PI
          );
          context.closePath();
          context.stroke();
          break;
        case "diamond":
          {
            const [segments, curves] = deconstructDiamondElement2(
              element,
              offset
            );
            segments.forEach((segment) => {
              context.beginPath();
              context.moveTo(
                segment[0][0] - element.x + offset,
                segment[0][1] - element.y + offset
              );
              context.lineTo(
                segment[1][0] - element.x + offset,
                segment[1][1] - element.y + offset
              );
              context.stroke();
            });
            curves.forEach((curve3) => {
              const [start2, control1, control2, end] = curve3;
              context.beginPath();
              context.moveTo(
                start2[0] - element.x + offset,
                start2[1] - element.y + offset
              );
              context.bezierCurveTo(
                control1[0] - element.x + offset,
                control1[1] - element.y + offset,
                control2[0] - element.x + offset,
                control2[1] - element.y + offset,
                end[0] - element.x + offset,
                end[1] - element.y + offset
              );
              context.stroke();
            });
          }
          break;
        default:
          {
            const [segments, curves] = deconstructRectanguloidElement2(
              element,
              offset
            );
            segments.forEach((segment) => {
              context.beginPath();
              context.moveTo(
                segment[0][0] - element.x + offset,
                segment[0][1] - element.y + offset
              );
              context.lineTo(
                segment[1][0] - element.x + offset,
                segment[1][1] - element.y + offset
              );
              context.stroke();
            });
            curves.forEach((curve3) => {
              const [start2, control1, control2, end] = curve3;
              context.beginPath();
              context.moveTo(
                start2[0] - element.x + offset,
                start2[1] - element.y + offset
              );
              context.bezierCurveTo(
                control1[0] - element.x + offset,
                control1[1] - element.y + offset,
                control2[0] - element.x + offset,
                control2[1] - element.y + offset,
                end[0] - element.x + offset,
                end[1] - element.y + offset
              );
              context.stroke();
            });
          }
          break;
      }
      context.restore();
      break;
  }
  if (!countdownInProgress || (state?.runtime ?? 0) > BIND_MODE_TIMEOUT) {
    return;
  }
  const radius = 0.5 * (Math.min(element.width, element.height) / 2);
  if (!isFrameLikeElement11(element)) {
    context.save();
    context.translate(
      element.x + appState.scrollX,
      element.y + appState.scrollY
    );
    const PROGRESS_RATIO = 1 / BIND_MODE_TIMEOUT * remainingTime;
    context.strokeStyle = "rgba(0, 0, 0, 0.2)";
    context.lineWidth = 1 / appState.zoom.value;
    context.setLineDash([4 / appState.zoom.value, 4 / appState.zoom.value]);
    context.lineDashOffset = -PROGRESS_RATIO * 10 / appState.zoom.value;
    context.beginPath();
    context.ellipse(
      element.width / 2,
      element.height / 2,
      radius,
      radius,
      0,
      0,
      2 * Math.PI
    );
    context.stroke();
    context.fillStyle = "rgba(0, 0, 0, 0.04)";
    context.beginPath();
    context.ellipse(
      element.width / 2,
      element.height / 2,
      radius * (1 - opacity),
      radius * (1 - opacity),
      0,
      0,
      2 * Math.PI
    );
    context.fill();
    context.restore();
    context.save();
    context.translate(
      element.x + appState.scrollX,
      element.y + appState.scrollY
    );
    const midpointRadius = 5 / appState.zoom.value;
    const cutoutPadding = 5 / appState.zoom.value;
    const cutoutRadius = midpointRadius + cutoutPadding;
    let midpoints;
    if (element.type === "diamond") {
      const [, curves] = deconstructDiamondElement2(element);
      const center = elementCenterPoint2(element, allElementsMap);
      midpoints = curves.map((curve3) => {
        const point = bezierEquation2(curve3, 0.5);
        const rotatedPoint = pointRotateRads17(point, center, element.angle);
        return {
          x: rotatedPoint[0] - element.x,
          y: rotatedPoint[1] - element.y
        };
      });
    } else {
      const center = elementCenterPoint2(element, allElementsMap);
      const basePoints = [
        { x: element.width / 2, y: 0 },
        // TOP
        { x: element.width, y: element.height / 2 },
        // RIGHT
        { x: element.width / 2, y: element.height },
        // BOTTOM
        { x: 0, y: element.height / 2 }
        // LEFT
      ];
      midpoints = basePoints.map((point) => {
        const globalPoint = pointFrom25(
          point.x + element.x,
          point.y + element.y
        );
        const rotatedPoint = pointRotateRads17(
          globalPoint,
          center,
          element.angle
        );
        return {
          x: rotatedPoint[0] - element.x,
          y: rotatedPoint[1] - element.y
        };
      });
    }
    midpoints.forEach((midpoint) => {
      context.clearRect(
        midpoint.x - cutoutRadius,
        midpoint.y - cutoutRadius,
        cutoutRadius * 2,
        cutoutRadius * 2
      );
    });
    context.fillStyle = appState.theme === THEME17.DARK ? `rgba(3, 93, 161, ${opacity})` : `rgba(106, 189, 252, ${opacity})`;
    midpoints.forEach((midpoint) => {
      context.beginPath();
      context.arc(midpoint.x, midpoint.y, midpointRadius, 0, 2 * Math.PI);
      context.fill();
    });
    context.restore();
  }
  return {
    runtime: (state?.runtime ?? 0) + deltaTime
  };
};
var renderBindingHighlightForBindableElement = (app, context, suggestedBinding, allElementsMap, appState, deltaTime, state) => {
  if (suggestedBinding === null) {
    return;
  }
  if (getFeatureFlag3("COMPLEX_BINDINGS")) {
    return renderBindingHighlightForBindableElement_complex(
      app,
      context,
      suggestedBinding.element,
      allElementsMap,
      appState,
      deltaTime,
      state
    );
  }
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  const pointerCoords = app.lastPointerMoveCoords ? pointFrom25(
    app.lastPointerMoveCoords.x,
    app.lastPointerMoveCoords.y
  ) : null;
  renderBindingHighlightForBindableElement_simple(
    context,
    suggestedBinding,
    allElementsMap,
    appState,
    pointerCoords
  );
  context.restore();
};
var renderSelectionBorder = (context, appState, elementProperties) => {
  const {
    angle,
    x1,
    y1,
    x2,
    y2,
    selectionColors,
    cx,
    cy,
    dashed,
    activeEmbeddable
  } = elementProperties;
  const elementWidth = x2 - x1;
  const elementHeight = y2 - y1;
  const padding = elementProperties.padding ?? DEFAULT_TRANSFORM_HANDLE_SPACING * 2;
  const linePadding = padding / appState.zoom.value;
  const lineWidth = 8 / appState.zoom.value;
  const spaceWidth = 4 / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = (activeEmbeddable ? 4 : 3) / appState.zoom.value;
  const count = selectionColors.length;
  for (let index = 0; index < count; ++index) {
    context.strokeStyle = selectionColors[index];
    if (dashed) {
      context.setLineDash([
        lineWidth,
        spaceWidth + (lineWidth + spaceWidth) * (count - 1)
      ]);
    }
    context.lineDashOffset = (lineWidth + spaceWidth) * index;
    strokeRectWithRotation_simple(
      context,
      x1 - linePadding,
      y1 - linePadding,
      elementWidth + linePadding * 2,
      elementHeight + linePadding * 2,
      cx,
      cy,
      angle
    );
  }
  context.restore();
};
var renderFrameHighlight = (context, appState, frame, elementsMap) => {
  const [x1, y1, x2, y2] = getElementAbsoluteCoords8(frame, elementsMap);
  const width = x2 - x1;
  const height = y2 - y1;
  context.strokeStyle = appState.theme === THEME17.DARK ? applyDarkModeFilter4(FRAME_STYLE4.strokeColor) : FRAME_STYLE4.strokeColor;
  context.lineWidth = FRAME_STYLE4.strokeWidth / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  strokeRectWithRotation_simple(
    context,
    x1,
    y1,
    width,
    height,
    x1 + width / 2,
    y1 + height / 2,
    frame.angle,
    false,
    FRAME_STYLE4.radius / appState.zoom.value
  );
  context.restore();
};
var renderElementsBoxHighlight = (context, appState, elements, config) => {
  const { colors = ["rgb(0,118,255)"], dashed = false } = config || {};
  const individualElements = elements.filter(
    (element) => element.groupIds.length === 0
  );
  const elementsInGroups = elements.filter(
    (element) => element.groupIds.length > 0
  );
  const getSelectionFromElements = (elements2) => {
    const [x1, y1, x2, y2] = getCommonBounds6(elements2);
    return {
      angle: 0,
      x1,
      x2,
      y1,
      y2,
      selectionColors: colors,
      dashed,
      cx: x1 + (x2 - x1) / 2,
      cy: y1 + (y2 - y1) / 2,
      activeEmbeddable: false
    };
  };
  const getSelectionForGroupId = (groupId) => {
    const groupElements = getElementsInGroup6(elements, groupId);
    return getSelectionFromElements(groupElements);
  };
  Object.entries(selectGroupsFromGivenElements3(elementsInGroups, appState)).filter(([id, isSelected]) => isSelected).map(([id, isSelected]) => id).map((groupId) => getSelectionForGroupId(groupId)).concat(
    individualElements.map((element) => getSelectionFromElements([element]))
  ).forEach(
    (selection) => renderSelectionBorder(context, appState, selection)
  );
};
var renderLinearPointHandles = (context, appState, element, elementsMap) => {
  if (!appState.selectedLinearElement) {
    return;
  }
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = 1 / appState.zoom.value;
  const points = LinearElementEditor10.getPointsGlobalCoordinates(
    element,
    elementsMap
  );
  const { POINT_HANDLE_SIZE } = LinearElementEditor10;
  const radius = appState.selectedLinearElement?.isEditing ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;
  const _isElbowArrow = isElbowArrow8(element);
  const _isLineElement = isLineElement7(element);
  points.forEach((point, idx) => {
    if (_isElbowArrow && idx !== 0 && idx !== points.length - 1) {
      return;
    }
    const isOverlappingPoint = idx > 0 && (idx !== points.length - 1 || !_isLineElement || !element.polygon) && pointsEqual8(
      point,
      idx === points.length - 1 ? points[0] : points[idx - 1],
      2 / appState.zoom.value
    );
    let isSelected = !!appState.selectedLinearElement?.isEditing && !!appState.selectedLinearElement?.selectedPointsIndices?.includes(idx);
    if (_isLineElement && element.polygon && !isSelected && idx === element.points.length - 1 && !!appState.selectedLinearElement?.isEditing && !!appState.selectedLinearElement?.selectedPointsIndices?.includes(0)) {
      isSelected = true;
    }
    renderSingleLinearPoint(
      context,
      appState,
      point,
      radius,
      isSelected,
      false,
      isOverlappingPoint
    );
  });
  if (isElbowArrow8(element)) {
    const fixedSegments = element.fixedSegments?.map((segment) => segment.index) || [];
    points.slice(0, -1).forEach((p, idx) => {
      if (!LinearElementEditor10.isSegmentTooShort(
        element,
        points[idx + 1],
        points[idx],
        idx,
        appState.zoom
      )) {
        renderSingleLinearPoint(
          context,
          appState,
          pointFrom25(
            (p[0] + points[idx + 1][0]) / 2,
            (p[1] + points[idx + 1][1]) / 2
          ),
          POINT_HANDLE_SIZE / 2,
          false,
          !fixedSegments.includes(idx + 1),
          false
        );
      }
    });
  } else {
    const midPoints = LinearElementEditor10.getEditorMidPoints(
      element,
      elementsMap,
      appState
    ).filter(
      (midPoint, idx, midPoints2) => midPoint !== null && !(isElbowArrow8(element) && (idx === 0 || idx === midPoints2.length - 1))
    );
    midPoints.forEach((segmentMidPoint) => {
      if (appState.selectedLinearElement?.isEditing || points.length === 2) {
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          POINT_HANDLE_SIZE / 2,
          false,
          true,
          false
        );
      }
    });
  }
  context.restore();
};
var renderFocusPointConnectionLine = (context, appState, fromPoint, toPoint) => {
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.strokeStyle = "rgba(134, 131, 226, 0.6)";
  context.lineWidth = 1 / appState.zoom.value;
  context.setLineDash([4 / appState.zoom.value, 4 / appState.zoom.value]);
  context.beginPath();
  context.moveTo(fromPoint[0], fromPoint[1]);
  context.lineTo(toPoint[0], toPoint[1]);
  context.stroke();
  context.restore();
};
var renderFocusPointCicle = (context, appState, point, radius, isHovered) => {
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.strokeStyle = "rgba(134, 131, 226, 0.6)";
  context.lineWidth = 1 / appState.zoom.value;
  context.setLineDash([]);
  context.fillStyle = isHovered ? "rgba(134, 131, 226, 0.9)" : "rgba(255, 255, 255, 0.9)";
  fillCircle(
    context,
    point[0],
    point[1],
    radius / appState.zoom.value,
    true,
    true
  );
  context.restore();
};
var renderFocusPointIndicator = ({
  arrow,
  appState,
  type,
  context,
  elementsMap
}) => {
  const binding = type === "start" ? arrow.startBinding : arrow.endBinding;
  const bindableElement = binding?.elementId && elementsMap.get(binding.elementId);
  if (!bindableElement || !isBindableElement2(bindableElement) || bindableElement.isDeleted) {
    return;
  }
  const focusPoint = getGlobalFixedPointForBindableElement2(
    binding.fixedPoint,
    bindableElement,
    elementsMap
  );
  if (!isFocusPointVisible(
    focusPoint,
    arrow,
    bindableElement,
    elementsMap,
    appState
  )) {
    return;
  }
  const linearState = appState.selectedLinearElement;
  const isDragging = !!linearState?.isDragging;
  const pointIndex = type === "start" ? 0 : arrow.points.length - 1;
  const pointSelected = !!linearState?.selectedPointsIndices?.includes(pointIndex);
  if (linearState?.hoveredFocusPointBinding === type && !linearState.draggedFocusPointBinding) {
    renderFocusPointHighlight(context, appState, focusPoint);
  }
  if (!(pointSelected && isDragging)) {
    const focusPoint2 = getGlobalFixedPointForBindableElement2(
      binding.fixedPoint,
      bindableElement,
      elementsMap
    );
    const isHovered = linearState?.hoveredFocusPointBinding === type;
    const arrowPoint = LinearElementEditor10.getPointAtIndexGlobalCoordinates(
      arrow,
      pointIndex,
      elementsMap
    );
    renderFocusPointConnectionLine(context, appState, arrowPoint, focusPoint2);
    renderFocusPointCicle(
      context,
      appState,
      focusPoint2,
      FOCUS_POINT_SIZE2 / 1.5,
      isHovered
    );
  }
};
var renderTransformHandles = (context, renderConfig, appState, transformHandles, angle) => {
  Object.keys(transformHandles).forEach((key) => {
    const transformHandle = transformHandles[key];
    if (transformHandle !== void 0) {
      const [x, y, width, height] = transformHandle;
      context.save();
      context.lineWidth = 3 / appState.zoom.value;
      if (renderConfig.selectionColor) {
        context.strokeStyle = renderConfig.selectionColor;
      }
      if (key === "rotation") {
        fillCircle(context, x + width / 2, y + height / 2, width / 2, true);
      } else if (context.roundRect) {
        context.beginPath();
        context.roundRect(x, y, width, height, 2 / appState.zoom.value);
        context.fill();
        context.stroke();
      } else {
        strokeRectWithRotation_simple(
          context,
          x,
          y,
          width,
          height,
          x + width / 2,
          y + height / 2,
          angle,
          true
          // fill before stroke
        );
      }
      context.restore();
    }
  });
};
var renderCropHandles = (context, renderConfig, appState, croppingElement, elementsMap) => {
  const [x1, y1, , , cx, cy] = getElementAbsoluteCoords8(
    croppingElement,
    elementsMap
  );
  const LINE_WIDTH = 3;
  const LINE_LENGTH = 20;
  const ZOOMED_LINE_WIDTH = LINE_WIDTH / appState.zoom.value;
  const ZOOMED_HALF_LINE_WIDTH = ZOOMED_LINE_WIDTH / 2;
  const HALF_WIDTH = cx - x1 + ZOOMED_LINE_WIDTH;
  const HALF_HEIGHT = cy - y1 + ZOOMED_LINE_WIDTH;
  const HORIZONTAL_LINE_LENGTH = Math.min(
    LINE_LENGTH / appState.zoom.value,
    HALF_WIDTH
  );
  const VERTICAL_LINE_LENGTH = Math.min(
    LINE_LENGTH / appState.zoom.value,
    HALF_HEIGHT
  );
  context.save();
  context.fillStyle = renderConfig.selectionColor;
  context.strokeStyle = renderConfig.selectionColor;
  context.lineWidth = ZOOMED_LINE_WIDTH;
  const handles = [
    [
      // x, y
      [-HALF_WIDTH, -HALF_HEIGHT],
      // horizontal line: first start and to
      [0, ZOOMED_HALF_LINE_WIDTH],
      [HORIZONTAL_LINE_LENGTH, ZOOMED_HALF_LINE_WIDTH],
      // vertical line: second  start and to
      [ZOOMED_HALF_LINE_WIDTH, 0],
      [ZOOMED_HALF_LINE_WIDTH, VERTICAL_LINE_LENGTH]
    ],
    [
      [HALF_WIDTH - ZOOMED_HALF_LINE_WIDTH, -HALF_HEIGHT],
      [ZOOMED_HALF_LINE_WIDTH, ZOOMED_HALF_LINE_WIDTH],
      [
        -HORIZONTAL_LINE_LENGTH + ZOOMED_HALF_LINE_WIDTH,
        ZOOMED_HALF_LINE_WIDTH
      ],
      [0, 0],
      [0, VERTICAL_LINE_LENGTH]
    ],
    [
      [-HALF_WIDTH, HALF_HEIGHT],
      [0, -ZOOMED_HALF_LINE_WIDTH],
      [HORIZONTAL_LINE_LENGTH, -ZOOMED_HALF_LINE_WIDTH],
      [ZOOMED_HALF_LINE_WIDTH, 0],
      [ZOOMED_HALF_LINE_WIDTH, -VERTICAL_LINE_LENGTH]
    ],
    [
      [HALF_WIDTH - ZOOMED_HALF_LINE_WIDTH, HALF_HEIGHT],
      [ZOOMED_HALF_LINE_WIDTH, -ZOOMED_HALF_LINE_WIDTH],
      [
        -HORIZONTAL_LINE_LENGTH + ZOOMED_HALF_LINE_WIDTH,
        -ZOOMED_HALF_LINE_WIDTH
      ],
      [0, 0],
      [0, -VERTICAL_LINE_LENGTH]
    ]
  ];
  handles.forEach((handle) => {
    const [[x, y], [x1s, y1s], [x1t, y1t], [x2s, y2s], [x2t, y2t]] = handle;
    context.save();
    context.translate(cx, cy);
    context.rotate(croppingElement.angle);
    context.beginPath();
    context.moveTo(x + x1s, y + y1s);
    context.lineTo(x + x1t, y + y1t);
    context.stroke();
    context.beginPath();
    context.moveTo(x + x2s, y + y2s);
    context.lineTo(x + x2t, y + y2t);
    context.stroke();
    context.restore();
  });
  context.restore();
};
var renderTextBox = (text, context, appState, selectionColor) => {
  context.save();
  const padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
  const width = text.width + padding * 2;
  const height = text.height + padding * 2;
  const cx = text.x + width / 2;
  const cy = text.y + height / 2;
  const shiftX = -(width / 2 + padding);
  const shiftY = -(height / 2 + padding);
  context.translate(cx + appState.scrollX, cy + appState.scrollY);
  context.rotate(text.angle);
  context.lineWidth = 1 / appState.zoom.value;
  context.strokeStyle = selectionColor;
  context.strokeRect(shiftX, shiftY, width, height);
  context.restore();
};
var _renderInteractiveScene = ({
  app,
  canvas,
  elementsMap,
  visibleElements,
  selectedElements,
  allElementsMap,
  scale,
  appState,
  renderConfig,
  editorInterface,
  animationState,
  deltaTime
}) => {
  if (canvas === null) {
    return { atLeastOneVisibleElement: false, elementsMap };
  }
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas,
    scale
  );
  let nextAnimationState = animationState;
  const context = bootstrapCanvas({
    canvas,
    scale,
    normalizedWidth,
    normalizedHeight
  });
  context.save();
  context.scale(appState.zoom.value, appState.zoom.value);
  let editingLinearElement = void 0;
  visibleElements.forEach((element) => {
    if (appState.selectedLinearElement?.isEditing && appState.selectedLinearElement.elementId === element.id) {
      if (element) {
        editingLinearElement = element;
      }
    }
  });
  if (editingLinearElement) {
    renderLinearPointHandles(
      context,
      appState,
      editingLinearElement,
      elementsMap
    );
  }
  if (appState.selectionElement && !appState.isCropping) {
    try {
      renderSelectionElement(
        appState.selectionElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    } catch (error) {
      console.error(error);
    }
  }
  if (appState.editingTextElement && isTextElement15(appState.editingTextElement)) {
    const textElement = allElementsMap.get(appState.editingTextElement.id);
    if (textElement && !textElement.autoResize) {
      renderTextBox(
        textElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    }
  }
  if (appState.isBindingEnabled && appState.suggestedBinding) {
    nextAnimationState = {
      ...animationState,
      bindingHighlight: renderBindingHighlightForBindableElement(
        app,
        context,
        appState.suggestedBinding,
        allElementsMap,
        appState,
        deltaTime,
        animationState?.bindingHighlight
      )
    };
  } else {
    nextAnimationState = {
      ...animationState,
      bindingHighlight: void 0
    };
  }
  if (appState.frameToHighlight) {
    renderFrameHighlight(
      context,
      appState,
      appState.frameToHighlight,
      elementsMap
    );
  }
  if (appState.elementsToHighlight) {
    renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);
  }
  if (appState.activeLockedId) {
    const element = allElementsMap.get(appState.activeLockedId);
    const elements = element ? [element] : getElementsInGroup6(allElementsMap, appState.activeLockedId);
    renderElementsBoxHighlight(context, appState, elements, {
      colors: ["#ced4da"],
      dashed: true
    });
  }
  const isFrameSelected = selectedElements.some(
    (element) => isFrameLikeElement11(element)
  );
  if (selectedElements.length === 1 && appState.selectedLinearElement?.isEditing && appState.selectedLinearElement.elementId === selectedElements[0].id) {
    renderLinearPointHandles(
      context,
      appState,
      selectedElements[0],
      elementsMap
    );
  }
  const linearState = appState.selectedLinearElement;
  const selectedLinearElement = linearState && LinearElementEditor10.getElement(linearState.elementId, allElementsMap);
  if (selectedLinearElement) {
    if (!appState.selectedLinearElement.isDragging) {
      if (linearState.segmentMidPointHoveredCoords) {
        renderElbowArrowMidPointHighlight(context, appState);
      } else if (isElbowArrow8(selectedLinearElement) ? linearState.hoverPointIndex === 0 || linearState.hoverPointIndex === selectedLinearElement.points.length - 1 : linearState.hoverPointIndex >= 0) {
        renderLinearElementPointHighlight(context, appState, elementsMap);
      }
    }
    if (isArrowElement11(selectedLinearElement)) {
      renderFocusPointIndicator({
        arrow: selectedLinearElement,
        elementsMap: allElementsMap,
        appState,
        context,
        type: "start"
      });
      renderFocusPointIndicator({
        arrow: selectedLinearElement,
        elementsMap: allElementsMap,
        appState,
        context,
        type: "end"
      });
    }
  }
  if (!appState.multiElement && !appState.newElement && !appState.selectedLinearElement?.isEditing) {
    const showBoundingBox = hasBoundingBox(
      selectedElements,
      appState,
      editorInterface
    );
    const isSingleLinearElementSelected = selectedElements.length === 1 && isLinearElement11(selectedElements[0]);
    if (isSingleLinearElementSelected && appState.selectedLinearElement?.elementId === selectedElements[0].id && !selectedElements[0].locked) {
      renderLinearPointHandles(
        context,
        appState,
        selectedElements[0],
        elementsMap
      );
    }
    const selectionColor = renderConfig.selectionColor || "#000";
    if (showBoundingBox) {
      const locallySelectedIds = arrayToMap25(selectedElements);
      const selections = [];
      for (const element of elementsMap.values()) {
        const selectionColors = [];
        const remoteClients = renderConfig.remoteSelectedElementIds.get(
          element.id
        );
        if (!// Elbow arrow elements cannot be selected when bound on either end
        (isSingleLinearElementSelected && isElbowArrow8(element) && (element.startBinding || element.endBinding))) {
          if (locallySelectedIds.has(element.id) && !isSelectedViaGroup(appState, element)) {
            selectionColors.push(selectionColor);
          }
          if (remoteClients) {
            selectionColors.push(
              ...remoteClients.map((socketId) => {
                const background = getClientColor(
                  socketId,
                  appState.collaborators.get(socketId)
                );
                return background;
              })
            );
          }
        }
        if (selectionColors.length) {
          const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords8(
            element,
            elementsMap,
            true
          );
          selections.push({
            angle: element.angle,
            x1,
            y1,
            x2,
            y2,
            selectionColors: element.locked ? ["#ced4da"] : selectionColors,
            dashed: !!remoteClients || element.locked,
            cx,
            cy,
            activeEmbeddable: appState.activeEmbeddable?.element === element && appState.activeEmbeddable.state === "active",
            padding: element.id === appState.croppingElementId || isImageElement5(element) ? 0 : void 0
          });
        }
      }
      const addSelectionForGroupId = (groupId) => {
        const groupElements = getElementsInGroup6(elementsMap, groupId);
        const [x1, y1, x2, y2] = getCommonBounds6(groupElements);
        selections.push({
          angle: 0,
          x1,
          x2,
          y1,
          y2,
          selectionColors: groupElements.some((el) => el.locked) ? ["#ced4da"] : ["#000"],
          dashed: true,
          cx: x1 + (x2 - x1) / 2,
          cy: y1 + (y2 - y1) / 2,
          activeEmbeddable: false
        });
      };
      for (const groupId of getSelectedGroupIds2(appState)) {
        addSelectionForGroupId(groupId);
      }
      if (appState.editingGroupId) {
        addSelectionForGroupId(appState.editingGroupId);
      }
      selections.forEach(
        (selection) => renderSelectionBorder(context, appState, selection)
      );
    }
    context.save();
    context.translate(appState.scrollX, appState.scrollY);
    if (selectedElements.length === 1) {
      context.fillStyle = "#fff";
      const selectedElement = selectedElements[0];
      const elementForTransformHandles = isTextElement15(selectedElement) && selectedElement.containerId && elementsMap.get(selectedElement.containerId) ? elementsMap.get(selectedElement.containerId) : selectedElement;
      const transformHandles = getTransformHandles(
        elementForTransformHandles,
        appState.zoom,
        elementsMap,
        "mouse",
        // when we render we don't know which pointer type so use mouse,
        getOmitSidesForEditorInterface(editorInterface)
      );
      const isEditingBoundText = appState.editingTextElement && isTextElement15(appState.editingTextElement) && appState.editingTextElement.containerId != null;
      if (!appState.viewModeEnabled && showBoundingBox && // show transform handles when not editing, or when editing bound text (container handles)
      (!appState.editingTextElement || isEditingBoundText) && // do not show transform handles when image is being cropped
      !appState.croppingElementId) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          elementForTransformHandles.angle
        );
      }
      if (appState.croppingElementId && !appState.isCropping) {
        const croppingElement = elementsMap.get(appState.croppingElementId);
        if (croppingElement && isImageElement5(croppingElement)) {
          renderCropHandles(
            context,
            renderConfig,
            appState,
            croppingElement,
            elementsMap
          );
        }
      }
    } else if (selectedElements.length > 1 && !appState.isRotating && !selectedElements.some((el) => el.locked)) {
      const dashedLinePadding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
      context.fillStyle = "#fff";
      const [x1, y1, x2, y2] = getCommonBounds6(selectedElements, elementsMap);
      const initialLineDash = context.getLineDash();
      context.setLineDash([2 / appState.zoom.value]);
      const lineWidth = context.lineWidth;
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = selectionColor;
      strokeRectWithRotation_simple(
        context,
        x1 - dashedLinePadding,
        y1 - dashedLinePadding,
        x2 - x1 + dashedLinePadding * 2,
        y2 - y1 + dashedLinePadding * 2,
        (x1 + x2) / 2,
        (y1 + y2) / 2,
        0
      );
      context.lineWidth = lineWidth;
      context.setLineDash(initialLineDash);
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],
        0,
        appState.zoom,
        "mouse",
        isFrameSelected ? {
          ...getOmitSidesForEditorInterface(editorInterface),
          rotation: true
        } : getOmitSidesForEditorInterface(editorInterface)
      );
      if (selectedElements.some((element) => !element.locked)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          0
        );
      }
    }
    context.restore();
  }
  appState.searchMatches?.matches.forEach(({ id, focus, matchedLines }) => {
    const element = elementsMap.get(id);
    if (element) {
      const [elementX1, elementY1, , , cx, cy] = getElementAbsoluteCoords8(
        element,
        elementsMap,
        true
      );
      context.save();
      if (appState.theme === THEME17.LIGHT) {
        if (focus) {
          context.fillStyle = "rgba(255, 124, 0, 0.4)";
        } else {
          context.fillStyle = "rgba(255, 226, 0, 0.4)";
        }
      } else if (focus) {
        context.fillStyle = "rgba(229, 82, 0, 0.4)";
      } else {
        context.fillStyle = "rgba(99, 52, 0, 0.4)";
      }
      const zoomFactor = isFrameLikeElement11(element) ? appState.zoom.value : 1;
      context.translate(appState.scrollX, appState.scrollY);
      context.translate(cx, cy);
      context.rotate(element.angle);
      matchedLines.forEach((matchedLine) => {
        (matchedLine.showOnCanvas || focus) && context.fillRect(
          elementX1 + matchedLine.offsetX / zoomFactor - cx,
          elementY1 + matchedLine.offsetY / zoomFactor - cy,
          matchedLine.width / zoomFactor,
          matchedLine.height / zoomFactor
        );
      });
      context.restore();
    }
  });
  renderSnaps(context, appState);
  context.restore();
  renderRemoteCursors({
    context,
    renderConfig,
    appState,
    normalizedWidth,
    normalizedHeight
  });
  let scrollBars;
  if (renderConfig.renderScrollbars) {
    scrollBars = getScrollBars(
      elementsMap,
      normalizedWidth,
      normalizedHeight,
      appState
    );
    context.save();
    context.fillStyle = SCROLLBAR_COLOR;
    context.strokeStyle = "rgba(255,255,255,0.8)";
    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {
      if (scrollBar) {
        roundRect(
          context,
          scrollBar.x,
          scrollBar.y,
          scrollBar.width,
          scrollBar.height,
          SCROLLBAR_WIDTH / 2
        );
      }
    });
    context.restore();
  }
  return {
    scrollBars,
    atLeastOneVisibleElement: visibleElements.length > 0,
    elementsMap,
    animationState: nextAnimationState
  };
};
var renderInteractiveScene = (renderConfig) => {
  const ret = _renderInteractiveScene(renderConfig);
  renderConfig.callback(ret);
  return ret;
};

// components/canvases/InteractiveCanvas.tsx
import { jsx as jsx146 } from "react/jsx-runtime";
var INTERACTIVE_SCENE_ANIMATION_KEY = "animateInteractiveScene";
var InteractiveCanvas = (props) => {
  const isComponentMounted = useRef41(false);
  const rendererParams = useRef41(null);
  useEffect44(() => {
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      return;
    }
    const remotePointerButton = /* @__PURE__ */ new Map();
    const remotePointerViewportCoords = /* @__PURE__ */ new Map();
    const remoteSelectedElementIds = /* @__PURE__ */ new Map();
    const remotePointerUsernames = /* @__PURE__ */ new Map();
    const remotePointerUserStates = /* @__PURE__ */ new Map();
    props.appState.collaborators.forEach((user, socketId) => {
      if (user.selectedElementIds) {
        for (const id of Object.keys(user.selectedElementIds)) {
          if (!remoteSelectedElementIds.has(id)) {
            remoteSelectedElementIds.set(id, []);
          }
          remoteSelectedElementIds.get(id).push(socketId);
        }
      }
      if (!user.pointer || user.pointer.renderCursor === false) {
        return;
      }
      if (user.username) {
        remotePointerUsernames.set(socketId, user.username);
      }
      if (user.userState) {
        remotePointerUserStates.set(socketId, user.userState);
      }
      remotePointerViewportCoords.set(
        socketId,
        sceneCoordsToViewportCoords6(
          {
            sceneX: user.pointer.x,
            sceneY: user.pointer.y
          },
          props.appState
        )
      );
      remotePointerButton.set(socketId, user.button);
    });
    const selectionColor = COLOR_PALETTE7.blue[2];
    rendererParams.current = {
      app: props.app,
      canvas: props.canvas,
      elementsMap: props.elementsMap,
      visibleElements: props.visibleElements,
      selectedElements: props.selectedElements,
      allElementsMap: props.allElementsMap,
      scale: window.devicePixelRatio,
      appState: props.appState,
      renderConfig: {
        remotePointerViewportCoords,
        remotePointerButton,
        remoteSelectedElementIds,
        remotePointerUsernames,
        remotePointerUserStates,
        selectionColor,
        renderScrollbars: props.renderScrollbars,
        // NOTE not memoized on so we don't rerender on cursor move
        lastViewportPosition: props.app.lastViewportPosition
      },
      editorInterface: props.editorInterface,
      callback: props.renderInteractiveSceneCallback,
      animationState: {
        bindingHighlight: void 0
      },
      deltaTime: 0
    };
    if (!AnimationController.running(INTERACTIVE_SCENE_ANIMATION_KEY)) {
      AnimationController.start(
        INTERACTIVE_SCENE_ANIMATION_KEY,
        ({ deltaTime, state }) => {
          const nextAnimationState = renderInteractiveScene({
            ...rendererParams.current,
            deltaTime,
            animationState: state
          }).animationState;
          if (nextAnimationState) {
            for (const key in nextAnimationState) {
              if (nextAnimationState[key] !== void 0) {
                return nextAnimationState;
              }
            }
          }
          return void 0;
        }
      );
    }
  });
  return /* @__PURE__ */ jsx146(
    "canvas",
    {
      className: "excalidraw__canvas interactive",
      style: {
        width: props.appState.width,
        height: props.appState.height,
        cursor: props.appState.viewModeEnabled ? CURSOR_TYPE3.GRAB : CURSOR_TYPE3.AUTO
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: props.handleCanvasRef,
      onContextMenu: props.onContextMenu,
      onPointerMove: props.onPointerMove,
      onPointerUp: props.onPointerUp,
      onPointerCancel: props.onPointerCancel,
      onTouchMove: props.onTouchMove,
      onPointerDown: props.onPointerDown,
      onDoubleClick: props.appState.viewModeEnabled ? void 0 : props.onDoubleClick,
      children: t("labels.drawingCanvas")
    }
  );
};
var getRelevantAppStateProps = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  openDialog: appState.openDialog,
  editingGroupId: appState.editingGroupId,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  selectionElement: appState.selectionElement,
  selectedGroupIds: appState.selectedGroupIds,
  selectedLinearElement: appState.selectedLinearElement,
  multiElement: appState.multiElement,
  newElement: appState.newElement,
  isBindingEnabled: appState.isBindingEnabled,
  suggestedBinding: appState.suggestedBinding,
  isRotating: appState.isRotating,
  elementsToHighlight: appState.elementsToHighlight,
  collaborators: appState.collaborators,
  // Necessary for collab. sessions
  activeEmbeddable: appState.activeEmbeddable,
  snapLines: appState.snapLines,
  zenModeEnabled: appState.zenModeEnabled,
  editingTextElement: appState.editingTextElement,
  isCropping: appState.isCropping,
  croppingElementId: appState.croppingElementId,
  searchMatches: appState.searchMatches,
  activeLockedId: appState.activeLockedId,
  hoveredElementIds: appState.hoveredElementIds,
  frameRendering: appState.frameRendering,
  shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
  exportScale: appState.exportScale
});
var areEqual3 = (prevProps, nextProps) => {
  if (prevProps.selectionNonce !== nextProps.selectionNonce || prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements || prevProps.selectedElements !== nextProps.selectedElements || prevProps.renderScrollbars !== nextProps.renderScrollbars) {
    return false;
  }
  return isShallowEqual7(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the InteractiveCanvas-relevant props
    getRelevantAppStateProps(prevProps.appState),
    getRelevantAppStateProps(nextProps.appState)
  );
};
var InteractiveCanvas_default = React45.memo(InteractiveCanvas, areEqual3);

// components/canvases/StaticCanvas.tsx
import React46, { useEffect as useEffect45, useRef as useRef42 } from "react";
import { isShallowEqual as isShallowEqual8 } from "@excalidraw/common";
import { jsx as jsx147 } from "react/jsx-runtime";
var StaticCanvas = (props) => {
  const wrapperRef = useRef42(null);
  const isComponentMounted = useRef42(false);
  useEffect45(() => {
    props.canvas.style.width = `${props.appState.width}px`;
    props.canvas.style.height = `${props.appState.height}px`;
    props.canvas.width = props.appState.width * props.scale;
    props.canvas.height = props.appState.height * props.scale;
  }, [props.appState.height, props.appState.width, props.canvas, props.scale]);
  useEffect45(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) {
      return;
    }
    const canvas = props.canvas;
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      wrapper.replaceChildren(canvas);
      canvas.classList.add("excalidraw__canvas", "static");
    }
    renderStaticScene(
      {
        canvas,
        rc: props.rc,
        scale: props.scale,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        visibleElements: props.visibleElements,
        appState: props.appState,
        renderConfig: props.renderConfig
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ jsx147("div", { className: "excalidraw__canvas-wrapper", ref: wrapperRef });
};
var getRelevantAppStateProps2 = (appState) => {
  const relevantAppStateProps = {
    zoom: appState.zoom,
    scrollX: appState.scrollX,
    scrollY: appState.scrollY,
    width: appState.width,
    height: appState.height,
    viewModeEnabled: appState.viewModeEnabled,
    openDialog: appState.openDialog,
    hoveredElementIds: appState.hoveredElementIds,
    offsetLeft: appState.offsetLeft,
    offsetTop: appState.offsetTop,
    theme: appState.theme,
    shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
    viewBackgroundColor: appState.viewBackgroundColor,
    exportScale: appState.exportScale,
    selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,
    gridSize: appState.gridSize,
    gridStep: appState.gridStep,
    frameRendering: appState.frameRendering,
    selectedElementIds: appState.selectedElementIds,
    frameToHighlight: appState.frameToHighlight,
    editingGroupId: appState.editingGroupId,
    currentHoveredFontFamily: appState.currentHoveredFontFamily,
    croppingElementId: appState.croppingElementId,
    suggestedBinding: appState.suggestedBinding
  };
  return relevantAppStateProps;
};
var areEqual4 = (prevProps, nextProps) => {
  if (prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements) {
    return false;
  }
  return isShallowEqual8(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the StaticCanvas-relevant props
    getRelevantAppStateProps2(prevProps.appState),
    getRelevantAppStateProps2(nextProps.appState)
  ) && isShallowEqual8(prevProps.renderConfig, nextProps.renderConfig);
};
var StaticCanvas_default = React46.memo(StaticCanvas, areEqual4);

// components/canvases/NewElementCanvas.tsx
import { useEffect as useEffect46, useRef as useRef43 } from "react";

// renderer/renderNewElementScene.ts
import { throttleRAF as throttleRAF2 } from "@excalidraw/common";
import {
  getTargetFrame,
  isInvisiblySmallElement as isInvisiblySmallElement2,
  renderElement,
  shouldApplyFrameClip
} from "@excalidraw/element";
var _renderNewElementScene = ({
  canvas,
  rc,
  newElement: newElement5,
  elementsMap,
  allElementsMap,
  scale,
  appState,
  renderConfig
}) => {
  if (canvas) {
    const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
      canvas,
      scale
    );
    const context = bootstrapCanvas({
      canvas,
      scale,
      normalizedWidth,
      normalizedHeight
    });
    context.save();
    context.scale(appState.zoom.value, appState.zoom.value);
    if (newElement5 && newElement5.type !== "selection") {
      if (isInvisiblySmallElement2(newElement5)) {
        return;
      }
      const frameId = newElement5.frameId || appState.frameToHighlight?.id;
      if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
        const frame = getTargetFrame(newElement5, elementsMap, appState);
        if (frame && shouldApplyFrameClip(newElement5, frame, appState, elementsMap)) {
          frameClip(frame, context, renderConfig, appState);
        }
      }
      renderElement(
        newElement5,
        elementsMap,
        allElementsMap,
        rc,
        context,
        renderConfig,
        appState
      );
    } else {
      context.clearRect(0, 0, normalizedWidth, normalizedHeight);
    }
    context.restore();
  }
};
var renderNewElementSceneThrottled = throttleRAF2(
  (config) => {
    _renderNewElementScene(config);
  },
  { trailing: true }
);
var renderNewElementScene = (renderConfig, throttle5) => {
  if (throttle5) {
    renderNewElementSceneThrottled(renderConfig);
    return;
  }
  _renderNewElementScene(renderConfig);
};

// components/canvases/NewElementCanvas.tsx
import { jsx as jsx148 } from "react/jsx-runtime";
var NewElementCanvas = (props) => {
  const canvasRef = useRef43(null);
  useEffect46(() => {
    if (!canvasRef.current) {
      return;
    }
    renderNewElementScene(
      {
        canvas: canvasRef.current,
        scale: props.scale,
        newElement: props.appState.newElement,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        rc: props.rc,
        renderConfig: props.renderConfig,
        appState: props.appState
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ jsx148(
    "canvas",
    {
      className: "excalidraw__canvas",
      style: {
        width: props.appState.width,
        height: props.appState.height
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: canvasRef
    }
  );
};
var NewElementCanvas_default = NewElementCanvas;

// components/Toast.tsx
import { useCallback as useCallback21, useEffect as useEffect47, useRef as useRef44 } from "react";
import { jsx as jsx149, jsxs as jsxs86 } from "react/jsx-runtime";
var DEFAULT_TOAST_TIMEOUT = 5e3;
var Toast = ({
  message,
  onClose,
  closable = false,
  // To prevent autoclose, pass duration as Infinity
  duration = DEFAULT_TOAST_TIMEOUT,
  style
}) => {
  const timerRef = useRef44(0);
  const shouldAutoClose = duration !== Infinity;
  const scheduleTimeout = useCallback21(() => {
    if (!shouldAutoClose) {
      return;
    }
    timerRef.current = window.setTimeout(() => onClose(), duration);
  }, [onClose, duration, shouldAutoClose]);
  useEffect47(() => {
    if (!shouldAutoClose) {
      return;
    }
    scheduleTimeout();
    return () => clearTimeout(timerRef.current);
  }, [scheduleTimeout, message, duration, shouldAutoClose]);
  const onMouseEnter = shouldAutoClose ? () => clearTimeout(timerRef?.current) : void 0;
  const onMouseLeave = shouldAutoClose ? scheduleTimeout : void 0;
  return /* @__PURE__ */ jsxs86(
    "div",
    {
      className: "Toast",
      onMouseEnter,
      onMouseLeave,
      style,
      children: [
        /* @__PURE__ */ jsx149("p", { className: "Toast__message", children: message }),
        closable && /* @__PURE__ */ jsx149(
          ToolButton,
          {
            icon: CloseIcon,
            "aria-label": "close",
            type: "icon",
            onClick: onClose,
            className: "close"
          }
        )
      ]
    }
  );
};

// components/UnlockPopup.tsx
import {
  getCommonBounds as getCommonBounds7,
  getElementsInGroup as getElementsInGroup7,
  selectGroupsFromGivenElements as selectGroupsFromGivenElements4
} from "@excalidraw/element";
import { sceneCoordsToViewportCoords as sceneCoordsToViewportCoords7 } from "@excalidraw/common";
import { flushSync as flushSync2 } from "react-dom";
import { jsx as jsx150 } from "react/jsx-runtime";
var UnlockPopup = ({
  app,
  activeLockedId
}) => {
  const element = app.scene.getElement(activeLockedId);
  const elements = element ? [element] : getElementsInGroup7(app.scene.getNonDeletedElementsMap(), activeLockedId);
  if (elements.length === 0) {
    return null;
  }
  const [x, y] = getCommonBounds7(elements);
  const { x: viewX, y: viewY } = sceneCoordsToViewportCoords7(
    { sceneX: x, sceneY: y },
    app.state
  );
  return /* @__PURE__ */ jsx150(
    "div",
    {
      className: "UnlockPopup",
      style: {
        bottom: `${app.state.height + 12 - viewY + app.state.offsetTop}px`,
        left: `${viewX - app.state.offsetLeft}px`
      },
      onClick: () => {
        flushSync2(() => {
          const groupIds = selectGroupsFromGivenElements4(elements, app.state);
          app.setState({
            selectedElementIds: elements.reduce(
              (acc, element2) => ({
                ...acc,
                [element2.id]: true
              }),
              {}
            ),
            selectedGroupIds: groupIds,
            activeLockedId: null
          });
        });
        app.actionManager.executeAction(actionToggleElementLock);
      },
      title: t("labels.elementLock.unlock"),
      children: LockedIconFilled
    }
  );
};
var UnlockPopup_default = UnlockPopup;

// components/App.tsx
import { Fragment as Fragment27, jsx as jsx151, jsxs as jsxs87 } from "react/jsx-runtime";
var AppContext = React47.createContext(null);
var AppPropsContext = React47.createContext(null);
var editorInterfaceContextInitialValue = {
  formFactor: "desktop",
  desktopUIMode: "compact",
  userAgent: createUserAgentDescriptor(
    typeof navigator !== "undefined" ? navigator.userAgent : ""
  ),
  isTouchScreen: false,
  canFitSidebar: false,
  isLandscape: true
};
var EditorInterfaceContext = React47.createContext(
  editorInterfaceContextInitialValue
);
EditorInterfaceContext.displayName = "EditorInterfaceContext";
var ExcalidrawContainerContext = React47.createContext({ container: null, id: null });
ExcalidrawContainerContext.displayName = "ExcalidrawContainerContext";
var ExcalidrawElementsContext = React47.createContext([]);
ExcalidrawElementsContext.displayName = "ExcalidrawElementsContext";
var ExcalidrawAppStateContext = React47.createContext({
  ...getDefaultAppState(),
  width: 0,
  height: 0,
  offsetLeft: 0,
  offsetTop: 0
});
ExcalidrawAppStateContext.displayName = "ExcalidrawAppStateContext";
var ExcalidrawSetAppStateContext = React47.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
ExcalidrawSetAppStateContext.displayName = "ExcalidrawSetAppStateContext";
var ExcalidrawActionManagerContext = React47.createContext(
  null
);
ExcalidrawActionManagerContext.displayName = "ExcalidrawActionManagerContext";
var useApp = () => useContext3(AppContext);
var useAppProps = () => useContext3(AppPropsContext);
var useEditorInterface = () => useContext3(EditorInterfaceContext);
var useStylesPanelMode = () => deriveStylesPanelMode2(useEditorInterface());
var useExcalidrawContainer = () => useContext3(ExcalidrawContainerContext);
var useExcalidrawElements = () => useContext3(ExcalidrawElementsContext);
var useExcalidrawAppState = () => useContext3(ExcalidrawAppStateContext);
var useExcalidrawSetAppState = () => useContext3(ExcalidrawSetAppStateContext);
var useExcalidrawActionManager = () => useContext3(ExcalidrawActionManagerContext);
var didTapTwice = false;
var tappedTwiceTimer = 0;
var firstTapPosition = null;
var isHoldingSpace = false;
var isPanning = false;
var isDraggingScrollBar = false;
var currentScrollBars = { horizontal: null, vertical: null };
var touchTimeout = 0;
var invalidateContextMenu = false;
var YOUTUBE_VIDEO_STATES = /* @__PURE__ */ new Map();
var IS_PLAIN_PASTE = false;
var IS_PLAIN_PASTE_TIMER = 0;
var PLAIN_PASTE_TOAST_SHOWN = false;
var lastPointerUp = null;
var gesture = {
  pointers: /* @__PURE__ */ new Map(),
  lastCenter: null,
  initialDistance: null,
  initialScale: null
};
var App = class _App extends React47.Component {
  constructor(props) {
    super(props);
    __publicField(this, "canvas");
    __publicField(this, "interactiveCanvas", null);
    __publicField(this, "rc");
    __publicField(this, "unmounted", false);
    __publicField(this, "actionManager");
    __publicField(this, "editorInterface", editorInterfaceContextInitialValue);
    __publicField(this, "stylesPanelMode", deriveStylesPanelMode2(
      editorInterfaceContextInitialValue
    ));
    __publicField(this, "excalidrawContainerRef", React47.createRef());
    __publicField(this, "scene");
    __publicField(this, "fonts");
    __publicField(this, "renderer");
    __publicField(this, "visibleElements");
    __publicField(this, "resizeObserver");
    __publicField(this, "library");
    __publicField(this, "libraryItemsFromStorage");
    __publicField(this, "id");
    __publicField(this, "store");
    __publicField(this, "history");
    __publicField(this, "excalidrawContainerValue");
    __publicField(this, "files", {});
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "iFrameRefs", /* @__PURE__ */ new Map());
    /**
     * Indicates whether the embeddable's url has been validated for rendering.
     * If value not set, indicates that the validation is pending.
     * Initially or on url change the flag is not reset so that we can guarantee
     * the validation came from a trusted source (the editor).
     **/
    __publicField(this, "embedsValidationStatus", /* @__PURE__ */ new Map());
    /** embeds that have been inserted to DOM (as a perf optim, we don't want to
     * insert to DOM before user initially scrolls to them) */
    __publicField(this, "initializedEmbeds", /* @__PURE__ */ new Set());
    __publicField(this, "handleToastClose", () => {
      this.setToast(null);
    });
    __publicField(this, "elementsPendingErasure", /* @__PURE__ */ new Set());
    __publicField(this, "flowChartCreator", new FlowChartCreator());
    __publicField(this, "flowChartNavigator", new FlowChartNavigator());
    __publicField(this, "bindModeHandler", null);
    __publicField(this, "hitLinkElement");
    __publicField(this, "lastPointerDownEvent", null);
    __publicField(this, "lastPointerUpEvent", null);
    __publicField(this, "lastPointerMoveEvent", null);
    /** current frame pointer cords */
    __publicField(this, "lastPointerMoveCoords", null);
    /** previous frame pointer coords */
    __publicField(this, "previousPointerMoveCoords", null);
    __publicField(this, "lastViewportPosition", { x: 0, y: 0 });
    __publicField(this, "animationFrameHandler", new AnimationFrameHandler());
    __publicField(this, "laserTrails", new LaserTrails(this.animationFrameHandler, this));
    __publicField(this, "eraserTrail", new EraserTrail(this.animationFrameHandler, this));
    __publicField(this, "lassoTrail", new LassoTrail(this.animationFrameHandler, this));
    __publicField(this, "onChangeEmitter", new Emitter3());
    __publicField(this, "onPointerDownEmitter", new Emitter3());
    __publicField(this, "onPointerUpEmitter", new Emitter3());
    __publicField(this, "onUserFollowEmitter", new Emitter3());
    __publicField(this, "onScrollChangeEmitter", new Emitter3());
    __publicField(this, "missingPointerEventCleanupEmitter", new Emitter3());
    __publicField(this, "onRemoveEventListenersEmitter", new Emitter3());
    __publicField(this, "updateEditorAtom", (atom2, ...args) => {
      const result = editorJotaiStore.set(atom2, ...args);
      this.triggerRender();
      return result;
    });
    __publicField(this, "previousHoveredBindableElement", null);
    /**
     * Returns gridSize taking into account `gridModeEnabled`.
     * If disabled, returns null.
     */
    __publicField(this, "getEffectiveGridSize", () => {
      return isGridModeEnabled(this) ? this.state.gridSize : null;
    });
    __publicField(this, "updateEmbedValidationStatus", (element, status) => {
      this.embedsValidationStatus.set(element.id, status);
      ShapeCache4.delete(element);
    });
    __publicField(this, "updateEmbeddables", () => {
      const iframeLikes = /* @__PURE__ */ new Set();
      let updated = false;
      this.scene.getNonDeletedElements().filter((element) => {
        if (isEmbeddableElement4(element)) {
          iframeLikes.add(element.id);
          if (!this.embedsValidationStatus.has(element.id)) {
            updated = true;
            const validated = embeddableURLValidator2(
              element.link,
              this.props.validateEmbeddable
            );
            this.updateEmbedValidationStatus(element, validated);
          }
        } else if (isIframeElement2(element)) {
          iframeLikes.add(element.id);
        }
        return false;
      });
      if (updated) {
        this.scene.triggerUpdate();
      }
      this.iFrameRefs.forEach((ref, id) => {
        if (!iframeLikes.has(id)) {
          this.iFrameRefs.delete(id);
        }
      });
    });
    __publicField(this, "getFrameNameDOMId", (frameElement) => {
      return `${this.id}-frame-name-${frameElement.id}`;
    });
    __publicField(this, "frameNameBoundsCache", {
      get: (frameElement) => {
        let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);
        if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {
          const frameNameDiv = document.getElementById(
            this.getFrameNameDOMId(frameElement)
          );
          if (frameNameDiv) {
            const box = frameNameDiv.getBoundingClientRect();
            const boxSceneTopLeft = viewportCoordsToSceneCoords3(
              { clientX: box.x, clientY: box.y },
              this.state
            );
            const boxSceneBottomRight = viewportCoordsToSceneCoords3(
              { clientX: box.right, clientY: box.bottom },
              this.state
            );
            bounds = {
              x: boxSceneTopLeft.x,
              y: boxSceneTopLeft.y,
              width: boxSceneBottomRight.x - boxSceneTopLeft.x,
              height: boxSceneBottomRight.y - boxSceneTopLeft.y,
              angle: 0,
              zoom: this.state.zoom.value,
              versionNonce: frameElement.versionNonce
            };
            this.frameNameBoundsCache._cache.set(frameElement.id, bounds);
            return bounds;
          }
          return null;
        }
        return bounds;
      },
      /**
       * @private
       */
      _cache: /* @__PURE__ */ new Map()
    });
    __publicField(this, "resetEditingFrame", (frame) => {
      if (frame) {
        this.scene.mutateElement(frame, { name: frame.name?.trim() || null });
      }
      this.setState({ editingFrame: null });
    });
    __publicField(this, "renderFrameNames", () => {
      if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {
        if (this.state.editingFrame) {
          this.resetEditingFrame(null);
        }
        return null;
      }
      const isDarkTheme = this.state.theme === THEME18.DARK;
      const nonDeletedFramesLikes = this.scene.getNonDeletedFramesLikes();
      const focusedSearchMatch = nonDeletedFramesLikes.length > 0 ? this.state.searchMatches?.focusedId && isFrameLikeElement12(
        this.scene.getElement(this.state.searchMatches.focusedId)
      ) ? this.state.searchMatches.matches.find((sm) => sm.focus) : null : null;
      return nonDeletedFramesLikes.map((f) => {
        if (!isElementInViewport3(
          f,
          this.canvas.width / window.devicePixelRatio,
          this.canvas.height / window.devicePixelRatio,
          {
            offsetLeft: this.state.offsetLeft,
            offsetTop: this.state.offsetTop,
            scrollX: this.state.scrollX,
            scrollY: this.state.scrollY,
            zoom: this.state.zoom
          },
          this.scene.getNonDeletedElementsMap()
        )) {
          if (this.state.editingFrame === f.id) {
            this.resetEditingFrame(f);
          }
          return null;
        }
        const { x: x1, y: y1 } = sceneCoordsToViewportCoords8(
          { sceneX: f.x, sceneY: f.y },
          this.state
        );
        const FRAME_NAME_EDIT_PADDING = 6;
        let frameNameJSX;
        const frameName = getFrameLikeTitle(f);
        if (f.id === this.state.editingFrame) {
          const frameNameInEdit = frameName;
          frameNameJSX = /* @__PURE__ */ jsx151(
            "input",
            {
              autoFocus: true,
              value: frameNameInEdit,
              onChange: (e) => {
                this.scene.mutateElement(f, {
                  name: e.target.value
                });
              },
              onFocus: (e) => e.target.select(),
              onBlur: () => this.resetEditingFrame(f),
              onKeyDown: (event) => {
                if (event.key === KEYS54.ESCAPE || event.key === KEYS54.ENTER) {
                  this.resetEditingFrame(f);
                }
              },
              style: {
                background: isDarkTheme ? applyDarkModeFilter5(this.state.viewBackgroundColor) : this.state.viewBackgroundColor,
                zIndex: 2,
                border: "none",
                display: "block",
                padding: `${FRAME_NAME_EDIT_PADDING}px`,
                borderRadius: 4,
                boxShadow: "inset 0 0 0 1px var(--color-primary)",
                fontFamily: "Assistant",
                fontSize: `${FRAME_STYLE5.nameFontSize}px`,
                transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,
                color: isDarkTheme ? FRAME_STYLE5.nameColorDarkTheme : FRAME_STYLE5.nameColorLightTheme,
                overflow: "hidden",
                maxWidth: `${document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING}px`
              },
              size: frameNameInEdit.length + 1 || 1,
              dir: "auto",
              autoComplete: "off",
              autoCapitalize: "off",
              autoCorrect: "off"
            }
          );
        } else {
          frameNameJSX = frameName;
        }
        return /* @__PURE__ */ jsx151(
          "div",
          {
            id: this.getFrameNameDOMId(f),
            className: CLASSES11.FRAME_NAME,
            style: {
              position: "absolute",
              // Positioning from bottom so that we don't to either
              // calculate text height or adjust using transform (which)
              // messes up input position when editing the frame name.
              // This makes the positioning deterministic and we can calculate
              // the same position when rendering to canvas / svg.
              bottom: `${this.state.height + FRAME_STYLE5.nameOffsetY - y1 + this.state.offsetTop}px`,
              left: `${x1 - this.state.offsetLeft}px`,
              zIndex: 2,
              fontSize: FRAME_STYLE5.nameFontSize,
              color: isDarkTheme ? FRAME_STYLE5.nameColorDarkTheme : FRAME_STYLE5.nameColorLightTheme,
              lineHeight: FRAME_STYLE5.nameLineHeight,
              width: "max-content",
              maxWidth: focusedSearchMatch?.id === f.id && focusedSearchMatch?.focus ? "none" : `${f.width * this.state.zoom.value}px`,
              overflow: f.id === this.state.editingFrame ? "visible" : "hidden",
              whiteSpace: "nowrap",
              textOverflow: "ellipsis",
              cursor: CURSOR_TYPE4.MOVE,
              pointerEvents: this.state.viewModeEnabled ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
            },
            onPointerDown: (event) => this.handleCanvasPointerDown(event),
            onWheel: (event) => this.handleWheel(event),
            onContextMenu: this.handleCanvasContextMenu,
            onDoubleClick: () => {
              this.setState({
                editingFrame: f.id
              });
            },
            children: frameNameJSX
          },
          f.id
        );
      });
    });
    __publicField(this, "focusContainer", () => {
      this.excalidrawContainerRef.current?.focus();
    });
    __publicField(this, "getSceneElementsIncludingDeleted", () => {
      return this.scene.getElementsIncludingDeleted();
    });
    __publicField(this, "getSceneElementsMapIncludingDeleted", () => {
      return this.scene.getElementsMapIncludingDeleted();
    });
    __publicField(this, "getSceneElements", () => {
      return this.scene.getNonDeletedElements();
    });
    __publicField(this, "onInsertElements", (elements) => {
      this.addElementsFromPasteOrLibrary({
        elements,
        position: "center",
        files: null
      });
    });
    __publicField(this, "onExportImage", async (type, elements, opts) => {
      trackEvent("export", type, "ui");
      const fileHandle = await exportCanvas(
        type,
        elements,
        this.state,
        this.files,
        {
          exportBackground: this.state.exportBackground,
          name: this.getName(),
          viewBackgroundColor: this.state.viewBackgroundColor,
          exportingFrame: opts.exportingFrame
        }
      ).catch(muteFSAbortError2).catch((error) => {
        console.error(error);
        this.setState({ errorMessage: error.message });
      });
      if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {
        this.setState({ fileHandle });
      }
    });
    __publicField(this, "magicGenerations", /* @__PURE__ */ new Map());
    __publicField(this, "updateMagicGeneration", ({
      frameElement,
      data
    }) => {
      if (data.status === "pending") {
        this.scene.mutateElement(
          frameElement,
          {
            customData: { generationData: void 0 }
          },
          { informMutation: false, isDragging: false }
        );
      } else {
        this.scene.mutateElement(
          frameElement,
          {
            customData: { generationData: data }
          },
          { informMutation: false, isDragging: false }
        );
      }
      this.magicGenerations.set(frameElement.id, data);
      this.triggerRender();
    });
    __publicField(this, "plugins", {});
    __publicField(this, "onMagicframeToolSelect", () => {
      const selectedElements = this.scene.getSelectedElements({
        selectedElementIds: this.state.selectedElementIds
      });
      if (selectedElements.length === 0) {
        this.setActiveTool({ type: TOOL_TYPE3.magicframe });
        trackEvent("ai", "tool-select (empty-selection)", "d2c");
      } else {
        const selectedMagicFrame = selectedElements.length === 1 && isMagicFrameElement2(selectedElements[0]) && selectedElements[0];
        if (!selectedMagicFrame && selectedElements.some((el) => isFrameLikeElement12(el) || el.frameId)) {
          this.setActiveTool({ type: TOOL_TYPE3.magicframe });
          return;
        }
        trackEvent("ai", "tool-select (existing selection)", "d2c");
        let frame;
        if (selectedMagicFrame) {
          frame = selectedMagicFrame;
        } else {
          const [minX, minY, maxX, maxY] = getCommonBounds8(selectedElements);
          const padding = 50;
          frame = newMagicFrameElement({
            ...FRAME_STYLE5,
            x: minX - padding,
            y: minY - padding,
            width: maxX - minX + padding * 2,
            height: maxY - minY + padding * 2,
            opacity: 100,
            locked: false
          });
          this.scene.insertElement(frame);
          for (const child of selectedElements) {
            this.scene.mutateElement(child, { frameId: frame.id });
          }
          this.setState({
            selectedElementIds: { [frame.id]: true }
          });
        }
        this.onMagicFrameGenerate(frame, "upstream");
      }
    });
    __publicField(this, "openEyeDropper", ({ type }) => {
      this.updateEditorAtom(activeEyeDropperAtom, {
        swapPreviewOnAlt: true,
        colorPickerType: type === "stroke" ? "elementStroke" : "elementBackground",
        onSelect: (color, event) => {
          const shouldUpdateStrokeColor = type === "background" && event.altKey || type === "stroke" && !event.altKey;
          const selectedElements = this.scene.getSelectedElements(this.state);
          if (!selectedElements.length || this.state.activeTool.type !== "selection") {
            if (shouldUpdateStrokeColor) {
              this.syncActionResult({
                appState: { ...this.state, currentItemStrokeColor: color },
                captureUpdate: CaptureUpdateAction36.IMMEDIATELY
              });
            } else {
              this.syncActionResult({
                appState: { ...this.state, currentItemBackgroundColor: color },
                captureUpdate: CaptureUpdateAction36.IMMEDIATELY
              });
            }
          } else {
            this.updateScene({
              elements: this.scene.getElementsIncludingDeleted().map((el) => {
                if (this.state.selectedElementIds[el.id]) {
                  return newElementWith11(el, {
                    [shouldUpdateStrokeColor ? "strokeColor" : "backgroundColor"]: color
                  });
                }
                return el;
              }),
              captureUpdate: CaptureUpdateAction36.IMMEDIATELY
            });
          }
        },
        keepOpenOnAlt: false
      });
    });
    __publicField(this, "dismissLinearEditor", () => {
      setTimeout(() => {
        if (this.state.selectedLinearElement?.isEditing) {
          this.setState({
            selectedLinearElement: {
              ...this.state.selectedLinearElement,
              isEditing: false
            }
          });
        }
      });
    });
    __publicField(this, "syncActionResult", withBatchedUpdates((actionResult) => {
      if (this.unmounted || actionResult === false) {
        return;
      }
      this.store.scheduleAction(actionResult.captureUpdate);
      let didUpdate = false;
      let editingTextElement = null;
      if (actionResult.elements) {
        this.scene.replaceAllElements(actionResult.elements);
        didUpdate = true;
      }
      if (actionResult.files) {
        this.addMissingFiles(actionResult.files, actionResult.replaceFiles);
        this.addNewImagesToImageCache();
      }
      if (actionResult.appState || editingTextElement || this.state.contextMenu) {
        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;
        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;
        const theme = actionResult?.appState?.theme || this.props.theme || THEME18.LIGHT;
        const name = actionResult?.appState?.name ?? this.state.name;
        const errorMessage = actionResult?.appState?.errorMessage ?? this.state.errorMessage;
        if (typeof this.props.viewModeEnabled !== "undefined") {
          viewModeEnabled = this.props.viewModeEnabled;
        }
        if (typeof this.props.zenModeEnabled !== "undefined") {
          zenModeEnabled = this.props.zenModeEnabled;
        }
        editingTextElement = actionResult.appState?.editingTextElement || null;
        if (actionResult.elements && editingTextElement) {
          actionResult.elements.forEach((element) => {
            if (editingTextElement?.id === element.id && editingTextElement !== element && isNonDeletedElement(element) && isTextElement16(element)) {
              editingTextElement = element;
            }
          });
        }
        if (editingTextElement?.isDeleted) {
          editingTextElement = null;
        }
        this.setState((prevAppState) => {
          const actionAppState = actionResult.appState || {};
          return {
            ...prevAppState,
            ...actionAppState,
            // NOTE this will prevent opening context menu using an action
            // or programmatically from the host, so it will need to be
            // rewritten later
            contextMenu: null,
            editingTextElement,
            viewModeEnabled,
            zenModeEnabled,
            theme,
            name,
            errorMessage
          };
        });
        didUpdate = true;
      }
      if (!didUpdate) {
        this.scene.triggerUpdate();
      }
    }));
    // Lifecycle
    __publicField(this, "onBlur", withBatchedUpdates(() => {
      isHoldingSpace = false;
      this.setState({ isBindingEnabled: true });
    }));
    __publicField(this, "onUnload", () => {
      this.onBlur();
    });
    __publicField(this, "disableEvent", (event) => {
      event.preventDefault();
    });
    __publicField(this, "resetHistory", () => {
      this.history.clear();
    });
    __publicField(this, "resetStore", () => {
      this.store.clear();
    });
    /**
     * Resets scene & history.
     * ! Do not use to clear scene user action !
     */
    __publicField(this, "resetScene", withBatchedUpdates(
      (opts) => {
        this.scene.replaceAllElements([]);
        this.setState((state) => ({
          ...getDefaultAppState(),
          isLoading: opts?.resetLoadingState ? false : state.isLoading,
          theme: this.state.theme
        }));
        this.resetStore();
        this.resetHistory();
      }
    ));
    __publicField(this, "initializeScene", async () => {
      if ("launchQueue" in window && "LaunchParams" in window) {
        window.launchQueue.setConsumer(
          async (launchParams) => {
            if (!launchParams.files.length) {
              return;
            }
            const fileHandle = launchParams.files[0];
            const blob = await fileHandle.getFile();
            this.loadFileToCanvas(
              new File([blob], blob.name || "", { type: blob.type }),
              fileHandle
            );
          }
        );
      }
      if (this.props.theme) {
        this.setState({ theme: this.props.theme });
      }
      if (!this.state.isLoading) {
        this.setState({ isLoading: true });
      }
      let initialData = null;
      try {
        if (typeof this.props.initialData === "function") {
          initialData = await this.props.initialData() || null;
        } else {
          initialData = await this.props.initialData || null;
        }
        if (initialData?.libraryItems) {
          this.library.updateLibrary({
            libraryItems: initialData.libraryItems,
            merge: true
          }).catch((error) => {
            console.error(error);
          });
        }
      } catch (error) {
        console.error(error);
        initialData = {
          appState: {
            errorMessage: error.message || "Encountered an error during importing or restoring scene data"
          }
        };
      }
      const restoredElements = restoreElements(initialData?.elements, null, {
        repairBindings: true,
        deleteInvisibleElements: true
      });
      let restoredAppState = restoreAppState(initialData?.appState, null);
      const activeTool = restoredAppState.activeTool;
      if (!restoredAppState.preferredSelectionTool.initialized) {
        restoredAppState.preferredSelectionTool = {
          type: this.editorInterface.formFactor === "phone" ? "lasso" : "selection",
          initialized: true
        };
      }
      restoredAppState = {
        ...restoredAppState,
        theme: this.props.theme || restoredAppState.theme,
        // we're falling back to current (pre-init) state when deciding
        // whether to open the library, to handle a case where we
        // update the state outside of initialData (e.g. when loading the app
        // with a library install link, which should auto-open the library)
        openSidebar: restoredAppState?.openSidebar || this.state.openSidebar,
        activeTool: activeTool.type === "image" || activeTool.type === "lasso" || activeTool.type === "selection" ? {
          ...activeTool,
          type: restoredAppState.preferredSelectionTool.type
        } : restoredAppState.activeTool,
        isLoading: false,
        toast: this.state.toast
      };
      if (initialData?.scrollToContent) {
        restoredAppState = {
          ...restoredAppState,
          ...calculateScrollCenter(restoredElements, {
            ...restoredAppState,
            width: this.state.width,
            height: this.state.height,
            offsetTop: this.state.offsetTop,
            offsetLeft: this.state.offsetLeft
          })
        };
      }
      this.resetStore();
      this.resetHistory();
      this.syncActionResult({
        elements: restoredElements,
        appState: restoredAppState,
        files: initialData?.files,
        captureUpdate: CaptureUpdateAction36.NEVER
      });
      this.clearImageShapeCache();
      this.fonts.loadSceneFonts().then((fontFaces) => {
        this.fonts.onLoaded(fontFaces);
      });
      if (isElementLink2(window.location.href)) {
        this.scrollToContent(window.location.href, { animate: false });
      }
    });
    __publicField(this, "getFormFactor", (editorWidth, editorHeight) => {
      return this.props.UIOptions.getFormFactor?.(editorWidth, editorHeight) ?? getFormFactor(editorWidth, editorHeight);
    });
    __publicField(this, "refreshEditorInterface", () => {
      const container = this.excalidrawContainerRef.current;
      if (!container) {
        return;
      }
      const { width: editorWidth, height: editorHeight } = container.getBoundingClientRect();
      const storedDesktopUIMode = loadDesktopUIModePreference();
      const userAgentDescriptor = createUserAgentDescriptor(
        typeof navigator !== "undefined" ? navigator.userAgent : ""
      );
      const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;
      const nextEditorInterface = updateObject2(this.editorInterface, {
        desktopUIMode: storedDesktopUIMode ?? this.editorInterface.desktopUIMode,
        formFactor: this.getFormFactor(editorWidth, editorHeight),
        userAgent: userAgentDescriptor,
        canFitSidebar: editorWidth > sidebarBreakpoint,
        isLandscape: editorWidth > editorHeight
      });
      this.editorInterface = nextEditorInterface;
      this.reconcileStylesPanelMode(nextEditorInterface);
    });
    __publicField(this, "reconcileStylesPanelMode", (nextEditorInterface) => {
      const nextStylesPanelMode = deriveStylesPanelMode2(nextEditorInterface);
      if (nextStylesPanelMode === this.stylesPanelMode) {
        return;
      }
      const prevStylesPanelMode = this.stylesPanelMode;
      this.stylesPanelMode = nextStylesPanelMode;
      if (prevStylesPanelMode !== "full" && nextStylesPanelMode === "full") {
        this.setState((prevState) => ({
          preferredSelectionTool: {
            type: "selection",
            initialized: true
          }
        }));
      }
    });
    /** TO BE USED LATER */
    __publicField(this, "setDesktopUIMode", (mode) => {
      const nextMode = setDesktopUIMode(mode);
      this.editorInterface = updateObject2(this.editorInterface, {
        desktopUIMode: nextMode
      });
      this.reconcileStylesPanelMode(this.editorInterface);
    });
    __publicField(this, "onResize", withBatchedUpdates(() => {
      this.scene.getElementsIncludingDeleted().forEach((element) => ShapeCache4.delete(element));
      this.refreshEditorInterface();
      this.updateDOMRect();
      this.setState({});
    }));
    /** generally invoked only if fullscreen was invoked programmatically */
    __publicField(this, "onFullscreenChange", () => {
      if (
        // points to the iframe element we fullscreened
        !document.fullscreenElement && this.state.activeEmbeddable?.state === "active"
      ) {
        this.setState({
          activeEmbeddable: null
        });
      }
    });
    __publicField(this, "renderInteractiveSceneCallback", ({
      atLeastOneVisibleElement,
      scrollBars,
      elementsMap
    }) => {
      if (scrollBars) {
        currentScrollBars = scrollBars;
      }
      const scrolledOutside = (
        // hide when editing text
        this.state.editingTextElement ? false : !atLeastOneVisibleElement && elementsMap.size > 0
      );
      if (this.state.scrolledOutside !== scrolledOutside) {
        this.setState({ scrolledOutside });
      }
      this.scheduleImageRefresh();
    });
    __publicField(this, "onScroll", debounce4(() => {
      const { offsetTop, offsetLeft } = this.getCanvasOffsets();
      this.setState((state) => {
        if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {
          return null;
        }
        return { offsetTop, offsetLeft };
      });
    }, SCROLL_TIMEOUT));
    // Copy/paste
    __publicField(this, "onCut", withBatchedUpdates((event) => {
      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
        document.activeElement
      );
      if (!isExcalidrawActive || isWritableElement5(event.target)) {
        return;
      }
      this.actionManager.executeAction(actionCut, "keyboard", event);
      event.preventDefault();
      event.stopPropagation();
    }));
    __publicField(this, "onCopy", withBatchedUpdates((event) => {
      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
        document.activeElement
      );
      if (!isExcalidrawActive || isWritableElement5(event.target)) {
        return;
      }
      this.actionManager.executeAction(actionCopy, "keyboard", event);
      event.preventDefault();
      event.stopPropagation();
    }));
    __publicField(this, "onTouchStart", (event) => {
      if (isIOS) {
        event.preventDefault();
      }
      if (!didTapTwice) {
        didTapTwice = true;
        if (event.touches.length === 1) {
          firstTapPosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
          };
        }
        clearTimeout(tappedTwiceTimer);
        tappedTwiceTimer = window.setTimeout(
          _App.resetTapTwice,
          TAP_TWICE_TIMEOUT
        );
        return;
      }
      if (didTapTwice && event.touches.length === 1 && firstTapPosition) {
        const touch = event.touches[0];
        const distance3 = pointDistance8(
          pointFrom26(touch.clientX, touch.clientY),
          pointFrom26(firstTapPosition.x, firstTapPosition.y)
        );
        if (distance3 <= DOUBLE_TAP_POSITION_THRESHOLD) {
          this.lassoTrail.endPath();
          this.deselectElements();
          this.handleCanvasDoubleClick({
            clientX: touch.clientX,
            clientY: touch.clientY
          });
        }
        didTapTwice = false;
        clearTimeout(tappedTwiceTimer);
      }
      if (event.touches.length === 2) {
        this.setState({
          selectedElementIds: makeNextSelectedElementIds2({}, this.state),
          activeEmbeddable: null
        });
      }
    });
    __publicField(this, "onTouchEnd", (event) => {
      this.resetContextMenuTimer();
      if (event.touches.length > 0) {
        this.setState({
          previousSelectedElementIds: {},
          selectedElementIds: makeNextSelectedElementIds2(
            this.state.previousSelectedElementIds,
            this.state
          )
        });
      } else {
        gesture.pointers.clear();
      }
    });
    __publicField(this, "pasteFromClipboard", withBatchedUpdates(
      async (event) => {
        const isPlainPaste = !!IS_PLAIN_PASTE;
        const target = document.activeElement;
        const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(target);
        if (event && !isExcalidrawActive) {
          return;
        }
        const elementUnderCursor = document.elementFromPoint(
          this.lastViewportPosition.x,
          this.lastViewportPosition.y
        );
        if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement5(target))) {
          return;
        }
        const dataTransferList = await parseDataTransferEvent(event);
        const filesList = dataTransferList.getFiles();
        const data = await parseClipboard(dataTransferList, isPlainPaste);
        if (this.props.onPaste) {
          try {
            if (await this.props.onPaste(data, event) === false) {
              return;
            }
          } catch (error) {
            console.error(error);
          }
        }
        await this.insertClipboardContent(data, filesList, isPlainPaste);
        this.setActiveTool(
          { type: this.state.preferredSelectionTool.type },
          true
        );
        event?.preventDefault();
      }
    ));
    __publicField(this, "addElementsFromPasteOrLibrary", (opts) => {
      const elements = restoreElements(opts.elements, null, {
        deleteInvisibleElements: true
      });
      const [minX, minY, maxX, maxY] = getCommonBounds8(elements);
      const elementsCenterX = distance2(minX, maxX) / 2;
      const elementsCenterY = distance2(minY, maxY) / 2;
      const clientX = typeof opts.position === "object" ? opts.position.clientX : opts.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;
      const clientY = typeof opts.position === "object" ? opts.position.clientY : opts.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;
      const { x, y } = viewportCoordsToSceneCoords3(
        { clientX, clientY },
        this.state
      );
      const dx = x - elementsCenterX;
      const dy = y - elementsCenterY;
      const [gridX, gridY] = getGridPoint2(dx, dy, this.getEffectiveGridSize());
      const { duplicatedElements } = duplicateElements3({
        type: "everything",
        elements: elements.map((element) => {
          return newElementWith11(element, {
            x: element.x + gridX - minX,
            y: element.y + gridY - minY
          });
        }),
        randomizeSeed: !opts.retainSeed
      });
      const prevElements = this.scene.getElementsIncludingDeleted();
      let nextElements = [...prevElements, ...duplicatedElements];
      const mappedNewSceneElements = this.props.onDuplicate?.(
        nextElements,
        prevElements
      );
      nextElements = mappedNewSceneElements || nextElements;
      syncMovedIndices4(nextElements, arrayToMap26(duplicatedElements));
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x, y });
      if (topLayerFrame) {
        const eligibleElements = filterElementsEligibleAsFrameChildren(
          duplicatedElements,
          topLayerFrame
        );
        addElementsToFrame2(
          nextElements,
          eligibleElements,
          topLayerFrame,
          this.state
        );
      }
      this.scene.replaceAllElements(nextElements);
      duplicatedElements.forEach((newElement5) => {
        if (isTextElement16(newElement5) && isBoundToContainer9(newElement5)) {
          const container = getContainerElement7(
            newElement5,
            this.scene.getElementsMapIncludingDeleted()
          );
          redrawTextBoundingBox6(newElement5, container, this.scene);
        }
      });
      if (isSafari2) {
        Fonts.loadElementsFonts(duplicatedElements).then((fontFaces) => {
          this.fonts.onLoaded(fontFaces);
        });
      }
      if (opts.files) {
        this.addMissingFiles(opts.files);
      }
      const nextElementsToSelect = excludeElementsInFramesFromSelection(duplicatedElements);
      this.store.scheduleCapture();
      this.setState(
        {
          ...this.state,
          // keep sidebar (presumably the library) open if it's docked and
          // can fit.
          //
          // Note, we should close the sidebar only if we're dropping items
          // from library, not when pasting from clipboard. Alas.
          openSidebar: this.state.openSidebar && this.editorInterface.canFitSidebar && editorJotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,
          ...selectGroupsForSelectedElements6(
            {
              editingGroupId: null,
              selectedElementIds: nextElementsToSelect.reduce(
                (acc, element) => {
                  if (!isBoundToContainer9(element)) {
                    acc[element.id] = true;
                  }
                  return acc;
                },
                {}
              )
            },
            this.scene.getNonDeletedElements(),
            this.state,
            this
          )
        },
        () => {
          if (opts.files) {
            this.addNewImagesToImageCache();
          }
        }
      );
      this.setActiveTool({ type: this.state.preferredSelectionTool.type }, true);
      if (opts.fitToContent) {
        this.scrollToContent(duplicatedElements, {
          fitToContent: true,
          canvasOffsets: this.getEditorUIOffsets()
        });
      }
    });
    __publicField(this, "setAppState", (state, callback) => {
      this.setState(state, callback);
    });
    __publicField(this, "removePointer", (event) => {
      if (touchTimeout) {
        this.resetContextMenuTimer();
      }
      gesture.pointers.delete(event.pointerId);
    });
    __publicField(this, "toggleLock", (source = "ui") => {
      if (!this.state.activeTool.locked) {
        trackEvent(
          "toolbar",
          "toggleLock",
          `${source} (${this.editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
        );
      }
      this.setState((prevState) => {
        return {
          activeTool: {
            ...prevState.activeTool,
            ...updateActiveTool7(
              this.state,
              prevState.activeTool.locked ? { type: this.state.preferredSelectionTool.type } : prevState.activeTool
            ),
            locked: !prevState.activeTool.locked
          }
        };
      });
    });
    __publicField(this, "updateFrameRendering", (opts) => {
      this.setState((prevState) => {
        const next = typeof opts === "function" ? opts(prevState.frameRendering) : opts;
        return {
          frameRendering: {
            enabled: next?.enabled ?? prevState.frameRendering.enabled,
            clip: next?.clip ?? prevState.frameRendering.clip,
            name: next?.name ?? prevState.frameRendering.name,
            outline: next?.outline ?? prevState.frameRendering.outline
          }
        };
      });
    });
    __publicField(this, "togglePenMode", (force) => {
      this.setState((prevState) => {
        return {
          penMode: force ?? !prevState.penMode,
          penDetected: true
        };
      });
    });
    __publicField(this, "onHandToolToggle", () => {
      this.actionManager.executeAction(actionToggleHandTool);
    });
    /**
     * Zooms on canvas viewport center
     */
    __publicField(this, "zoomCanvas", (value) => {
      this.setState({
        ...getStateForZoom(
          {
            viewportX: this.state.width / 2 + this.state.offsetLeft,
            viewportY: this.state.height / 2 + this.state.offsetTop,
            nextZoom: getNormalizedZoom(value)
          },
          this.state
        )
      });
    });
    __publicField(this, "cancelInProgressAnimation", null);
    __publicField(this, "scrollToContent", (target = this.scene.getNonDeletedElements(), opts) => {
      if (typeof target === "string") {
        let id;
        if (isElementLink2(target)) {
          id = parseElementLinkFromURL(target);
        } else {
          id = target;
        }
        if (id) {
          const elements = this.scene.getElementsFromId(id);
          if (elements?.length) {
            this.scrollToContent(elements, {
              fitToContent: opts?.fitToContent ?? true,
              animate: opts?.animate ?? true
            });
          } else if (isElementLink2(target)) {
            this.setState({
              toast: {
                message: t("elementLink.notFound"),
                duration: 3e3,
                closable: true
              }
            });
          }
        }
        return;
      }
      this.cancelInProgressAnimation?.();
      const targetElements = Array.isArray(target) ? target : [target];
      let zoom = this.state.zoom;
      let scrollX = this.state.scrollX;
      let scrollY = this.state.scrollY;
      if (opts?.fitToContent || opts?.fitToViewport) {
        const { appState } = zoomToFit({
          canvasOffsets: opts.canvasOffsets,
          targetElements,
          appState: this.state,
          fitToViewport: !!opts?.fitToViewport,
          viewportZoomFactor: opts?.viewportZoomFactor,
          minZoom: opts?.minZoom,
          maxZoom: opts?.maxZoom
        });
        zoom = appState.zoom;
        scrollX = appState.scrollX;
        scrollY = appState.scrollY;
      } else {
        const scroll = calculateScrollCenter(targetElements, this.state);
        scrollX = scroll.scrollX;
        scrollY = scroll.scrollY;
      }
      if (opts?.animate) {
        const origScrollX = this.state.scrollX;
        const origScrollY = this.state.scrollY;
        const origZoom = this.state.zoom.value;
        const cancel = easeToValuesRAF({
          fromValues: {
            scrollX: origScrollX,
            scrollY: origScrollY,
            zoom: origZoom
          },
          toValues: { scrollX, scrollY, zoom: zoom.value },
          interpolateValue: (from, to, progress, key) => {
            if (key === "zoom") {
              return from * Math.pow(to / from, easeOut4(progress));
            }
            return void 0;
          },
          onStep: ({ scrollX: scrollX2, scrollY: scrollY2, zoom: zoom2 }) => {
            this.setState({
              scrollX: scrollX2,
              scrollY: scrollY2,
              zoom: { value: zoom2 }
            });
          },
          onStart: () => {
            this.setState({ shouldCacheIgnoreZoom: true });
          },
          onEnd: () => {
            this.setState({ shouldCacheIgnoreZoom: false });
          },
          onCancel: () => {
            this.setState({ shouldCacheIgnoreZoom: false });
          },
          duration: opts?.duration ?? 500
        });
        this.cancelInProgressAnimation = () => {
          cancel();
          this.cancelInProgressAnimation = null;
        };
      } else {
        this.setState({ scrollX, scrollY, zoom });
      }
    });
    __publicField(this, "maybeUnfollowRemoteUser", () => {
      if (this.state.userToFollow) {
        this.setState({ userToFollow: null });
      }
    });
    /** use when changing scrollX/scrollY/zoom based on user interaction */
    __publicField(this, "translateCanvas", (state) => {
      this.cancelInProgressAnimation?.();
      this.maybeUnfollowRemoteUser();
      this.setState(state);
    });
    __publicField(this, "setToast", (toast) => {
      this.setState({ toast });
    });
    __publicField(this, "restoreFileFromShare", async () => {
      try {
        const webShareTargetCache = await caches.open("web-share-target");
        const response = await webShareTargetCache.match("shared-file");
        if (response) {
          const blob = await response.blob();
          const file2 = new File([blob], blob.name || "", { type: blob.type });
          this.loadFileToCanvas(file2, null);
          await webShareTargetCache.delete("shared-file");
          window.history.replaceState(null, APP_NAME2, window.location.pathname);
        }
      } catch (error) {
        this.setState({ errorMessage: error.message });
      }
    });
    /**
     * adds supplied files to existing files in the appState.
     * NOTE if file already exists in editor state, the file data is not updated
     * */
    __publicField(this, "addFiles", withBatchedUpdates(
      (files) => {
        const { addedFiles } = this.addMissingFiles(files);
        this.clearImageShapeCache(addedFiles);
        this.scene.triggerUpdate();
        this.addNewImagesToImageCache();
      }
    ));
    __publicField(this, "addMissingFiles", (files, replace = false) => {
      const nextFiles = replace ? {} : { ...this.files };
      const addedFiles = {};
      const _files = Array.isArray(files) ? files : Object.values(files);
      for (const fileData of _files) {
        if (nextFiles[fileData.id]) {
          continue;
        }
        addedFiles[fileData.id] = fileData;
        nextFiles[fileData.id] = fileData;
        if (fileData.mimeType === MIME_TYPES9.svg) {
          try {
            const restoredDataURL = getDataURL_sync(
              normalizeSVG(dataURLToString(fileData.dataURL)),
              MIME_TYPES9.svg
            );
            if (fileData.dataURL !== restoredDataURL) {
              fileData.version = (fileData.version ?? 1) + 1;
              fileData.dataURL = restoredDataURL;
            }
          } catch (error) {
            console.error(error);
          }
        }
      }
      this.files = nextFiles;
      return { addedFiles };
    });
    __publicField(this, "updateScene", withBatchedUpdates(
      (sceneData) => {
        const { elements, appState, collaborators, captureUpdate } = sceneData;
        if (captureUpdate) {
          const nextElements = elements ? elements : void 0;
          const observedAppState = appState ? getObservedAppState({
            ...this.store.snapshot.appState,
            ...appState
          }) : void 0;
          this.store.scheduleMicroAction({
            action: captureUpdate,
            elements: nextElements,
            appState: observedAppState
          });
        }
        if (appState) {
          this.setState(appState);
        }
        if (elements) {
          this.scene.replaceAllElements(elements);
        }
        if (collaborators) {
          this.setState({ collaborators });
        }
      }
    ));
    __publicField(this, "applyDeltas", (deltas, options) => {
      const aggregatedDelta = StoreDelta2.squash(...deltas);
      const nextAppState = { ...this.state };
      const nextElements = new Map(
        this.scene.getElementsMapIncludingDeleted()
      );
      return StoreDelta2.applyTo(
        aggregatedDelta,
        nextElements,
        nextAppState,
        options
      );
    });
    __publicField(this, "mutateElement", (element, updates, informMutation = true) => {
      return this.scene.mutateElement(element, updates, {
        informMutation,
        isDragging: false
      });
    });
    __publicField(this, "triggerRender", (force) => {
      if (force === true) {
        this.scene.triggerUpdate();
      } else {
        this.setState({});
      }
    });
    /**
     * @returns whether the menu was toggled on or off
     */
    __publicField(this, "toggleSidebar", ({
      name,
      tab,
      force
    }) => {
      let nextName;
      if (force === void 0) {
        nextName = this.state.openSidebar?.name === name && this.state.openSidebar?.tab === tab ? null : name;
      } else {
        nextName = force ? name : null;
      }
      const nextState = nextName ? { name: nextName } : null;
      if (nextState && tab) {
        nextState.tab = tab;
      }
      this.setState({ openSidebar: nextState });
      return !!nextName;
    });
    __publicField(this, "updateCurrentCursorPosition", withBatchedUpdates(
      (event) => {
        this.lastViewportPosition.x = event.clientX;
        this.lastViewportPosition.y = event.clientY;
      }
    ));
    __publicField(this, "getEditorUIOffsets", () => {
      const toolbarBottom = this.excalidrawContainerRef?.current?.querySelector(".App-toolbar")?.getBoundingClientRect()?.bottom ?? 0;
      const sidebarRect = this.excalidrawContainerRef?.current?.querySelector(".sidebar")?.getBoundingClientRect();
      const propertiesPanelRect = this.excalidrawContainerRef?.current?.querySelector(".App-menu__left")?.getBoundingClientRect();
      const PADDING = 16;
      return getLanguage().rtl ? {
        top: toolbarBottom + PADDING,
        right: Math.max(
          this.state.width - (propertiesPanelRect?.left ?? this.state.width),
          0
        ) + PADDING,
        bottom: PADDING,
        left: Math.max(sidebarRect?.right ?? 0, 0) + PADDING
      } : {
        top: toolbarBottom + PADDING,
        right: Math.max(
          this.state.width - (sidebarRect?.left ?? this.state.width) + PADDING,
          0
        ),
        bottom: PADDING,
        left: Math.max(propertiesPanelRect?.right ?? 0, 0) + PADDING
      };
    });
    // Input handling
    __publicField(this, "onKeyDown", withBatchedUpdates(
      (event) => {
        if ("Proxy" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {
          event = new Proxy(event, {
            get(ev, prop) {
              const value = ev[prop];
              if (typeof value === "function") {
                return value.bind(ev);
              }
              return prop === "key" ? (
                // CapsLock inverts capitalization based on ShiftKey, so invert
                // it back
                event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase()
              ) : value;
            }
          });
        }
        if (!isInputLike(event.target)) {
          if ((event.key === KEYS54.ESCAPE || event.key === KEYS54.ENTER) && this.state.croppingElementId) {
            this.finishImageCropping();
            return;
          }
          const selectedElements = getSelectedElements(
            this.scene.getNonDeletedElementsMap(),
            this.state
          );
          if (selectedElements.length === 1 && isImageElement6(selectedElements[0]) && event.key === KEYS54.ENTER) {
            this.startImageCropping(selectedElements[0]);
            return;
          }
          if (event.key === KEYS54.ESCAPE) {
            this.updateEditorAtom(convertElementTypePopupAtom, null);
          } else if (event.key === KEYS54.TAB && (document.activeElement === this.excalidrawContainerRef?.current || document.activeElement?.classList.contains(
            CLASSES11.CONVERT_ELEMENT_TYPE_POPUP
          ))) {
            event.preventDefault();
            const conversionType = getConversionTypeFromElements(selectedElements);
            if (editorJotaiStore.get(convertElementTypePopupAtom)?.type === "panel") {
              if (convertElementTypes(this, {
                conversionType,
                direction: event.shiftKey ? "left" : "right"
              })) {
                this.store.scheduleCapture();
              }
            }
            if (conversionType) {
              this.updateEditorAtom(convertElementTypePopupAtom, {
                type: "panel"
              });
            }
          }
          if (event.key === KEYS54.ESCAPE && this.flowChartCreator.isCreatingChart) {
            this.flowChartCreator.clear();
            this.triggerRender(true);
            return;
          }
          const arrowKeyPressed = isArrowKey2(event.key);
          if (event[KEYS54.CTRL_OR_CMD] && arrowKeyPressed && !event.shiftKey) {
            event.preventDefault();
            const selectedElements2 = getSelectedElements(
              this.scene.getNonDeletedElementsMap(),
              this.state
            );
            if (selectedElements2.length === 1 && isFlowchartNodeElement2(selectedElements2[0])) {
              this.flowChartCreator.createNodes(
                selectedElements2[0],
                this.state,
                getLinkDirectionFromKey(event.key),
                this.scene
              );
            }
            if (this.flowChartCreator.pendingNodes?.length && !isElementCompletelyInViewport2(
              this.flowChartCreator.pendingNodes,
              this.canvas.width / window.devicePixelRatio,
              this.canvas.height / window.devicePixelRatio,
              {
                offsetLeft: this.state.offsetLeft,
                offsetTop: this.state.offsetTop,
                scrollX: this.state.scrollX,
                scrollY: this.state.scrollY,
                zoom: this.state.zoom
              },
              this.scene.getNonDeletedElementsMap(),
              this.getEditorUIOffsets()
            )) {
              this.scrollToContent(this.flowChartCreator.pendingNodes, {
                animate: true,
                duration: 300,
                fitToContent: true,
                canvasOffsets: this.getEditorUIOffsets()
              });
            }
            return;
          }
          if (event.altKey) {
            const selectedElements2 = getSelectedElements(
              this.scene.getNonDeletedElementsMap(),
              this.state
            );
            if (selectedElements2.length === 1 && arrowKeyPressed) {
              event.preventDefault();
              const nextId = this.flowChartNavigator.exploreByDirection(
                selectedElements2[0],
                this.scene.getNonDeletedElementsMap(),
                getLinkDirectionFromKey(event.key)
              );
              if (nextId) {
                this.setState((prevState) => ({
                  selectedElementIds: makeNextSelectedElementIds2(
                    {
                      [nextId]: true
                    },
                    prevState
                  )
                }));
                const nextNode = this.scene.getNonDeletedElementsMap().get(nextId);
                if (nextNode && !isElementCompletelyInViewport2(
                  [nextNode],
                  this.canvas.width / window.devicePixelRatio,
                  this.canvas.height / window.devicePixelRatio,
                  {
                    offsetLeft: this.state.offsetLeft,
                    offsetTop: this.state.offsetTop,
                    scrollX: this.state.scrollX,
                    scrollY: this.state.scrollY,
                    zoom: this.state.zoom
                  },
                  this.scene.getNonDeletedElementsMap(),
                  this.getEditorUIOffsets()
                )) {
                  this.scrollToContent(nextNode, {
                    animate: true,
                    duration: 300,
                    canvasOffsets: this.getEditorUIOffsets()
                  });
                }
              }
              return;
            }
          }
        }
        if (event[KEYS54.CTRL_OR_CMD] && event.key === KEYS54.P && !event.shiftKey && !event.altKey) {
          this.setToast({
            message: t("commandPalette.shortcutHint", {
              shortcut: getShortcutFromShortcutName("commandPalette")
            })
          });
          event.preventDefault();
          return;
        }
        if (event[KEYS54.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS54.V) {
          IS_PLAIN_PASTE = event.shiftKey;
          clearTimeout(IS_PLAIN_PASTE_TIMER);
          IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {
            IS_PLAIN_PASTE = false;
          }, 100);
        }
        if (event[KEYS54.CTRL_OR_CMD] && isWritableElement5(event.target)) {
          if (event.code === CODES13.MINUS || event.code === CODES13.EQUAL) {
            event.preventDefault();
            return;
          }
        }
        if (
          // inside an input
          isWritableElement5(event.target) && // unless pressing escape (finalize action)
          event.key !== KEYS54.ESCAPE || // or unless using arrows (to move between buttons)
          isArrowKey2(event.key) && isInputLike(event.target)
        ) {
          return;
        }
        if (event.key === KEYS54.QUESTION_MARK) {
          this.setState({
            openDialog: { name: "help" }
          });
          return;
        } else if (event.key.toLowerCase() === KEYS54.E && event.shiftKey && event[KEYS54.CTRL_OR_CMD]) {
          event.preventDefault();
          this.setState({ openDialog: { name: "imageExport" } });
          return;
        }
        if (event.key === KEYS54.PAGE_UP || event.key === KEYS54.PAGE_DOWN) {
          let offset = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
          if (event.key === KEYS54.PAGE_DOWN) {
            offset = -offset;
          }
          if (event.shiftKey) {
            this.translateCanvas((state) => ({
              scrollX: state.scrollX + offset
            }));
          } else {
            this.translateCanvas((state) => ({
              scrollY: state.scrollY + offset
            }));
          }
        }
        if (this.state.openDialog?.name === "elementLinkSelector") {
          return;
        }
        if (event.key === KEYS54.ALT) {
          if (getFeatureFlag4("COMPLEX_BINDINGS")) {
            this.handleSkipBindMode();
          } else {
            maybeHandleArrowPointlikeDrag({ app: this, event });
          }
        }
        if (this.actionManager.handleKeyDown(event)) {
          return;
        }
        if (this.state.viewModeEnabled) {
          return;
        }
        if (event[KEYS54.CTRL_OR_CMD] && this.state.isBindingEnabled) {
          if (getFeatureFlag4("COMPLEX_BINDINGS")) {
            this.resetDelayedBindMode();
          }
          flushSync3(() => {
            this.setState({ isBindingEnabled: false });
          });
          maybeHandleArrowPointlikeDrag({ app: this, event });
        }
        if (isArrowKey2(event.key)) {
          let selectedElements = this.scene.getSelectedElements({
            selectedElementIds: this.state.selectedElementIds,
            includeBoundTextElement: true,
            includeElementsInFrames: true
          });
          const arrowIdsToRemove = /* @__PURE__ */ new Set();
          selectedElements.filter(
            (el) => isBindingElement3(el)
          ).filter((arrow) => {
            const startElementNotInSelection = arrow.startBinding && !selectedElements.some(
              (el) => el.id === arrow.startBinding?.elementId
            );
            const endElementNotInSelection = arrow.endBinding && !selectedElements.some(
              (el) => el.id === arrow.endBinding?.elementId
            );
            return startElementNotInSelection || endElementNotInSelection;
          }).forEach((arrow) => arrowIdsToRemove.add(arrow.id));
          selectedElements = selectedElements.filter(
            (el) => !arrowIdsToRemove.has(el.id)
          );
          const step = this.getEffectiveGridSize() && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.getEffectiveGridSize()) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);
          let offsetX = 0;
          let offsetY = 0;
          if (event.key === KEYS54.ARROW_LEFT) {
            offsetX = -step;
          } else if (event.key === KEYS54.ARROW_RIGHT) {
            offsetX = step;
          } else if (event.key === KEYS54.ARROW_UP) {
            offsetY = -step;
          } else if (event.key === KEYS54.ARROW_DOWN) {
            offsetY = step;
          }
          selectedElements.forEach((element) => {
            this.scene.mutateElement(
              element,
              {
                x: element.x + offsetX,
                y: element.y + offsetY
              },
              { informMutation: false, isDragging: false }
            );
            updateBoundElements3(element, this.scene, {
              simultaneouslyUpdated: selectedElements
            });
          });
          this.scene.triggerUpdate();
          event.preventDefault();
        } else if (event.key === KEYS54.ENTER) {
          const selectedElements = this.scene.getSelectedElements(this.state);
          if (selectedElements.length === 1) {
            const selectedElement = selectedElements[0];
            if (event[KEYS54.CTRL_OR_CMD] || isLineElement8(selectedElement)) {
              if (isLinearElement12(selectedElement)) {
                if (!this.state.selectedLinearElement?.isEditing || this.state.selectedLinearElement.elementId !== selectedElement.id) {
                  this.store.scheduleCapture();
                  if (!isElbowArrow9(selectedElement)) {
                    this.actionManager.executeAction(actionToggleLinearEditor);
                  }
                }
              }
            } else if (isTextElement16(selectedElement) || isValidTextContainer(selectedElement)) {
              let container;
              if (!isTextElement16(selectedElement)) {
                container = selectedElement;
              }
              const midPoint = getContainerCenter(
                selectedElement,
                this.state,
                this.scene.getNonDeletedElementsMap()
              );
              const sceneX = midPoint.x;
              const sceneY = midPoint.y;
              this.startTextEditing({
                sceneX,
                sceneY,
                container
              });
              event.preventDefault();
              return;
            } else if (isFrameLikeElement12(selectedElement)) {
              this.setState({
                editingFrame: selectedElement.id
              });
            }
          }
        } else if (!event.ctrlKey && !event.altKey && !event.metaKey && !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged) {
          const shape = findShapeByKey(event.key, this);
          if (shape) {
            if (this.state.activeTool.type !== shape) {
              trackEvent(
                "toolbar",
                shape,
                `keyboard (${this.editorInterface.formFactor === "phone" ? "mobile" : "desktop"})`
              );
            }
            if (shape === "arrow" && this.state.activeTool.type === "arrow") {
              this.setState((prevState) => ({
                currentItemArrowType: prevState.currentItemArrowType === ARROW_TYPE2.sharp ? ARROW_TYPE2.round : prevState.currentItemArrowType === ARROW_TYPE2.round ? ARROW_TYPE2.elbow : ARROW_TYPE2.sharp
              }));
            }
            this.setActiveTool({ type: shape });
            event.stopPropagation();
          } else if (event.key === KEYS54.Q) {
            this.toggleLock("keyboard");
            event.stopPropagation();
          }
        }
        if (event.key === KEYS54.SPACE && gesture.pointers.size === 0) {
          isHoldingSpace = true;
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRAB);
          event.preventDefault();
        }
        if ((event.key === KEYS54.G || event.key === KEYS54.S) && !event.altKey && !event[KEYS54.CTRL_OR_CMD]) {
          const selectedElements = this.scene.getSelectedElements(this.state);
          if (this.state.activeTool.type === "selection" && !selectedElements.length) {
            return;
          }
          if (event.key === KEYS54.G && (hasBackground(this.state.activeTool.type) || selectedElements.some((element) => hasBackground(element.type)))) {
            this.setState({ openPopup: "elementBackground" });
            event.stopPropagation();
          }
          if (event.key === KEYS54.S) {
            this.setState({ openPopup: "elementStroke" });
            event.stopPropagation();
          }
        }
        if (!event[KEYS54.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS54.F) {
          const selectedElements = this.scene.getSelectedElements(this.state);
          if (this.state.activeTool.type === "selection" && !selectedElements.length) {
            return;
          }
          if (this.state.activeTool.type === "text" || selectedElements.find(
            (element) => isTextElement16(element) || getBoundTextElement9(
              element,
              this.scene.getNonDeletedElementsMap()
            )
          )) {
            event.preventDefault();
            this.setState({ openPopup: "fontFamily" });
          }
        }
        if (event.key === KEYS54.K && !event.altKey && !event[KEYS54.CTRL_OR_CMD]) {
          if (this.state.activeTool.type === "laser") {
            this.setActiveTool({ type: this.state.preferredSelectionTool.type });
          } else {
            this.setActiveTool({ type: "laser" });
          }
          return;
        }
        if (event[KEYS54.CTRL_OR_CMD] && (event.key === KEYS54.BACKSPACE || event.key === KEYS54.DELETE)) {
          this.updateEditorAtom(activeConfirmDialogAtom, "clearCanvas");
        }
        const lowerCased = event.key.toLocaleLowerCase();
        const isPickingStroke = lowerCased === KEYS54.S && event.shiftKey;
        const isPickingBackground = event.key === KEYS54.I || lowerCased === KEYS54.G && event.shiftKey;
        if (isPickingStroke || isPickingBackground) {
          this.openEyeDropper({
            type: isPickingStroke ? "stroke" : "background"
          });
        }
      }
    ));
    __publicField(this, "onKeyUp", withBatchedUpdates((event) => {
      if (event.key === KEYS54.SPACE) {
        if (this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector") {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRAB);
        } else if (isSelectionLikeTool(this.state.activeTool.type)) {
          resetCursor(this.interactiveCanvas);
        } else {
          setCursorForShape(this.interactiveCanvas, this.state);
          this.setState({
            selectedElementIds: makeNextSelectedElementIds2({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
        isHoldingSpace = false;
      }
      if (event.key === KEYS54.ALT) {
        maybeHandleArrowPointlikeDrag({ app: this, event });
      }
      if (event.key === KEYS54.ALT && this.state.bindMode === "skip" || !event[KEYS54.CTRL_OR_CMD] && !isBindingEnabled2(this.state)) {
        this.setState({
          bindMode: "orbit"
        });
        if (this.lastPointerMoveEvent && getFeatureFlag4("COMPLEX_BINDINGS")) {
          const scenePointer = viewportCoordsToSceneCoords3(
            {
              clientX: this.lastPointerMoveEvent.clientX,
              clientY: this.lastPointerMoveEvent.clientY
            },
            this.state
          );
          const hoveredElement = getHoveredElementForBinding2(
            pointFrom26(scenePointer.x, scenePointer.y),
            this.scene.getNonDeletedElements(),
            this.scene.getNonDeletedElementsMap()
          );
          if (this.state.selectedLinearElement) {
            const element = LinearElementEditor11.getElement(
              this.state.selectedLinearElement.elementId,
              this.scene.getNonDeletedElementsMap()
            );
            if (isBindingElement3(element)) {
              this.handleDelayedBindModeChange(element, hoveredElement);
            }
          }
        }
      }
      if (!event[KEYS54.CTRL_OR_CMD] && !this.state.isBindingEnabled) {
        flushSync3(() => {
          this.setState({ isBindingEnabled: true });
        });
        maybeHandleArrowPointlikeDrag({ app: this, event });
      }
      if (isArrowKey2(event.key)) {
        bindOrUnbindBindingElements2(
          this.scene.getSelectedElements(this.state).filter(isArrowElement12),
          this.scene,
          this.state
        );
        const elementsMap = this.scene.getNonDeletedElementsMap();
        this.scene.getSelectedElements(this.state).filter(isSimpleArrow).forEach((element) => {
          if (element.startBinding) {
            this.scene.mutateElement(element, {
              startBinding: {
                ...element.startBinding,
                ...calculateFixedPointForNonElbowArrowBinding2(
                  element,
                  elementsMap.get(
                    element.startBinding.elementId
                  ),
                  "start",
                  elementsMap
                )
              }
            });
          }
          if (element.endBinding) {
            this.scene.mutateElement(element, {
              endBinding: {
                ...element.endBinding,
                ...calculateFixedPointForNonElbowArrowBinding2(
                  element,
                  elementsMap.get(
                    element.endBinding.elementId
                  ),
                  "end",
                  elementsMap
                )
              }
            });
          }
        });
        this.setState({ suggestedBinding: null });
      }
      if (!event.altKey) {
        if (this.flowChartNavigator.isExploring) {
          this.flowChartNavigator.clear();
          this.syncActionResult({
            captureUpdate: CaptureUpdateAction36.IMMEDIATELY
          });
        }
      }
      if (!event[KEYS54.CTRL_OR_CMD]) {
        if (this.flowChartCreator.isCreatingChart) {
          if (this.flowChartCreator.pendingNodes?.length) {
            this.scene.insertElements(this.flowChartCreator.pendingNodes);
          }
          const firstNode = this.flowChartCreator.pendingNodes?.[0];
          if (firstNode) {
            this.setState((prevState) => ({
              selectedElementIds: makeNextSelectedElementIds2(
                {
                  [firstNode.id]: true
                },
                prevState
              )
            }));
            if (!isElementCompletelyInViewport2(
              [firstNode],
              this.canvas.width / window.devicePixelRatio,
              this.canvas.height / window.devicePixelRatio,
              {
                offsetLeft: this.state.offsetLeft,
                offsetTop: this.state.offsetTop,
                scrollX: this.state.scrollX,
                scrollY: this.state.scrollY,
                zoom: this.state.zoom
              },
              this.scene.getNonDeletedElementsMap(),
              this.getEditorUIOffsets()
            )) {
              this.scrollToContent(firstNode, {
                animate: true,
                duration: 300,
                canvasOffsets: this.getEditorUIOffsets()
              });
            }
          }
          this.flowChartCreator.clear();
          this.syncActionResult({
            captureUpdate: CaptureUpdateAction36.IMMEDIATELY
          });
        }
      }
    }));
    // We purposely widen the `tool` type so this helper can be called with
    // any tool without having to type check it
    __publicField(this, "isToolSupported", (tool) => {
      return this.props.UIOptions.tools?.[tool] !== false;
    });
    __publicField(this, "setActiveTool", (tool, keepSelection = false) => {
      if (!this.isToolSupported(tool.type)) {
        console.warn(
          `"${tool.type}" tool is disabled via "UIOptions.canvasActions.tools.${tool.type}"`
        );
        return;
      }
      const nextActiveTool = updateActiveTool7(this.state, tool);
      if (nextActiveTool.type === "hand") {
        setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRAB);
      } else if (!isHoldingSpace) {
        setCursorForShape(this.interactiveCanvas, {
          ...this.state,
          activeTool: nextActiveTool
        });
      }
      if (isToolIcon(document.activeElement)) {
        this.focusContainer();
      }
      if (!isLinearElementType2(nextActiveTool.type)) {
        this.setState({ suggestedBinding: null });
      }
      if (nextActiveTool.type === "image") {
        this.onImageToolbarButtonClick();
      }
      this.setState((prevState) => {
        const commonResets = {
          snapLines: prevState.snapLines.length ? [] : prevState.snapLines,
          originSnapOffset: null,
          activeEmbeddable: null,
          selectedLinearElement: isSelectionLikeTool(nextActiveTool.type) ? prevState.selectedLinearElement : null
        };
        if (nextActiveTool.type === "freedraw") {
          this.store.scheduleCapture();
        }
        if (nextActiveTool.type === "lasso") {
          return {
            ...prevState,
            ...commonResets,
            activeTool: nextActiveTool,
            ...keepSelection ? {} : {
              selectedElementIds: makeNextSelectedElementIds2({}, prevState),
              selectedGroupIds: makeNextSelectedElementIds2({}, prevState),
              editingGroupId: null,
              multiElement: null
            }
          };
        } else if (nextActiveTool.type !== "selection") {
          const base = {
            ...prevState,
            ...commonResets,
            activeTool: nextActiveTool,
            selectedElementIds: makeNextSelectedElementIds2({}, prevState),
            selectedGroupIds: makeNextSelectedElementIds2({}, prevState),
            editingGroupId: null,
            multiElement: null
          };
          if (nextActiveTool.type === "StickyNote") {
            return {
              ...base,
              currentItemBackgroundColor: COLOR_PALETTE8.yellow[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX2],
              currentItemFillStyle: "solid",
              currentItemStrokeWidth: 0,
              currentItemStrokeStyle: "solid",
              currentItemRoughness: ROUGHNESS2.architect,
              currentItemTextAlign: "left"
            };
          }
          if (prevState.activeTool.type === "StickyNote") {
            return {
              ...base,
              currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS2.backgroundColor,
              currentItemFillStyle: DEFAULT_ELEMENT_PROPS2.fillStyle,
              currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS2.strokeWidth,
              currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS2.strokeStyle,
              currentItemRoughness: DEFAULT_ELEMENT_PROPS2.roughness,
              currentItemTextAlign: DEFAULT_TEXT_ALIGN3
            };
          }
          if ((nextActiveTool.type === "rectangle" || nextActiveTool.type === "diamond" || nextActiveTool.type === "ellipse") && prevState.currentItemStrokeWidth === 0) {
            return {
              ...base,
              currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS2.backgroundColor,
              currentItemFillStyle: DEFAULT_ELEMENT_PROPS2.fillStyle,
              currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS2.strokeWidth,
              currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS2.strokeStyle,
              currentItemRoughness: DEFAULT_ELEMENT_PROPS2.roughness,
              currentItemTextAlign: DEFAULT_TEXT_ALIGN3
            };
          }
          if (nextActiveTool.type === "rectangle" || nextActiveTool.type === "diamond" || nextActiveTool.type === "ellipse") {
            return {
              ...base,
              currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS2.backgroundColor
            };
          }
          return base;
        }
        if (prevState.activeTool.type === "StickyNote") {
          return {
            ...prevState,
            ...commonResets,
            activeTool: nextActiveTool,
            currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS2.backgroundColor,
            currentItemFillStyle: DEFAULT_ELEMENT_PROPS2.fillStyle,
            currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS2.strokeWidth,
            currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS2.strokeStyle,
            currentItemRoughness: DEFAULT_ELEMENT_PROPS2.roughness,
            currentItemTextAlign: DEFAULT_TEXT_ALIGN3
          };
        }
        return {
          ...prevState,
          ...commonResets,
          activeTool: nextActiveTool
        };
      });
    });
    __publicField(this, "setOpenDialog", (dialogType) => {
      this.setState({ openDialog: dialogType });
    });
    __publicField(this, "setCursor", (cursor) => {
      setCursor(this.interactiveCanvas, cursor);
    });
    __publicField(this, "resetCursor", () => {
      resetCursor(this.interactiveCanvas);
    });
    /**
     * returns whether user is making a gesture with >= 2 fingers (points)
     * on o touch screen (not on a trackpad). Currently only relates to Darwin
     * (iOS/iPadOS,MacOS), but may work on other devices in the future if
     * GestureEvent is standardized.
     */
    __publicField(this, "isTouchScreenMultiTouchGesture", () => {
      return gesture.pointers.size >= 2;
    });
    __publicField(this, "getName", () => {
      return this.state.name || this.props.name || `${t("labels.untitled")}-${getDateTime()}`;
    });
    // fires only on Safari
    __publicField(this, "onGestureStart", withBatchedUpdates((event) => {
      event.preventDefault();
      if (this.isTouchScreenMultiTouchGesture()) {
        this.setState({
          selectedElementIds: makeNextSelectedElementIds2({}, this.state),
          activeEmbeddable: null
        });
      }
      gesture.initialScale = this.state.zoom.value;
    }));
    // fires only on Safari
    __publicField(this, "onGestureChange", withBatchedUpdates((event) => {
      event.preventDefault();
      if (this.isTouchScreenMultiTouchGesture()) {
        return;
      }
      const initialScale = gesture.initialScale;
      if (initialScale) {
        this.setState((state) => ({
          ...getStateForZoom(
            {
              viewportX: this.lastViewportPosition.x,
              viewportY: this.lastViewportPosition.y,
              nextZoom: getNormalizedZoom(initialScale * event.scale)
            },
            state
          )
        }));
      }
    }));
    // fires only on Safari
    __publicField(this, "onGestureEnd", withBatchedUpdates((event) => {
      event.preventDefault();
      if (this.isTouchScreenMultiTouchGesture()) {
        this.setState({
          previousSelectedElementIds: {},
          selectedElementIds: makeNextSelectedElementIds2(
            this.state.previousSelectedElementIds,
            this.state
          )
        });
      }
      gesture.initialScale = null;
    }));
    __publicField(this, "startTextEditing", ({
      sceneX,
      sceneY,
      insertAtParentCenter = true,
      container,
      autoEdit = true
    }) => {
      let shouldBindToContainer = false;
      let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(
        sceneX,
        sceneY,
        this.state,
        container
      );
      if (container && parentCenterPosition) {
        const boundTextElementToContainer = getBoundTextElement9(
          container,
          this.scene.getNonDeletedElementsMap()
        );
        if (!boundTextElementToContainer) {
          shouldBindToContainer = true;
        }
      }
      let existingTextElement = null;
      const selectedElements = this.scene.getSelectedElements(this.state);
      if (selectedElements.length === 1) {
        if (isTextElement16(selectedElements[0])) {
          existingTextElement = selectedElements[0];
        } else if (container) {
          existingTextElement = getBoundTextElement9(
            selectedElements[0],
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
        }
      } else {
        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
      }
      const fontFamily = existingTextElement?.fontFamily || this.state.currentItemFontFamily;
      const lineHeight = existingTextElement?.lineHeight || getLineHeight4(fontFamily);
      const fontSize = this.state.currentItemFontSize;
      if (!existingTextElement && shouldBindToContainer && container && !isArrowElement12(container)) {
        const fontString = {
          fontSize,
          fontFamily
        };
        const minWidth = getApproxMinLineWidth(
          getFontString9(fontString),
          lineHeight
        );
        const minHeight = getApproxMinLineHeight(fontSize, lineHeight);
        const newHeight = Math.max(container.height, minHeight);
        const newWidth = Math.max(container.width, minWidth);
        this.scene.mutateElement(container, {
          height: newHeight,
          width: newWidth
        });
        sceneX = container.x + newWidth / 2;
        sceneY = container.y + newHeight / 2;
        if (parentCenterPosition) {
          parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(
            sceneX,
            sceneY,
            this.state,
            container
          );
        }
      }
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: sceneX,
        y: sceneY
      });
      const isStickyNoteContainer = container && container.type === "rectangle" && container.customData?.isStickyNote === true;
      const element = existingTextElement || newTextElement3({
        x: isStickyNoteContainer ? container.x + STICKY_NOTE_PADDING3 : parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,
        y: isStickyNoteContainer ? container.y + STICKY_NOTE_PADDING3 : parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,
        strokeColor: shouldBindToContainer && container ? DEFAULT_BOUND_TEXT_STROKE_COLOR : this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        text: "",
        fontSize,
        fontFamily,
        textAlign: isStickyNoteContainer ? "left" : parentCenterPosition ? "center" : this.state.currentItemTextAlign,
        verticalAlign: isStickyNoteContainer ? "top" : parentCenterPosition ? VERTICAL_ALIGN6.MIDDLE : DEFAULT_VERTICAL_ALIGN,
        containerId: shouldBindToContainer ? container?.id : void 0,
        groupIds: container?.groupIds ?? [],
        lineHeight,
        angle: container ? isArrowElement12(container) ? 0 : container.angle : 0,
        frameId: topLayerFrame ? topLayerFrame.id : null
      });
      if (!existingTextElement && shouldBindToContainer && container) {
        this.scene.mutateElement(container, {
          boundElements: (container.boundElements || []).concat({
            type: "text",
            id: element.id
          })
        });
      }
      if (!existingTextElement) {
        if (container && shouldBindToContainer) {
          const containerIndex = this.scene.getElementIndex(container.id);
          this.scene.insertElementAtIndex(element, containerIndex + 1);
        } else {
          this.scene.insertElement(element);
        }
      }
      flushSync3(() => {
        this.setState({ editingTextElement: element });
      });
      if (autoEdit || existingTextElement || container) {
        this.handleTextWysiwyg(element, {
          isExistingElement: !!existingTextElement,
          placeholder: container && !existingTextElement ? t("labels.addTextPlaceholder") : void 0
        });
      } else {
        this.setState({
          newElement: element,
          multiElement: null
        });
      }
    });
    __publicField(this, "startImageCropping", (image) => {
      this.store.scheduleCapture();
      this.setState({
        croppingElementId: image.id
      });
    });
    __publicField(this, "finishImageCropping", () => {
      if (this.state.croppingElementId) {
        this.store.scheduleCapture();
        this.setState({
          croppingElementId: null
        });
      }
    });
    __publicField(this, "handleCanvasDoubleClick", (event) => {
      if (this.state.multiElement) {
        return;
      }
      if (this.state.activeTool.type !== this.state.preferredSelectionTool.type) {
        return;
      }
      const selectedElements = this.scene.getSelectedElements(this.state);
      let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords3(
        event,
        this.state
      );
      if (selectedElements.length === 1 && isLinearElement12(selectedElements[0])) {
        const selectedLinearElement = selectedElements[0];
        if ((event[KEYS54.CTRL_OR_CMD] && isSimpleArrow(selectedLinearElement) || isLineElement8(selectedLinearElement)) && (!this.state.selectedLinearElement?.isEditing || this.state.selectedLinearElement.elementId !== selectedLinearElement.id)) {
          this.actionManager.executeAction(actionToggleLinearEditor);
          return;
        } else if (this.state.selectedLinearElement && isElbowArrow9(selectedElements[0])) {
          const hitCoords = LinearElementEditor11.getSegmentMidpointHitCoords(
            this.state.selectedLinearElement,
            { x: sceneX, y: sceneY },
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          const midPoint = hitCoords ? LinearElementEditor11.getSegmentMidPointIndex(
            this.state.selectedLinearElement,
            this.state,
            hitCoords,
            this.scene.getNonDeletedElementsMap()
          ) : -1;
          if (midPoint && midPoint > -1) {
            this.store.scheduleCapture();
            LinearElementEditor11.deleteFixedSegment(
              selectedElements[0],
              this.scene,
              midPoint
            );
            const nextCoords = LinearElementEditor11.getSegmentMidpointHitCoords(
              {
                ...this.state.selectedLinearElement,
                segmentMidPointHoveredCoords: null
              },
              { x: sceneX, y: sceneY },
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            const nextIndex = nextCoords ? LinearElementEditor11.getSegmentMidPointIndex(
              this.state.selectedLinearElement,
              this.state,
              nextCoords,
              this.scene.getNonDeletedElementsMap()
            ) : null;
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                initialState: {
                  ...this.state.selectedLinearElement.initialState,
                  segmentMidpoint: {
                    index: nextIndex,
                    value: hitCoords,
                    added: false
                  }
                },
                segmentMidPointHoveredCoords: nextCoords
              }
            });
            return;
          }
        } else if (this.state.selectedLinearElement?.isEditing && this.state.selectedLinearElement.elementId === selectedLinearElement.id && isLineElement8(selectedLinearElement)) {
          return;
        }
      }
      if (selectedElements.length === 1 && isImageElement6(selectedElements[0])) {
        this.startImageCropping(selectedElements[0]);
        return;
      }
      resetCursor(this.interactiveCanvas);
      const selectedGroupIds = getSelectedGroupIds3(this.state);
      if (selectedGroupIds.length > 0) {
        const hitElement = this.getElementAtPosition(sceneX, sceneY);
        const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);
        if (selectedGroupId) {
          this.store.scheduleCapture();
          this.setState((prevState) => ({
            ...prevState,
            ...selectGroupsForSelectedElements6(
              {
                editingGroupId: selectedGroupId,
                selectedElementIds: { [hitElement.id]: true }
              },
              this.scene.getNonDeletedElements(),
              prevState,
              this
            )
          }));
          return;
        }
      }
      resetCursor(this.interactiveCanvas);
      if (!event[KEYS54.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
        const hitElement = this.getElementAtPosition(sceneX, sceneY);
        if (isIframeLikeElement2(hitElement)) {
          this.setState({
            activeEmbeddable: { element: hitElement, state: "active" }
          });
          return;
        }
        if (!this.state.selectedLinearElement?.isEditing) {
          const container = this.getTextBindableContainerAtPosition(
            sceneX,
            sceneY
          );
          if (container) {
            if (hasBoundTextElement7(container) || !isTransparent6(container.backgroundColor) || hitElementItself3({
              point: pointFrom26(sceneX, sceneY),
              element: container,
              elementsMap: this.scene.getNonDeletedElementsMap(),
              threshold: this.getElementHitThreshold(container)
            })) {
              const midPoint = getContainerCenter(
                container,
                this.state,
                this.scene.getNonDeletedElementsMap()
              );
              sceneX = midPoint.x;
              sceneY = midPoint.y;
            }
          }
          this.startTextEditing({
            sceneX,
            sceneY,
            insertAtParentCenter: !event.altKey,
            container
          });
        }
      }
    });
    __publicField(this, "getElementLinkAtPosition", (scenePointer, hitElementMightBeLocked) => {
      if (hitElementMightBeLocked && hitElementMightBeLocked.locked) {
        return void 0;
      }
      const elements = this.scene.getNonDeletedElements();
      let hitElementIndex = -1;
      for (let index = elements.length - 1; index >= 0; index--) {
        const element = elements[index];
        if (hitElementMightBeLocked && element.id === hitElementMightBeLocked.id) {
          hitElementIndex = index;
        }
        if (element.link && index >= hitElementIndex && isPointHittingLink(
          element,
          this.scene.getNonDeletedElementsMap(),
          this.state,
          pointFrom26(scenePointer.x, scenePointer.y),
          this.editorInterface.formFactor === "phone"
        )) {
          return element;
        }
      }
    });
    __publicField(this, "redirectToLink", (event, isTouchScreen) => {
      const draggedDistance = pointDistance8(
        pointFrom26(
          this.lastPointerDownEvent.clientX,
          this.lastPointerDownEvent.clientY
        ),
        pointFrom26(
          this.lastPointerUpEvent.clientX,
          this.lastPointerUpEvent.clientY
        )
      );
      if (!this.hitLinkElement || draggedDistance > DRAGGING_THRESHOLD2) {
        return;
      }
      const lastPointerDownCoords = viewportCoordsToSceneCoords3(
        this.lastPointerDownEvent,
        this.state
      );
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const lastPointerDownHittingLinkIcon = isPointHittingLink(
        this.hitLinkElement,
        elementsMap,
        this.state,
        pointFrom26(lastPointerDownCoords.x, lastPointerDownCoords.y),
        this.editorInterface.formFactor === "phone"
      );
      const lastPointerUpCoords = viewportCoordsToSceneCoords3(
        this.lastPointerUpEvent,
        this.state
      );
      const lastPointerUpHittingLinkIcon = isPointHittingLink(
        this.hitLinkElement,
        elementsMap,
        this.state,
        pointFrom26(lastPointerUpCoords.x, lastPointerUpCoords.y),
        this.editorInterface.formFactor === "phone"
      );
      if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {
        hideHyperlinkToolip();
        let url = this.hitLinkElement.link;
        if (url) {
          url = normalizeLink3(url);
          let customEvent;
          if (this.props.onLinkOpen) {
            customEvent = wrapEvent2(EVENT13.EXCALIDRAW_LINK, event.nativeEvent);
            this.props.onLinkOpen(
              {
                ...this.hitLinkElement,
                link: url
              },
              customEvent
            );
          }
          if (!customEvent?.defaultPrevented) {
            const target = isLocalLink2(url) ? "_self" : "_blank";
            const newWindow = window.open(void 0, target);
            if (newWindow) {
              newWindow.opener = null;
              newWindow.location = url;
            }
          }
        }
      }
    });
    __publicField(this, "getTopLayerFrameAtSceneCoords", (sceneCoords) => {
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const frames = this.scene.getNonDeletedFramesLikes().filter(
        (frame) => !frame.locked && isCursorInFrame(sceneCoords, frame, elementsMap)
      );
      return frames.length ? frames[frames.length - 1] : null;
    });
    __publicField(this, "handleCanvasPointerMove", (event) => {
      this.savePointer(event.clientX, event.clientY, this.state.cursorButton);
      this.lastPointerMoveEvent = event.nativeEvent;
      const scenePointer = viewportCoordsToSceneCoords3(event, this.state);
      const { x: scenePointerX, y: scenePointerY } = scenePointer;
      this.lastPointerMoveCoords = {
        x: scenePointerX,
        y: scenePointerY
      };
      if (gesture.pointers.has(event.pointerId)) {
        gesture.pointers.set(event.pointerId, {
          x: event.clientX,
          y: event.clientY
        });
      }
      const initialScale = gesture.initialScale;
      if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {
        const center = getCenter(gesture.pointers);
        const deltaX = center.x - gesture.lastCenter.x;
        const deltaY = center.y - gesture.lastCenter.y;
        gesture.lastCenter = center;
        const distance3 = getDistance(Array.from(gesture.pointers.values()));
        const scaleFactor = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : distance3 / gesture.initialDistance;
        const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;
        this.setState((state) => {
          const zoomState = getStateForZoom(
            {
              viewportX: center.x,
              viewportY: center.y,
              nextZoom
            },
            state
          );
          this.translateCanvas({
            zoom: zoomState.zoom,
            // 2x multiplier is just a magic number that makes this work correctly
            // on touchscreen devices (note: if we get report that panning is slower/faster
            // than actual movement, consider swapping with devicePixelRatio)
            scrollX: zoomState.scrollX + 2 * (deltaX / nextZoom),
            scrollY: zoomState.scrollY + 2 * (deltaY / nextZoom),
            shouldCacheIgnoreZoom: true
          });
          return null;
        });
        this.resetShouldCacheIgnoreZoomDebounced();
      } else {
        gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;
      }
      if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {
        return;
      }
      const isPointerOverScrollBars = isOverScrollBars(
        currentScrollBars,
        event.clientX - this.state.offsetLeft,
        event.clientY - this.state.offsetTop
      );
      const isOverScrollBar = isPointerOverScrollBars.isOverEither;
      if (!this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged && !this.state.multiElement) {
        if (isOverScrollBar) {
          resetCursor(this.interactiveCanvas);
        } else {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
      }
      if (!this.state.newElement && isActiveToolNonLinearSnappable(this.state.activeTool.type)) {
        const { originOffset, snapLines } = getSnapLinesAtPointer(
          this.scene.getNonDeletedElements(),
          this,
          {
            x: scenePointerX,
            y: scenePointerY
          },
          event,
          this.scene.getNonDeletedElementsMap()
        );
        this.setState((prevState) => {
          const nextSnapLines = updateStable(prevState.snapLines, snapLines);
          const nextOriginOffset = prevState.originSnapOffset ? updateStable(prevState.originSnapOffset, originOffset) : originOffset;
          if (prevState.snapLines === nextSnapLines && prevState.originSnapOffset === nextOriginOffset) {
            return null;
          }
          return {
            snapLines: nextSnapLines,
            originSnapOffset: nextOriginOffset
          };
        });
      } else if (!this.state.newElement && !this.state.selectedElementsAreBeingDragged && !this.state.selectionElement) {
        this.setState((prevState) => {
          if (prevState.snapLines.length) {
            return {
              snapLines: []
            };
          }
          return null;
        });
      }
      if (this.state.selectedLinearElement?.isEditing && !this.state.selectedLinearElement.isDragging) {
        const editingLinearElement = this.state.newElement ? null : LinearElementEditor11.handlePointerMoveInEditMode(
          event,
          scenePointerX,
          scenePointerY,
          this
        );
        if (editingLinearElement && editingLinearElement !== this.state.selectedLinearElement) {
          flushSync3(() => {
            this.setState({
              selectedLinearElement: editingLinearElement
            });
          });
        }
      }
      if (isBindingElementType(this.state.activeTool.type)) {
        const { newElement: newElement5 } = this.state;
        if (!newElement5 && isBindingEnabled2(this.state)) {
          const globalPoint = pointFrom26(
            scenePointerX,
            scenePointerY
          );
          const elementsMap = this.scene.getNonDeletedElementsMap();
          const hoveredElement = getHoveredElementForBinding2(
            globalPoint,
            this.scene.getNonDeletedElements(),
            elementsMap,
            maxBindingDistance_simple2(this.state.zoom)
          );
          if (hoveredElement) {
            this.setState({
              suggestedBinding: {
                element: hoveredElement,
                midPoint: getSnapOutlineMidPoint2(
                  globalPoint,
                  hoveredElement,
                  elementsMap,
                  this.state.zoom
                )
              }
            });
          } else if (this.state.suggestedBinding) {
            this.setState({
              suggestedBinding: null
            });
          }
        }
      }
      if (this.state.multiElement && this.state.selectedLinearElement) {
        const { multiElement, selectedLinearElement } = this.state;
        const { x: rx, y: ry, points } = multiElement;
        const lastPoint = points[points.length - 1];
        const { lastCommittedPoint } = selectedLinearElement;
        setCursorForShape(this.interactiveCanvas, this.state);
        if (lastPoint === lastCommittedPoint) {
          const hoveredElement = isArrowElement12(this.state.newElement) && isBindingEnabled2(this.state) && getHoveredElementForBinding2(
            pointFrom26(scenePointerX, scenePointerY),
            this.scene.getNonDeletedElements(),
            this.scene.getNonDeletedElementsMap(),
            maxBindingDistance_simple2(this.state.zoom)
          );
          if (hoveredElement) {
            this.actionManager.executeAction(actionFinalize, "ui", {
              event: event.nativeEvent,
              sceneCoords: {
                x: scenePointerX,
                y: scenePointerY
              }
            });
            this.setState({ suggestedBinding: null, startBoundElement: null });
            if (!this.state.activeTool.locked) {
              resetCursor(this.interactiveCanvas);
              this.setState((prevState) => ({
                newElement: null,
                activeTool: updateActiveTool7(this.state, {
                  type: this.state.preferredSelectionTool.type
                }),
                selectedElementIds: makeNextSelectedElementIds2(
                  {
                    ...prevState.selectedElementIds,
                    [multiElement.id]: true
                  },
                  prevState
                ),
                selectedLinearElement: new LinearElementEditor11(
                  multiElement,
                  this.scene.getNonDeletedElementsMap()
                )
              }));
            }
          } else if (
            // if we haven't yet created a temp point and we're beyond commit-zone
            // threshold, add a point
            pointDistance8(
              pointFrom26(scenePointerX - rx, scenePointerY - ry),
              lastPoint
            ) >= LINE_CONFIRM_THRESHOLD2
          ) {
            this.scene.mutateElement(
              multiElement,
              {
                points: [
                  ...points,
                  pointFrom26(scenePointerX - rx, scenePointerY - ry)
                ]
              },
              { informMutation: false, isDragging: false }
            );
            invariant16(
              this.state.selectedLinearElement?.initialState,
              "initialState must be set"
            );
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                lastCommittedPoint: points[points.length - 1],
                selectedPointsIndices: [multiElement.points.length - 1],
                initialState: {
                  ...this.state.selectedLinearElement.initialState,
                  lastClickedPoint: multiElement.points.length - 1
                }
              }
            });
          } else {
            setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
          }
        } else if (points.length > 2 && lastCommittedPoint && pointDistance8(
          pointFrom26(scenePointerX - rx, scenePointerY - ry),
          lastCommittedPoint
        ) < LINE_CONFIRM_THRESHOLD2) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
          this.scene.mutateElement(
            multiElement,
            {
              points: points.slice(0, -1)
            },
            { informMutation: false, isDragging: false }
          );
          this.setState({
            selectedLinearElement: {
              ...selectedLinearElement,
              selectedPointsIndices: selectedLinearElement.selectedPointsIndices?.includes(
                multiElement.points.length
              ) ? [
                ...selectedLinearElement.selectedPointsIndices.filter(
                  (idx) => idx !== multiElement.points.length && idx !== multiElement.points.length - 1
                ),
                multiElement.points.length - 1
              ] : selectedLinearElement.selectedPointsIndices,
              lastCommittedPoint: multiElement.points[multiElement.points.length - 1],
              initialState: {
                ...selectedLinearElement.initialState,
                lastClickedPoint: multiElement.points.length - 1
              }
            }
          });
        } else {
          if (isPathALoop4(points, this.state.zoom.value)) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
          }
          const elementsMap = this.scene.getNonDeletedElementsMap();
          if (isSimpleArrow(multiElement)) {
            const hoveredElement = getHoveredElementForBinding2(
              pointFrom26(scenePointerX, scenePointerY),
              this.scene.getNonDeletedElements(),
              elementsMap
            );
            if (getFeatureFlag4("COMPLEX_BINDINGS")) {
              this.handleDelayedBindModeChange(multiElement, hoveredElement);
            }
          }
          invariant16(
            this.state.selectedLinearElement,
            "Expected selectedLinearElement to be set to operate on a linear element"
          );
          const newState = LinearElementEditor11.handlePointerMove(
            event.nativeEvent,
            this,
            scenePointerX,
            scenePointerY,
            this.state.selectedLinearElement
          );
          if (newState) {
            this.setState(newState);
          }
        }
        return;
      }
      if (this.state.activeTool.type === "arrow") {
        const hit = getHoveredElementForBinding2(
          pointFrom26(scenePointerX, scenePointerY),
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap(),
          maxBindingDistance_simple2(this.state.zoom)
        );
        const scenePointer2 = pointFrom26(scenePointerX, scenePointerY);
        const elementsMap = this.scene.getNonDeletedElementsMap();
        if (hit && !isPointInElement3(scenePointer2, hit, elementsMap)) {
          this.setState({
            suggestedBinding: {
              element: hit,
              midPoint: getSnapOutlineMidPoint2(
                scenePointer2,
                hit,
                elementsMap,
                this.state.zoom
              )
            }
          });
        }
      }
      const hasDeselectedButton = Boolean(event.buttons);
      if (hasDeselectedButton || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "lasso" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") {
        return;
      }
      const elements = this.scene.getNonDeletedElements();
      const selectedElements = this.scene.getSelectedElements(this.state);
      if (selectedElements.length === 1 && !isOverScrollBar && !this.state.selectedLinearElement?.isEditing) {
        if (this.state.selectedLinearElement) {
          this.handleHoverSelectedLinearElement(
            this.state.selectedLinearElement,
            scenePointerX,
            scenePointerY
          );
        }
        if ((!this.state.selectedLinearElement || this.state.selectedLinearElement.hoverPointIndex === -1) && this.state.openDialog?.name !== "elementLinkSelector" && !(selectedElements.length === 1 && isElbowArrow9(selectedElements[0])) && // HACK: Disable transform handles for linear elements on mobile until a
        // better way of showing them is found
        !(isLinearElement12(selectedElements[0]) && (this.editorInterface.userAgent.isMobileDevice || selectedElements[0].points.length === 2))) {
          const elementWithTransformHandleType = getElementWithTransformHandleType(
            elements,
            this.state,
            scenePointerX,
            scenePointerY,
            this.state.zoom,
            event.pointerType,
            this.scene.getNonDeletedElementsMap(),
            this.editorInterface
          );
          if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {
            setCursor(
              this.interactiveCanvas,
              getCursorForResizingElement(elementWithTransformHandleType)
            );
            return;
          }
        }
      } else if (selectedElements.length > 1 && !isOverScrollBar && this.state.openDialog?.name !== "elementLinkSelector") {
        const transformHandleType = getTransformHandleTypeFromCoords(
          getCommonBounds8(selectedElements),
          scenePointerX,
          scenePointerY,
          this.state.zoom,
          event.pointerType,
          this.editorInterface
        );
        if (transformHandleType) {
          setCursor(
            this.interactiveCanvas,
            getCursorForResizingElement({
              transformHandleType
            })
          );
          return;
        }
      }
      const hitElementMightBeLocked = this.getElementAtPosition(
        scenePointerX,
        scenePointerY,
        {
          preferSelected: true,
          includeLockedElements: true
        }
      );
      let hitElement = null;
      if (hitElementMightBeLocked && hitElementMightBeLocked.locked) {
        hitElement = null;
      } else {
        hitElement = hitElementMightBeLocked;
      }
      this.hitLinkElement = this.getElementLinkAtPosition(
        scenePointer,
        hitElementMightBeLocked
      );
      if (isEraserActive(this.state)) {
        return;
      }
      if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
        showHyperlinkTooltip(
          this.hitLinkElement,
          this.state,
          this.scene.getNonDeletedElementsMap()
        );
      } else {
        hideHyperlinkToolip();
        if (hitElement && (hitElement.link || isEmbeddableElement4(hitElement)) && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {
          this.setState({ showHyperlinkPopup: "info" });
        } else if (this.state.activeTool.type === "text") {
          setCursor(
            this.interactiveCanvas,
            isTextElement16(hitElement) ? CURSOR_TYPE4.TEXT : CURSOR_TYPE4.CROSSHAIR
          );
        } else if (this.state.viewModeEnabled) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRAB);
        } else if (this.state.openDialog?.name === "elementLinkSelector") {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.AUTO);
        } else if (isOverScrollBar) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.AUTO);
        } else if (
          // if using cmd/ctrl, we're not dragging
          !event[KEYS54.CTRL_OR_CMD]
        ) {
          if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(
            scenePointer,
            selectedElements
          )) && !hitElement?.locked) {
            if (hitElement && isIframeLikeElement2(hitElement) && this.isIframeLikeElementCenter(
              hitElement,
              event,
              scenePointerX,
              scenePointerY
            )) {
              setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
              this.setState({
                activeEmbeddable: { element: hitElement, state: "hover" }
              });
            } else if (!hitElement || // Elbow arrows can only be moved when unconnected
            !isElbowArrow9(hitElement) || !(hitElement.startBinding || hitElement.endBinding)) {
              if (this.state.activeTool.type !== "lasso" || selectedElements.length > 0) {
                setCursor(this.interactiveCanvas, CURSOR_TYPE4.MOVE);
              }
              if (this.state.activeEmbeddable?.state === "hover") {
                this.setState({ activeEmbeddable: null });
              }
            }
          }
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.AUTO);
        }
        if (this.state.selectedLinearElement) {
          this.handleHoverSelectedLinearElement(
            this.state.selectedLinearElement,
            scenePointerX,
            scenePointerY
          );
        }
      }
      if (this.state.openDialog?.name === "elementLinkSelector" && hitElement) {
        this.setState((prevState) => {
          return {
            hoveredElementIds: updateStable(
              prevState.hoveredElementIds,
              selectGroupsForSelectedElements6(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: { [hitElement.id]: true }
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ).selectedElementIds
            )
          };
        });
      } else if (this.state.openDialog?.name === "elementLinkSelector" && !hitElement) {
        this.setState((prevState) => ({
          hoveredElementIds: updateStable(prevState.hoveredElementIds, {})
        }));
      }
    });
    __publicField(this, "handleEraser", (event, scenePointer) => {
      const elementsToErase = this.eraserTrail.addPointToPath(
        scenePointer.x,
        scenePointer.y,
        event.altKey
      );
      this.elementsPendingErasure = new Set(elementsToErase);
      this.triggerRender();
    });
    // set touch moving for mobile context menu
    __publicField(this, "handleTouchMove", (event) => {
      invalidateContextMenu = true;
    });
    __publicField(this, "handleCanvasPointerDown", (event) => {
      const scenePointer = viewportCoordsToSceneCoords3(event, this.state);
      const { x: scenePointerX, y: scenePointerY } = scenePointer;
      this.lastPointerMoveCoords = {
        x: scenePointerX,
        y: scenePointerY
      };
      const target = event.target;
      if (target.setPointerCapture) {
        target.setPointerCapture(event.pointerId);
      }
      this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);
      this.maybeUnfollowRemoteUser();
      if (this.state.searchMatches) {
        this.setState((state) => {
          return {
            searchMatches: state.searchMatches && {
              focusedId: null,
              matches: state.searchMatches.matches.map((searchMatch) => ({
                ...searchMatch,
                focus: false
              }))
            }
          };
        });
        this.updateEditorAtom(searchItemInFocusAtom, null);
      }
      if (editorJotaiStore.get(convertElementTypePopupAtom)) {
        this.updateEditorAtom(convertElementTypePopupAtom, null);
      }
      if (this.state.contextMenu) {
        this.setState({ contextMenu: null });
      }
      if (this.state.snapLines) {
        this.setAppState({ snapLines: [] });
      }
      if (this.state.openPopup) {
        this.setState({ openPopup: null });
      }
      this.updateGestureOnPointerDown(event);
      if (event.pointerType === "touch" && this.state.newElement && this.state.newElement.type === "freedraw") {
        const element = this.state.newElement;
        this.updateScene({
          ...element.points.length < 10 ? {
            elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== element.id)
          } : {},
          appState: {
            newElement: null,
            editingTextElement: null,
            startBoundElement: null,
            suggestedBinding: null,
            selectedElementIds: makeNextSelectedElementIds2(
              Object.keys(this.state.selectedElementIds).filter((key) => key !== element.id).reduce((obj, key) => {
                obj[key] = this.state.selectedElementIds[key];
                return obj;
              }, {}),
              this.state
            )
          },
          captureUpdate: this.state.openDialog?.name === "elementLinkSelector" ? CaptureUpdateAction36.EVENTUALLY : CaptureUpdateAction36.NEVER
        });
        return;
      }
      const selection = document.getSelection();
      if (selection?.anchorNode) {
        selection.removeAllRanges();
      }
      this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);
      if (!this.state.penDetected && event.pointerType === "pen") {
        this.setState((prevState) => {
          return {
            penMode: true,
            penDetected: true
          };
        });
      }
      if (!this.editorInterface.isTouchScreen && ["pen", "touch"].includes(event.pointerType)) {
        this.editorInterface = updateObject2(this.editorInterface, {
          isTouchScreen: true
        });
      }
      if (isPanning) {
        return;
      }
      this.lastPointerDownEvent = event;
      if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {
        return;
      }
      this.setState({
        lastPointerDownWith: event.pointerType,
        cursorButton: "down"
      });
      this.savePointer(event.clientX, event.clientY, "down");
      if (event.button === POINTER_BUTTON2.ERASER && this.state.activeTool.type !== TOOL_TYPE3.eraser) {
        this.setState(
          {
            activeTool: updateActiveTool7(this.state, {
              type: TOOL_TYPE3.eraser,
              lastActiveToolBeforeEraser: this.state.activeTool
            })
          },
          () => {
            this.handleCanvasPointerDown(event);
            const onPointerUp2 = () => {
              unsubPointerUp();
              unsubCleanup?.();
              if (isEraserActive(this.state)) {
                this.setState({
                  activeTool: updateActiveTool7(this.state, {
                    ...this.state.activeTool.lastActiveTool || {
                      type: TOOL_TYPE3.selection
                    },
                    lastActiveToolBeforeEraser: null
                  })
                });
              }
            };
            const unsubPointerUp = addEventListener3(
              window,
              EVENT13.POINTER_UP,
              onPointerUp2,
              {
                once: true
              }
            );
            let unsubCleanup;
            requestAnimationFrame(() => {
              unsubCleanup = this.missingPointerEventCleanupEmitter.once(onPointerUp2);
            });
          }
        );
        return;
      }
      if (event.button !== POINTER_BUTTON2.MAIN && event.button !== POINTER_BUTTON2.TOUCH && event.button !== POINTER_BUTTON2.ERASER) {
        return;
      }
      if (gesture.pointers.size > 1) {
        return;
      }
      const pointerDownState = this.initialPointerDownState(event);
      this.setState({
        selectedElementsAreBeingDragged: false
      });
      if (this.handleDraggingScrollBar(event, pointerDownState)) {
        return;
      }
      this.clearSelectionIfNotUsingSelection();
      this.updateBindingEnabledOnPointerMove(event);
      if (this.handleSelectionOnPointerDown(event, pointerDownState)) {
        return;
      }
      const allowOnPointerDown = !this.state.penMode || event.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "lasso" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image";
      if (!allowOnPointerDown) {
        return;
      }
      if (this.state.activeTool.type === "lasso") {
        const hitSelectedElement = pointerDownState.hit.element && this.isASelectedElement(pointerDownState.hit.element);
        if (!pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements && !pointerDownState.resize.handleType && !hitSelectedElement) {
          this.lassoTrail.startPath(
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            event.shiftKey
          );
          pointerDownState.drag.blockDragging = this.editorInterface.formFactor === "desktop";
        }
        if (this.editorInterface.formFactor !== "desktop" && pointerDownState.hit.element && !hitSelectedElement) {
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...prevState.selectedElementIds,
              [pointerDownState.hit.element.id]: true
            };
            const previouslySelectedElements = [];
            Object.keys(prevState.selectedElementIds).forEach((id) => {
              const element = this.scene.getElement(id);
              element && previouslySelectedElements.push(element);
            });
            const hitElement = pointerDownState.hit.element;
            if (isFrameLikeElement12(hitElement)) {
              getFrameChildren5(previouslySelectedElements, hitElement.id).forEach(
                (element) => {
                  delete nextSelectedElementIds[element.id];
                }
              );
            } else if (hitElement.frameId) {
              if (nextSelectedElementIds[hitElement.frameId]) {
                delete nextSelectedElementIds[hitElement.id];
              }
            } else {
              const groupIds = hitElement.groupIds;
              const framesInGroups = new Set(
                groupIds.flatMap(
                  (gid) => getElementsInGroup8(this.scene.getNonDeletedElements(), gid)
                ).filter((element) => isFrameLikeElement12(element)).map((frame) => frame.id)
              );
              if (framesInGroups.size > 0) {
                previouslySelectedElements.forEach((element) => {
                  if (element.frameId && framesInGroups.has(element.frameId)) {
                    delete nextSelectedElementIds[element.id];
                    element.groupIds.flatMap(
                      (gid) => getElementsInGroup8(
                        this.scene.getNonDeletedElements(),
                        gid
                      )
                    ).forEach((element2) => {
                      delete nextSelectedElementIds[element2.id];
                    });
                  }
                });
              }
            }
            return {
              ...selectGroupsForSelectedElements6(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: nextSelectedElementIds
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ),
              showHyperlinkPopup: hitElement.link || isEmbeddableElement4(hitElement) ? "info" : false
            };
          });
          pointerDownState.hit.wasAddedToSelection = true;
        }
      } else if (this.state.activeTool.type === "text") {
        this.handleTextOnPointerDown(event, pointerDownState);
      } else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") {
        this.handleLinearElementOnPointerDown(
          event,
          this.state.activeTool.type,
          pointerDownState
        );
      } else if (this.state.activeTool.type === "freedraw") {
        this.handleFreeDrawElementOnPointerDown(
          event,
          this.state.activeTool.type,
          pointerDownState
        );
      } else if (this.state.activeTool.type === "custom") {
        setCursorForShape(this.interactiveCanvas, this.state);
      } else if (this.state.activeTool.type === TOOL_TYPE3.frame || this.state.activeTool.type === TOOL_TYPE3.magicframe) {
        this.createFrameElementOnPointerDown(
          pointerDownState,
          this.state.activeTool.type
        );
      } else if (this.state.activeTool.type === "laser") {
        this.laserTrails.startPath(
          pointerDownState.lastCoords.x,
          pointerDownState.lastCoords.y
        );
      } else if (this.state.activeTool.type === "StickyNote") {
        this.createStickyNoteOnPointerDown(pointerDownState);
      } else if (this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand" && this.state.activeTool.type !== "image") {
        this.createGenericElementOnPointerDown(
          this.state.activeTool.type,
          pointerDownState
        );
      }
      this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);
      this.onPointerDownEmitter.trigger(
        this.state.activeTool,
        pointerDownState,
        event
      );
      if (this.state.activeTool.type === "eraser") {
        this.eraserTrail.startPath(
          pointerDownState.lastCoords.x,
          pointerDownState.lastCoords.y
        );
      }
      const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);
      const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);
      const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);
      const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);
      this.missingPointerEventCleanupEmitter.once(
        (_event) => onPointerUp(_event || event.nativeEvent)
      );
      if (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") {
        window.addEventListener(EVENT13.POINTER_MOVE, onPointerMove);
        window.addEventListener(EVENT13.POINTER_UP, onPointerUp);
        window.addEventListener(EVENT13.KEYDOWN, onKeyDown);
        window.addEventListener(EVENT13.KEYUP, onKeyUp);
        pointerDownState.eventListeners.onMove = onPointerMove;
        pointerDownState.eventListeners.onUp = onPointerUp;
        pointerDownState.eventListeners.onKeyUp = onKeyUp;
        pointerDownState.eventListeners.onKeyDown = onKeyDown;
      }
    });
    __publicField(this, "handleCanvasPointerUp", (event) => {
      if (getFeatureFlag4("COMPLEX_BINDINGS")) {
        this.resetDelayedBindMode();
      }
      this.removePointer(event);
      this.lastPointerUpEvent = event;
      const scenePointer = viewportCoordsToSceneCoords3(
        { clientX: event.clientX, clientY: event.clientY },
        this.state
      );
      const { x: scenePointerX, y: scenePointerY } = scenePointer;
      this.lastPointerMoveCoords = {
        x: scenePointerX,
        y: scenePointerY
      };
      const clicklength = event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
      if (this.editorInterface.formFactor === "phone" && clicklength < 300) {
        const hitElement = this.getElementAtPosition(
          scenePointer.x,
          scenePointer.y
        );
        if (isIframeLikeElement2(hitElement) && this.isIframeLikeElementCenter(
          hitElement,
          event,
          scenePointer.x,
          scenePointer.y
        )) {
          this.handleEmbeddableCenterClick(hitElement);
          return;
        }
      }
      if (this.editorInterface.isTouchScreen) {
        const hitElement = this.getElementAtPosition(
          scenePointer.x,
          scenePointer.y,
          {
            includeLockedElements: true
          }
        );
        this.hitLinkElement = this.getElementLinkAtPosition(
          scenePointer,
          hitElement
        );
      }
      if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
        if (clicklength < 300 && isIframeLikeElement2(this.hitLinkElement) && !isPointHittingLinkIcon(
          this.hitLinkElement,
          this.scene.getNonDeletedElementsMap(),
          this.state,
          pointFrom26(scenePointer.x, scenePointer.y)
        )) {
          this.handleEmbeddableCenterClick(this.hitLinkElement);
        } else {
          this.redirectToLink(event, this.editorInterface.isTouchScreen);
        }
      } else if (this.state.viewModeEnabled) {
        this.setState({
          activeEmbeddable: null,
          selectedElementIds: {}
        });
      }
    });
    __publicField(this, "maybeOpenContextMenuAfterPointerDownOnTouchDevices", (event) => {
      if (event.pointerType === "touch") {
        invalidateContextMenu = false;
        if (touchTimeout) {
          invalidateContextMenu = true;
        } else {
          touchTimeout = window.setTimeout(() => {
            touchTimeout = 0;
            if (!invalidateContextMenu) {
              this.handleCanvasContextMenu(event);
            }
          }, TOUCH_CTX_MENU_TIMEOUT);
        }
      }
    });
    __publicField(this, "resetContextMenuTimer", () => {
      clearTimeout(touchTimeout);
      touchTimeout = 0;
      invalidateContextMenu = false;
    });
    /**
     * pointerup may not fire in certian cases (user tabs away...), so in order
     * to properly cleanup pointerdown state, we need to fire any hanging
     * pointerup handlers manually
     */
    __publicField(this, "maybeCleanupAfterMissingPointerUp", (event) => {
      lastPointerUp?.();
      this.missingPointerEventCleanupEmitter.trigger(event).clear();
    });
    // Returns whether the event is a panning
    __publicField(this, "handleCanvasPanUsingWheelOrSpaceDrag", (event) => {
      if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON2.WHEEL || event.button === POINTER_BUTTON2.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled))) {
        return false;
      }
      isPanning = true;
      this.focusContainer();
      if (!this.state.editingTextElement) {
        event.preventDefault();
      }
      let nextPastePrevented = false;
      const isLinux = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
      setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRABBING);
      let { clientX: lastX, clientY: lastY } = event;
      const onPointerMove = withBatchedUpdatesThrottled((event2) => {
        const deltaX = lastX - event2.clientX;
        const deltaY = lastY - event2.clientY;
        lastX = event2.clientX;
        lastY = event2.clientY;
        if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {
          nextPastePrevented = true;
          const preventNextPaste = (event3) => {
            document.body.removeEventListener(EVENT13.PASTE, preventNextPaste);
            event3.stopPropagation();
          };
          const enableNextPaste = () => {
            setTimeout(() => {
              document.body.removeEventListener(EVENT13.PASTE, preventNextPaste);
              window.removeEventListener(EVENT13.POINTER_UP, enableNextPaste);
            }, 100);
          };
          document.body.addEventListener(EVENT13.PASTE, preventNextPaste);
          window.addEventListener(EVENT13.POINTER_UP, enableNextPaste);
        }
        this.translateCanvas({
          scrollX: this.state.scrollX - deltaX / this.state.zoom.value,
          scrollY: this.state.scrollY - deltaY / this.state.zoom.value
        });
      });
      const teardown = withBatchedUpdates(
        lastPointerUp = () => {
          lastPointerUp = null;
          isPanning = false;
          if (!isHoldingSpace) {
            if (this.state.viewModeEnabled) {
              setCursor(this.interactiveCanvas, CURSOR_TYPE4.GRAB);
            } else {
              setCursorForShape(this.interactiveCanvas, this.state);
            }
          }
          this.setState({
            cursorButton: "up"
          });
          this.savePointer(event.clientX, event.clientY, "up");
          window.removeEventListener(EVENT13.POINTER_MOVE, onPointerMove);
          window.removeEventListener(EVENT13.POINTER_UP, teardown);
          window.removeEventListener(EVENT13.BLUR, teardown);
          onPointerMove.flush();
        }
      );
      window.addEventListener(EVENT13.BLUR, teardown);
      window.addEventListener(EVENT13.POINTER_MOVE, onPointerMove, {
        passive: true
      });
      window.addEventListener(EVENT13.POINTER_UP, teardown);
      return true;
    });
    __publicField(this, "clearSelectionIfNotUsingSelection", () => {
      if (!isSelectionLikeTool(this.state.activeTool.type)) {
        this.setState({
          selectedElementIds: makeNextSelectedElementIds2({}, this.state),
          selectedGroupIds: {},
          editingGroupId: null,
          activeEmbeddable: null
        });
      }
    });
    /**
     * @returns whether the pointer event has been completely handled
     */
    __publicField(this, "handleSelectionOnPointerDown", (event, pointerDownState) => {
      if (isSelectionLikeTool(this.state.activeTool.type)) {
        const elements = this.scene.getNonDeletedElements();
        const elementsMap = this.scene.getNonDeletedElementsMap();
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1 && !this.state.selectedLinearElement?.isEditing && !isElbowArrow9(selectedElements[0]) && !(isLinearElement12(selectedElements[0]) && (this.editorInterface.userAgent.isMobileDevice || selectedElements[0].points.length === 2)) && !(this.state.selectedLinearElement && this.state.selectedLinearElement.hoverPointIndex !== -1)) {
          const elementWithTransformHandleType = getElementWithTransformHandleType(
            elements,
            this.state,
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            this.state.zoom,
            event.pointerType,
            this.scene.getNonDeletedElementsMap(),
            this.editorInterface
          );
          if (elementWithTransformHandleType != null) {
            if (elementWithTransformHandleType.transformHandleType === "rotation") {
              this.setState({
                resizingElement: elementWithTransformHandleType.element
              });
              pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
            } else if (this.state.croppingElementId) {
              pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
            } else {
              this.setState({
                resizingElement: elementWithTransformHandleType.element
              });
              pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
            }
          }
        } else if (selectedElements.length > 1) {
          pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(
            getCommonBounds8(selectedElements),
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            this.state.zoom,
            event.pointerType,
            this.editorInterface
          );
        }
        if (pointerDownState.resize.handleType) {
          pointerDownState.resize.isResizing = true;
          pointerDownState.resize.offset = tupleToCoors(
            getResizeOffsetXY(
              pointerDownState.resize.handleType,
              selectedElements,
              elementsMap,
              pointerDownState.origin.x,
              pointerDownState.origin.y
            )
          );
          if (selectedElements.length === 1 && isLinearElement12(selectedElements[0]) && selectedElements[0].points.length === 2) {
            pointerDownState.resize.arrowDirection = getResizeArrowDirection(
              pointerDownState.resize.handleType,
              selectedElements[0]
            );
          }
        } else {
          if (this.state.selectedLinearElement) {
            const linearElementEditor = this.state.selectedLinearElement;
            const ret = LinearElementEditor11.handlePointerDown(
              event,
              this,
              this.store,
              pointerDownState.origin,
              linearElementEditor,
              this.scene
            );
            if (ret.hitElement) {
              pointerDownState.hit.element = ret.hitElement;
            }
            if (ret.linearElementEditor) {
              this.setState({ selectedLinearElement: ret.linearElementEditor });
            }
            if (ret.didAddPoint) {
              return true;
            }
            const elementsMap2 = this.scene.getNonDeletedElementsMap();
            const arrow = LinearElementEditor11.getElement(
              linearElementEditor.elementId,
              elementsMap2
            );
            if (arrow && isBindingElement3(arrow)) {
              const { hitFocusPoint, pointerOffset } = handleFocusPointPointerDown(
                arrow,
                pointerDownState,
                elementsMap2,
                this.state
              );
              if (hitFocusPoint) {
                this.setState({
                  selectedLinearElement: {
                    ...linearElementEditor,
                    hoveredFocusPointBinding: hitFocusPoint,
                    draggedFocusPointBinding: hitFocusPoint,
                    pointerOffset
                  }
                });
                return false;
              }
            }
          }
          const allHitElements = this.getElementsAtPosition(
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            {
              includeLockedElements: true
            }
          );
          const unlockedHitElements = allHitElements.filter((e) => !e.locked);
          const hitElementMightBeLocked = this.getElementAtPosition(
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            {
              allHitElements
            }
          );
          if (!hitElementMightBeLocked || hitElementMightBeLocked.id !== this.state.activeLockedId) {
            this.setState({
              activeLockedId: null
            });
          }
          if (hitElementMightBeLocked && hitElementMightBeLocked.locked && !unlockedHitElements.some(
            (el) => this.state.selectedElementIds[el.id]
          )) {
            pointerDownState.hit.element = null;
          } else {
            pointerDownState.hit.element = pointerDownState.hit.element ?? this.getElementAtPosition(
              pointerDownState.origin.x,
              pointerDownState.origin.y
            );
          }
          this.hitLinkElement = this.getElementLinkAtPosition(
            pointerDownState.origin,
            hitElementMightBeLocked
          );
          if (this.hitLinkElement) {
            return true;
          }
          if (this.state.croppingElementId && pointerDownState.hit.element?.id !== this.state.croppingElementId) {
            this.finishImageCropping();
          }
          if (pointerDownState.hit.element) {
            const hitLinkElement = this.getElementLinkAtPosition(
              {
                x: pointerDownState.origin.x,
                y: pointerDownState.origin.y
              },
              pointerDownState.hit.element
            );
            if (hitLinkElement) {
              return false;
            }
          }
          pointerDownState.hit.allHitElements = unlockedHitElements;
          const hitElement = pointerDownState.hit.element;
          const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(
            (element) => this.isASelectedElement(element)
          );
          if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements && (!this.state.selectedLinearElement?.isEditing || hitElement && hitElement?.id !== this.state.selectedLinearElement?.elementId)) {
            this.clearSelection(hitElement);
          }
          if (this.state.selectedLinearElement?.isEditing) {
            this.setState((prevState) => ({
              selectedLinearElement: prevState.selectedLinearElement ? {
                ...prevState.selectedLinearElement,
                isEditing: !!hitElement && hitElement.id === this.state.selectedLinearElement?.elementId
              } : null,
              selectedElementIds: prevState.selectedLinearElement ? makeNextSelectedElementIds2(
                {
                  [prevState.selectedLinearElement.elementId]: true
                },
                this.state
              ) : makeNextSelectedElementIds2({}, prevState)
            }));
          } else if (hitElement != null) {
            if (event[KEYS54.CTRL_OR_CMD]) {
              if (event.altKey) {
                if (this.state.openDialog?.name === "elementLinkSelector") {
                  this.setOpenDialog(null);
                }
                this.lassoTrail.startPath(
                  pointerDownState.origin.x,
                  pointerDownState.origin.y,
                  event.shiftKey
                );
                this.setActiveTool({ type: "lasso", fromSelection: true });
                return false;
              }
              if (!this.state.selectedElementIds[hitElement.id]) {
                pointerDownState.hit.wasAddedToSelection = true;
              }
              this.setState((prevState) => ({
                ...editGroupForSelectedElement(prevState, hitElement),
                previousSelectedElementIds: this.state.selectedElementIds
              }));
              return false;
            }
            if (!this.state.selectedElementIds[hitElement.id]) {
              if (this.state.editingGroupId && !isElementInGroup2(hitElement, this.state.editingGroupId)) {
                this.setState({
                  selectedElementIds: makeNextSelectedElementIds2({}, this.state),
                  selectedGroupIds: {},
                  editingGroupId: null,
                  activeEmbeddable: null
                });
              }
              if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
                this.setState((prevState) => {
                  let nextSelectedElementIds = {
                    ...prevState.selectedElementIds,
                    [hitElement.id]: true
                  };
                  const previouslySelectedElements = [];
                  Object.keys(prevState.selectedElementIds).forEach((id) => {
                    const element = this.scene.getElement(id);
                    element && previouslySelectedElements.push(element);
                  });
                  if (isFrameLikeElement12(hitElement)) {
                    getFrameChildren5(
                      previouslySelectedElements,
                      hitElement.id
                    ).forEach((element) => {
                      delete nextSelectedElementIds[element.id];
                    });
                  } else if (hitElement.frameId) {
                    if (nextSelectedElementIds[hitElement.frameId]) {
                      delete nextSelectedElementIds[hitElement.id];
                    }
                  } else {
                    const groupIds = hitElement.groupIds;
                    const framesInGroups = new Set(
                      groupIds.flatMap(
                        (gid) => getElementsInGroup8(
                          this.scene.getNonDeletedElements(),
                          gid
                        )
                      ).filter((element) => isFrameLikeElement12(element)).map((frame) => frame.id)
                    );
                    if (framesInGroups.size > 0) {
                      previouslySelectedElements.forEach((element) => {
                        if (element.frameId && framesInGroups.has(element.frameId)) {
                          delete nextSelectedElementIds[element.id];
                          element.groupIds.flatMap(
                            (gid) => getElementsInGroup8(
                              this.scene.getNonDeletedElements(),
                              gid
                            )
                          ).forEach((element2) => {
                            delete nextSelectedElementIds[element2.id];
                          });
                        }
                      });
                    }
                  }
                  if (prevState.openDialog?.name === "elementLinkSelector") {
                    if (!hitElement.groupIds.some(
                      (gid) => prevState.selectedGroupIds[gid]
                    )) {
                      nextSelectedElementIds = {
                        [hitElement.id]: true
                      };
                    }
                  }
                  return {
                    ...selectGroupsForSelectedElements6(
                      {
                        editingGroupId: prevState.editingGroupId,
                        selectedElementIds: nextSelectedElementIds
                      },
                      this.scene.getNonDeletedElements(),
                      prevState,
                      this
                    ),
                    showHyperlinkPopup: hitElement.link || isEmbeddableElement4(hitElement) ? "info" : false
                  };
                });
                pointerDownState.hit.wasAddedToSelection = true;
              }
            }
          }
          this.setState({
            previousSelectedElementIds: this.state.selectedElementIds
          });
        }
      }
      return false;
    });
    __publicField(this, "handleTextOnPointerDown", (event, pointerDownState) => {
      if (this.state.editingTextElement) {
        return;
      }
      let sceneX = pointerDownState.origin.x;
      let sceneY = pointerDownState.origin.y;
      const element = this.getElementAtPosition(sceneX, sceneY, {
        includeBoundTextElement: true
      });
      let container = this.getTextBindableContainerAtPosition(sceneX, sceneY);
      if (hasBoundTextElement7(element)) {
        container = element;
        sceneX = element.x + element.width / 2;
        sceneY = element.y + element.height / 2;
      }
      this.startTextEditing({
        sceneX,
        sceneY,
        insertAtParentCenter: !event.altKey,
        container,
        autoEdit: false
      });
      resetCursor(this.interactiveCanvas);
      if (!this.state.activeTool.locked) {
        this.setState({
          activeTool: updateActiveTool7(this.state, {
            type: this.state.preferredSelectionTool.type
          })
        });
      }
    });
    __publicField(this, "handleFreeDrawElementOnPointerDown", (event, elementType, pointerDownState) => {
      const [gridX, gridY] = getGridPoint2(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        null
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const simulatePressure = event.pressure === 0.5;
      const element = newFreeDrawElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: null,
        simulatePressure,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null,
        points: [pointFrom26(0, 0)],
        pressures: simulatePressure ? [] : [event.pressure]
      });
      this.scene.insertElement(element);
      this.setState((prevState) => {
        const nextSelectedElementIds = {
          ...prevState.selectedElementIds
        };
        delete nextSelectedElementIds[element.id];
        return {
          selectedElementIds: makeNextSelectedElementIds2(
            nextSelectedElementIds,
            prevState
          )
        };
      });
      const boundElement = getHoveredElementForBinding2(
        pointFrom26(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        ),
        this.scene.getNonDeletedElements(),
        this.scene.getNonDeletedElementsMap()
      );
      this.setState({
        newElement: element,
        startBoundElement: boundElement,
        suggestedBinding: null
      });
    });
    __publicField(this, "insertIframeElement", ({
      sceneX,
      sceneY,
      width,
      height
    }) => {
      const [gridX, gridY] = getGridPoint2(
        sceneX,
        sceneY,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const element = newIframeElement({
        type: "iframe",
        x: gridX,
        y: gridY,
        strokeColor: "transparent",
        backgroundColor: "transparent",
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        roundness: this.getCurrentItemRoundness("iframe"),
        opacity: this.state.currentItemOpacity,
        locked: false,
        width,
        height
      });
      this.scene.insertElement(element);
      return element;
    });
    //create rectangle element with youtube top left on nearest grid point width / hight 640/360
    __publicField(this, "insertEmbeddableElement", ({
      sceneX,
      sceneY,
      link
    }) => {
      const [gridX, gridY] = getGridPoint2(
        sceneX,
        sceneY,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const embedLink = getEmbedLink2(link);
      if (!embedLink) {
        return;
      }
      if (embedLink.error instanceof URIError) {
        this.setToast({
          message: t("toast.unrecognizedLinkFormat"),
          closable: true
        });
      }
      const element = newEmbeddableElement({
        type: "embeddable",
        x: gridX,
        y: gridY,
        strokeColor: "transparent",
        backgroundColor: "transparent",
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        roundness: this.getCurrentItemRoundness("embeddable"),
        opacity: this.state.currentItemOpacity,
        locked: false,
        width: embedLink.intrinsicSize.w,
        height: embedLink.intrinsicSize.h,
        link
      });
      this.scene.insertElement(element);
      return element;
    });
    __publicField(this, "newImagePlaceholder", ({
      sceneX,
      sceneY,
      addToFrameUnderCursor = true
    }) => {
      const [gridX, gridY] = getGridPoint2(
        sceneX,
        sceneY,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = addToFrameUnderCursor ? this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      }) : null;
      const placeholderSize = 100 / this.state.zoom.value;
      return newImageElement({
        type: "image",
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        roundness: null,
        opacity: this.state.currentItemOpacity,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null,
        x: gridX - placeholderSize / 2,
        y: gridY - placeholderSize / 2,
        width: placeholderSize,
        height: placeholderSize
      });
    });
    __publicField(this, "handleLinearElementOnPointerDown", (event, elementType, pointerDownState) => {
      if (event.ctrlKey) {
        flushSync3(() => {
          this.setState({ isBindingEnabled: false });
        });
      }
      if (this.state.multiElement) {
        const { multiElement, selectedLinearElement } = this.state;
        invariant16(
          selectedLinearElement,
          "selectedLinearElement is expected to be set"
        );
        if (multiElement.type === "line" && isPathALoop4(multiElement.points, this.state.zoom.value)) {
          flushSync3(() => {
            this.setState({
              selectedLinearElement: {
                ...selectedLinearElement,
                lastCommittedPoint: multiElement.points[multiElement.points.length - 1],
                initialState: {
                  ...selectedLinearElement.initialState,
                  lastClickedPoint: -1
                  // Disable dragging
                }
              }
            });
          });
          this.actionManager.executeAction(actionFinalize);
          return;
        }
        if (isElbowArrow9(multiElement) && multiElement.points.length > 1) {
          this.actionManager.executeAction(actionFinalize, "ui", {
            event: event.nativeEvent,
            sceneCoords: {
              x: pointerDownState.origin.x,
              y: pointerDownState.origin.y
            }
          });
          return;
        }
        const { x: rx, y: ry } = multiElement;
        const { lastCommittedPoint } = selectedLinearElement;
        const hoveredElementForBinding = isBindingEnabled2(this.state) && getHoveredElementForBinding2(
          pointFrom26(
            this.lastPointerMoveCoords?.x ?? rx + multiElement.points[multiElement.points.length - 1][0],
            this.lastPointerMoveCoords?.y ?? ry + multiElement.points[multiElement.points.length - 1][1]
          ),
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap()
        );
        if (isBindingElement3(multiElement) && hoveredElementForBinding || multiElement.points.length > 1 && lastCommittedPoint && pointDistance8(
          pointFrom26(
            pointerDownState.origin.x - rx,
            pointerDownState.origin.y - ry
          ),
          lastCommittedPoint
        ) < LINE_CONFIRM_THRESHOLD2) {
          this.actionManager.executeAction(actionFinalize, "ui", {
            event: event.nativeEvent,
            sceneCoords: {
              x: pointerDownState.origin.x,
              y: pointerDownState.origin.y
            }
          });
          return;
        }
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds2(
            {
              ...prevState.selectedElementIds,
              [multiElement.id]: true
            },
            prevState
          )
        }));
        setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
      } else {
        const [gridX, gridY] = getGridPoint2(
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
          x: gridX,
          y: gridY
        });
        const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;
        const [startArrowhead, endArrowhead] = elementType === "arrow" ? [
          currentItemStartArrowhead ?? null,
          currentItemEndArrowhead ?? "arrow"
        ] : [null, null];
        const element = elementType === "arrow" ? newArrowElement2({
          type: elementType,
          x: gridX,
          y: gridY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          roundness: this.state.currentItemArrowType === ARROW_TYPE2.round ? { type: ROUNDNESS6.PROPORTIONAL_RADIUS } : (
            // note, roundness doesn't have any effect for elbow arrows,
            // but it's best to set it to null as well
            null
          ),
          startArrowhead,
          endArrowhead,
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null,
          elbowed: this.state.currentItemArrowType === ARROW_TYPE2.elbow,
          fixedSegments: this.state.currentItemArrowType === ARROW_TYPE2.elbow ? [] : null
        }) : newLinearElement3({
          type: elementType,
          x: gridX,
          y: gridY,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          roundness: this.state.currentItemRoundness === "round" ? { type: ROUNDNESS6.PROPORTIONAL_RADIUS } : null,
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null
        });
        const point = pointFrom26(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        const elementsMap = this.scene.getNonDeletedElementsMap();
        const boundElement = isBindingEnabled2(this.state) ? getHoveredElementForBinding2(
          point,
          this.scene.getNonDeletedElements(),
          elementsMap
        ) : null;
        this.scene.mutateElement(element, {
          points: [pointFrom26(0, 0), pointFrom26(0, 0)]
        });
        this.scene.insertElement(element);
        if (isBindingElement3(element)) {
          bindOrUnbindBindingElement2(
            element,
            /* @__PURE__ */ new Map([
              [
                0,
                {
                  point: pointFrom26(0, 0),
                  isDragging: false
                }
              ]
            ]),
            point[0],
            point[1],
            this.scene,
            this.state,
            {
              newArrow: true,
              altKey: event.altKey,
              initialBinding: true,
              angleLocked: shouldRotateWithDiscreteAngle3(event.nativeEvent)
            }
          );
        }
        flushSync3(() => {
          this.setState((prevState) => {
            let linearElementEditor = null;
            let nextSelectedElementIds = prevState.selectedElementIds;
            if (isLinearElement12(element)) {
              linearElementEditor = new LinearElementEditor11(
                element,
                this.scene.getNonDeletedElementsMap()
              );
              const endIdx = element.points.length - 1;
              linearElementEditor = {
                ...linearElementEditor,
                selectedPointsIndices: [endIdx],
                initialState: {
                  ...linearElementEditor.initialState,
                  arrowStartIsInside: event.altKey,
                  lastClickedPoint: endIdx,
                  origin: pointFrom26(
                    pointerDownState.origin.x,
                    pointerDownState.origin.y
                  )
                }
              };
            }
            nextSelectedElementIds = !this.state.activeTool.locked ? makeNextSelectedElementIds2({ [element.id]: true }, prevState) : prevState.selectedElementIds;
            return {
              ...prevState,
              bindMode: "orbit",
              newElement: element,
              startBoundElement: boundElement,
              suggestedBinding: boundElement && isBindingElement3(element) ? {
                element: boundElement,
                midPoint: getSnapOutlineMidPoint2(
                  point,
                  boundElement,
                  elementsMap,
                  this.state.zoom
                )
              } : null,
              selectedElementIds: nextSelectedElementIds,
              selectedLinearElement: linearElementEditor
            };
          });
        });
        if (isBindingElement3(element) && getFeatureFlag4("COMPLEX_BINDINGS")) {
          this.handleDelayedBindModeChange(element, boundElement);
        }
      }
    });
    __publicField(this, "createGenericElementOnPointerDown", (elementType, pointerDownState) => {
      const [gridX, gridY] = getGridPoint2(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const baseElementAttributes = {
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.getCurrentItemRoundness(elementType),
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null
      };
      let element;
      if (elementType === "embeddable") {
        element = newEmbeddableElement({
          type: "embeddable",
          ...baseElementAttributes
        });
      } else {
        element = newElement4({
          type: elementType,
          ...baseElementAttributes
        });
      }
      if (element.type === "selection") {
        this.setState({
          selectionElement: element
        });
      } else {
        this.scene.insertElement(element);
        this.setState({
          multiElement: null,
          newElement: element
        });
      }
    });
    __publicField(this, "createStickyNoteOnPointerDown", (pointerDownState) => {
      const [gridX, gridY] = getGridPoint2(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const STICKY_NOTE_DEFAULT_WIDTH = 200;
      const STICKY_NOTE_DEFAULT_HEIGHT = 205;
      const element = newElement4({
        type: "rectangle",
        x: gridX,
        y: gridY,
        width: STICKY_NOTE_DEFAULT_WIDTH,
        height: STICKY_NOTE_DEFAULT_HEIGHT,
        backgroundColor: this.state.lastStickyNoteBackgroundColor,
        fillStyle: "solid",
        strokeColor: this.state.currentItemStrokeColor,
        strokeWidth: 0,
        strokeStyle: "solid",
        roughness: ROUGHNESS2.architect,
        opacity: this.state.currentItemOpacity,
        roundness: null,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null,
        customData: { isStickyNote: true }
      });
      this.scene.insertElement(element);
      this.setState(
        {
          multiElement: null,
          newElement: null
        },
        () => {
          const sceneX = element.x + element.width / 2;
          const sceneY = element.y + element.height / 2;
          const container = element;
          queueMicrotask(() => {
            this.startTextEditing({
              sceneX,
              sceneY,
              container,
              insertAtParentCenter: true
            });
          });
        }
      );
    });
    __publicField(this, "handleQuickAddHandleActivate", (side, originShapeId) => {
      const hadPreviousTextEditing = !!this.state.editingTextElement;
      if (this.state.editingTextElement) {
        flushSync3(() => this.setState({ editingTextElement: null }));
      }
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const origin = elementsMap.get(originShapeId);
      if (!origin || origin.isDeleted) {
        return;
      }
      const isSticky = origin.type === "rectangle" && origin.customData?.isStickyNote === true;
      const gap = isSticky ? 20 : 60;
      const STICKY_NOTE_DEFAULT_WIDTH = 200;
      const STICKY_NOTE_DEFAULT_HEIGHT = 205;
      const w = isSticky ? STICKY_NOTE_DEFAULT_WIDTH : origin.width;
      const h = isSticky ? STICKY_NOTE_DEFAULT_HEIGHT : origin.height;
      let sceneX;
      let sceneY;
      switch (side) {
        case "top":
          sceneX = origin.x + origin.width / 2 - w / 2;
          sceneY = origin.y - h - gap;
          break;
        case "right":
          sceneX = origin.x + origin.width + gap;
          sceneY = origin.y + (origin.height - h) / 2;
          break;
        case "bottom":
          sceneX = origin.x + (origin.width - w) / 2;
          sceneY = origin.y + origin.height + gap;
          break;
        case "left":
          sceneX = origin.x - w - gap;
          sceneY = origin.y + (origin.height - h) / 2;
          break;
      }
      const [gridX, gridY] = getGridPoint2(
        sceneX,
        sceneY,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      if (isSticky) {
        const element = newElement4({
          type: "rectangle",
          x: gridX,
          y: gridY,
          width: STICKY_NOTE_DEFAULT_WIDTH,
          height: STICKY_NOTE_DEFAULT_HEIGHT,
          backgroundColor: this.state.lastStickyNoteBackgroundColor,
          fillStyle: "solid",
          strokeColor: this.state.currentItemStrokeColor,
          strokeWidth: 0,
          strokeStyle: "solid",
          roughness: ROUGHNESS2.architect,
          opacity: this.state.currentItemOpacity,
          roundness: null,
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null,
          customData: { isStickyNote: true }
        });
        this.scene.insertElement(element);
        flushSync3(() => {
          this.setState({
            multiElement: null,
            newElement: null,
            selectedElementIds: { [element.id]: true }
          });
        });
        requestAnimationFrame(() => {
          this.startTextEditing({
            sceneX: element.x + element.width / 2,
            sceneY: element.y + element.height / 2,
            container: element,
            insertAtParentCenter: true
          });
          if (hadPreviousTextEditing) {
            requestAnimationFrame(() => {
              const map = this.scene.getNonDeletedElementsMap();
              const boundText = getBoundTextElement9(element, map);
              if (boundText) {
                flushSync3(() => this.setState({ editingTextElement: null }));
                flushSync3(
                  () => this.setState({ editingTextElement: boundText })
                );
              }
            });
          }
        });
      } else {
        const elementType = origin.type;
        const baseElementAttributes = {
          x: gridX,
          y: gridY,
          width: w,
          height: h,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          roundness: this.getCurrentItemRoundness(elementType),
          locked: false,
          frameId: topLayerFrame ? topLayerFrame.id : null
        };
        const element = newElement4({
          type: elementType,
          ...baseElementAttributes
        });
        this.scene.insertElement(element);
        const originCenterX = side === "left" || side === "right" ? side === "right" ? origin.x + origin.width : origin.x : origin.x + origin.width / 2;
        const originCenterY = side === "top" || side === "bottom" ? side === "bottom" ? origin.y + origin.height : origin.y : origin.y + origin.height / 2;
        const newShapeCenterX = side === "left" || side === "right" ? side === "right" ? gridX : gridX + w : gridX + w / 2;
        const newShapeCenterY = side === "top" || side === "bottom" ? side === "bottom" ? gridY : gridY + h : gridY + h / 2;
        const arrow = newArrowElement2({
          type: "arrow",
          x: originCenterX,
          y: originCenterY,
          strokeColor: this.state.currentItemStrokeColor,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          startArrowhead: null,
          endArrowhead: this.state.currentItemEndArrowhead ?? "arrow",
          points: [
            pointFrom26(0, 0),
            pointFrom26(
              newShapeCenterX - originCenterX,
              newShapeCenterY - originCenterY
            )
          ],
          elbowed: this.state.currentItemArrowType === ARROW_TYPE2.elbow,
          fixedSegments: this.state.currentItemArrowType === ARROW_TYPE2.elbow ? [] : null,
          frameId: topLayerFrame ? topLayerFrame.id : null
        });
        this.scene.insertElement(arrow);
        bindBindingElement2(
          arrow,
          origin,
          "orbit",
          "start",
          this.scene
        );
        bindBindingElement2(
          arrow,
          element,
          "orbit",
          "end",
          this.scene
        );
        flushSync3(() => {
          this.setState({
            multiElement: null,
            newElement: null,
            selectedElementIds: { [element.id]: true }
          });
        });
        requestAnimationFrame(() => {
          this.startTextEditing({
            sceneX: element.x + element.width / 2,
            sceneY: element.y + element.height / 2,
            container: element,
            insertAtParentCenter: true
          });
          if (hadPreviousTextEditing) {
            requestAnimationFrame(() => {
              const map = this.scene.getNonDeletedElementsMap();
              const boundText = getBoundTextElement9(element, map);
              if (boundText) {
                flushSync3(() => this.setState({ editingTextElement: null }));
                flushSync3(
                  () => this.setState({ editingTextElement: boundText })
                );
              }
            });
          }
        });
      }
      this.props.onQuickAddHandleActivate?.(side, originShapeId);
    });
    __publicField(this, "createFrameElementOnPointerDown", (pointerDownState, type) => {
      const [gridX, gridY] = getGridPoint2(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        this.lastPointerDownEvent?.[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const constructorOpts = {
        x: gridX,
        y: gridY,
        opacity: this.state.currentItemOpacity,
        locked: false,
        ...FRAME_STYLE5
      };
      const frame = type === TOOL_TYPE3.magicframe ? newMagicFrameElement(constructorOpts) : newFrameElement2(constructorOpts);
      this.scene.insertElement(frame);
      this.setState({
        multiElement: null,
        newElement: frame
      });
    });
    __publicField(this, "restoreReadyToEraseElements", () => {
      this.elementsPendingErasure = /* @__PURE__ */ new Set();
      this.triggerRender();
    });
    __publicField(this, "eraseElements", () => {
      let didChange = false;
      this.elementsPendingErasure.forEach((id) => {
        const element = this.scene.getElement(id);
        if (isBindingElement3(element)) {
          if (element.startBinding) {
            const bindable = this.scene.getElement(
              element.startBinding.elementId
            );
            mutateElement6(bindable, this.scene.getElementsMapIncludingDeleted(), {
              boundElements: bindable.boundElements.filter(
                (e) => e.id !== element.id
              )
            });
          }
          if (element.endBinding) {
            const bindable = this.scene.getElement(element.endBinding.elementId);
            mutateElement6(bindable, this.scene.getElementsMapIncludingDeleted(), {
              boundElements: bindable.boundElements.filter(
                (e) => e.id !== element.id
              )
            });
          }
        } else if (isBindableElement3(element)) {
          element.boundElements?.forEach((boundElement) => {
            if (boundElement.type === "arrow") {
              const arrow = this.scene.getElement(
                boundElement.id
              );
              if (arrow?.startBinding?.elementId === element.id) {
                mutateElement6(
                  arrow,
                  this.scene.getElementsMapIncludingDeleted(),
                  {
                    startBinding: null
                  }
                );
              }
              if (arrow?.endBinding?.elementId === element.id) {
                mutateElement6(
                  arrow,
                  this.scene.getElementsMapIncludingDeleted(),
                  {
                    endBinding: null
                  }
                );
              }
            }
          });
        }
      });
      const elements = this.scene.getElementsIncludingDeleted().map((ele) => {
        if (this.elementsPendingErasure.has(ele.id) || ele.frameId && this.elementsPendingErasure.has(ele.frameId) || isBoundToContainer9(ele) && this.elementsPendingErasure.has(ele.containerId)) {
          didChange = true;
          return newElementWith11(ele, { isDeleted: true });
        }
        return ele;
      });
      this.elementsPendingErasure = /* @__PURE__ */ new Set();
      if (didChange) {
        this.store.scheduleCapture();
        this.scene.replaceAllElements(elements);
      }
    });
    __publicField(this, "initializeImage", async (placeholderImageElement, imageFile) => {
      if (!isSupportedImageFile(imageFile)) {
        throw new Error(t("errors.unsupportedFileType"));
      }
      const mimeType = imageFile.type;
      setCursor(this.interactiveCanvas, "wait");
      if (mimeType === MIME_TYPES9.svg) {
        try {
          imageFile = SVGStringToFile(
            normalizeSVG(await imageFile.text()),
            imageFile.name
          );
        } catch (error) {
          console.warn(error);
          throw new Error(t("errors.svgImageInsertError"));
        }
      }
      const fileId = await (this.props.generateIdForFile?.(
        imageFile
      ) || generateIdFromFile(imageFile));
      if (!fileId) {
        console.warn(
          "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
        );
        throw new Error(t("errors.imageInsertError"));
      }
      const existingFileData = this.files[fileId];
      if (!existingFileData?.dataURL) {
        try {
          imageFile = await resizeImageFile(imageFile, {
            maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT
          });
        } catch (error) {
          console.error(
            "Error trying to resizing image file on insertion",
            error
          );
        }
        if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {
          throw new Error(
            t("errors.fileTooBig", {
              maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`
            })
          );
        }
      }
      const dataURL = this.files[fileId]?.dataURL || await getDataURL(imageFile);
      return new Promise(
        async (resolve, reject) => {
          try {
            let initializedImageElement = this.getLatestInitializedImageElement(
              placeholderImageElement,
              fileId
            );
            this.addMissingFiles([
              {
                mimeType,
                id: fileId,
                dataURL,
                created: Date.now(),
                lastRetrieved: Date.now()
              }
            ]);
            if (!this.imageCache.get(fileId)) {
              this.addNewImagesToImageCache();
              const { erroredFiles } = await this.updateImageCache([
                initializedImageElement
              ]);
              if (erroredFiles.size) {
                throw new Error("Image cache update resulted with an error.");
              }
            }
            const imageHTML = await this.imageCache.get(fileId)?.image;
            if (imageHTML && this.state.newElement?.id !== initializedImageElement.id) {
              initializedImageElement = this.getLatestInitializedImageElement(
                placeholderImageElement,
                fileId
              );
              const naturalDimensions = this.getImageNaturalDimensions(
                initializedImageElement,
                imageHTML
              );
              Object.assign(initializedImageElement, naturalDimensions);
            }
            resolve(initializedImageElement);
          } catch (error) {
            console.error(error);
            reject(new Error(t("errors.imageInsertError")));
          }
        }
      );
    });
    /**
     * use during async image initialization,
     * when the placeholder image could have been modified in the meantime,
     * and when you don't want to loose those modifications
     */
    __publicField(this, "getLatestInitializedImageElement", (imagePlaceholder, fileId) => {
      const latestImageElement = this.scene.getElement(imagePlaceholder.id) ?? imagePlaceholder;
      return newElementWith11(
        latestImageElement,
        {
          fileId
        }
      );
    });
    __publicField(this, "onImageToolbarButtonClick", async () => {
      try {
        const clientX = this.state.width / 2 + this.state.offsetLeft;
        const clientY = this.state.height / 2 + this.state.offsetTop;
        const { x, y } = viewportCoordsToSceneCoords3(
          { clientX, clientY },
          this.state
        );
        const imageFiles = await fileOpen({
          description: "Image",
          extensions: Object.keys(
            IMAGE_MIME_TYPES2
          ),
          multiple: true
        });
        this.insertImages(imageFiles, x, y);
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error(error);
        } else {
          console.warn(error);
        }
        this.setState(
          {
            newElement: null,
            activeTool: updateActiveTool7(this.state, {
              type: this.state.preferredSelectionTool.type
            })
          },
          () => {
            this.actionManager.executeAction(actionFinalize);
          }
        );
      }
    });
    __publicField(this, "getImageNaturalDimensions", (imageElement, imageHTML) => {
      const minHeight = Math.max(this.state.height - 120, 160);
      const maxHeight = Math.min(
        minHeight,
        Math.floor(this.state.height * 0.5) / this.state.zoom.value
      );
      const height = Math.min(imageHTML.naturalHeight, maxHeight);
      const width = height * (imageHTML.naturalWidth / imageHTML.naturalHeight);
      const x = imageElement.x + imageElement.width / 2 - width / 2;
      const y = imageElement.y + imageElement.height / 2 - height / 2;
      return {
        x,
        y,
        width,
        height,
        crop: null
      };
    });
    /** updates image cache, refreshing updated elements and/or setting status
        to error for images that fail during <img> element creation */
    __publicField(this, "updateImageCache", async (elements, files = this.files) => {
      const { updatedFiles, erroredFiles } = await _updateImageCache({
        imageCache: this.imageCache,
        fileIds: elements.map((element) => element.fileId),
        files
      });
      if (erroredFiles.size) {
        this.store.scheduleAction(CaptureUpdateAction36.NEVER);
        this.scene.replaceAllElements(
          this.scene.getElementsIncludingDeleted().map((element) => {
            if (isInitializedImageElement3(element) && erroredFiles.has(element.fileId)) {
              return newElementWith11(element, {
                status: "error"
              });
            }
            return element;
          })
        );
      }
      return { updatedFiles, erroredFiles };
    });
    /** adds new images to imageCache and re-renders if needed */
    __publicField(this, "addNewImagesToImageCache", async (imageElements = getInitializedImageElements(
      this.scene.getNonDeletedElements()
    ), files = this.files) => {
      const uncachedImageElements = imageElements.filter(
        (element) => !element.isDeleted && !this.imageCache.has(element.fileId)
      );
      if (uncachedImageElements.length) {
        const { updatedFiles } = await this.updateImageCache(
          uncachedImageElements,
          files
        );
        if (updatedFiles.size) {
          for (const element of uncachedImageElements) {
            if (updatedFiles.has(element.fileId)) {
              ShapeCache4.delete(element);
            }
          }
        }
        if (updatedFiles.size) {
          this.scene.triggerUpdate();
        }
      }
    });
    /** generally you should use `addNewImagesToImageCache()` directly if you need
     *  to render new images. This is just a failsafe  */
    __publicField(this, "scheduleImageRefresh", throttle2(() => {
      this.addNewImagesToImageCache();
    }, IMAGE_RENDER_TIMEOUT));
    __publicField(this, "updateBindingEnabledOnPointerMove", (event) => {
      const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);
      if (this.state.isBindingEnabled !== shouldEnableBinding) {
        this.setState({ isBindingEnabled: shouldEnableBinding });
      }
    });
    __publicField(this, "handleInteractiveCanvasRef", (canvas) => {
      if (canvas !== null) {
        this.interactiveCanvas = canvas;
        this.interactiveCanvas.addEventListener(
          EVENT13.TOUCH_START,
          this.onTouchStart,
          { passive: false }
        );
        this.interactiveCanvas.addEventListener(EVENT13.TOUCH_END, this.onTouchEnd);
      } else {
        this.interactiveCanvas?.removeEventListener(
          EVENT13.TOUCH_START,
          this.onTouchStart
        );
        this.interactiveCanvas?.removeEventListener(
          EVENT13.TOUCH_END,
          this.onTouchEnd
        );
      }
    });
    __publicField(this, "insertImages", async (imageFiles, sceneX, sceneY) => {
      const gridPadding = 50 / this.state.zoom.value;
      const placeholders = positionElementsOnGrid(
        imageFiles.map(() => this.newImagePlaceholder({ sceneX, sceneY })),
        sceneX,
        sceneY,
        gridPadding
      );
      placeholders.forEach((el) => this.scene.insertElement(el));
      const initialized = await Promise.all(
        placeholders.map(async (placeholder, i) => {
          try {
            return await this.initializeImage(
              placeholder,
              await normalizeFile(imageFiles[i])
            );
          } catch (error) {
            this.setState({
              errorMessage: error.message || t("errors.imageInsertError")
            });
            return newElementWith11(placeholder, { isDeleted: true });
          }
        })
      );
      const initializedMap = arrayToMap26(initialized);
      const positioned = positionElementsOnGrid(
        initialized.filter((el) => !el.isDeleted),
        sceneX,
        sceneY,
        gridPadding
      );
      const positionedMap = arrayToMap26(positioned);
      const nextElements = this.scene.getElementsIncludingDeleted().map((el) => positionedMap.get(el.id) ?? initializedMap.get(el.id) ?? el);
      this.updateScene({
        appState: {
          selectedElementIds: makeNextSelectedElementIds2(
            Object.fromEntries(positioned.map((el) => [el.id, true])),
            this.state
          )
        },
        elements: nextElements,
        captureUpdate: CaptureUpdateAction36.IMMEDIATELY
      });
      this.setState({}, () => {
        this.actionManager.executeAction(actionFinalize);
      });
    });
    __publicField(this, "handleAppOnDrop", async (event) => {
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords3(
        event,
        this.state
      );
      const dataTransferList = await parseDataTransferEvent(event);
      const fileItems = dataTransferList.getFiles();
      if (fileItems.length === 1) {
        const { file: file2, fileHandle } = fileItems[0];
        if (file2 && (file2.type === MIME_TYPES9.png || file2.type === MIME_TYPES9.svg)) {
          try {
            const scene = await loadFromBlob(
              file2,
              this.state,
              this.scene.getElementsIncludingDeleted(),
              fileHandle
            );
            this.syncActionResult({
              ...scene,
              appState: {
                ...scene.appState || this.state,
                isLoading: false
              },
              replaceFiles: true,
              captureUpdate: CaptureUpdateAction36.IMMEDIATELY
            });
            return;
          } catch (error) {
            if (error.name !== "EncodingError") {
              throw new Error(t("alerts.couldNotLoadInvalidFile"));
            }
          }
        }
      }
      const imageFiles = fileItems.map((data) => data.file).filter((file2) => isSupportedImageFile(file2));
      if (imageFiles.length > 0 && this.isToolSupported("image")) {
        return this.insertImages(imageFiles, sceneX, sceneY);
      }
      const excalidrawLibrary_ids = dataTransferList.getData(
        MIME_TYPES9.excalidrawlibIds
      );
      const excalidrawLibrary_data = dataTransferList.getData(
        MIME_TYPES9.excalidrawlib
      );
      if (excalidrawLibrary_ids || excalidrawLibrary_data) {
        try {
          let libraryItems = null;
          if (excalidrawLibrary_ids) {
            const { itemIds } = JSON.parse(
              excalidrawLibrary_ids
            );
            const allLibraryItems = await this.library.getLatestLibrary();
            libraryItems = allLibraryItems.filter(
              (item) => itemIds.includes(item.id)
            );
          } else if (excalidrawLibrary_data) {
            libraryItems = parseLibraryJSON(excalidrawLibrary_data);
          }
          if (libraryItems?.length) {
            libraryItems = libraryItems.map((item) => ({
              ...item,
              // #6465
              elements: duplicateElements3({
                type: "everything",
                elements: item.elements,
                randomizeSeed: true
              }).duplicatedElements
            }));
            this.addElementsFromPasteOrLibrary({
              elements: distributeLibraryItemsOnSquareGrid(libraryItems),
              position: event,
              files: null
            });
          }
        } catch (error) {
          this.setState({ errorMessage: error.message });
        }
        return;
      }
      if (fileItems.length > 0) {
        const { file: file2, fileHandle } = fileItems[0];
        if (file2) {
          await this.loadFileToCanvas(file2, fileHandle);
        }
      }
      const textItem = dataTransferList.findByType(MIME_TYPES9.text);
      if (textItem) {
        const text = textItem.value;
        if (text && embeddableURLValidator2(text, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(text) || getEmbedLink2(text)?.type === "video")) {
          const embeddable = this.insertEmbeddableElement({
            sceneX,
            sceneY,
            link: normalizeLink3(text)
          });
          if (embeddable) {
            this.store.scheduleCapture();
            this.setState({ selectedElementIds: { [embeddable.id]: true } });
          }
        }
      }
    });
    __publicField(this, "loadFileToCanvas", async (file2, fileHandle) => {
      file2 = await normalizeFile(file2);
      try {
        const elements = this.scene.getElementsIncludingDeleted();
        let ret;
        try {
          ret = await loadSceneOrLibraryFromBlob(
            file2,
            this.state,
            elements,
            fileHandle
          );
        } catch (error) {
          const imageSceneDataError = error instanceof ImageSceneDataError;
          if (imageSceneDataError && error.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
            this.setState({
              isLoading: false,
              errorMessage: t("errors.imageToolNotSupported")
            });
            return;
          }
          const errorMessage = imageSceneDataError ? t("alerts.cannotRestoreFromImage") : t("alerts.couldNotLoadInvalidFile");
          this.setState({
            isLoading: false,
            errorMessage
          });
        }
        if (!ret) {
          return;
        }
        if (ret.type === MIME_TYPES9.excalidraw) {
          syncInvalidIndices(elements.concat(ret.data.elements));
          this.store.scheduleMicroAction({
            action: CaptureUpdateAction36.NEVER,
            elements,
            appState: void 0
          });
          this.setState({ isLoading: true });
          this.syncActionResult({
            ...ret.data,
            appState: {
              ...ret.data.appState || this.state,
              isLoading: false
            },
            replaceFiles: true,
            captureUpdate: CaptureUpdateAction36.IMMEDIATELY
          });
        } else if (ret.type === MIME_TYPES9.excalidrawlib) {
          await this.library.updateLibrary({
            libraryItems: file2,
            merge: true,
            openLibraryMenu: true
          }).catch((error) => {
            console.error(error);
            this.setState({ errorMessage: t("errors.importLibraryError") });
          });
        }
      } catch (error) {
        this.setState({ isLoading: false, errorMessage: error.message });
      }
    });
    __publicField(this, "handleCanvasContextMenu", (event) => {
      event.preventDefault();
      if (("pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "touch" || "pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "pen" && // always allow if user uses a pen secondary button
      event.button !== POINTER_BUTTON2.SECONDARY) && this.state.activeTool.type !== this.state.preferredSelectionTool.type) {
        return;
      }
      const { x, y } = viewportCoordsToSceneCoords3(event, this.state);
      const element = this.getElementAtPosition(x, y, {
        preferSelected: true,
        includeLockedElements: true
      });
      const selectedElements = this.scene.getSelectedElements(this.state);
      const isHittingCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements(
        { x, y },
        selectedElements
      );
      const type = element || isHittingCommonBoundBox ? "element" : "canvas";
      const container = this.excalidrawContainerRef.current;
      const { top: offsetTop, left: offsetLeft } = container.getBoundingClientRect();
      const left = event.clientX - offsetLeft;
      const top = event.clientY - offsetTop;
      trackEvent("contextMenu", "openContextMenu", type);
      this.setState(
        {
          ...element && !this.state.selectedElementIds[element.id] ? {
            ...this.state,
            ...selectGroupsForSelectedElements6(
              {
                editingGroupId: this.state.editingGroupId,
                selectedElementIds: { [element.id]: true }
              },
              this.scene.getNonDeletedElements(),
              this.state,
              this
            ),
            selectedLinearElement: isLinearElement12(element) ? new LinearElementEditor11(
              element,
              this.scene.getNonDeletedElementsMap()
            ) : null
          } : this.state,
          showHyperlinkPopup: false
        },
        () => {
          this.setState({
            contextMenu: { top, left, items: this.getContextMenuItems(type) }
          });
        }
      );
    });
    __publicField(this, "maybeDragNewGenericElement", (pointerDownState, event, informMutation = true) => {
      const selectionElement = this.state.selectionElement;
      const pointerCoords = pointerDownState.lastCoords;
      if (selectionElement && pointerDownState.boxSelection.hasOccurred && this.state.activeTool.type !== "eraser") {
        dragNewElement({
          newElement: selectionElement,
          elementType: this.state.activeTool.type,
          originX: pointerDownState.origin.x,
          originY: pointerDownState.origin.y,
          x: pointerCoords.x,
          y: pointerCoords.y,
          width: distance2(pointerDownState.origin.x, pointerCoords.x),
          height: distance2(pointerDownState.origin.y, pointerCoords.y),
          shouldMaintainAspectRatio: shouldMaintainAspectRatio(event),
          shouldResizeFromCenter: false,
          scene: this.scene,
          zoom: this.state.zoom.value,
          informMutation: false
        });
        return;
      }
      const newElement5 = this.state.newElement;
      if (!newElement5) {
        return;
      }
      let [gridX, gridY] = getGridPoint2(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const image = isInitializedImageElement3(newElement5) && this.imageCache.get(newElement5.fileId)?.image;
      const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;
      this.maybeCacheReferenceSnapPoints(event, [newElement5]);
      const { snapOffset, snapLines } = snapNewElement(
        newElement5,
        this,
        event,
        {
          x: pointerDownState.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
          y: pointerDownState.originInGrid.y + (this.state.originSnapOffset?.y ?? 0)
        },
        {
          x: gridX - pointerDownState.originInGrid.x,
          y: gridY - pointerDownState.originInGrid.y
        },
        this.scene.getNonDeletedElementsMap()
      );
      gridX += snapOffset.x;
      gridY += snapOffset.y;
      this.setState({
        snapLines
      });
      if (!isBindingElement3(newElement5)) {
        dragNewElement({
          newElement: newElement5,
          elementType: this.state.activeTool.type,
          originX: pointerDownState.originInGrid.x,
          originY: pointerDownState.originInGrid.y,
          x: gridX,
          y: gridY,
          width: distance2(pointerDownState.originInGrid.x, gridX),
          height: distance2(pointerDownState.originInGrid.y, gridY),
          shouldMaintainAspectRatio: isImageElement6(newElement5) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
          shouldResizeFromCenter: shouldResizeFromCenter(event),
          zoom: this.state.zoom.value,
          scene: this.scene,
          widthAspectRatio: aspectRatio,
          originOffset: this.state.originSnapOffset,
          informMutation
        });
      }
      this.setState({
        newElement: newElement5
      });
      if (this.state.activeTool.type === TOOL_TYPE3.frame || this.state.activeTool.type === TOOL_TYPE3.magicframe) {
        this.setState({
          elementsToHighlight: getElementsInResizingFrame2(
            this.scene.getNonDeletedElements(),
            newElement5,
            this.state,
            this.scene.getNonDeletedElementsMap()
          )
        });
      }
    });
    __publicField(this, "maybeHandleCrop", (pointerDownState, event) => {
      if (!this.state.croppingElementId) {
        return false;
      }
      const transformHandleType = pointerDownState.resize.handleType;
      const pointerCoords = pointerDownState.lastCoords;
      const [x, y] = getGridPoint2(
        pointerCoords.x - pointerDownState.resize.offset.x,
        pointerCoords.y - pointerDownState.resize.offset.y,
        event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const croppingElement = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
      if (transformHandleType && croppingElement && isImageElement6(croppingElement)) {
        const croppingAtStateStart = pointerDownState.originalElements.get(
          croppingElement.id
        );
        const image = isInitializedImageElement3(croppingElement) && this.imageCache.get(croppingElement.fileId)?.image;
        if (croppingAtStateStart && isImageElement6(croppingAtStateStart) && image && !(image instanceof Promise)) {
          const [gridX, gridY] = getGridPoint2(
            pointerCoords.x,
            pointerCoords.y,
            event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          );
          const dragOffset = {
            x: gridX - pointerDownState.originInGrid.x,
            y: gridY - pointerDownState.originInGrid.y
          };
          this.maybeCacheReferenceSnapPoints(event, [croppingElement]);
          const { snapOffset, snapLines } = snapResizingElements(
            [croppingElement],
            [croppingAtStateStart],
            this,
            event,
            dragOffset,
            transformHandleType
          );
          this.scene.mutateElement(
            croppingElement,
            cropElement(
              croppingElement,
              this.scene.getNonDeletedElementsMap(),
              transformHandleType,
              image.naturalWidth,
              image.naturalHeight,
              x + snapOffset.x,
              y + snapOffset.y,
              event.shiftKey ? croppingAtStateStart.width / croppingAtStateStart.height : void 0
            )
          );
          updateBoundElements3(croppingElement, this.scene);
          this.setState({
            isCropping: transformHandleType && transformHandleType !== "rotation",
            snapLines
          });
        }
        return true;
      }
      return false;
    });
    __publicField(this, "maybeHandleResize", (pointerDownState, event) => {
      const selectedElements = this.scene.getSelectedElements(this.state);
      const selectedFrames = selectedElements.filter(
        (element) => isFrameLikeElement12(element)
      );
      const transformHandleType = pointerDownState.resize.handleType;
      if (
        // Frames cannot be rotated.
        selectedFrames.length > 0 && transformHandleType === "rotation" || // Elbow arrows cannot be transformed (resized or rotated).
        selectedElements.length === 1 && isElbowArrow9(selectedElements[0]) || // Do not resize when in crop mode
        this.state.croppingElementId
      ) {
        return false;
      }
      this.setState({
        // TODO: rename this state field to "isScaling" to distinguish
        // it from the generic "isResizing" which includes scaling and
        // rotating
        isResizing: transformHandleType && transformHandleType !== "rotation",
        isRotating: transformHandleType === "rotation",
        activeEmbeddable: null
      });
      const pointerCoords = pointerDownState.lastCoords;
      let [resizeX, resizeY] = getGridPoint2(
        pointerCoords.x - pointerDownState.resize.offset.x,
        pointerCoords.y - pointerDownState.resize.offset.y,
        event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const frameElementsOffsetsMap = /* @__PURE__ */ new Map();
      selectedFrames.forEach((frame) => {
        const elementsInFrame = getFrameChildren5(
          this.scene.getNonDeletedElements(),
          frame.id
        );
        elementsInFrame.forEach((element) => {
          frameElementsOffsetsMap.set(frame.id + element.id, {
            x: element.x - frame.x,
            y: element.y - frame.y
          });
        });
      });
      if (!this.state.selectedElementsAreBeingDragged) {
        const [gridX, gridY] = getGridPoint2(
          pointerCoords.x,
          pointerCoords.y,
          event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
        );
        const dragOffset = {
          x: gridX - pointerDownState.originInGrid.x,
          y: gridY - pointerDownState.originInGrid.y
        };
        const originalElements = [...pointerDownState.originalElements.values()];
        this.maybeCacheReferenceSnapPoints(event, selectedElements);
        const { snapOffset, snapLines } = snapResizingElements(
          selectedElements,
          getSelectedElements(originalElements, this.state),
          this,
          event,
          dragOffset,
          transformHandleType
        );
        resizeX += snapOffset.x;
        resizeY += snapOffset.y;
        this.setState({
          snapLines
        });
      }
      if (transformElements(
        pointerDownState.originalElements,
        transformHandleType,
        selectedElements,
        this.scene,
        shouldRotateWithDiscreteAngle3(event),
        shouldResizeFromCenter(event),
        selectedElements.some((element) => isImageElement6(element)) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
        resizeX,
        resizeY,
        pointerDownState.resize.center.x,
        pointerDownState.resize.center.y
      )) {
        const elementsToHighlight = /* @__PURE__ */ new Set();
        selectedFrames.forEach((frame) => {
          getElementsInResizingFrame2(
            this.scene.getNonDeletedElements(),
            frame,
            this.state,
            this.scene.getNonDeletedElementsMap()
          ).forEach((element) => elementsToHighlight.add(element));
        });
        this.setState({
          elementsToHighlight: [...elementsToHighlight]
        });
        return true;
      }
      return false;
    });
    __publicField(this, "getContextMenuItems", (type) => {
      const options = [];
      options.push(actionCopyAsPng, actionCopyAsSvg);
      if (type === "canvas") {
        if (this.state.viewModeEnabled) {
          return [
            ...options,
            actionToggleGridMode,
            actionToggleZenMode,
            actionToggleViewMode,
            actionToggleStats
          ];
        }
        return [
          actionPaste,
          CONTEXT_MENU_SEPARATOR,
          actionCopyAsPng,
          actionCopyAsSvg,
          copyText,
          CONTEXT_MENU_SEPARATOR,
          actionSelectAll,
          actionUnlockAllElements,
          CONTEXT_MENU_SEPARATOR,
          actionToggleGridMode,
          actionToggleObjectsSnapMode,
          actionToggleZenMode,
          actionToggleViewMode,
          actionToggleStats
        ];
      }
      options.push(copyText);
      if (this.state.viewModeEnabled) {
        return [actionCopy, ...options];
      }
      const zIndexActions = this.editorInterface.formFactor === "desktop" ? [
        CONTEXT_MENU_SEPARATOR,
        actionSendBackward,
        actionBringForward,
        actionSendToBack,
        actionBringToFront
      ] : [];
      return [
        CONTEXT_MENU_SEPARATOR,
        actionCut,
        actionCopy,
        actionPaste,
        CONTEXT_MENU_SEPARATOR,
        actionSelectAllElementsInFrame,
        actionRemoveAllElementsFromFrame,
        actionWrapSelectionInFrame,
        CONTEXT_MENU_SEPARATOR,
        actionToggleCropEditor,
        CONTEXT_MENU_SEPARATOR,
        ...options,
        CONTEXT_MENU_SEPARATOR,
        actionCopyStyles,
        actionPasteStyles,
        CONTEXT_MENU_SEPARATOR,
        actionGroup,
        actionTextAutoResize,
        actionUnbindText,
        actionBindText,
        actionWrapTextInContainer,
        actionUngroup,
        CONTEXT_MENU_SEPARATOR,
        actionAddToLibrary,
        ...zIndexActions,
        CONTEXT_MENU_SEPARATOR,
        actionFlipHorizontal,
        actionFlipVertical,
        CONTEXT_MENU_SEPARATOR,
        actionToggleLinearEditor,
        CONTEXT_MENU_SEPARATOR,
        actionLink,
        actionCopyElementLink,
        CONTEXT_MENU_SEPARATOR,
        actionDuplicateSelection,
        actionToggleElementLock,
        CONTEXT_MENU_SEPARATOR,
        actionDeleteSelected
      ];
    });
    __publicField(this, "handleWheel", withBatchedUpdates(
      (event) => {
        if (!(event.target instanceof HTMLCanvasElement || event.target instanceof HTMLTextAreaElement || event.target instanceof HTMLIFrameElement || event.target instanceof HTMLElement && event.target.classList.contains(CLASSES11.FRAME_NAME))) {
          if (event[KEYS54.CTRL_OR_CMD]) {
            event.preventDefault();
          }
          return;
        }
        event.preventDefault();
        if (isPanning) {
          return;
        }
        const { deltaX, deltaY } = event;
        if (event.metaKey || event.ctrlKey) {
          const sign = Math.sign(deltaY);
          const MAX_STEP = ZOOM_STEP2 * 100;
          const absDelta = Math.abs(deltaY);
          let delta = deltaY;
          if (absDelta > MAX_STEP) {
            delta = MAX_STEP * sign;
          }
          let newZoom = this.state.zoom.value - delta / 100;
          newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign * // reduced amplification for small deltas (small movements on a trackpad)
          Math.min(1, absDelta / 20);
          this.translateCanvas((state) => ({
            ...getStateForZoom(
              {
                viewportX: this.lastViewportPosition.x,
                viewportY: this.lastViewportPosition.y,
                nextZoom: getNormalizedZoom(newZoom)
              },
              state
            ),
            shouldCacheIgnoreZoom: true
          }));
          this.resetShouldCacheIgnoreZoomDebounced();
          return;
        }
        if (event.shiftKey) {
          this.translateCanvas(({ zoom, scrollX }) => ({
            // on Mac, shift+wheel tends to result in deltaX
            scrollX: scrollX - (deltaY || deltaX) / zoom.value
          }));
          return;
        }
        this.translateCanvas(({ zoom, scrollX, scrollY }) => ({
          scrollX: scrollX - deltaX / zoom.value,
          scrollY: scrollY - deltaY / zoom.value
        }));
      }
    ));
    __publicField(this, "savePointer", (x, y, button) => {
      if (!x || !y) {
        return;
      }
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords3(
        { clientX: x, clientY: y },
        this.state
      );
      if (isNaN(sceneX) || isNaN(sceneY)) {
      }
      const pointer = {
        x: sceneX,
        y: sceneY,
        tool: this.state.activeTool.type === "laser" ? "laser" : "pointer"
      };
      this.props.onPointerUpdate?.({
        pointer,
        button,
        pointersMap: gesture.pointers
      });
    });
    __publicField(this, "resetShouldCacheIgnoreZoomDebounced", debounce4(() => {
      if (!this.unmounted) {
        this.setState({ shouldCacheIgnoreZoom: false });
      }
    }, 300));
    __publicField(this, "updateDOMRect", (cb) => {
      if (this.excalidrawContainerRef?.current) {
        const excalidrawContainer = this.excalidrawContainerRef.current;
        const {
          width,
          height,
          left: offsetLeft,
          top: offsetTop
        } = excalidrawContainer.getBoundingClientRect();
        const {
          width: currentWidth,
          height: currentHeight,
          offsetTop: currentOffsetTop,
          offsetLeft: currentOffsetLeft
        } = this.state;
        if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {
          if (cb) {
            cb();
          }
          return;
        }
        this.setState(
          {
            width,
            height,
            offsetLeft,
            offsetTop
          },
          () => {
            cb && cb();
          }
        );
      }
    });
    __publicField(this, "refresh", () => {
      this.setState({ ...this.getCanvasOffsets() });
    });
    __publicField(this, "watchState", () => {
    });
    const defaultAppState = getDefaultAppState();
    const {
      excalidrawAPI,
      viewModeEnabled = false,
      zenModeEnabled = false,
      gridModeEnabled = false,
      objectsSnapModeEnabled = false,
      theme = defaultAppState.theme,
      name = `${t("labels.untitled")}-${getDateTime()}`
    } = props;
    this.state = {
      ...defaultAppState,
      theme,
      isLoading: true,
      ...this.getCanvasOffsets(),
      viewModeEnabled,
      zenModeEnabled,
      objectsSnapModeEnabled,
      gridModeEnabled: gridModeEnabled ?? defaultAppState.gridModeEnabled,
      name,
      width: window.innerWidth,
      height: window.innerHeight
    };
    this.refreshEditorInterface();
    this.stylesPanelMode = deriveStylesPanelMode2(this.editorInterface);
    this.id = nanoid();
    this.library = new library_default(this);
    this.actionManager = new ActionManager(
      this.syncActionResult,
      () => this.state,
      () => this.scene.getElementsIncludingDeleted(),
      this
    );
    this.scene = new Scene();
    this.canvas = document.createElement("canvas");
    this.rc = rough3.canvas(this.canvas);
    this.renderer = new Renderer(this.scene);
    this.visibleElements = [];
    this.store = new Store(this);
    this.history = new History(this.store);
    if (excalidrawAPI) {
      const api = {
        updateScene: this.updateScene,
        applyDeltas: this.applyDeltas,
        mutateElement: this.mutateElement,
        updateLibrary: this.library.updateLibrary,
        addFiles: this.addFiles,
        resetScene: this.resetScene,
        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
        getSceneElementsMapIncludingDeleted: this.getSceneElementsMapIncludingDeleted,
        history: {
          clear: this.resetHistory
        },
        scrollToContent: this.scrollToContent,
        getSceneElements: this.getSceneElements,
        getAppState: () => this.state,
        getFiles: () => this.files,
        getName: this.getName,
        registerAction: (action) => {
          this.actionManager.registerAction(action);
        },
        refresh: this.refresh,
        setToast: this.setToast,
        id: this.id,
        setActiveTool: this.setActiveTool,
        setCursor: this.setCursor,
        resetCursor: this.resetCursor,
        getEditorInterface: () => this.editorInterface,
        updateFrameRendering: this.updateFrameRendering,
        toggleSidebar: this.toggleSidebar,
        onChange: (cb) => this.onChangeEmitter.on(cb),
        onIncrement: (cb) => this.store.onStoreIncrementEmitter.on(cb),
        onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),
        onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),
        onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),
        onUserFollow: (cb) => this.onUserFollowEmitter.on(cb)
      };
      if (typeof excalidrawAPI === "function") {
        excalidrawAPI(api);
      } else {
        console.error("excalidrawAPI should be a function!");
      }
    }
    this.excalidrawContainerValue = {
      container: this.excalidrawContainerRef.current,
      id: this.id
    };
    this.fonts = new Fonts(this.scene);
    this.history = new History(this.store);
    this.actionManager.registerAll(actions);
    this.actionManager.registerAction(createUndoAction(this.history));
    this.actionManager.registerAction(createRedoAction(this.history));
  }
  onWindowMessage(event) {
    if (event.origin !== "https://player.vimeo.com" && event.origin !== "https://www.youtube.com") {
      return;
    }
    let data = null;
    try {
      data = JSON.parse(event.data);
    } catch (e) {
    }
    if (!data) {
      return;
    }
    switch (event.origin) {
      case "https://player.vimeo.com":
        if (data.method === "paused") {
          let source = null;
          const iframes = document.body.querySelectorAll(
            "iframe.excalidraw__embeddable"
          );
          if (!iframes) {
            break;
          }
          for (const iframe of iframes) {
            if (iframe.contentWindow === event.source) {
              source = iframe.contentWindow;
            }
          }
          source?.postMessage(
            JSON.stringify({
              method: data.value ? "play" : "pause",
              value: true
            }),
            "*"
          );
        }
        break;
      case "https://www.youtube.com":
        if (data.event === "infoDelivery" && data.info && data.id && typeof data.info.playerState === "number") {
          const id = data.id;
          const playerState = data.info.playerState;
          if (Object.values(YOUTUBE_STATES).includes(playerState)) {
            YOUTUBE_VIDEO_STATES.set(
              id,
              playerState
            );
          }
        }
        break;
    }
  }
  handleSkipBindMode() {
    if (this.state.selectedLinearElement?.initialState && !this.state.selectedLinearElement.initialState.arrowStartIsInside) {
      invariant16(
        this.lastPointerMoveCoords,
        "Missing last pointer move coords when changing bind skip mode for arrow start"
      );
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const hoveredElement = getHoveredElementForBinding2(
        pointFrom26(
          this.lastPointerMoveCoords.x,
          this.lastPointerMoveCoords.y
        ),
        this.scene.getNonDeletedElements(),
        elementsMap
      );
      const element = LinearElementEditor11.getElement(
        this.state.selectedLinearElement.elementId,
        elementsMap
      );
      if (element?.startBinding && hoveredElement?.id === element.startBinding.elementId) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            initialState: {
              ...this.state.selectedLinearElement.initialState,
              arrowStartIsInside: true
            }
          }
        });
      }
    }
    if (this.state.bindMode === "orbit") {
      if (this.bindModeHandler) {
        clearTimeout(this.bindModeHandler);
        this.bindModeHandler = null;
      }
      flushSync3(() => {
        this.setState({
          bindMode: "skip"
        });
      });
      if (this.lastPointerMoveCoords && this.state.selectedLinearElement?.selectedPointsIndices && this.state.selectedLinearElement?.selectedPointsIndices.length) {
        const { x, y } = this.lastPointerMoveCoords;
        const event = this.lastPointerMoveEvent ?? this.lastPointerDownEvent?.nativeEvent;
        invariant16(event, "Last event must exist");
        const deltaX = x - this.state.selectedLinearElement.pointerOffset.x;
        const deltaY = y - this.state.selectedLinearElement.pointerOffset.y;
        const newState = this.state.multiElement ? LinearElementEditor11.handlePointerMove(
          event,
          this,
          deltaX,
          deltaY,
          this.state.selectedLinearElement
        ) : LinearElementEditor11.handlePointDragging(
          event,
          this,
          deltaX,
          deltaY,
          this.state.selectedLinearElement
        );
        if (newState) {
          this.setState(newState);
        }
      }
    }
  }
  resetDelayedBindMode() {
    if (this.bindModeHandler) {
      clearTimeout(this.bindModeHandler);
      this.bindModeHandler = null;
    }
    if (this.state.bindMode !== "orbit") {
      setTimeout(
        () => this.setState({
          bindMode: "orbit"
        })
      );
    }
  }
  handleDelayedBindModeChange(arrow, hoveredElement) {
    if (arrow.isDeleted || isElbowArrow9(arrow)) {
      return;
    }
    const effector = () => {
      this.bindModeHandler = null;
      invariant16(
        this.lastPointerMoveCoords,
        "Expected lastPointerMoveCoords to be set"
      );
      if (!this.state.multiElement) {
        if (!this.state.selectedLinearElement || !this.state.selectedLinearElement.selectedPointsIndices || !this.state.selectedLinearElement.selectedPointsIndices.length) {
          return;
        }
        const startDragged2 = this.state.selectedLinearElement.selectedPointsIndices.includes(0);
        const endDragged2 = this.state.selectedLinearElement.selectedPointsIndices.includes(
          arrow.points.length - 1
        );
        if (!startDragged2 && !endDragged2 || startDragged2 && endDragged2) {
          return;
        }
      }
      const { x, y } = this.lastPointerMoveCoords;
      const hoveredElement2 = getHoveredElementForBinding2(
        pointFrom26(x, y),
        this.scene.getNonDeletedElements(),
        this.scene.getNonDeletedElementsMap()
      );
      if (hoveredElement2 && this.state.bindMode !== "skip") {
        invariant16(
          this.state.selectedLinearElement?.elementId === arrow.id,
          "The selectedLinearElement is expected to not change while a bind mode timeout is ticking"
        );
        const arrowStartIsInside = this.state.selectedLinearElement.initialState.arrowStartIsInside || arrow.startBinding?.elementId === hoveredElement2.id;
        flushSync3(() => {
          invariant16(
            this.state.selectedLinearElement,
            "this.state.selectedLinearElement must exist"
          );
          this.setState({
            bindMode: "inside",
            selectedLinearElement: {
              ...this.state.selectedLinearElement,
              initialState: {
                ...this.state.selectedLinearElement.initialState,
                arrowStartIsInside
              }
            }
          });
        });
        const event = this.lastPointerMoveEvent ?? this.lastPointerDownEvent?.nativeEvent;
        invariant16(event, "Last event must exist");
        const deltaX = x - this.state.selectedLinearElement.pointerOffset.x;
        const deltaY = y - this.state.selectedLinearElement.pointerOffset.y;
        const newState = this.state.multiElement ? LinearElementEditor11.handlePointerMove(
          event,
          this,
          deltaX,
          deltaY,
          this.state.selectedLinearElement
        ) : LinearElementEditor11.handlePointDragging(
          event,
          this,
          deltaX,
          deltaY,
          this.state.selectedLinearElement
        );
        if (newState) {
          this.setState(newState);
        }
      }
    };
    let isOverlapping = false;
    if (this.state.selectedLinearElement?.selectedPointsIndices) {
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const startDragged2 = this.state.selectedLinearElement.selectedPointsIndices.includes(0);
      const endDragged2 = this.state.selectedLinearElement.selectedPointsIndices.includes(
        arrow.points.length - 1
      );
      const startElement = startDragged2 ? hoveredElement : arrow.startBinding && elementsMap.get(arrow.startBinding.elementId);
      const endElement = endDragged2 ? hoveredElement : arrow.endBinding && elementsMap.get(arrow.endBinding.elementId);
      const startBounds = startElement && getElementBounds5(startElement, elementsMap);
      const endBounds = endElement && getElementBounds5(endElement, elementsMap);
      isOverlapping = !!(startBounds && endBounds && startElement.id !== endElement.id && doBoundsIntersect4(startBounds, endBounds));
    }
    const startDragged = this.state.selectedLinearElement?.selectedPointsIndices?.includes(0);
    const endDragged = this.state.selectedLinearElement?.selectedPointsIndices?.includes(
      arrow.points.length - 1
    );
    const currentBinding = startDragged ? "startBinding" : endDragged ? "endBinding" : null;
    const otherBinding = startDragged ? "endBinding" : endDragged ? "startBinding" : null;
    const isAlreadyInsideBindingToSameElement = otherBinding && arrow[otherBinding]?.mode === "inside" && arrow[otherBinding]?.elementId === hoveredElement?.id || currentBinding && arrow[currentBinding]?.mode === "inside" && hoveredElement?.id === arrow[currentBinding]?.elementId;
    if (currentBinding && otherBinding && arrow[currentBinding]?.mode === "inside" && hoveredElement?.id !== arrow[currentBinding]?.elementId && arrow[otherBinding]?.elementId !== arrow[currentBinding]?.elementId) {
      this.scene.mutateElement(
        arrow,
        {
          [currentBinding]: {
            ...arrow[currentBinding],
            mode: "orbit"
          }
        },
        {
          informMutation: false,
          isDragging: true
        }
      );
    }
    if (!hoveredElement || this.previousHoveredBindableElement && hoveredElement.id !== this.previousHoveredBindableElement.id) {
      if (this.bindModeHandler) {
        clearTimeout(this.bindModeHandler);
        this.bindModeHandler = null;
      }
      if (this.state.bindMode === "inside") {
        flushSync3(() => {
          this.setState({
            bindMode: "orbit"
          });
        });
      }
      this.previousHoveredBindableElement = null;
    } else if (!this.bindModeHandler && (!this.state.newElement || !arrow.startBinding || isOverlapping) && !isAlreadyInsideBindingToSameElement) {
      this.bindModeHandler = setTimeout(effector, BIND_MODE_TIMEOUT2);
    }
    this.previousHoveredBindableElement = hoveredElement;
  }
  cacheEmbeddableRef(element, ref) {
    if (ref) {
      this.iFrameRefs.set(element.id, ref);
    }
  }
  getHTMLIFrameElement(element) {
    return this.iFrameRefs.get(element.id);
  }
  handleEmbeddableCenterClick(element) {
    if (this.state.activeEmbeddable?.element === element && this.state.activeEmbeddable?.state === "active") {
      return;
    }
    setTimeout(() => {
      this.setState({
        activeEmbeddable: { element, state: "active" },
        selectedElementIds: { [element.id]: true },
        newElement: null,
        selectionElement: null
      });
    }, 100);
    if (isIframeElement2(element)) {
      return;
    }
    const iframe = this.getHTMLIFrameElement(element);
    if (!iframe?.contentWindow) {
      return;
    }
    if (iframe.src.includes("youtube")) {
      const state = YOUTUBE_VIDEO_STATES.get(element.id);
      if (!state) {
        YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);
        iframe.contentWindow.postMessage(
          JSON.stringify({
            event: "listening",
            id: element.id
          }),
          "*"
        );
      }
      switch (state) {
        case YOUTUBE_STATES.PLAYING:
        case YOUTUBE_STATES.BUFFERING:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "pauseVideo",
              args: ""
            }),
            "*"
          );
          break;
        default:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "playVideo",
              args: ""
            }),
            "*"
          );
      }
    }
    if (iframe.src.includes("player.vimeo.com")) {
      iframe.contentWindow.postMessage(
        JSON.stringify({
          method: "paused"
          //video play/pause in onWindowMessage handler
        }),
        "*"
      );
    }
  }
  isIframeLikeElementCenter(el, event, sceneX, sceneY) {
    return el && !event.altKey && !event.shiftKey && !event.metaKey && !event.ctrlKey && (this.state.activeEmbeddable?.element !== el || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && sceneX >= el.x + el.width / 3 && sceneX <= el.x + 2 * el.width / 3 && sceneY >= el.y + el.height / 3 && sceneY <= el.y + 2 * el.height / 3;
  }
  renderEmbeddables() {
    const scale = this.state.zoom.value;
    const normalizedWidth = this.state.width;
    const normalizedHeight = this.state.height;
    const embeddableElements = this.scene.getNonDeletedElements().filter(
      (el) => isEmbeddableElement4(el) && this.embedsValidationStatus.get(el.id) === true || isIframeElement2(el)
    );
    return /* @__PURE__ */ jsx151(Fragment27, { children: embeddableElements.map((el) => {
      const { x, y } = sceneCoordsToViewportCoords8(
        { sceneX: el.x, sceneY: el.y },
        this.state
      );
      const isVisible = isElementInViewport3(
        el,
        normalizedWidth,
        normalizedHeight,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
      const hasBeenInitialized = this.initializedEmbeds.has(el.id);
      if (isVisible && !hasBeenInitialized) {
        this.initializedEmbeds.add(el.id);
      }
      const shouldRender = isVisible || hasBeenInitialized;
      if (!shouldRender) {
        return null;
      }
      let src;
      if (isIframeElement2(el)) {
        src = null;
        const data = (el.customData?.generationData ?? this.magicGenerations.get(el.id)) || {
          status: "error",
          message: "No generation data",
          code: "ERR_NO_GENERATION_DATA"
        };
        if (data.status === "done") {
          const html = data.html;
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return html;
            }
          };
        } else if (data.status === "pending") {
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === THEME18.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `);
            }
          };
        } else {
          let message;
          if (data.code === "ERR_GENERATION_INTERRUPTED") {
            message = "Generation was interrupted...";
          } else {
            message = data.message || "Generation failed";
          }
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${COLOR_PALETTE8.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${message}</h3>
                  `);
            }
          };
        }
      } else {
        src = getEmbedLink2(toValidURL2(el.link || ""));
      }
      const isActive = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "active";
      const isHovered = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "hover";
      return /* @__PURE__ */ jsx151(
        "div",
        {
          className: clsx62("excalidraw__embeddable-container", {
            "is-hovered": isHovered
          }),
          style: {
            transform: isVisible ? `translate(${x - this.state.offsetLeft}px, ${y - this.state.offsetTop}px) scale(${scale})` : "none",
            display: isVisible ? "block" : "none",
            opacity: getRenderOpacity(
              el,
              getContainingFrame3(el, this.scene.getNonDeletedElementsMap()),
              this.elementsPendingErasure,
              null,
              this.state.openDialog?.name === "elementLinkSelector" ? DEFAULT_REDUCED_GLOBAL_ALPHA2 : 1
            ),
            ["--embeddable-radius"]: `${getCornerRadius2(
              Math.min(el.width, el.height),
              el
            )}px`
          },
          children: /* @__PURE__ */ jsxs87(
            "div",
            {
              className: "excalidraw__embeddable-container__inner",
              style: {
                width: isVisible ? `${el.width}px` : 0,
                height: isVisible ? `${el.height}px` : 0,
                transform: isVisible ? `rotate(${el.angle}rad)` : "none",
                pointerEvents: isActive ? POINTER_EVENTS.enabled : POINTER_EVENTS.disabled
              },
              children: [
                isHovered && /* @__PURE__ */ jsx151("div", { className: "excalidraw__embeddable-hint", children: t("buttons.embeddableInteractionButton") }),
                /* @__PURE__ */ jsx151(
                  "div",
                  {
                    className: "excalidraw__embeddable__outer",
                    style: {
                      padding: `${el.strokeWidth}px`
                    },
                    children: (isEmbeddableElement4(el) ? this.props.renderEmbeddable?.(el, this.state) : null) ?? /* @__PURE__ */ jsx151(
                      "iframe",
                      {
                        ref: (ref) => this.cacheEmbeddableRef(el, ref),
                        className: "excalidraw__embeddable",
                        srcDoc: src?.type === "document" ? src.srcdoc(this.state.theme) : void 0,
                        src: src?.type !== "document" ? src?.link ?? "" : void 0,
                        scrolling: "no",
                        referrerPolicy: "no-referrer-when-downgrade",
                        title: "Excalidraw Embedded Content",
                        allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                        allowFullScreen: true,
                        sandbox: `${src?.sandbox?.allowSameOrigin ? "allow-same-origin" : ""} allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads`
                      }
                    )
                  }
                )
              ]
            }
          )
        },
        el.id
      );
    }) });
  }
  toggleOverscrollBehavior(event) {
    document.documentElement.style.overscrollBehaviorX = event.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const { renderTopRightUI, renderTopLeftUI, renderCustomStats } = this.props;
    const sceneNonce = this.scene.getSceneNonce();
    const { elementsMap, visibleElements } = this.renderer.getRenderableElements({
      sceneNonce,
      zoom: this.state.zoom,
      offsetLeft: this.state.offsetLeft,
      offsetTop: this.state.offsetTop,
      scrollX: this.state.scrollX,
      scrollY: this.state.scrollY,
      height: this.state.height,
      width: this.state.width,
      editingTextElement: this.state.editingTextElement,
      newElementId: this.state.newElement?.id
    });
    this.visibleElements = visibleElements;
    const allElementsMap = this.scene.getNonDeletedElementsMap();
    const shouldBlockPointerEvents = (
      // default back to `--ui-pointerEvents` flow if setPointerCapture
      // not supported
      "setPointerCapture" in HTMLElement.prototype ? false : this.state.selectionElement || this.state.newElement || this.state.selectedElementsAreBeingDragged || this.state.resizingElement || this.state.activeTool.type === "laser" && // technically we can just test on this once we make it more safe
      this.state.cursorButton === "down"
    );
    const firstSelectedElement = selectedElements[0];
    const showShapeSwitchPanel = editorJotaiStore.get(convertElementTypePopupAtom)?.type === "panel";
    return /* @__PURE__ */ jsx151(
      "div",
      {
        translate: "no",
        className: clsx62("excalidraw excalidraw-container notranslate", {
          "excalidraw--view-mode": this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector",
          "excalidraw--mobile": this.editorInterface.formFactor === "phone"
        }),
        style: {
          ["--ui-pointerEvents"]: shouldBlockPointerEvents ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled,
          ["--right-sidebar-width"]: "302px"
        },
        ref: this.excalidrawContainerRef,
        onDrop: this.handleAppOnDrop,
        tabIndex: 0,
        onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
        onPointerEnter: this.toggleOverscrollBehavior,
        onPointerLeave: this.toggleOverscrollBehavior,
        children: /* @__PURE__ */ jsx151(AppContext.Provider, { value: this, children: /* @__PURE__ */ jsx151(AppPropsContext.Provider, { value: this.props, children: /* @__PURE__ */ jsx151(
          ExcalidrawContainerContext.Provider,
          {
            value: this.excalidrawContainerValue,
            children: /* @__PURE__ */ jsx151(EditorInterfaceContext.Provider, { value: this.editorInterface, children: /* @__PURE__ */ jsx151(ExcalidrawSetAppStateContext.Provider, { value: this.setAppState, children: /* @__PURE__ */ jsx151(ExcalidrawAppStateContext.Provider, { value: this.state, children: /* @__PURE__ */ jsxs87(
              ExcalidrawElementsContext.Provider,
              {
                value: this.scene.getNonDeletedElements(),
                children: [
                  /* @__PURE__ */ jsxs87(
                    ExcalidrawActionManagerContext.Provider,
                    {
                      value: this.actionManager,
                      children: [
                        /* @__PURE__ */ jsx151(
                          LayerUI_default,
                          {
                            canvas: this.canvas,
                            appState: this.state,
                            files: this.files,
                            setAppState: this.setAppState,
                            actionManager: this.actionManager,
                            elements: this.scene.getNonDeletedElements(),
                            onLockToggle: this.toggleLock,
                            onPenModeToggle: this.togglePenMode,
                            onHandToolToggle: this.onHandToolToggle,
                            langCode: getLanguage().code,
                            renderTopLeftUI,
                            renderTopRightUI,
                            renderCustomStats,
                            showExitZenModeBtn: typeof this.props?.zenModeEnabled === "undefined" && this.state.zenModeEnabled,
                            UIOptions: this.props.UIOptions,
                            onExportImage: this.onExportImage,
                            renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === this.state.preferredSelectionTool.type && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,
                            app: this,
                            isCollaborating: this.props.isCollaborating,
                            generateLinkForSelection: this.props.generateLinkForSelection,
                            children: this.props.children
                          }
                        ),
                        /* @__PURE__ */ jsx151("div", { className: "excalidraw-textEditorContainer" }),
                        /* @__PURE__ */ jsx151("div", { className: "excalidraw-contextMenuContainer" }),
                        /* @__PURE__ */ jsx151("div", { className: "excalidraw-eye-dropper-container" }),
                        /* @__PURE__ */ jsx151(
                          SVGLayer,
                          {
                            trails: [
                              this.laserTrails,
                              this.lassoTrail,
                              this.eraserTrail
                            ]
                          }
                        ),
                        selectedElements.length === 1 && this.state.openDialog?.name !== "elementLinkSelector" && this.state.showHyperlinkPopup && /* @__PURE__ */ jsx151(
                          Hyperlink,
                          {
                            element: firstSelectedElement,
                            scene: this.scene,
                            setAppState: this.setAppState,
                            onLinkOpen: this.props.onLinkOpen,
                            setToast: this.setToast,
                            updateEmbedValidationStatus: this.updateEmbedValidationStatus
                          },
                          firstSelectedElement.id
                        ),
                        this.props.aiEnabled !== false && selectedElements.length === 1 && isMagicFrameElement2(firstSelectedElement) && /* @__PURE__ */ jsx151(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: /* @__PURE__ */ jsx151(
                              ElementCanvasButton,
                              {
                                title: t("labels.convertToCode"),
                                icon: MagicIcon,
                                checked: false,
                                onChange: () => this.onMagicFrameGenerate(
                                  firstSelectedElement,
                                  "button"
                                )
                              }
                            )
                          }
                        ),
                        selectedElements.length === 1 && isIframeElement2(firstSelectedElement) && firstSelectedElement.customData?.generationData?.status === "done" && /* @__PURE__ */ jsxs87(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: [
                              /* @__PURE__ */ jsx151(
                                ElementCanvasButton,
                                {
                                  title: t("labels.copySource"),
                                  icon: copyIcon,
                                  checked: false,
                                  onChange: () => this.onIframeSrcCopy(firstSelectedElement)
                                }
                              ),
                              /* @__PURE__ */ jsx151(
                                ElementCanvasButton,
                                {
                                  title: "Enter fullscreen",
                                  icon: fullscreenIcon,
                                  checked: false,
                                  onChange: () => {
                                    const iframe = this.getHTMLIFrameElement(
                                      firstSelectedElement
                                    );
                                    if (iframe) {
                                      try {
                                        iframe.requestFullscreen();
                                        this.setState({
                                          activeEmbeddable: {
                                            element: firstSelectedElement,
                                            state: "active"
                                          },
                                          selectedElementIds: {
                                            [firstSelectedElement.id]: true
                                          },
                                          newElement: null,
                                          selectionElement: null
                                        });
                                      } catch (err) {
                                        console.warn(err);
                                        this.setState({
                                          errorMessage: "Couldn't enter fullscreen"
                                        });
                                      }
                                    }
                                  }
                                }
                              )
                            ]
                          }
                        ),
                        this.state.toast !== null && /* @__PURE__ */ jsx151(
                          Toast,
                          {
                            message: this.state.toast.message,
                            onClose: this.handleToastClose,
                            duration: this.state.toast.duration,
                            closable: this.state.toast.closable
                          }
                        ),
                        this.state.contextMenu && /* @__PURE__ */ jsx151(
                          ContextMenu,
                          {
                            items: this.state.contextMenu.items,
                            top: this.state.contextMenu.top,
                            left: this.state.contextMenu.left,
                            actionManager: this.actionManager,
                            onClose: (callback) => {
                              this.setState({ contextMenu: null }, () => {
                                this.focusContainer();
                                callback?.();
                              });
                            }
                          }
                        ),
                        /* @__PURE__ */ jsx151(
                          StaticCanvas_default,
                          {
                            canvas: this.canvas,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            visibleElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: isGridModeEnabled(this),
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: this.flowChartCreator.pendingNodes,
                              theme: this.state.theme,
                              stickyNotePlaceholder: t(
                                "labels.addTextPlaceholder"
                              ),
                              editingTextElementId: this.state.editingTextElement?.id ?? null
                            }
                          }
                        ),
                        this.state.newElement && /* @__PURE__ */ jsx151(
                          NewElementCanvas_default,
                          {
                            appState: this.state,
                            scale: window.devicePixelRatio,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: false,
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: null,
                              theme: this.state.theme,
                              stickyNotePlaceholder: t(
                                "labels.addTextPlaceholder"
                              ),
                              editingTextElementId: this.state.editingTextElement?.id ?? null
                            }
                          }
                        ),
                        /* @__PURE__ */ jsx151(
                          InteractiveCanvas_default,
                          {
                            app: this,
                            containerRef: this.excalidrawContainerRef,
                            canvas: this.interactiveCanvas,
                            elementsMap,
                            visibleElements,
                            allElementsMap,
                            selectedElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderScrollbars: this.props.renderScrollbars === true,
                            editorInterface: this.editorInterface,
                            renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                            handleCanvasRef: this.handleInteractiveCanvasRef,
                            onContextMenu: this.handleCanvasContextMenu,
                            onPointerMove: this.handleCanvasPointerMove,
                            onPointerUp: this.handleCanvasPointerUp,
                            onPointerCancel: this.removePointer,
                            onTouchMove: this.handleTouchMove,
                            onPointerDown: this.handleCanvasPointerDown,
                            onDoubleClick: this.handleCanvasDoubleClick
                          }
                        ),
                        (selectedElements.length === 1 || this.state.editingTextElement) && !this.state.resizingElement && !this.state.isRotating && !this.state.selectedElementsAreBeingDragged && (() => {
                          const focusedElement = this.state.editingTextElement ?? (selectedElements.length === 1 ? firstSelectedElement : null);
                          const originShape = focusedElement ? getQuickAddOriginShape(
                            focusedElement,
                            allElementsMap
                          ) : null;
                          return originShape && this.props.onQuickAddHandleActivate && /* @__PURE__ */ jsx151(
                            QuickAddHandles,
                            {
                              originShape,
                              appState: this.state,
                              onActivate: this.handleQuickAddHandleActivate
                            }
                          );
                        })(),
                        this.state.userToFollow && /* @__PURE__ */ jsx151(
                          FollowMode_default,
                          {
                            width: this.state.width,
                            height: this.state.height,
                            userToFollow: this.state.userToFollow,
                            onDisconnect: this.maybeUnfollowRemoteUser
                          }
                        ),
                        this.renderFrameNames(),
                        this.state.activeLockedId && /* @__PURE__ */ jsx151(
                          UnlockPopup_default,
                          {
                            app: this,
                            activeLockedId: this.state.activeLockedId
                          }
                        ),
                        showShapeSwitchPanel && /* @__PURE__ */ jsx151(ConvertElementTypePopup_default, { app: this })
                      ]
                    }
                  ),
                  this.renderEmbeddables()
                ]
              }
            ) }) }) })
          }
        ) }) })
      }
    );
  }
  setPlugins(plugins) {
    Object.assign(this.plugins, plugins);
  }
  async onMagicFrameGenerate(magicFrame, source) {
    const generateDiagramToCode = this.plugins.diagramToCode?.generate;
    if (!generateDiagramToCode) {
      this.setState({
        errorMessage: "No diagram to code plugin found"
      });
      return;
    }
    const magicFrameChildren = getElementsOverlappingFrame2(
      this.scene.getNonDeletedElements(),
      magicFrame
    ).filter((el) => !isMagicFrameElement2(el));
    if (!magicFrameChildren.length) {
      if (source === "button") {
        this.setState({ errorMessage: "Cannot generate from an empty frame" });
        trackEvent("ai", "generate (no-children)", "d2c");
      } else {
        this.setActiveTool({ type: "magicframe" });
      }
      return;
    }
    const frameElement = this.insertIframeElement({
      sceneX: magicFrame.x + magicFrame.width + 30,
      sceneY: magicFrame.y,
      width: magicFrame.width,
      height: magicFrame.height
    });
    if (!frameElement) {
      return;
    }
    this.updateMagicGeneration({
      frameElement,
      data: { status: "pending" }
    });
    this.setState({
      selectedElementIds: { [frameElement.id]: true }
    });
    trackEvent("ai", "generate (start)", "d2c");
    try {
      const { html } = await generateDiagramToCode({
        frame: magicFrame,
        children: magicFrameChildren
      });
      trackEvent("ai", "generate (success)", "d2c");
      if (!html.trim()) {
        this.updateMagicGeneration({
          frameElement,
          data: {
            status: "error",
            code: "ERR_OAI",
            message: "Nothing genereated :("
          }
        });
        return;
      }
      const parsedHtml = html.includes("<!DOCTYPE html>") && html.includes("</html>") ? html.slice(
        html.indexOf("<!DOCTYPE html>"),
        html.indexOf("</html>") + "</html>".length
      ) : html;
      this.updateMagicGeneration({
        frameElement,
        data: { status: "done", html: parsedHtml }
      });
    } catch (error) {
      trackEvent("ai", "generate (failed)", "d2c");
      this.updateMagicGeneration({
        frameElement,
        data: {
          status: "error",
          code: "ERR_OAI",
          message: error.message || "Unknown error during generation"
        }
      });
    }
  }
  onIframeSrcCopy(element) {
    if (element.customData?.generationData?.status === "done") {
      copyTextToSystemClipboard(element.customData.generationData.html);
      this.setToast({
        message: "copied to clipboard",
        closable: false,
        duration: 1500
      });
    }
  }
  clearImageShapeCache(filesMap) {
    const files = filesMap ?? this.files;
    this.scene.getNonDeletedElements().forEach((element) => {
      if (isInitializedImageElement3(element) && files[element.fileId]) {
        this.imageCache.delete(element.fileId);
        ShapeCache4.delete(element);
      }
    });
  }
  async componentDidMount() {
    this.unmounted = false;
    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;
    if (isTestEnv5() || isDevEnv9()) {
      const setState = this.setState.bind(this);
      Object.defineProperties(window.h, {
        state: {
          configurable: true,
          get: () => {
            return this.state;
          }
        },
        setState: {
          configurable: true,
          value: (...args) => {
            return this.setState(...args);
          }
        },
        app: {
          configurable: true,
          value: this
        },
        history: {
          configurable: true,
          value: this.history
        },
        store: {
          configurable: true,
          value: this.store
        },
        fonts: {
          configurable: true,
          value: this.fonts
        }
      });
    }
    this.store.onDurableIncrementEmitter.on((increment) => {
      this.history.record(increment.delta);
    });
    const { onIncrement } = this.props;
    if (onIncrement) {
      this.store.onStoreIncrementEmitter.on((increment) => {
        onIncrement(increment);
      });
    }
    this.scene.onUpdate(this.triggerRender);
    this.addEventListeners();
    if (this.props.autoFocus && this.excalidrawContainerRef.current) {
      this.focusContainer();
    }
    if (supportsResizeObserver2 && this.excalidrawContainerRef.current) {
      this.resizeObserver = new ResizeObserver(() => {
        this.refreshEditorInterface();
        this.updateDOMRect();
      });
      this.resizeObserver?.observe(this.excalidrawContainerRef.current);
    }
    const searchParams = new URLSearchParams(window.location.search.slice(1));
    if (searchParams.has("web-share-target")) {
      this.restoreFileFromShare();
    } else {
      this.updateDOMRect(this.initializeScene);
    }
    if (isBrave() && !isMeasureTextSupported()) {
      this.setState({
        errorMessage: /* @__PURE__ */ jsx151(BraveMeasureTextError_default, {})
      });
    }
  }
  componentWillUnmount() {
    window.launchQueue?.setConsumer(() => {
    });
    this.renderer.destroy();
    this.scene.destroy();
    this.scene = new Scene();
    this.fonts = new Fonts(this.scene);
    this.renderer = new Renderer(this.scene);
    this.files = {};
    this.imageCache.clear();
    this.resizeObserver?.disconnect();
    this.unmounted = true;
    this.removeEventListeners();
    this.library.destroy();
    this.laserTrails.stop();
    this.eraserTrail.stop();
    this.onChangeEmitter.clear();
    this.store.onStoreIncrementEmitter.clear();
    this.store.onDurableIncrementEmitter.clear();
    ShapeCache4.destroy();
    SnapCache.destroy();
    clearTimeout(touchTimeout);
    isSomeElementSelected.clearCache();
    selectGroupsForSelectedElements6.clearCache();
    touchTimeout = 0;
    document.documentElement.style.overscrollBehaviorX = "";
  }
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners();
    if (this.props.handleKeyboardGlobally) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener3(document, EVENT13.KEYDOWN, this.onKeyDown, false)
      );
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener3(
        this.excalidrawContainerRef.current,
        EVENT13.WHEEL,
        this.handleWheel,
        { passive: false }
      ),
      addEventListener3(window, EVENT13.MESSAGE, this.onWindowMessage, false),
      addEventListener3(document, EVENT13.POINTER_UP, this.removePointer, {
        passive: false
      }),
      // #3553
      addEventListener3(document, EVENT13.COPY, this.onCopy, { passive: false }),
      addEventListener3(document, EVENT13.KEYUP, this.onKeyUp, { passive: true }),
      addEventListener3(
        document,
        EVENT13.POINTER_MOVE,
        this.updateCurrentCursorPosition,
        { passive: false }
      ),
      // rerender text elements on font load to fix #637 && #1553
      addEventListener3(
        document.fonts,
        "loadingdone",
        (event) => {
          const fontFaces = event.fontfaces;
          this.fonts.onLoaded(fontFaces);
        },
        { passive: false }
      ),
      // Safari-only desktop pinch zoom
      addEventListener3(
        document,
        EVENT13.GESTURE_START,
        this.onGestureStart,
        false
      ),
      addEventListener3(
        document,
        EVENT13.GESTURE_CHANGE,
        this.onGestureChange,
        false
      ),
      addEventListener3(
        document,
        EVENT13.GESTURE_END,
        this.onGestureEnd,
        false
      ),
      addEventListener3(
        window,
        EVENT13.FOCUS,
        () => {
          this.maybeCleanupAfterMissingPointerUp(null);
          this.triggerRender(true);
        },
        { passive: false }
      )
    );
    if (this.state.viewModeEnabled) {
      return;
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener3(
        document,
        EVENT13.FULLSCREENCHANGE,
        this.onFullscreenChange,
        { passive: false }
      ),
      addEventListener3(document, EVENT13.PASTE, this.pasteFromClipboard, {
        passive: false
      }),
      addEventListener3(document, EVENT13.CUT, this.onCut, { passive: false }),
      addEventListener3(window, EVENT13.RESIZE, this.onResize, false),
      addEventListener3(window, EVENT13.UNLOAD, this.onUnload, false),
      addEventListener3(window, EVENT13.BLUR, this.onBlur, false),
      addEventListener3(
        this.excalidrawContainerRef.current,
        EVENT13.WHEEL,
        this.handleWheel,
        { passive: false }
      ),
      addEventListener3(
        this.excalidrawContainerRef.current,
        EVENT13.DRAG_OVER,
        this.disableEvent,
        false
      ),
      addEventListener3(
        this.excalidrawContainerRef.current,
        EVENT13.DROP,
        this.disableEvent,
        false
      )
    );
    if (this.props.detectScroll) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener3(
          getNearestScrollableContainer(this.excalidrawContainerRef.current),
          EVENT13.SCROLL,
          this.onScroll,
          { passive: false }
        )
      );
    }
  }
  componentDidUpdate(prevProps, prevState) {
    this.updateEmbeddables();
    const elements = this.scene.getElementsIncludingDeleted();
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const hasFollowedPersonLeft = prevState.userToFollow && !this.state.collaborators.has(prevState.userToFollow.socketId);
    if (hasFollowedPersonLeft) {
      this.maybeUnfollowRemoteUser();
    }
    if (prevState.zoom.value !== this.state.zoom.value || prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {
      this.props?.onScrollChange?.(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
      this.onScrollChangeEmitter.trigger(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
    }
    if (prevState.userToFollow !== this.state.userToFollow) {
      if (prevState.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: prevState.userToFollow,
          action: "UNFOLLOW"
        });
      }
      if (this.state.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: this.state.userToFollow,
          action: "FOLLOW"
        });
      }
    }
    if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {
      this.setState({
        activeTool: updateActiveTool7(this.state, { type: "selection" })
      });
    }
    if (this.state.activeTool.type === "eraser" && prevState.theme !== this.state.theme) {
      setEraserCursor(this.interactiveCanvas, this.state.theme);
    }
    if (prevState.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup) {
      this.setState({ showHyperlinkPopup: false });
    }
    if (prevProps.langCode !== this.props.langCode) {
      this.updateLanguage();
    }
    if (isEraserActive(prevState) && !isEraserActive(this.state)) {
      this.eraserTrail.endPath();
    }
    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {
      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });
    }
    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {
      this.addEventListeners();
      this.deselectElements();
    }
    if ((prevState.openDialog?.name === "elementLinkSelector" || this.state.openDialog?.name === "elementLinkSelector") && prevState.openDialog?.name !== this.state.openDialog?.name) {
      this.deselectElements();
      this.setState({
        hoveredElementIds: {}
      });
    }
    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {
      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });
    }
    if (prevProps.theme !== this.props.theme && this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    this.excalidrawContainerRef.current?.classList.toggle(
      "theme--dark",
      this.state.theme === THEME18.DARK
    );
    if (this.state.selectedLinearElement?.isEditing && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {
      setTimeout(() => {
        this.state.selectedLinearElement?.isEditing && this.actionManager.executeAction(actionFinalize);
      });
    }
    if (this.state.editingTextElement?.isDeleted) {
      this.setState({ editingTextElement: null });
    }
    this.store.commit(elementsMap, this.state);
    if (!this.state.isLoading) {
      this.props.onChange?.(elements, this.state, this.files);
      this.onChangeEmitter.trigger(elements, this.state, this.files);
    }
  }
  static resetTapTwice() {
    didTapTwice = false;
    firstTapPosition = null;
  }
  // TODO: Cover with tests
  async insertClipboardContent(data, dataTransferFiles, isPlainPaste) {
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords3(
      {
        clientX: this.lastViewportPosition.x,
        clientY: this.lastViewportPosition.y
      },
      this.state
    );
    if (data.errorMessage) {
      this.setState({ errorMessage: data.errorMessage });
      return;
    }
    if (dataTransferFiles.length === 0 && !isPlainPaste && data.mixedContent) {
      await this.addElementsFromMixedContentPaste(data.mixedContent, {
        isPlainPaste,
        sceneX,
        sceneY
      });
      return;
    }
    if (data.spreadsheet && !isPlainPaste) {
      this.setState({
        pasteDialog: {
          data: data.spreadsheet,
          shown: true
        }
      });
      return;
    }
    const imageFiles = dataTransferFiles.map((data2) => data2.file);
    if (imageFiles.length === 0 && data.text && !isPlainPaste) {
      const trimmedText = data.text.trim();
      if (trimmedText.startsWith("<svg") && trimmedText.endsWith("</svg>")) {
        imageFiles.push(SVGStringToFile(trimmedText));
      }
    }
    if (imageFiles.length > 0) {
      if (this.isToolSupported("image")) {
        await this.insertImages(imageFiles, sceneX, sceneY);
      } else {
        this.setState({ errorMessage: t("errors.imageToolNotSupported") });
      }
      return;
    }
    if (data.elements) {
      const elements = data.programmaticAPI ? convertToExcalidrawElements2(
        data.elements
      ) : data.elements;
      this.addElementsFromPasteOrLibrary({
        elements,
        files: data.files || null,
        position: this.editorInterface.formFactor === "desktop" ? "cursor" : "center",
        retainSeed: isPlainPaste
      });
      return;
    }
    if (!data.text) {
      return;
    }
    if (!isPlainPaste && isMaybeMermaidDefinition(data.text)) {
      const api = await import("@excalidraw/mermaid-to-excalidraw");
      try {
        const { elements: skeletonElements, files } = await api.parseMermaidToExcalidraw(data.text);
        const elements = convertToExcalidrawElements2(skeletonElements, {
          regenerateIds: true
        });
        this.addElementsFromPasteOrLibrary({
          elements,
          files,
          position: this.editorInterface.formFactor === "desktop" ? "cursor" : "center"
        });
        return;
      } catch (err) {
        console.warn(
          `parsing pasted text as mermaid definition failed: ${err.message}`
        );
      }
    }
    const nonEmptyLines = normalizeEOL2(data.text).split(/\n+/).map((s) => s.trim()).filter(Boolean);
    const embbeddableUrls = nonEmptyLines.map((str) => maybeParseEmbedSrc(str)).filter(
      (string) => embeddableURLValidator2(string, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(string) || getEmbedLink2(string)?.type === "video")
    );
    if (!isPlainPaste && embbeddableUrls.length > 0 && embbeddableUrls.length === nonEmptyLines.length) {
      const embeddables = [];
      for (const url of embbeddableUrls) {
        const prevEmbeddable = embeddables[embeddables.length - 1];
        const embeddable = this.insertEmbeddableElement({
          sceneX: prevEmbeddable ? prevEmbeddable.x + prevEmbeddable.width + 20 : sceneX,
          sceneY,
          link: normalizeLink3(url)
        });
        if (embeddable) {
          embeddables.push(embeddable);
        }
      }
      if (embeddables.length) {
        this.store.scheduleCapture();
        this.setState({
          selectedElementIds: Object.fromEntries(
            embeddables.map((embeddable) => [embeddable.id, true])
          )
        });
      }
      return;
    }
    this.addTextFromPaste(data.text, isPlainPaste);
  }
  // TODO rewrite this to paste both text & images at the same time if
  // pasted data contains both
  async addElementsFromMixedContentPaste(mixedContent, {
    isPlainPaste,
    sceneX,
    sceneY
  }) {
    if (!isPlainPaste && mixedContent.some((node) => node.type === "imageUrl") && this.isToolSupported("image")) {
      const imageURLs = mixedContent.filter((node) => node.type === "imageUrl").map((node) => node.value);
      const responses = await Promise.all(
        imageURLs.map(async (url) => {
          try {
            return { file: await ImageURLToFile(url) };
          } catch (error2) {
            let errorMessage = error2.message;
            if (error2.cause === "FETCH_ERROR") {
              errorMessage = t("errors.failedToFetchImage");
            } else if (error2.cause === "UNSUPPORTED") {
              errorMessage = t("errors.unsupportedFileType");
            }
            return { errorMessage };
          }
        })
      );
      const imageFiles = responses.filter((response) => !!response.file).map((response) => response.file);
      await this.insertImages(imageFiles, sceneX, sceneY);
      const error = responses.find((response) => !!response.errorMessage);
      if (error && error.errorMessage) {
        this.setState({ errorMessage: error.errorMessage });
      }
    } else {
      const textNodes = mixedContent.filter((node) => node.type === "text");
      if (textNodes.length) {
        this.addTextFromPaste(
          textNodes.map((node) => node.value).join("\n\n"),
          isPlainPaste
        );
      }
    }
  }
  addTextFromPaste(text, isPlainPaste = false) {
    const { x, y } = viewportCoordsToSceneCoords3(
      {
        clientX: this.lastViewportPosition.x,
        clientY: this.lastViewportPosition.y
      },
      this.state
    );
    const textElementProps = {
      x,
      y,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roundness: null,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text,
      fontSize: this.state.currentItemFontSize,
      fontFamily: this.state.currentItemFontFamily,
      textAlign: DEFAULT_TEXT_ALIGN3,
      verticalAlign: DEFAULT_VERTICAL_ALIGN,
      locked: false
    };
    const fontString = getFontString9({
      fontSize: textElementProps.fontSize,
      fontFamily: textElementProps.fontFamily
    });
    const lineHeight = getLineHeight4(textElementProps.fontFamily);
    const [x1, , x2] = getVisibleSceneBounds(this.state);
    const maxTextWidth = Math.max(Math.min((x2 - x1) * 0.5, 800), 200);
    const LINE_GAP = 10;
    let currentY = y;
    const lines = isPlainPaste ? [text] : text.split("\n");
    const textElements = lines.reduce(
      (acc, line, idx) => {
        const originalText = normalizeText2(line).trim();
        if (originalText.length) {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
            x,
            y: currentY
          });
          let metrics = measureText6(originalText, fontString, lineHeight);
          const isTextUnwrapped = metrics.width > maxTextWidth;
          const text2 = isTextUnwrapped ? wrapText4(originalText, fontString, maxTextWidth) : originalText;
          metrics = isTextUnwrapped ? measureText6(text2, fontString, lineHeight) : metrics;
          const startX = x - metrics.width / 2;
          const startY = currentY - metrics.height / 2;
          const element = newTextElement3({
            ...textElementProps,
            x: startX,
            y: startY,
            text: text2,
            originalText,
            lineHeight,
            autoResize: !isTextUnwrapped,
            frameId: topLayerFrame ? topLayerFrame.id : null
          });
          acc.push(element);
          currentY += element.height + LINE_GAP;
        } else {
          const prevLine = lines[idx - 1]?.trim();
          if (prevLine) {
            currentY += getLineHeightInPx3(textElementProps.fontSize, lineHeight) + LINE_GAP;
          }
        }
        return acc;
      },
      []
    );
    if (textElements.length === 0) {
      return;
    }
    this.scene.insertElements(textElements);
    this.store.scheduleCapture();
    this.setState({
      selectedElementIds: makeNextSelectedElementIds2(
        Object.fromEntries(textElements.map((el) => [el.id, true])),
        this.state
      )
    });
    if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && this.editorInterface.formFactor !== "phone") {
      this.setToast({
        message: t("toast.pasteAsSingleElement", {
          shortcut: getShortcutKey("CtrlOrCmd+Shift+V")
        }),
        duration: 5e3
      });
      PLAIN_PASTE_TOAST_SHOWN = true;
    }
  }
  handleTextWysiwyg(element, {
    isExistingElement = false,
    placeholder
  }) {
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const updateElement = (nextOriginalText, isDeleted) => {
      this.scene.replaceAllElements([
        // Not sure why we include deleted elements as well hence using deleted elements map
        ...this.scene.getElementsIncludingDeleted().map((_element) => {
          if (_element.id === element.id && isTextElement16(_element)) {
            return newElementWith11(_element, {
              originalText: nextOriginalText,
              isDeleted: isDeleted ?? _element.isDeleted,
              // returns (wrapped) text and new dimensions
              ...refreshTextDimensions(
                _element,
                getContainerElement7(_element, elementsMap),
                elementsMap,
                nextOriginalText
              )
            });
          }
          return _element;
        })
      ]);
    };
    textWysiwyg({
      id: element.id,
      canvas: this.canvas,
      getViewportCoords: (x, y) => {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords8(
          {
            sceneX: x,
            sceneY: y
          },
          this.state
        );
        return [
          viewportX - this.state.offsetLeft,
          viewportY - this.state.offsetTop
        ];
      },
      onChange: withBatchedUpdates((nextOriginalText) => {
        updateElement(nextOriginalText, false);
        if (isNonDeletedElement(element)) {
          updateBoundElements3(element, this.scene);
        }
      }),
      onSubmit: withBatchedUpdates(({ viaKeyboard, nextOriginalText }) => {
        const isDeleted = !nextOriginalText.trim();
        updateElement(nextOriginalText, isDeleted);
        if (!isDeleted && viaKeyboard) {
          const elementIdToSelect = element.containerId ? element.containerId : element.id;
          flushSync3(() => {
            this.setState((prevState) => ({
              selectedElementIds: makeNextSelectedElementIds2(
                {
                  ...prevState.selectedElementIds,
                  [elementIdToSelect]: true
                },
                prevState
              )
            }));
          });
        }
        if (isDeleted) {
          fixBindingsAfterDeletion2(this.scene.getNonDeletedElements(), [
            element
          ]);
        }
        if (!isDeleted || isExistingElement) {
          this.store.scheduleCapture();
        }
        flushSync3(() => {
          this.setState({
            newElement: null,
            editingTextElement: null
          });
        });
        if (this.state.activeTool.locked) {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
        this.focusContainer();
      }),
      element,
      excalidrawContainer: this.excalidrawContainerRef.current,
      app: this,
      // when text is selected, it's hard (at least on iOS) to re-position the
      // caret (i.e. deselect). There's not much use for always selecting
      // the text on edit anyway (and users can select-all from contextmenu
      // if needed). Don't select when showing placeholder so cursor stays at start
      autoSelect: !this.editorInterface.isTouchScreen && !placeholder,
      placeholder: placeholder ?? ""
    });
    if (!element.containerId) {
      this.deselectElements();
    }
    updateElement(element.originalText, false);
  }
  deselectElements() {
    this.setState({
      selectedElementIds: makeNextSelectedElementIds2({}, this.state),
      selectedGroupIds: {},
      editingGroupId: null,
      activeEmbeddable: null
    });
  }
  getTextElementAtPosition(x, y) {
    const element = this.getElementAtPosition(x, y, {
      includeBoundTextElement: true
    });
    if (element && isTextElement16(element) && !element.isDeleted) {
      return element;
    }
    return null;
  }
  // NOTE: Hot path for hit testing, so avoid unnecessary computations
  getElementAtPosition(x, y, opts) {
    let allHitElements = [];
    if (opts && "allHitElements" in opts) {
      allHitElements = opts?.allHitElements || [];
    } else {
      allHitElements = this.getElementsAtPosition(x, y, {
        includeBoundTextElement: opts?.includeBoundTextElement,
        includeLockedElements: opts?.includeLockedElements
      });
    }
    if (allHitElements.length > 1) {
      if (opts?.preferSelected) {
        for (let index = allHitElements.length - 1; index > -1; index--) {
          if (this.state.selectedElementIds[allHitElements[index].id]) {
            return allHitElements[index];
          }
        }
      }
      let elementWithHighestZIndex = allHitElements[allHitElements.length - 1];
      if (isFrameLikeElement12(elementWithHighestZIndex)) {
        for (let i = allHitElements.length - 2; i >= 0; i--) {
          const el = allHitElements[i];
          if (el.frameId === elementWithHighestZIndex.id) {
            elementWithHighestZIndex = el;
            break;
          }
        }
      }
      return hitElementItself3({
        point: pointFrom26(x, y),
        element: elementWithHighestZIndex,
        // when overlapping, we would like to be more precise
        // this also avoids the need to update past tests
        threshold: this.getElementHitThreshold(elementWithHighestZIndex) / 2,
        elementsMap: this.scene.getNonDeletedElementsMap(),
        frameNameBound: isFrameLikeElement12(elementWithHighestZIndex) ? this.frameNameBoundsCache.get(elementWithHighestZIndex) : null
      }) ? elementWithHighestZIndex : allHitElements[allHitElements.length - 2];
    }
    if (allHitElements.length === 1) {
      return allHitElements[0];
    }
    return null;
  }
  // NOTE: Hot path for hit testing, so avoid unnecessary computations
  getElementsAtPosition(x, y, opts) {
    const iframeLikes = [];
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const elements = (opts?.includeBoundTextElement && opts?.includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(
      (element) => (opts?.includeLockedElements || !element.locked) && (opts?.includeBoundTextElement || !(isTextElement16(element) && element.containerId))
    )).filter((el) => this.hitElement(x, y, el)).filter((element) => {
      const containingFrame = getContainingFrame3(element, elementsMap);
      return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({ x, y }, containingFrame, elementsMap) : true;
    }).filter((el) => {
      if (isIframeElement2(el)) {
        iframeLikes.push(el);
        return false;
      }
      return true;
    }).concat(iframeLikes);
    return elements;
  }
  getElementHitThreshold(element) {
    return Math.max(
      element.strokeWidth / 2 + 0.1,
      // NOTE: Here be dragons. Do not go under the 0.63 multiplier unless you're
      // willing to test extensively. The hit testing starts to become unreliable
      // due to FP imprecision under 0.63 in high zoom levels.
      0.85 * (DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value)
    );
  }
  hitElement(x, y, element, considerBoundingBox = true) {
    if (considerBoundingBox && this.state.selectedElementIds[element.id] && hasBoundingBox2([element], this.state, this.editorInterface)) {
      if (hitElementBoundingBox2(
        pointFrom26(x, y),
        element,
        this.scene.getNonDeletedElementsMap(),
        this.getElementHitThreshold(element)
      )) {
        return true;
      }
    }
    const hitBoundTextOfElement = hitElementBoundText(
      pointFrom26(x, y),
      element,
      this.scene.getNonDeletedElementsMap()
    );
    if (hitBoundTextOfElement) {
      return true;
    }
    return hitElementItself3({
      point: pointFrom26(x, y),
      element,
      threshold: this.getElementHitThreshold(element),
      elementsMap: this.scene.getNonDeletedElementsMap(),
      frameNameBound: isFrameLikeElement12(element) ? this.frameNameBoundsCache.get(element) : null
    });
  }
  getTextBindableContainerAtPosition(x, y) {
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      return isTextBindableContainer3(selectedElements[0], false) ? selectedElements[0] : null;
    }
    let hitElement = null;
    for (let index = elements.length - 1; index >= 0; --index) {
      if (elements[index].isDeleted) {
        continue;
      }
      const [x1, y1, x2, y2] = getElementAbsoluteCoords9(
        elements[index],
        this.scene.getNonDeletedElementsMap()
      );
      if (isArrowElement12(elements[index]) && hitElementItself3({
        point: pointFrom26(x, y),
        element: elements[index],
        elementsMap: this.scene.getNonDeletedElementsMap(),
        threshold: this.getElementHitThreshold(elements[index])
      })) {
        hitElement = elements[index];
        break;
      } else if (x1 < x && x < x2 && y1 < y && y < y2) {
        hitElement = elements[index];
        break;
      }
    }
    return isTextBindableContainer3(hitElement, false) ? hitElement : null;
  }
  handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const element = LinearElementEditor11.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return;
    }
    if (this.state.selectedLinearElement) {
      let hoverPointIndex = -1;
      let segmentMidPointHoveredCoords = null;
      if (hitElementItself3({
        point: pointFrom26(scenePointerX, scenePointerY),
        element,
        elementsMap,
        threshold: this.getElementHitThreshold(element)
      })) {
        hoverPointIndex = LinearElementEditor11.getPointIndexUnderCursor(
          element,
          elementsMap,
          this.state.zoom,
          scenePointerX,
          scenePointerY
        );
        segmentMidPointHoveredCoords = LinearElementEditor11.getSegmentMidpointHitCoords(
          linearElementEditor,
          { x: scenePointerX, y: scenePointerY },
          this.state,
          this.scene.getNonDeletedElementsMap()
        );
        const isHoveringAPointHandle = isElbowArrow9(element) ? hoverPointIndex === 0 || hoverPointIndex === element.points.length - 1 : hoverPointIndex >= 0;
        if (isHoveringAPointHandle || segmentMidPointHoveredCoords) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
        } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
          if (
            // Elbow arrows can only be moved when unconnected
            !isElbowArrow9(element) || !(element.startBinding || element.endBinding)
          ) {
            if (this.state.activeTool.type !== "lasso" || Object.keys(this.state.selectedElementIds).length > 0) {
              setCursor(this.interactiveCanvas, CURSOR_TYPE4.MOVE);
            }
          }
        }
      } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
        if (
          // Elbow arrow can only be moved when unconnected
          !isElbowArrow9(element) || !(element.startBinding || element.endBinding)
        ) {
          if (this.state.activeTool.type !== "lasso" || Object.keys(this.state.selectedElementIds).length > 0) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE4.MOVE);
          }
        }
      }
      if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            hoverPointIndex
          }
        });
      }
      if (!LinearElementEditor11.arePointsEqual(
        this.state.selectedLinearElement.segmentMidPointHoveredCoords,
        segmentMidPointHoveredCoords
      )) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            segmentMidPointHoveredCoords
          }
        });
      }
      let hoveredFocusPointBinding = null;
      const arrow = element;
      if (arrow.startBinding || arrow.endBinding) {
        hoveredFocusPointBinding = handleFocusPointHover(
          element,
          scenePointerX,
          scenePointerY,
          this.scene,
          this.state
        );
      }
      if (this.state.selectedLinearElement.hoveredFocusPointBinding !== hoveredFocusPointBinding) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            isDragging: false,
            hoveredFocusPointBinding
          }
        });
      }
      if (hoveredFocusPointBinding) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE4.POINTER);
      }
    } else {
      setCursor(this.interactiveCanvas, CURSOR_TYPE4.AUTO);
    }
  }
  updateGestureOnPointerDown(event) {
    gesture.pointers.set(event.pointerId, {
      x: event.clientX,
      y: event.clientY
    });
    if (gesture.pointers.size === 2) {
      gesture.lastCenter = getCenter(gesture.pointers);
      gesture.initialScale = this.state.zoom.value;
      gesture.initialDistance = getDistance(
        Array.from(gesture.pointers.values())
      );
    }
  }
  initialPointerDownState(event) {
    const origin = viewportCoordsToSceneCoords3(event, this.state);
    const selectedElements = this.scene.getSelectedElements(this.state);
    const [minX, minY, maxX, maxY] = getCommonBounds8(selectedElements);
    const isElbowArrowOnly = selectedElements.findIndex(isElbowArrow9) === 0;
    return {
      origin,
      withCmdOrCtrl: event[KEYS54.CTRL_OR_CMD],
      originInGrid: tupleToCoors(
        getGridPoint2(
          origin.x,
          origin.y,
          event[KEYS54.CTRL_OR_CMD] || isElbowArrowOnly ? null : this.getEffectiveGridSize()
        )
      ),
      scrollbars: isOverScrollBars(
        currentScrollBars,
        event.clientX - this.state.offsetLeft,
        event.clientY - this.state.offsetTop
      ),
      // we need to duplicate because we'll be updating this state
      lastCoords: { ...origin },
      originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {
        acc.set(element.id, deepCopyElement4(element));
        return acc;
      }, /* @__PURE__ */ new Map()),
      resize: {
        handleType: false,
        isResizing: false,
        offset: { x: 0, y: 0 },
        arrowDirection: "origin",
        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 }
      },
      hit: {
        element: null,
        allHitElements: [],
        wasAddedToSelection: false,
        hasBeenDuplicated: false,
        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(
          origin,
          selectedElements
        )
      },
      drag: {
        hasOccurred: false,
        offset: null,
        origin: { ...origin },
        blockDragging: false
      },
      eventListeners: {
        onMove: null,
        onUp: null,
        onKeyUp: null,
        onKeyDown: null
      },
      boxSelection: {
        hasOccurred: false
      }
    };
  }
  // Returns whether the event is a dragging a scrollbar
  handleDraggingScrollBar(event, pointerDownState) {
    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {
      return false;
    }
    isDraggingScrollBar = true;
    pointerDownState.lastCoords.x = event.clientX;
    pointerDownState.lastCoords.y = event.clientY;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const target = event2.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      this.handlePointerMoveOverScrollbars(event2, pointerDownState);
    });
    const onPointerUp = withBatchedUpdates(() => {
      lastPointerUp = null;
      isDraggingScrollBar = false;
      setCursorForShape(this.interactiveCanvas, this.state);
      this.setState({
        cursorButton: "up"
      });
      this.savePointer(event.clientX, event.clientY, "up");
      window.removeEventListener(EVENT13.POINTER_MOVE, onPointerMove);
      window.removeEventListener(EVENT13.POINTER_UP, onPointerUp);
      onPointerMove.flush();
    });
    lastPointerUp = onPointerUp;
    window.addEventListener(EVENT13.POINTER_MOVE, onPointerMove);
    window.addEventListener(EVENT13.POINTER_UP, onPointerUp);
    return true;
  }
  isASelectedElement(hitElement) {
    return hitElement != null && this.state.selectedElementIds[hitElement.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(point, selectedElements) {
    if (selectedElements.length < 2) {
      return false;
    }
    const threshold = Math.max(
      DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value,
      1
    );
    const [x1, y1, x2, y2] = getCommonBounds8(selectedElements);
    return point.x > x1 - threshold && point.x < x2 + threshold && point.y > y1 - threshold && point.y < y2 + threshold;
  }
  getCurrentItemRoundness(elementType) {
    return this.state.currentItemRoundness === "round" ? {
      type: isUsingAdaptiveRadius4(elementType) ? ROUNDNESS6.ADAPTIVE_RADIUS : ROUNDNESS6.PROPORTIONAL_RADIUS
    } : null;
  }
  maybeCacheReferenceSnapPoints(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getReferenceSnapPoints())) {
      SnapCache.setReferenceSnapPoints(
        getReferenceSnapPoints(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  maybeCacheVisibleGaps(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getVisibleGaps())) {
      SnapCache.setVisibleGaps(
        getVisibleGaps(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  onKeyDownFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onKeyUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      event.key === KEYS54.ALT && event.preventDefault();
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onPointerMoveFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdatesThrottled((event) => {
      if (this.state.openDialog?.name === "elementLinkSelector") {
        return;
      }
      const pointerCoords = viewportCoordsToSceneCoords3(event, this.state);
      if (this.state.activeLockedId) {
        this.setState({
          activeLockedId: null
        });
      }
      if (this.state.selectedLinearElement && this.state.selectedLinearElement.elbowed && this.state.selectedLinearElement.initialState.segmentMidpoint.index) {
        const [gridX2, gridY2] = getGridPoint2(
          pointerCoords.x,
          pointerCoords.y,
          event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
        );
        let index = this.state.selectedLinearElement.initialState.segmentMidpoint.index;
        if (index < 0) {
          const nextCoords = LinearElementEditor11.getSegmentMidpointHitCoords(
            {
              ...this.state.selectedLinearElement,
              segmentMidPointHoveredCoords: null
            },
            { x: gridX2, y: gridY2 },
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          index = nextCoords ? LinearElementEditor11.getSegmentMidPointIndex(
            this.state.selectedLinearElement,
            this.state,
            nextCoords,
            this.scene.getNonDeletedElementsMap()
          ) : -1;
        }
        const ret = LinearElementEditor11.moveFixedSegment(
          this.state.selectedLinearElement,
          index,
          gridX2,
          gridY2,
          this.scene
        );
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            isDragging: true,
            segmentMidPointHoveredCoords: ret.segmentMidPointHoveredCoords,
            initialState: ret.initialState
          }
        });
        return;
      }
      const lastPointerCoords = this.previousPointerMoveCoords ?? pointerDownState.origin;
      this.previousPointerMoveCoords = pointerCoords;
      if (pointerDownState.drag.offset === null) {
        pointerDownState.drag.offset = tupleToCoors(
          getDragOffsetXY(
            this.scene.getSelectedElements(this.state),
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
      }
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {
        return;
      }
      if (isEraserActive(this.state)) {
        this.handleEraser(event, pointerCoords);
        return;
      }
      if (this.state.activeTool.type === "laser") {
        this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);
      }
      const [gridX, gridY] = getGridPoint2(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      if (pointerDownState.resize.isResizing) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        if (this.maybeHandleCrop(pointerDownState, event)) {
          return true;
        }
        if (this.maybeHandleResize(pointerDownState, event)) {
          return true;
        }
      }
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        const linearElementEditor = this.state.selectedLinearElement;
        if (linearElementEditor.draggedFocusPointBinding) {
          handleFocusPointDrag(
            linearElementEditor,
            elementsMap,
            pointerCoords,
            this.scene,
            this.state,
            this.getEffectiveGridSize(),
            event.altKey
          );
          this.setState({
            selectedLinearElement: {
              ...linearElementEditor,
              isDragging: false,
              selectedPointsIndices: [],
              initialState: {
                ...linearElementEditor.initialState,
                lastClickedPoint: -1
              }
            }
          });
          return;
        }
        if (LinearElementEditor11.shouldAddMidpoint(
          this.state.selectedLinearElement,
          pointerCoords,
          this.state,
          elementsMap
        )) {
          const ret = LinearElementEditor11.addMidpoint(
            this.state.selectedLinearElement,
            pointerCoords,
            this,
            !event[KEYS54.CTRL_OR_CMD],
            this.scene
          );
          if (!ret) {
            return;
          }
          flushSync3(() => {
            if (this.state.selectedLinearElement) {
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  initialState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices,
                  segmentMidPointHoveredCoords: null
                }
              });
            }
          });
          return;
        } else if (linearElementEditor.initialState.segmentMidpoint.value !== null && !linearElementEditor.initialState.segmentMidpoint.added) {
          return;
        } else if (linearElementEditor.initialState.lastClickedPoint > -1) {
          const element = LinearElementEditor11.getElement(
            linearElementEditor.elementId,
            elementsMap
          );
          if (element?.isDeleted) {
            return;
          }
          if (isBindingElement3(element)) {
            const hoveredElement = getHoveredElementForBinding2(
              pointFrom26(pointerCoords.x, pointerCoords.y),
              this.scene.getNonDeletedElements(),
              elementsMap
            );
            if (getFeatureFlag4("COMPLEX_BINDINGS")) {
              this.handleDelayedBindModeChange(element, hoveredElement);
            }
          }
          if (event.altKey && !this.state.selectedLinearElement?.initialState?.arrowStartIsInside && getFeatureFlag4("COMPLEX_BINDINGS")) {
            this.handleSkipBindMode();
          }
          if (linearElementEditor.initialState.lastClickedPoint === -1) {
            return;
          }
          const newState = LinearElementEditor11.handlePointDragging(
            event,
            this,
            pointerCoords.x,
            pointerCoords.y,
            linearElementEditor
          );
          if (newState) {
            pointerDownState.lastCoords.x = pointerCoords.x;
            pointerDownState.lastCoords.y = pointerCoords.y;
            pointerDownState.drag.hasOccurred = true;
            if (newState.suggestedBinding !== this.state.suggestedBinding || !isShallowEqual9(
              newState.selectedLinearElement?.selectedPointsIndices ?? [],
              this.state.selectedLinearElement?.selectedPointsIndices ?? []
            ) || newState.selectedLinearElement?.hoverPointIndex !== this.state.selectedLinearElement?.hoverPointIndex || newState.selectedLinearElement?.customLineAngle !== this.state.selectedLinearElement?.customLineAngle || this.state.selectedLinearElement.isDragging !== newState.selectedLinearElement?.isDragging || this.state.selectedLinearElement?.initialState?.altFocusPoint !== newState.selectedLinearElement?.initialState?.altFocusPoint) {
              this.setState(newState);
            }
            return;
          }
        }
      }
      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(
        (element) => this.isASelectedElement(element)
      );
      const isSelectingPointsInLineEditor = this.state.selectedLinearElement?.isEditing && event.shiftKey && this.state.selectedLinearElement.elementId === pointerDownState.hit.element?.id;
      if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor && !pointerDownState.drag.blockDragging) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length > 0 && selectedElements.every((element) => element.locked)) {
          return;
        }
        const selectedElementsHasAFrame = selectedElements.find(
          (e) => isFrameLikeElement12(e)
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);
        const frameToHighlight = topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null;
        if (this.state.frameToHighlight !== frameToHighlight) {
          flushSync3(() => {
            this.setState({ frameToHighlight });
          });
        }
        pointerDownState.drag.hasOccurred = true;
        if (this.state.activeTool.type === "lasso" && this.lassoTrail.hasCurrentTrail && !(this.editorInterface.formFactor !== "desktop" && pointerDownState.hit.element) && !this.state.activeTool.fromSelection) {
          return;
        }
        if (this.state.activeTool.type === "lasso" && selectedElements.length > 0 && pointerDownState.drag.hasOccurred && !this.state.activeTool.fromSelection) {
          this.lassoTrail.endPath();
        }
        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingTextElement && this.state.activeEmbeddable?.state !== "active") {
          const dragOffset = {
            x: pointerCoords.x - pointerDownState.drag.origin.x,
            y: pointerCoords.y - pointerDownState.drag.origin.y
          };
          const originalElements = [
            ...pointerDownState.originalElements.values()
          ];
          const lockDirection = event.shiftKey;
          if (lockDirection) {
            const distanceX = Math.abs(dragOffset.x);
            const distanceY = Math.abs(dragOffset.y);
            const lockX = lockDirection && distanceX < distanceY;
            const lockY = lockDirection && distanceX > distanceY;
            if (lockX) {
              dragOffset.x = 0;
            }
            if (lockY) {
              dragOffset.y = 0;
            }
          }
          if (this.state.croppingElementId) {
            const croppingElement = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
            if (croppingElement && isImageElement6(croppingElement) && croppingElement.crop !== null && pointerDownState.hit.element === croppingElement) {
              const crop = croppingElement.crop;
              const image = isInitializedImageElement3(croppingElement) && this.imageCache.get(croppingElement.fileId)?.image;
              if (image && !(image instanceof Promise)) {
                const uncroppedSize = getUncroppedWidthAndHeight(croppingElement);
                const instantDragOffset = vector3(
                  pointerCoords.x - lastPointerCoords.x,
                  pointerCoords.y - lastPointerCoords.y
                );
                instantDragOffset[0] *= image.naturalWidth / uncroppedSize.width;
                instantDragOffset[1] *= image.naturalHeight / uncroppedSize.height;
                const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords9(
                  croppingElement,
                  elementsMap
                );
                const topLeft = vectorFromPoint10(
                  pointRotateRads18(
                    pointFrom26(x1, y1),
                    pointFrom26(cx, cy),
                    croppingElement.angle
                  )
                );
                const topRight = vectorFromPoint10(
                  pointRotateRads18(
                    pointFrom26(x2, y1),
                    pointFrom26(cx, cy),
                    croppingElement.angle
                  )
                );
                const bottomLeft = vectorFromPoint10(
                  pointRotateRads18(
                    pointFrom26(x1, y2),
                    pointFrom26(cx, cy),
                    croppingElement.angle
                  )
                );
                const topEdge = vectorNormalize5(
                  vectorSubtract2(topRight, topLeft)
                );
                const leftEdge = vectorNormalize5(
                  vectorSubtract2(bottomLeft, topLeft)
                );
                const offsetVector = vector3(
                  vectorDot(instantDragOffset, topEdge),
                  vectorDot(instantDragOffset, leftEdge)
                );
                const nextCrop = {
                  ...crop,
                  x: clamp6(
                    crop.x - offsetVector[0] * Math.sign(croppingElement.scale[0]),
                    0,
                    image.naturalWidth - crop.width
                  ),
                  y: clamp6(
                    crop.y - offsetVector[1] * Math.sign(croppingElement.scale[1]),
                    0,
                    image.naturalHeight - crop.height
                  )
                };
                this.scene.mutateElement(croppingElement, {
                  crop: nextCrop
                });
                return;
              }
            }
          }
          this.maybeCacheVisibleGaps(event, selectedElements);
          this.maybeCacheReferenceSnapPoints(event, selectedElements);
          const { snapOffset, snapLines } = snapDraggedElements(
            originalElements,
            dragOffset,
            this,
            event,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState({ snapLines });
          if (!this.state.editingFrame) {
            dragSelectedElements(
              pointerDownState,
              selectedElements,
              dragOffset,
              this.scene,
              snapOffset,
              event[KEYS54.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
            );
          }
          this.setState({
            selectedElementsAreBeingDragged: true,
            // element is being dragged and selectionElement that was created on pointer down
            // should be removed
            selectionElement: null
          });
          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {
            pointerDownState.hit.hasBeenDuplicated = true;
            const elements = this.scene.getElementsIncludingDeleted();
            const hitElement = pointerDownState.hit.element;
            const selectedElements2 = this.scene.getSelectedElements({
              selectedElementIds: this.state.selectedElementIds,
              includeBoundTextElement: true,
              includeElementsInFrames: true
            });
            if (hitElement && // hit element may not end up being selected
            // if we're alt-dragging a common bounding box
            // over the hit element
            pointerDownState.hit.wasAddedToSelection && !selectedElements2.find((el) => el.id === hitElement.id)) {
              selectedElements2.push(hitElement);
            }
            const idsOfElementsToDuplicate = new Map(
              selectedElements2.map((el) => [el.id, el])
            );
            const {
              duplicatedElements,
              duplicateElementsMap,
              elementsWithDuplicates,
              origIdToDuplicateId
            } = duplicateElements3({
              type: "in-place",
              elements,
              appState: this.state,
              randomizeSeed: true,
              idsOfElementsToDuplicate,
              overrides: ({ duplicateElement, origElement }) => {
                return {
                  // reset to the original element's frameId (unless we've
                  // duplicated alongside a frame in which case we need to
                  // keep the duplicate frame's id) so that the element
                  // frame membership is refreshed on pointerup
                  // NOTE this is a hacky solution and should be done
                  // differently
                  frameId: duplicateElement.frameId ?? origElement.frameId,
                  seed: randomInteger4()
                };
              }
            });
            duplicatedElements.forEach((element) => {
              pointerDownState.originalElements.set(
                element.id,
                deepCopyElement4(element)
              );
            });
            const mappedClonedElements = elementsWithDuplicates.map((el) => {
              if (idsOfElementsToDuplicate.has(el.id)) {
                const origEl = pointerDownState.originalElements.get(el.id);
                if (origEl) {
                  return newElementWith11(el, {
                    x: origEl.x,
                    y: origEl.y
                  });
                }
              }
              return el;
            });
            const mappedNewSceneElements = this.props.onDuplicate?.(
              mappedClonedElements,
              elements
            );
            const elementsWithIndices = syncMovedIndices4(
              mappedNewSceneElements || mappedClonedElements,
              arrayToMap26(duplicatedElements)
            );
            flushSync3(() => {
              if (pointerDownState.hit.element) {
                const cloneId = origIdToDuplicateId.get(
                  pointerDownState.hit.element.id
                );
                const clonedElement = cloneId && duplicateElementsMap.get(cloneId);
                pointerDownState.hit.element = clonedElement || null;
              }
              pointerDownState.hit.allHitElements = pointerDownState.hit.allHitElements.reduce(
                (acc, origHitElement) => {
                  const cloneId = origIdToDuplicateId.get(origHitElement.id);
                  const clonedElement = cloneId && duplicateElementsMap.get(cloneId);
                  if (clonedElement) {
                    acc.push(clonedElement);
                  }
                  return acc;
                },
                []
              );
              pointerDownState.drag.origin = viewportCoordsToSceneCoords3(
                event,
                this.state
              );
              this.setState((prevState) => ({
                ...getSelectionStateForElements2(
                  duplicatedElements,
                  this.scene.getNonDeletedElements(),
                  prevState
                )
              }));
              this.scene.replaceAllElements(elementsWithIndices);
              selectedElements2.forEach((element) => {
                if (isBindableElement3(element) && element.boundElements?.some((other) => other.type === "arrow")) {
                  updateBoundElements3(element, this.scene, {
                    indirectArrowUpdate: true
                  });
                }
              });
              this.maybeCacheVisibleGaps(event, selectedElements2, true);
              this.maybeCacheReferenceSnapPoints(event, selectedElements2, true);
            });
          }
          return;
        }
      }
      if (this.state.selectionElement) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        if (event.altKey) {
          this.setActiveTool(
            { type: "lasso", fromSelection: true },
            event.shiftKey
          );
          this.lassoTrail.startPath(
            pointerDownState.origin.x,
            pointerDownState.origin.y,
            event.shiftKey
          );
          this.setAppState({
            selectionElement: null
          });
          return;
        }
        this.maybeDragNewGenericElement(pointerDownState, event);
      } else if (this.state.activeTool.type === "lasso") {
        if (!event.altKey && this.state.activeTool.fromSelection) {
          this.setActiveTool({ type: "selection" });
          this.createGenericElementOnPointerDown("selection", pointerDownState);
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          this.maybeDragNewGenericElement(pointerDownState, event);
          this.lassoTrail.endPath();
        } else {
          this.lassoTrail.addPointToPath(
            pointerCoords.x,
            pointerCoords.y,
            event.shiftKey
          );
        }
      } else {
        const newElement5 = this.state.newElement;
        if (!newElement5) {
          return;
        }
        if (newElement5.type === "freedraw") {
          const points = newElement5.points;
          const dx = pointerCoords.x - newElement5.x;
          const dy = pointerCoords.y - newElement5.y;
          const lastPoint = points.length > 0 && points[points.length - 1];
          const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;
          if (!discardPoint) {
            const pressures = newElement5.simulatePressure ? newElement5.pressures : [...newElement5.pressures, event.pressure];
            this.scene.mutateElement(
              newElement5,
              {
                points: [...points, pointFrom26(dx, dy)],
                pressures
              },
              {
                informMutation: false,
                isDragging: false
              }
            );
            this.setState({
              newElement: newElement5
            });
          }
        } else if (isLinearElement12(newElement5) && !newElement5.isDeleted) {
          pointerDownState.drag.hasOccurred = true;
          const points = newElement5.points;
          invariant16(
            points.length > 1,
            "Do not create linear elements with less than 2 points"
          );
          let linearElementEditor = this.state.selectedLinearElement;
          if (!linearElementEditor) {
            linearElementEditor = new LinearElementEditor11(
              newElement5,
              this.scene.getNonDeletedElementsMap()
            );
            linearElementEditor = {
              ...linearElementEditor,
              selectedPointsIndices: [1],
              initialState: {
                ...linearElementEditor.initialState,
                lastClickedPoint: 1
              }
            };
          }
          this.setState({
            newElement: newElement5,
            ...LinearElementEditor11.handlePointDragging(
              event,
              this,
              gridX,
              gridY,
              linearElementEditor
            )
          });
        } else {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          this.maybeDragNewGenericElement(pointerDownState, event, false);
        }
      }
      if (this.state.activeTool.type === "selection") {
        pointerDownState.boxSelection.hasOccurred = true;
        const elements = this.scene.getNonDeletedElements();
        if (this.state.selectedLinearElement?.isEditing) {
          LinearElementEditor11.handleBoxSelection(
            event,
            this.state,
            this.setState.bind(this),
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          let shouldReuseSelection = true;
          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {
            if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {
              this.setState(
                (prevState) => selectGroupsForSelectedElements6(
                  {
                    ...prevState,
                    selectedElementIds: {
                      [pointerDownState.hit.element.id]: true
                    }
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                )
              );
            } else {
              shouldReuseSelection = false;
            }
          }
          const elementsWithinSelection = this.state.selectionElement ? getElementsWithinSelection(
            elements,
            this.state.selectionElement,
            this.scene.getNonDeletedElementsMap(),
            false
          ) : [];
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...shouldReuseSelection && prevState.selectedElementIds,
              ...elementsWithinSelection.reduce(
                (acc, element) => {
                  acc[element.id] = true;
                  return acc;
                },
                {}
              )
            };
            if (pointerDownState.hit.element) {
              if (!elementsWithinSelection.length) {
                nextSelectedElementIds[pointerDownState.hit.element.id] = true;
              } else {
                delete nextSelectedElementIds[pointerDownState.hit.element.id];
              }
            }
            prevState = !shouldReuseSelection ? { ...prevState, selectedGroupIds: {}, editingGroupId: null } : prevState;
            return {
              ...selectGroupsForSelectedElements6(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: nextSelectedElementIds
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ),
              // select linear element only when we haven't box-selected anything else
              selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement12(elementsWithinSelection[0]) ? new LinearElementEditor11(
                elementsWithinSelection[0],
                this.scene.getNonDeletedElementsMap()
              ) : null,
              showHyperlinkPopup: elementsWithinSelection.length === 1 && (elementsWithinSelection[0].link || isEmbeddableElement4(elementsWithinSelection[0])) ? "info" : false
            };
          });
        }
      }
    });
  }
  // Returns whether the pointer move happened over either scrollbar
  handlePointerMoveOverScrollbars(event, pointerDownState) {
    if (pointerDownState.scrollbars.isOverHorizontal) {
      const x = event.clientX;
      const dx = x - pointerDownState.lastCoords.x;
      this.translateCanvas({
        scrollX: this.state.scrollX - dx * (currentScrollBars.horizontal?.deltaMultiplier || 1) / this.state.zoom.value
      });
      pointerDownState.lastCoords.x = x;
      return true;
    }
    if (pointerDownState.scrollbars.isOverVertical) {
      const y = event.clientY;
      const dy = y - pointerDownState.lastCoords.y;
      this.translateCanvas({
        scrollY: this.state.scrollY - dy * (currentScrollBars.vertical?.deltaMultiplier || 1) / this.state.zoom.value
      });
      pointerDownState.lastCoords.y = y;
      return true;
    }
    return false;
  }
  onPointerUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((childEvent) => {
      const elementsMap = this.scene.getNonDeletedElementsMap();
      this.removePointer(childEvent);
      pointerDownState.drag.blockDragging = false;
      if (pointerDownState.eventListeners.onMove) {
        pointerDownState.eventListeners.onMove.flush();
      }
      const {
        newElement: newElement5,
        resizingElement,
        croppingElementId,
        multiElement,
        activeTool,
        isResizing,
        isRotating,
        isCropping
      } = this.state;
      this.setState((prevState) => ({
        isResizing: false,
        isRotating: false,
        isCropping: false,
        resizingElement: null,
        selectionElement: null,
        frameToHighlight: null,
        elementsToHighlight: null,
        cursorButton: "up",
        snapLines: updateStable(prevState.snapLines, []),
        originSnapOffset: null
      }));
      this.lassoTrail.endPath();
      this.previousPointerMoveCoords = null;
      SnapCache.setReferenceSnapPoints(null);
      SnapCache.setVisibleGaps(null);
      this.savePointer(childEvent.clientX, childEvent.clientY, "up");
      const hitElements = pointerDownState.hit.allHitElements;
      const sceneCoords = viewportCoordsToSceneCoords3(
        { clientX: childEvent.clientX, clientY: childEvent.clientY },
        this.state
      );
      if (this.state.activeTool.type === "selection" && !pointerDownState.boxSelection.hasOccurred && !pointerDownState.resize.isResizing && !hitElements.some((el) => this.state.selectedElementIds[el.id])) {
        const hitLockedElement = this.getElementAtPosition(
          sceneCoords.x,
          sceneCoords.y,
          {
            includeLockedElements: true
          }
        );
        this.store.scheduleCapture();
        if (hitLockedElement?.locked) {
          this.setState({
            activeLockedId: hitLockedElement.groupIds.length > 0 ? hitLockedElement.groupIds.at(-1) || "" : hitLockedElement.id
          });
        } else {
          this.setState({
            activeLockedId: null
          });
        }
      } else {
        this.setState({
          activeLockedId: null
        });
      }
      if (getFeatureFlag4("COMPLEX_BINDINGS")) {
        this.resetDelayedBindMode();
      }
      this.setState({
        selectedElementsAreBeingDragged: false,
        bindMode: "orbit"
      });
      if (pointerDownState.drag.hasOccurred && pointerDownState.hit?.element?.id) {
        const element = elementsMap.get(pointerDownState.hit.element.id);
        if (isBindableElement3(element)) {
          element.boundElements?.filter((e) => e.type === "arrow").map((e) => elementsMap.get(e.id)).filter((e) => isElbowArrow9(e)).forEach((e) => {
            !!e && this.scene.mutateElement(e, {});
          });
        }
      }
      if (this.state.selectedLinearElement?.isEditing && !this.state.newElement && this.state.selectedLinearElement.draggedFocusPointBinding === null) {
        if (!pointerDownState.boxSelection.hasOccurred && pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId && this.state.selectedLinearElement.draggedFocusPointBinding === null) {
          this.actionManager.executeAction(actionFinalize);
        } else {
          const editingLinearElement = LinearElementEditor11.handlePointerUp(
            childEvent,
            this.state.selectedLinearElement,
            this.state,
            this.scene
          );
          this.actionManager.executeAction(actionFinalize, "ui", {
            event: childEvent,
            sceneCoords
          });
          if (editingLinearElement !== this.state.selectedLinearElement) {
            this.setState({
              selectedLinearElement: editingLinearElement,
              suggestedBinding: null
            });
          }
        }
      } else if (this.state.selectedLinearElement) {
        if (this.state.selectedLinearElement.elbowed) {
          const element = LinearElementEditor11.getElement(
            this.state.selectedLinearElement.elementId,
            this.scene.getNonDeletedElementsMap()
          );
          if (element) {
            this.scene.mutateElement(
              element,
              {}
            );
          }
        }
        if (this.state.selectedLinearElement.draggedFocusPointBinding) {
          handleFocusPointPointerUp(
            this.state.selectedLinearElement,
            this.scene
          );
          this.setState({
            selectedLinearElement: {
              ...this.state.selectedLinearElement,
              draggedFocusPointBinding: null
            }
          });
        } else if (pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId) {
          const selectedELements = this.scene.getSelectedElements(this.state);
          if (selectedELements.length > 1) {
            this.setState({ selectedLinearElement: null });
          }
        } else if (this.state.selectedLinearElement.isDragging) {
          this.setState({
            selectedLinearElement: {
              ...this.state.selectedLinearElement,
              isDragging: false
            }
          });
          this.actionManager.executeAction(actionFinalize, "ui", {
            event: childEvent,
            sceneCoords
          });
        }
        if (this.state.newElement && this.state.multiElement && isLinearElement12(this.state.newElement) && this.state.selectedLinearElement) {
          const { multiElement: multiElement2 } = this.state;
          this.setState({
            selectedLinearElement: {
              ...this.state.selectedLinearElement,
              lastCommittedPoint: multiElement2.points[multiElement2.points.length - 1]
            }
          });
        }
      }
      this.missingPointerEventCleanupEmitter.clear();
      window.removeEventListener(
        EVENT13.POINTER_MOVE,
        pointerDownState.eventListeners.onMove
      );
      window.removeEventListener(
        EVENT13.POINTER_UP,
        pointerDownState.eventListeners.onUp
      );
      window.removeEventListener(
        EVENT13.KEYDOWN,
        pointerDownState.eventListeners.onKeyDown
      );
      window.removeEventListener(
        EVENT13.KEYUP,
        pointerDownState.eventListeners.onKeyUp
      );
      this.props?.onPointerUp?.(activeTool, pointerDownState);
      this.onPointerUpEmitter.trigger(
        this.state.activeTool,
        pointerDownState,
        childEvent
      );
      if (newElement5?.type === "freedraw") {
        const pointerCoords = viewportCoordsToSceneCoords3(
          childEvent,
          this.state
        );
        const points = newElement5.points;
        let dx = pointerCoords.x - newElement5.x;
        let dy = pointerCoords.y - newElement5.y;
        if (dx === points[0][0] && dy === points[0][1]) {
          dy += 1e-4;
          dx += 1e-4;
        }
        const pressures = newElement5.simulatePressure ? [] : [...newElement5.pressures, childEvent.pressure];
        this.scene.mutateElement(newElement5, {
          points: [...points, pointFrom26(dx, dy)],
          pressures
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isLinearElement12(newElement5)) {
        if (newElement5.points.length > 1 && newElement5.points[1][0] !== 0 && newElement5.points[1][1] !== 0) {
          this.store.scheduleCapture();
        }
        const pointerCoords = viewportCoordsToSceneCoords3(
          childEvent,
          this.state
        );
        const dragDistance = pointDistance8(
          pointFrom26(pointerCoords.x, pointerCoords.y),
          pointFrom26(pointerDownState.origin.x, pointerDownState.origin.y)
        ) * this.state.zoom.value;
        if ((!pointerDownState.drag.hasOccurred || dragDistance < MINIMUM_ARROW_SIZE) && newElement5 && !multiElement) {
          if (this.editorInterface.isTouchScreen) {
            const FIXED_DELTA_X = Math.min(
              this.state.width * 0.7 / this.state.zoom.value,
              100
            );
            this.scene.mutateElement(
              newElement5,
              {
                x: newElement5.x - FIXED_DELTA_X / 2,
                points: [
                  pointFrom26(0, 0),
                  pointFrom26(FIXED_DELTA_X, 0)
                ]
              },
              { informMutation: false, isDragging: false }
            );
            this.actionManager.executeAction(actionFinalize);
          } else {
            const dx = pointerCoords.x - newElement5.x;
            const dy = pointerCoords.y - newElement5.y;
            this.scene.mutateElement(
              newElement5,
              {
                points: [newElement5.points[0], pointFrom26(dx, dy)]
              },
              { informMutation: false, isDragging: false }
            );
            this.setState({
              multiElement: newElement5,
              newElement: newElement5
            });
          }
        } else if (pointerDownState.drag.hasOccurred && !multiElement) {
          if (isLinearElement12(newElement5)) {
            this.actionManager.executeAction(actionFinalize, "ui", {
              event: childEvent,
              sceneCoords
            });
          }
          this.setState({ suggestedBinding: null, startBoundElement: null });
          if (!activeTool.locked) {
            resetCursor(this.interactiveCanvas);
            this.setState((prevState) => ({
              newElement: null,
              activeTool: updateActiveTool7(this.state, {
                type: this.state.preferredSelectionTool.type
              }),
              selectedElementIds: makeNextSelectedElementIds2(
                {
                  ...prevState.selectedElementIds,
                  [newElement5.id]: true
                },
                prevState
              ),
              selectedLinearElement: new LinearElementEditor11(
                newElement5,
                this.scene.getNonDeletedElementsMap()
              )
            }));
          } else {
            this.setState((prevState) => ({
              newElement: null
            }));
          }
          this.scene.triggerUpdate();
        }
        return;
      }
      if (isTextElement16(newElement5)) {
        const minWidth = getMinTextElementWidth(
          getFontString9({
            fontSize: newElement5.fontSize,
            fontFamily: newElement5.fontFamily
          }),
          newElement5.lineHeight
        );
        if (newElement5.width < minWidth) {
          this.scene.mutateElement(newElement5, {
            autoResize: true
          });
        }
        this.resetCursor();
        this.handleTextWysiwyg(newElement5, {
          isExistingElement: true
        });
      }
      if (activeTool.type !== "selection" && newElement5 && isInvisiblySmallElement3(newElement5)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== newElement5.id),
          appState: {
            newElement: null
          },
          captureUpdate: CaptureUpdateAction36.NEVER
        });
        return;
      }
      if (isFrameLikeElement12(newElement5)) {
        const elementsInsideFrame = getElementsInNewFrame(
          this.scene.getElementsIncludingDeleted(),
          newElement5,
          this.scene.getNonDeletedElementsMap()
        );
        this.scene.replaceAllElements(
          addElementsToFrame2(
            this.scene.getElementsMapIncludingDeleted(),
            elementsInsideFrame,
            newElement5,
            this.state
          )
        );
      }
      if (newElement5) {
        this.scene.mutateElement(
          newElement5,
          getNormalizedDimensions(newElement5),
          {
            informMutation: false,
            isDragging: false
          }
        );
        this.scene.triggerUpdate();
      }
      if (pointerDownState.drag.hasOccurred) {
        const sceneCoords2 = viewportCoordsToSceneCoords3(childEvent, this.state);
        if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
          const linearElement = this.scene.getElement(
            this.state.selectedLinearElement.elementId
          );
          if (linearElement?.frameId) {
            const frame = getContainingFrame3(linearElement, elementsMap);
            if (frame && linearElement) {
              if (!elementOverlapsWithFrame2(
                linearElement,
                frame,
                this.scene.getNonDeletedElementsMap()
              )) {
                this.scene.mutateElement(linearElement, {
                  groupIds: []
                });
                removeElementsFromFrame2(
                  [linearElement],
                  this.scene.getNonDeletedElementsMap()
                );
                this.scene.triggerUpdate();
              }
            }
          }
        } else {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords2);
          const selectedElements = this.scene.getSelectedElements(this.state);
          let nextElements = this.scene.getElementsMapIncludingDeleted();
          const updateGroupIdsAfterEditingGroup = (elements) => {
            if (elements.length > 0) {
              for (const element of elements) {
                const index = element.groupIds.indexOf(
                  this.state.editingGroupId
                );
                this.scene.mutateElement(
                  element,
                  {
                    groupIds: element.groupIds.slice(0, index)
                  },
                  { informMutation: false, isDragging: false }
                );
              }
              nextElements.forEach((element) => {
                if (element.groupIds.length && getElementsInGroup8(
                  nextElements,
                  element.groupIds[element.groupIds.length - 1]
                ).length < 2) {
                  this.scene.mutateElement(
                    element,
                    {
                      groupIds: []
                    },
                    { informMutation: false, isDragging: false }
                  );
                }
              });
              this.setState({
                editingGroupId: null
              });
            }
          };
          if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {
            const elementsToAdd = selectedElements.filter(
              (element) => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state)
            );
            if (this.state.editingGroupId) {
              updateGroupIdsAfterEditingGroup(elementsToAdd);
            }
            nextElements = addElementsToFrame2(
              nextElements,
              elementsToAdd,
              topLayerFrame,
              this.state
            );
          } else if (!topLayerFrame) {
            if (this.state.editingGroupId) {
              const elementsToRemove = selectedElements.filter(
                (element) => element.frameId && !isElementInFrame(element, nextElements, this.state)
              );
              updateGroupIdsAfterEditingGroup(elementsToRemove);
            }
          }
          nextElements = updateFrameMembershipOfSelectedElements4(
            nextElements,
            this.state,
            this
          );
          this.scene.replaceAllElements(nextElements);
        }
      }
      if (resizingElement) {
        this.store.scheduleCapture();
      }
      if (resizingElement && isInvisiblySmallElement3(resizingElement)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== resizingElement.id),
          captureUpdate: CaptureUpdateAction36.NEVER
        });
      }
      if (pointerDownState.resize.isResizing) {
        let nextElements = updateFrameMembershipOfSelectedElements4(
          this.scene.getElementsIncludingDeleted(),
          this.state,
          this
        );
        const selectedFrames = this.scene.getSelectedElements(this.state).filter(
          (element) => isFrameLikeElement12(element)
        );
        for (const frame of selectedFrames) {
          nextElements = replaceAllElementsInFrame2(
            nextElements,
            getElementsInResizingFrame2(
              this.scene.getElementsIncludingDeleted(),
              frame,
              this.state,
              elementsMap
            ),
            frame,
            this
          );
        }
        this.scene.replaceAllElements(nextElements);
      }
      const hitElement = pointerDownState.hit.element;
      if (this.state.selectedLinearElement?.elementId !== hitElement?.id && isLinearElement12(hitElement)) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1) {
          this.setState({
            selectedLinearElement: new LinearElementEditor11(
              hitElement,
              this.scene.getNonDeletedElementsMap()
            )
          });
        }
      }
      if (
        // not in the cropping mode at all
        !croppingElementId || // in the cropping mode
        croppingElementId && // not cropping and no hit element
        (!hitElement && !isCropping || // hitting something else
        hitElement && hitElement.id !== croppingElementId)
      ) {
        this.finishImageCropping();
      }
      const pointerStart = this.lastPointerDownEvent;
      const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (isEraserActive(this.state) && pointerStart && pointerEnd) {
        this.eraserTrail.endPath();
        const draggedDistance = pointDistance8(
          pointFrom26(pointerStart.clientX, pointerStart.clientY),
          pointFrom26(pointerEnd.clientX, pointerEnd.clientY)
        );
        if (draggedDistance === 0) {
          const scenePointer = viewportCoordsToSceneCoords3(
            {
              clientX: pointerEnd.clientX,
              clientY: pointerEnd.clientY
            },
            this.state
          );
          const hitElements2 = this.getElementsAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          hitElements2.forEach(
            (hitElement2) => this.elementsPendingErasure.add(hitElement2.id)
          );
        }
        this.eraseElements();
        return;
      } else if (this.elementsPendingErasure.size) {
        this.restoreReadyToEraseElements();
      }
      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && // if we're editing a line, pointerup shouldn't switch selection if
      // box selected
      (!this.state.selectedLinearElement?.isEditing || !pointerDownState.boxSelection.hasOccurred) && // hitElement can be set when alt + ctrl to toggle lasso and we will
      // just respect the selected elements from lasso instead
      this.state.activeTool.type !== "lasso") {
        if (childEvent.shiftKey && !this.state.selectedLinearElement?.isEditing) {
          if (this.state.selectedElementIds[hitElement.id]) {
            if (isSelectedViaGroup2(this.state, hitElement)) {
              this.setState((_prevState) => {
                const nextSelectedElementIds = {
                  ..._prevState.selectedElementIds
                };
                for (const groupedElement of hitElement.groupIds.flatMap(
                  (groupId) => getElementsInGroup8(
                    this.scene.getNonDeletedElements(),
                    groupId
                  )
                )) {
                  delete nextSelectedElementIds[groupedElement.id];
                }
                return {
                  selectedGroupIds: {
                    ..._prevState.selectedElementIds,
                    ...hitElement.groupIds.map((gId) => ({ [gId]: false })).reduce((prev, acc) => ({ ...prev, ...acc }), {})
                  },
                  selectedElementIds: makeNextSelectedElementIds2(
                    nextSelectedElementIds,
                    _prevState
                  )
                };
              });
            } else if (!this.state.selectedLinearElement?.isDragging) {
              this.setState((prevState) => {
                const newSelectedElementIds = {
                  ...prevState.selectedElementIds
                };
                delete newSelectedElementIds[hitElement.id];
                const newSelectedElements = getSelectedElements(
                  this.scene.getNonDeletedElements(),
                  { selectedElementIds: newSelectedElementIds }
                );
                return {
                  ...selectGroupsForSelectedElements6(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: newSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  // set selectedLinearElement only if thats the only element selected
                  selectedLinearElement: newSelectedElements.length === 1 && isLinearElement12(newSelectedElements[0]) ? new LinearElementEditor11(
                    newSelectedElements[0],
                    this.scene.getNonDeletedElementsMap()
                  ) : prevState.selectedLinearElement
                };
              });
            }
          } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {
            this.setState((prevState) => {
              const nextSelectedElementIds = {
                ...prevState.selectedElementIds,
                [hitElement.id]: true
              };
              delete nextSelectedElementIds[hitElement.frameId];
              (this.scene.getElement(hitElement.frameId)?.groupIds ?? []).flatMap(
                (gid) => getElementsInGroup8(this.scene.getNonDeletedElements(), gid)
              ).forEach((element) => {
                delete nextSelectedElementIds[element.id];
              });
              return {
                ...selectGroupsForSelectedElements6(
                  {
                    editingGroupId: prevState.editingGroupId,
                    selectedElementIds: nextSelectedElementIds
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                ),
                showHyperlinkPopup: hitElement.link || isEmbeddableElement4(hitElement) ? "info" : false
              };
            });
          } else {
            this.setState((_prevState) => ({
              selectedElementIds: makeNextSelectedElementIds2(
                {
                  ..._prevState.selectedElementIds,
                  [hitElement.id]: true
                },
                _prevState
              )
            }));
          }
        } else {
          this.setState((prevState) => ({
            ...selectGroupsForSelectedElements6(
              {
                editingGroupId: prevState.editingGroupId,
                selectedElementIds: { [hitElement.id]: true }
              },
              this.scene.getNonDeletedElements(),
              prevState,
              this
            ),
            selectedLinearElement: isLinearElement12(hitElement) && // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.
            // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized
            prevState.selectedLinearElement?.elementId !== hitElement.id ? new LinearElementEditor11(
              hitElement,
              this.scene.getNonDeletedElementsMap()
            ) : prevState.selectedLinearElement
          }));
        }
      }
      if (
        // do not clear selection if lasso is active
        this.state.activeTool.type !== "lasso" && // not elbow midpoint dragged
        !(hitElement && isElbowArrow9(hitElement)) && // not dragged
        !pointerDownState.drag.hasOccurred && // not resized
        !this.state.isResizing && // only hitting the bounding box of the previous hit element
        (hitElement && hitElementBoundingBoxOnly(
          {
            point: pointFrom26(
              pointerDownState.origin.x,
              pointerDownState.origin.y
            ),
            element: hitElement,
            elementsMap,
            threshold: this.getElementHitThreshold(hitElement),
            frameNameBound: isFrameLikeElement12(hitElement) ? this.frameNameBoundsCache.get(hitElement) : null
          },
          elementsMap
        ) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)
      ) {
        if (this.state.selectedLinearElement?.isEditing) {
          this.actionManager.executeAction(actionToggleLinearEditor);
        } else {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds2({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
        setCursor(this.interactiveCanvas, CURSOR_TYPE4.AUTO);
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw" && newElement5) {
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds2(
            {
              ...prevState.selectedElementIds,
              [newElement5.id]: true
            },
            prevState
          ),
          showHyperlinkPopup: isEmbeddableElement4(newElement5) && !newElement5.link ? "editor" : prevState.showHyperlinkPopup
        }));
      }
      if (activeTool.type !== "selection" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state) || !isShallowEqual9(
        this.state.previousSelectedElementIds,
        this.state.selectedElementIds
      )) {
        this.store.scheduleCapture();
      }
      if (pointerDownState.drag.hasOccurred && !this.state.selectedLinearElement || isResizing || isRotating || isCropping) {
        const linearElements = this.scene.getSelectedElements(this.state).filter(isArrowElement12);
        bindOrUnbindBindingElements2(linearElements, this.scene, this.state);
      }
      if (activeTool.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      const drawnElement = this.state.newElement;
      const containerToEdit = drawnElement && isTextBindableContainer3(drawnElement, false) ? drawnElement : null;
      const containerIdToEdit = containerToEdit?.id;
      const openTextEditingForContainer = () => {
        if (!containerIdToEdit)
          return;
        const container = this.scene.getElement(containerIdToEdit);
        if (container && isTextBindableContainer3(container, false) && !getBoundTextElement9(container, this.scene.getElementsMapIncludingDeleted())) {
          const sceneX = container.x + container.width / 2;
          const sceneY = container.y + container.height / 2;
          queueMicrotask(() => {
            this.startTextEditing({
              sceneX,
              sceneY,
              container,
              insertAtParentCenter: true
            });
          });
        }
      };
      if (!activeTool.locked && activeTool.type !== "freedraw" && (activeTool.type !== "lasso" || // if lasso is turned on but from selection => reset to selection
      activeTool.type === "lasso" && activeTool.fromSelection)) {
        resetCursor(this.interactiveCanvas);
        this.setState(
          {
            newElement: null,
            suggestedBinding: null,
            activeTool: updateActiveTool7(this.state, {
              type: this.state.preferredSelectionTool.type
            })
          },
          openTextEditingForContainer
        );
      } else {
        this.setState(
          {
            newElement: null,
            suggestedBinding: null
          },
          openTextEditingForContainer
        );
      }
      if (hitElement && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && gesture.pointers.size <= 1 && isIframeLikeElement2(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        this.lastPointerUpEvent,
        pointerDownState.origin.x,
        pointerDownState.origin.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
      }
    });
  }
  clearSelection(hitElement) {
    this.setState((prevState) => ({
      selectedElementIds: makeNextSelectedElementIds2({}, prevState),
      activeEmbeddable: null,
      selectedGroupIds: {},
      // Continue editing the same group if the user selected a different
      // element from it
      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup2(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null
    }));
    this.setState({
      selectedElementIds: makeNextSelectedElementIds2({}, this.state),
      activeEmbeddable: null,
      previousSelectedElementIds: this.state.selectedElementIds,
      selectedLinearElement: null
    });
  }
  getTextWysiwygSnappedToCenterPosition(x, y, appState, container) {
    if (container) {
      let elementCenterX = container.x + container.width / 2;
      let elementCenterY = container.y + container.height / 2;
      const elementCenter = getContainerCenter(
        container,
        appState,
        this.scene.getNonDeletedElementsMap()
      );
      if (elementCenter) {
        elementCenterX = elementCenter.x;
        elementCenterY = elementCenter.y;
      }
      const distanceToCenter = Math.hypot(
        x - elementCenterX,
        y - elementCenterY
      );
      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;
      if (isSnappedToCenter) {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords8(
          { sceneX: elementCenterX, sceneY: elementCenterY },
          appState
        );
        return { viewportX, viewportY, elementCenterX, elementCenterY };
      }
    }
  }
  getCanvasOffsets() {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const { left, top } = excalidrawContainer.getBoundingClientRect();
      return {
        offsetLeft: left,
        offsetTop: top
      };
    }
    return {
      offsetLeft: 0,
      offsetTop: 0
    };
  }
  async updateLanguage() {
    const currentLang2 = languages.find((lang) => lang.code === this.props.langCode) || defaultLang;
    await setLanguage(currentLang2);
    this.setAppState({});
  }
};
var createTestHook = () => {
  if (isTestEnv5() || isDevEnv9()) {
    window.h = window.h || {};
    Object.defineProperties(window.h, {
      elements: {
        configurable: true,
        get() {
          return this.app?.scene.getElementsIncludingDeleted();
        },
        set(elements) {
          return this.app?.scene.replaceAllElements(
            syncInvalidIndices(elements)
          );
        }
      },
      scene: {
        configurable: true,
        get() {
          return this.app?.scene;
        }
      }
    });
  }
};
createTestHook();
var App_default = App;

// components/InitializeApp.tsx
import { useEffect as useEffect48, useState as useState42 } from "react";
import { jsx as jsx152 } from "react/jsx-runtime";
var InitializeApp = (props) => {
  const [loading, setLoading] = useState42(true);
  useEffect48(() => {
    const updateLang = async () => {
      await setLanguage(currentLang2);
      setLoading(false);
    };
    const currentLang2 = languages.find((lang) => lang.code === props.langCode) || defaultLang;
    updateLang();
  }, [props.langCode]);
  return loading ? /* @__PURE__ */ jsx152(LoadingMessage, { theme: props.theme }) : props.children;
};

// components/footer/FooterCenter.tsx
import clsx63 from "clsx";
import { jsx as jsx153 } from "react/jsx-runtime";
var FooterCenter = ({ children }) => {
  const { FooterCenterTunnel } = useTunnels();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx153(FooterCenterTunnel.In, { children: /* @__PURE__ */ jsx153(
    "div",
    {
      className: clsx63("footer-center zen-mode-transition", {
        "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
      }),
      children
    }
  ) });
};
var FooterCenter_default = FooterCenter;
FooterCenter.displayName = "FooterCenter";

// components/live-collaboration/LiveCollaborationTrigger.tsx
import clsx64 from "clsx";
import { MQ_MIN_WIDTH_DESKTOP } from "@excalidraw/common";
import { jsx as jsx154, jsxs as jsxs88 } from "react/jsx-runtime";
var LiveCollaborationTrigger2 = ({
  isCollaborating,
  onSelect,
  editorInterface,
  ...rest
}) => {
  const appState = useUIAppState();
  const showIconOnly = editorInterface?.formFactor !== "desktop" || appState.width < MQ_MIN_WIDTH_DESKTOP;
  return /* @__PURE__ */ jsxs88(
    Button,
    {
      ...rest,
      className: clsx64("collab-button", { active: isCollaborating }),
      type: "button",
      onSelect,
      style: { position: "relative", width: showIconOnly ? void 0 : "auto" },
      title: t("labels.liveCollaboration"),
      children: [
        showIconOnly ? share : t("labels.share"),
        appState.collaborators.size > 0 && /* @__PURE__ */ jsx154("div", { className: "CollabButton-collaborators", children: appState.collaborators.size })
      ]
    }
  );
};
var LiveCollaborationTrigger_default = LiveCollaborationTrigger2;
LiveCollaborationTrigger2.displayName = "LiveCollaborationTrigger";

// components/ExcalidrawLogo.tsx
import { jsx as jsx155, jsxs as jsxs89 } from "react/jsx-runtime";
var LogoIcon = () => /* @__PURE__ */ jsx155(
  "svg",
  {
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: "ExcalidrawLogo-icon",
    children: /* @__PURE__ */ jsx155(
      "path",
      {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor"
      }
    )
  }
);
var LogoText = () => /* @__PURE__ */ jsxs89(
  "svg",
  {
    viewBox: "0 0 450 55",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    className: "ExcalidrawLogo-text",
    children: [
      /* @__PURE__ */ jsx155(
        "path",
        {
          d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx155(
        "path",
        {
          d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx155(
        "path",
        {
          d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx155(
        "path",
        {
          d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
          fill: "currentColor",
          transform: "translate(-144.023 -51.76)"
        }
      )
    ]
  }
);
var ExcalidrawLogo = ({
  style,
  size = "small",
  withText
}) => {
  return /* @__PURE__ */ jsxs89("div", { className: `ExcalidrawLogo is-${size}`, style, children: [
    /* @__PURE__ */ jsx155(LogoIcon, {}),
    withText && /* @__PURE__ */ jsx155(LogoText, {})
  ] });
};

// components/welcome-screen/WelcomeScreen.Center.tsx
import { Fragment as Fragment28, jsx as jsx156, jsxs as jsxs90 } from "react/jsx-runtime";
var WelcomeScreenMenuItemContent = ({
  icon,
  shortcut,
  children
}) => {
  const editorInterface = useEditorInterface();
  return /* @__PURE__ */ jsxs90(Fragment28, { children: [
    /* @__PURE__ */ jsx156("div", { className: "welcome-screen-menu-item__icon", children: icon }),
    /* @__PURE__ */ jsx156("div", { className: "welcome-screen-menu-item__text", children }),
    shortcut && editorInterface.formFactor !== "phone" && /* @__PURE__ */ jsx156("div", { className: "welcome-screen-menu-item__shortcut", children: shortcut })
  ] });
};
WelcomeScreenMenuItemContent.displayName = "WelcomeScreenMenuItemContent";
var WelcomeScreenMenuItem = ({
  onSelect,
  children,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsx156(
    "button",
    {
      ...props,
      type: "button",
      className: `welcome-screen-menu-item ${className}`,
      onClick: onSelect,
      children: /* @__PURE__ */ jsx156(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItem.displayName = "WelcomeScreenMenuItem";
var WelcomeScreenMenuItemLink = ({
  children,
  href,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsx156(
    "a",
    {
      ...props,
      className: `welcome-screen-menu-item ${className}`,
      href,
      target: "_blank",
      rel: "noopener",
      children: /* @__PURE__ */ jsx156(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItemLink.displayName = "WelcomeScreenMenuItemLink";
var Center = ({ children }) => {
  const { WelcomeScreenCenterTunnel } = useTunnels();
  return /* @__PURE__ */ jsx156(WelcomeScreenCenterTunnel.In, { children: /* @__PURE__ */ jsx156("div", { className: "welcome-screen-center", children: children || /* @__PURE__ */ jsxs90(Fragment28, { children: [
    /* @__PURE__ */ jsx156(Logo, {}),
    /* @__PURE__ */ jsx156(Heading, { children: t("welcomeScreen.defaults.center_heading") }),
    /* @__PURE__ */ jsxs90(Menu, { children: [
      /* @__PURE__ */ jsx156(MenuItemLoadScene, {}),
      /* @__PURE__ */ jsx156(MenuItemHelp, {})
    ] })
  ] }) }) });
};
Center.displayName = "Center";
var Logo = ({ children }) => {
  return /* @__PURE__ */ jsx156("div", { className: "welcome-screen-center__logo excalifont welcome-screen-decor", children: children || /* @__PURE__ */ jsx156(ExcalidrawLogo, { withText: true }) });
};
Logo.displayName = "Logo";
var Heading = ({ children }) => {
  return /* @__PURE__ */ jsx156("div", { className: "welcome-screen-center__heading welcome-screen-decor excalifont", children });
};
Heading.displayName = "Heading";
var Menu = ({ children }) => {
  return /* @__PURE__ */ jsx156("div", { className: "welcome-screen-menu", children });
};
Menu.displayName = "Menu";
var MenuItemHelp = () => {
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx156(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      icon: HelpIcon,
      children: t("helpDialog.title")
    }
  );
};
MenuItemHelp.displayName = "MenuItemHelp";
var MenuItemLoadScene = () => {
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  if (appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ jsx156(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionLoadScene),
      shortcut: getShortcutFromShortcutName("loadScene"),
      icon: LoadIcon,
      children: t("buttons.load")
    }
  );
};
MenuItemLoadScene.displayName = "MenuItemLoadScene";
var MenuItemLiveCollaborationTrigger = ({
  onSelect
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx156(WelcomeScreenMenuItem, { shortcut: null, onSelect, icon: usersIcon, children: t2("labels.liveCollaboration") });
};
MenuItemLiveCollaborationTrigger.displayName = "MenuItemLiveCollaborationTrigger";
Center.Logo = Logo;
Center.Heading = Heading;
Center.Menu = Menu;
Center.MenuItem = WelcomeScreenMenuItem;
Center.MenuItemLink = WelcomeScreenMenuItemLink;
Center.MenuItemHelp = MenuItemHelp;
Center.MenuItemLoadScene = MenuItemLoadScene;
Center.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;

// components/welcome-screen/WelcomeScreen.Hints.tsx
import { jsx as jsx157, jsxs as jsxs91 } from "react/jsx-runtime";
var MenuHint = ({ children }) => {
  const { WelcomeScreenMenuHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx157(WelcomeScreenMenuHintTunnel.In, { children: /* @__PURE__ */ jsxs91("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [
    WelcomeScreenMenuArrow,
    /* @__PURE__ */ jsx157("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.menuHint") })
  ] }) });
};
MenuHint.displayName = "MenuHint";
var ToolbarHint = ({ children }) => {
  const { WelcomeScreenToolbarHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx157(WelcomeScreenToolbarHintTunnel.In, { children: /* @__PURE__ */ jsxs91("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [
    /* @__PURE__ */ jsx157("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.toolbarHint") }),
    WelcomeScreenTopToolbarArrow
  ] }) });
};
ToolbarHint.displayName = "ToolbarHint";
var HelpHint = ({ children }) => {
  const { WelcomeScreenHelpHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx157(WelcomeScreenHelpHintTunnel.In, { children: /* @__PURE__ */ jsxs91("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [
    /* @__PURE__ */ jsx157("div", { children: children || t("welcomeScreen.defaults.helpHint") }),
    WelcomeScreenHelpArrow
  ] }) });
};
HelpHint.displayName = "HelpHint";

// components/welcome-screen/WelcomeScreen.tsx
import { Fragment as Fragment29, jsx as jsx158, jsxs as jsxs92 } from "react/jsx-runtime";
var WelcomeScreen = (props) => {
  return /* @__PURE__ */ jsx158(Fragment29, { children: props.children || /* @__PURE__ */ jsxs92(Fragment29, { children: [
    /* @__PURE__ */ jsx158(Center, {}),
    /* @__PURE__ */ jsx158(MenuHint, {}),
    /* @__PURE__ */ jsx158(ToolbarHint, {}),
    /* @__PURE__ */ jsx158(HelpHint, {})
  ] }) });
};
WelcomeScreen.displayName = "WelcomeScreen";
WelcomeScreen.Center = Center;
WelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };
var WelcomeScreen_default = WelcomeScreen;

// polyfill.ts
var polyfill = () => {
  if (!Array.prototype.at) {
    Object.defineProperty(Array.prototype, "at", {
      value: function(n) {
        n = Math.trunc(n) || 0;
        if (n < 0) {
          n += this.length;
        }
        if (n < 0 || n >= this.length) {
          return void 0;
        }
        return this[n];
      },
      writable: true,
      enumerable: false,
      configurable: true
    });
  }
  if (!Element.prototype.replaceChildren) {
    Element.prototype.replaceChildren = function(...nodes) {
      this.innerHTML = "";
      this.append(...nodes);
    };
  }
};
var polyfill_default = polyfill;

// index.tsx
import {
  getSceneVersion,
  hashElementsVersion as hashElementsVersion2,
  hashString as hashString2,
  getNonDeletedElements as getNonDeletedElements13
} from "@excalidraw/element";
import { getTextFromElements as getTextFromElements3 } from "@excalidraw/element";
import { isInvisiblySmallElement as isInvisiblySmallElement4 } from "@excalidraw/element";

// data/reconcile.ts
import throttle3 from "lodash.throttle";
import { arrayToMap as arrayToMap27, isDevEnv as isDevEnv10, isTestEnv as isTestEnv6 } from "@excalidraw/common";
import {
  orderByFractionalIndex as orderByFractionalIndex2,
  syncInvalidIndices as syncInvalidIndices2,
  validateFractionalIndices
} from "@excalidraw/element";
var shouldDiscardRemoteElement = (localAppState, local, remote) => {
  if (local && // local element is being edited
  (local.id === localAppState.editingTextElement?.id || local.id === localAppState.resizingElement?.id || local.id === localAppState.newElement?.id || // local element is newer
  local.version > remote.version || // resolve conflicting edits deterministically by taking the one with
  // the lowest versionNonce
  local.version === remote.version && local.versionNonce <= remote.versionNonce)) {
    return true;
  }
  return false;
};
var validateIndicesThrottled = throttle3(
  (orderedElements, localElements, remoteElements) => {
    if (isDevEnv10() || isTestEnv6() || window?.DEBUG_FRACTIONAL_INDICES) {
      const elements = syncInvalidIndices2(
        orderedElements.map((x) => ({ ...x }))
      );
      validateFractionalIndices(elements, {
        // throw in dev & test only, to remain functional on `DEBUG_FRACTIONAL_INDICES`
        shouldThrow: isTestEnv6() || isDevEnv10(),
        includeBoundTextValidation: true,
        reconciliationContext: {
          localElements,
          remoteElements
        }
      });
    }
  },
  1e3 * 60,
  { leading: true, trailing: false }
);
var reconcileElements = (localElements, remoteElements, localAppState) => {
  const localElementsMap = arrayToMap27(localElements);
  const reconciledElements = [];
  const added = /* @__PURE__ */ new Set();
  for (const remoteElement of remoteElements) {
    if (!added.has(remoteElement.id)) {
      const localElement = localElementsMap.get(remoteElement.id);
      const discardRemoteElement = shouldDiscardRemoteElement(
        localAppState,
        localElement,
        remoteElement
      );
      if (localElement && discardRemoteElement) {
        reconciledElements.push(localElement);
        added.add(localElement.id);
      } else {
        reconciledElements.push(remoteElement);
        added.add(remoteElement.id);
      }
    }
  }
  for (const localElement of localElements) {
    if (!added.has(localElement.id)) {
      reconciledElements.push(localElement);
      added.add(localElement.id);
    }
  }
  const orderedElements = orderByFractionalIndex2(reconciledElements);
  validateIndicesThrottled(orderedElements, localElements, remoteElements);
  syncInvalidIndices2(orderedElements);
  return orderedElements;
};

// index.tsx
import { isLinearElement as isLinearElement13 } from "@excalidraw/element";
import {
  FONT_FAMILY as FONT_FAMILY5,
  THEME as THEME15,
  MIME_TYPES as MIME_TYPES10,
  ROUNDNESS as ROUNDNESS3,
  DEFAULT_LASER_COLOR as DEFAULT_LASER_COLOR2,
  UserIdleState as UserIdleState2,
  normalizeLink as normalizeLink4,
  sceneCoordsToViewportCoords as sceneCoordsToViewportCoords2,
  viewportCoordsToSceneCoords as viewportCoordsToSceneCoords4,
  getFormFactor as getFormFactor2
} from "@excalidraw/common";
import {
  mutateElement as mutateElement2,
  newElementWith as newElementWith12,
  bumpVersion
} from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction38 } from "@excalidraw/element";

// components/Stats/index.tsx
import { round as round5 } from "@excalidraw/math";
import clsx66 from "clsx";
import throttle4 from "lodash.throttle";
import { useEffect as useEffect50, useMemo as useMemo12, useState as useState44, memo as memo5 } from "react";
import { STATS_PANELS } from "@excalidraw/common";
import { getCommonBounds as getCommonBounds11 } from "@excalidraw/element";
import { getUncroppedWidthAndHeight as getUncroppedWidthAndHeight4 } from "@excalidraw/element";
import { isImageElement as isImageElement9 } from "@excalidraw/element";
import { frameAndChildrenSelectedTogether as frameAndChildrenSelectedTogether2 } from "@excalidraw/element";
import { elementsAreInSameGroup as elementsAreInSameGroup2 } from "@excalidraw/element";

// components/Stats/Angle.tsx
import { degreesToRadians as degreesToRadians2, radiansToDegrees } from "@excalidraw/math";
import { getBoundTextElement as getBoundTextElement11 } from "@excalidraw/element";
import { isArrowElement as isArrowElement13, isElbowArrow as isElbowArrow10 } from "@excalidraw/element";
import { updateBindings as updateBindings3 } from "@excalidraw/element";

// components/Stats/DragInput.tsx
import clsx65 from "clsx";
import { useEffect as useEffect49, useRef as useRef45, useState as useState43 } from "react";
import { EVENT as EVENT14, KEYS as KEYS55, cloneJSON as cloneJSON4 } from "@excalidraw/common";
import { deepCopyElement as deepCopyElement5 } from "@excalidraw/element";
import { CaptureUpdateAction as CaptureUpdateAction37 } from "@excalidraw/element";

// components/Stats/utils.ts
import { pointFrom as pointFrom27, pointRotateRads as pointRotateRads19 } from "@excalidraw/math";
import {
  getBoundTextElement as getBoundTextElement10,
  isBindingElement as isBindingElement4,
  unbindBindingElement
} from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement13 } from "@excalidraw/element";
import {
  getSelectedGroupIds as getSelectedGroupIds4,
  getElementsInGroup as getElementsInGroup9,
  isInGroup
} from "@excalidraw/element";
import { getFrameChildren as getFrameChildren6 } from "@excalidraw/element";
import { updateBindings as updateBindings2 } from "@excalidraw/element";
import { DRAGGING_THRESHOLD as DRAGGING_THRESHOLD3 } from "@excalidraw/common";
var SMALLEST_DELTA = 0.01;
var STEP_SIZE = 10;
var isPropertyEditable = (element, property) => {
  if (property === "angle" && isFrameLikeElement13(element)) {
    return false;
  }
  return true;
};
var getStepSizedValue = (value, stepSize) => {
  const v = value + stepSize / 2;
  return v - v % stepSize;
};
var getElementsInAtomicUnit = (atomicUnit, elementsMap, originalElementsMap) => {
  return Object.keys(atomicUnit).map((id) => ({
    original: (originalElementsMap ?? elementsMap).get(id),
    latest: elementsMap.get(id)
  })).filter((el) => el.original !== void 0 && el.latest !== void 0);
};
var moveElement = (newTopLeftX, newTopLeftY, originalElement, scene, appState, originalElementsMap, shouldInformMutation = true) => {
  if (isBindingElement4(originalElement) && (originalElement.startBinding || originalElement.endBinding)) {
    if (Math.abs(newTopLeftX - originalElement.x) < DRAGGING_THRESHOLD3 && Math.abs(newTopLeftY - originalElement.y) < DRAGGING_THRESHOLD3) {
      return;
    }
    unbindBindingElement(originalElement, "start", scene);
    unbindBindingElement(originalElement, "end", scene);
  }
  const elementsMap = scene.getNonDeletedElementsMap();
  const latestElement = elementsMap.get(originalElement.id);
  if (!latestElement) {
    return;
  }
  const [cx, cy] = [
    originalElement.x + originalElement.width / 2,
    originalElement.y + originalElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads19(
    pointFrom27(originalElement.x, originalElement.y),
    pointFrom27(cx, cy),
    originalElement.angle
  );
  const changeInX = newTopLeftX - topLeftX;
  const changeInY = newTopLeftY - topLeftY;
  const [x, y] = pointRotateRads19(
    pointFrom27(newTopLeftX, newTopLeftY),
    pointFrom27(cx + changeInX, cy + changeInY),
    -originalElement.angle
  );
  scene.mutateElement(
    latestElement,
    {
      x,
      y
    },
    { informMutation: shouldInformMutation, isDragging: false }
  );
  updateBindings2(latestElement, scene, appState);
  const boundTextElement = getBoundTextElement10(
    originalElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    latestBoundTextElement && scene.mutateElement(
      latestBoundTextElement,
      {
        x: boundTextElement.x + changeInX,
        y: boundTextElement.y + changeInY
      },
      { informMutation: shouldInformMutation, isDragging: false }
    );
  }
  if (isFrameLikeElement13(originalElement)) {
    const originalChildren = getFrameChildren6(
      originalElementsMap,
      originalElement.id
    );
    originalChildren.forEach((child) => {
      const latestChildElement = elementsMap.get(child.id);
      if (!latestChildElement) {
        return;
      }
      const [childCX, childCY] = [
        child.x + child.width / 2,
        child.y + child.height / 2
      ];
      const [childTopLeftX, childTopLeftY] = pointRotateRads19(
        pointFrom27(child.x, child.y),
        pointFrom27(childCX, childCY),
        child.angle
      );
      const childNewTopLeftX = Math.round(childTopLeftX + changeInX);
      const childNewTopLeftY = Math.round(childTopLeftY + changeInY);
      const [childX, childY] = pointRotateRads19(
        pointFrom27(childNewTopLeftX, childNewTopLeftY),
        pointFrom27(childCX + changeInX, childCY + changeInY),
        -child.angle
      );
      scene.mutateElement(
        latestChildElement,
        {
          x: childX,
          y: childY
        },
        { informMutation: shouldInformMutation, isDragging: false }
      );
      updateBindings2(latestChildElement, scene, appState, {
        simultaneouslyUpdated: originalChildren
      });
    });
  }
};
var getAtomicUnits = (targetElements, appState) => {
  const selectedGroupIds = getSelectedGroupIds4(appState);
  const _atomicUnits = selectedGroupIds.map((gid) => {
    return getElementsInGroup9(targetElements, gid).reduce((acc, el) => {
      acc[el.id] = true;
      return acc;
    }, {});
  });
  targetElements.filter((el) => !isInGroup(el)).forEach((el) => {
    _atomicUnits.push({
      [el.id]: true
    });
  });
  return _atomicUnits;
};

// components/Stats/DragInput.tsx
import { jsx as jsx159, jsxs as jsxs93 } from "react/jsx-runtime";
var StatsDragInput = ({
  label,
  icon,
  dragInputCallback,
  value,
  elements,
  editable = true,
  shouldKeepAspectRatio,
  property,
  scene,
  appState,
  sensitivity = 1,
  dragFinishedCallback
}) => {
  const app = useApp();
  const setAppState = useExcalidrawSetAppState();
  const inputRef = useRef45(null);
  const labelRef = useRef45(null);
  const [inputValue, setInputValue] = useState43(value.toString());
  const stateRef = useRef45(null);
  if (!stateRef.current) {
    stateRef.current = {
      originalAppState: cloneJSON4(appState),
      originalElements: elements,
      lastUpdatedValue: inputValue,
      updatePending: false
    };
  }
  useEffect49(() => {
    const inputValue2 = value.toString();
    setInputValue(inputValue2);
    stateRef.current.lastUpdatedValue = inputValue2;
  }, [value]);
  const handleInputValue = (updatedValue, elements2, appState2) => {
    if (!stateRef.current.updatePending) {
      return false;
    }
    stateRef.current.updatePending = false;
    const parsed = Number(updatedValue);
    if (isNaN(parsed)) {
      setInputValue(value.toString());
      return;
    }
    const rounded = Number(parsed.toFixed(2));
    const original = Number(value);
    if (isNaN(original) || Math.abs(rounded - original) >= SMALLEST_DELTA) {
      stateRef.current.lastUpdatedValue = updatedValue;
      dragInputCallback({
        accumulatedChange: 0,
        instantChange: 0,
        originalElements: elements2,
        originalElementsMap: app.scene.getNonDeletedElementsMap(),
        shouldKeepAspectRatio,
        shouldChangeByStepSize: false,
        scene,
        nextValue: rounded,
        property,
        originalAppState: appState2,
        setInputValue: (value2) => setInputValue(String(value2)),
        app,
        setAppState
      });
      app.syncActionResult({
        captureUpdate: CaptureUpdateAction37.IMMEDIATELY
      });
    }
  };
  const callbacksRef = useRef45({});
  callbacksRef.current.handleInputValue = handleInputValue;
  useEffect49(() => {
    const input = inputRef.current;
    const callbacks = callbacksRef.current;
    return () => {
      const nextValue = input?.value;
      if (nextValue) {
        callbacks.handleInputValue?.(
          nextValue,
          stateRef.current.originalElements,
          stateRef.current.originalAppState
        );
      }
      window.removeEventListener(
        EVENT14.POINTER_MOVE,
        callbacks.onPointerMove,
        false
      );
      window.removeEventListener(
        EVENT14.POINTER_UP,
        callbacks.onPointerUp,
        false
      );
    };
  }, [
    // we need to track change of `editable` state as mount/unmount
    // because react doesn't trigger `blur` when a an input is blurred due
    // to being disabled (https://github.com/facebook/react/issues/9142).
    // As such, if we keep rendering disabled inputs, then change in selection
    // to an element that has a given property as non-editable would not trigger
    // blur/unmount and wouldn't update the value.
    editable
  ]);
  if (!editable) {
    return null;
  }
  return /* @__PURE__ */ jsxs93(
    "div",
    {
      className: clsx65("drag-input-container", !editable && "disabled"),
      "data-testid": label,
      children: [
        /* @__PURE__ */ jsx159(
          "div",
          {
            className: "drag-input-label",
            ref: labelRef,
            onPointerDown: (event) => {
              if (inputRef.current && editable) {
                document.body.classList.add("excalidraw-cursor-resize");
                let startValue = Number(inputRef.current.value);
                if (isNaN(startValue)) {
                  startValue = 0;
                }
                let lastPointer = null;
                let originalElementsMap = app.scene.getNonDeletedElements().reduce((acc, element) => {
                  acc.set(element.id, deepCopyElement5(element));
                  return acc;
                }, /* @__PURE__ */ new Map());
                let originalElements = elements.map(
                  (element) => originalElementsMap.get(element.id)
                );
                const originalAppState = cloneJSON4(appState);
                let accumulatedChange = 0;
                let stepChange = 0;
                const onPointerMove = (event2) => {
                  if (lastPointer && originalElementsMap !== null && originalElements !== null) {
                    const instantChange = event2.clientX - lastPointer.x;
                    if (instantChange !== 0) {
                      stepChange += instantChange;
                      if (Math.abs(stepChange) >= sensitivity) {
                        stepChange = Math.sign(stepChange) * Math.floor(Math.abs(stepChange) / sensitivity);
                        accumulatedChange += stepChange;
                        dragInputCallback({
                          accumulatedChange,
                          instantChange: stepChange,
                          originalElements,
                          originalElementsMap,
                          shouldKeepAspectRatio,
                          shouldChangeByStepSize: event2.shiftKey,
                          property,
                          scene,
                          originalAppState,
                          setInputValue: (value2) => setInputValue(String(value2)),
                          app,
                          setAppState
                        });
                        stepChange = 0;
                      }
                    }
                  }
                  lastPointer = {
                    x: event2.clientX,
                    y: event2.clientY
                  };
                };
                const onPointerUp = () => {
                  window.removeEventListener(
                    EVENT14.POINTER_MOVE,
                    onPointerMove,
                    false
                  );
                  app.syncActionResult({
                    captureUpdate: CaptureUpdateAction37.IMMEDIATELY
                  });
                  dragFinishedCallback?.({
                    app,
                    setAppState,
                    originalElements,
                    originalAppState
                  });
                  lastPointer = null;
                  accumulatedChange = 0;
                  stepChange = 0;
                  originalElements = null;
                  originalElementsMap = null;
                  document.body.classList.remove("excalidraw-cursor-resize");
                  window.removeEventListener(EVENT14.POINTER_UP, onPointerUp, false);
                };
                callbacksRef.current.onPointerMove = onPointerMove;
                callbacksRef.current.onPointerUp = onPointerUp;
                window.addEventListener(EVENT14.POINTER_MOVE, onPointerMove, false);
                window.addEventListener(EVENT14.POINTER_UP, onPointerUp, false);
              }
            },
            onPointerEnter: () => {
              if (labelRef.current) {
                labelRef.current.style.cursor = "ew-resize";
              }
            },
            children: icon ? /* @__PURE__ */ jsx159(InlineIcon, { icon }) : label
          }
        ),
        /* @__PURE__ */ jsx159(
          "input",
          {
            className: "drag-input",
            autoComplete: "off",
            spellCheck: "false",
            onKeyDown: (event) => {
              if (editable) {
                const eventTarget = event.target;
                if (eventTarget instanceof HTMLInputElement && event.key === KEYS55.ENTER) {
                  handleInputValue(eventTarget.value, elements, appState);
                  app.focusContainer();
                }
              }
            },
            ref: inputRef,
            value: inputValue,
            onChange: (event) => {
              stateRef.current.updatePending = true;
              setInputValue(event.target.value);
            },
            onFocus: (event) => {
              event.target.select();
              stateRef.current.originalElements = elements;
              stateRef.current.originalAppState = cloneJSON4(appState);
            },
            onBlur: (event) => {
              if (!inputValue) {
                setInputValue(value.toString());
              } else if (editable) {
                handleInputValue(
                  event.target.value,
                  stateRef.current.originalElements,
                  stateRef.current.originalAppState
                );
              }
            },
            disabled: !editable
          }
        )
      ]
    }
  );
};
var DragInput_default = StatsDragInput;

// components/Stats/Angle.tsx
import { jsx as jsx160 } from "react/jsx-runtime";
var STEP_SIZE2 = 15;
var handleDegreeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene,
  app
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  if (origElement && !isElbowArrow10(origElement)) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      return;
    }
    if (nextValue !== void 0) {
      const nextAngle2 = degreesToRadians2(nextValue);
      scene.mutateElement(latestElement, {
        angle: nextAngle2
      });
      updateBindings3(latestElement, scene, app.state);
      const boundTextElement2 = getBoundTextElement11(latestElement, elementsMap);
      if (boundTextElement2 && !isArrowElement13(latestElement)) {
        scene.mutateElement(boundTextElement2, { angle: nextAngle2 });
      }
      return;
    }
    const originalAngleInDegrees = Math.round(radiansToDegrees(origElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE2);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians2(nextAngleInDegrees);
    scene.mutateElement(latestElement, {
      angle: nextAngle
    });
    updateBindings3(latestElement, scene, app.state);
    const boundTextElement = getBoundTextElement11(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement13(latestElement)) {
      scene.mutateElement(boundTextElement, { angle: nextAngle });
    }
  }
};
var Angle = ({ element, scene, appState, property }) => {
  return /* @__PURE__ */ jsx160(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value: Math.round(radiansToDegrees(element.angle) % 360 * 100) / 100,
      elements: [element],
      dragInputCallback: handleDegreeChange,
      editable: isPropertyEditable(element, "angle"),
      scene,
      appState,
      property
    }
  );
};
var Angle_default = Angle;

// components/Stats/CanvasGrid.tsx
import { jsx as jsx161 } from "react/jsx-runtime";
var STEP_SIZE3 = 5;
var CanvasGrid = ({
  property,
  scene,
  appState,
  setAppState
}) => {
  return /* @__PURE__ */ jsx161(
    DragInput_default,
    {
      label: "Grid step",
      sensitivity: 8,
      elements: [],
      dragInputCallback: ({
        nextValue,
        instantChange,
        shouldChangeByStepSize,
        setInputValue
      }) => {
        setAppState((state) => {
          let nextGridStep;
          if (nextValue) {
            nextGridStep = nextValue;
          } else if (instantChange) {
            nextGridStep = shouldChangeByStepSize ? getStepSizedValue(
              state.gridStep + STEP_SIZE3 * Math.sign(instantChange),
              STEP_SIZE3
            ) : state.gridStep + instantChange;
          }
          if (!nextGridStep) {
            setInputValue(state.gridStep);
            return null;
          }
          nextGridStep = getNormalizedGridStep(nextGridStep);
          setInputValue(nextGridStep);
          return {
            gridStep: nextGridStep
          };
        });
      },
      scene,
      value: appState.gridStep,
      property,
      appState
    }
  );
};
var CanvasGrid_default = CanvasGrid;

// components/Stats/Dimension.tsx
import { clamp as clamp7, round as round3 } from "@excalidraw/math";
import { MIN_WIDTH_OR_HEIGHT } from "@excalidraw/common";
import {
  MINIMAL_CROP_SIZE,
  getUncroppedWidthAndHeight as getUncroppedWidthAndHeight2
} from "@excalidraw/element";
import { resizeSingleElement } from "@excalidraw/element";
import { isImageElement as isImageElement7 } from "@excalidraw/element";
import { isFrameLikeElement as isFrameLikeElement14 } from "@excalidraw/element";
import { getElementsInResizingFrame as getElementsInResizingFrame3 } from "@excalidraw/element";
import { replaceAllElementsInFrame as replaceAllElementsInFrame3 } from "@excalidraw/element";
import { jsx as jsx162 } from "react/jsx-runtime";
var STEP_SIZE4 = 10;
var _shouldKeepAspectRatio = (element) => {
  return element.type === "image";
};
var handleDimensionChange = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldKeepAspectRatio,
  shouldChangeByStepSize,
  nextValue,
  property,
  originalAppState,
  instantChange,
  scene,
  app,
  setAppState
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  const latestElement = elementsMap.get(origElement.id);
  if (origElement && latestElement) {
    const keepAspectRatio = shouldKeepAspectRatio || _shouldKeepAspectRatio(origElement);
    const aspectRatio = origElement.width / origElement.height;
    if (originalAppState.croppingElementId === origElement.id) {
      const element = elementsMap.get(origElement.id);
      if (!element || !isImageElement7(element) || !element.crop) {
        return;
      }
      const crop = element.crop;
      let nextCrop = { ...crop };
      const isFlippedByX = element.scale[0] === -1;
      const isFlippedByY = element.scale[1] === -1;
      const { width: uncroppedWidth, height: uncroppedHeight } = getUncroppedWidthAndHeight2(element);
      const naturalToUncroppedWidthRatio = crop.naturalWidth / uncroppedWidth;
      const naturalToUncroppedHeightRatio = crop.naturalHeight / uncroppedHeight;
      const MAX_POSSIBLE_WIDTH = isFlippedByX ? crop.width + crop.x : crop.naturalWidth - crop.x;
      const MAX_POSSIBLE_HEIGHT = isFlippedByY ? crop.height + crop.y : crop.naturalHeight - crop.y;
      const MIN_WIDTH = MINIMAL_CROP_SIZE * naturalToUncroppedWidthRatio;
      const MIN_HEIGHT = MINIMAL_CROP_SIZE * naturalToUncroppedHeightRatio;
      if (nextValue !== void 0) {
        if (property === "width") {
          const nextValueInNatural = nextValue * naturalToUncroppedWidthRatio;
          const nextCropWidth2 = clamp7(
            nextValueInNatural,
            MIN_WIDTH,
            MAX_POSSIBLE_WIDTH
          );
          nextCrop = {
            ...nextCrop,
            width: nextCropWidth2,
            x: isFlippedByX ? crop.x + crop.width - nextCropWidth2 : crop.x
          };
        } else if (property === "height") {
          const nextValueInNatural = nextValue * naturalToUncroppedHeightRatio;
          const nextCropHeight2 = clamp7(
            nextValueInNatural,
            MIN_HEIGHT,
            MAX_POSSIBLE_HEIGHT
          );
          nextCrop = {
            ...nextCrop,
            height: nextCropHeight2,
            y: isFlippedByY ? crop.y + crop.height - nextCropHeight2 : crop.y
          };
        }
        scene.mutateElement(element, {
          crop: nextCrop,
          width: nextCrop.width / (crop.naturalWidth / uncroppedWidth),
          height: nextCrop.height / (crop.naturalHeight / uncroppedHeight)
        });
        return;
      }
      const changeInWidth = property === "width" ? instantChange : 0;
      const changeInHeight = property === "height" ? instantChange : 0;
      const nextCropWidth = clamp7(
        crop.width + changeInWidth,
        MIN_WIDTH,
        MAX_POSSIBLE_WIDTH
      );
      const nextCropHeight = clamp7(
        crop.height + changeInHeight,
        MIN_WIDTH,
        MAX_POSSIBLE_HEIGHT
      );
      nextCrop = {
        ...crop,
        x: isFlippedByX ? crop.x + crop.width - nextCropWidth : crop.x,
        y: isFlippedByY ? crop.y + crop.height - nextCropHeight : crop.y,
        width: nextCropWidth,
        height: nextCropHeight
      };
      scene.mutateElement(element, {
        crop: nextCrop,
        width: nextCrop.width / (crop.naturalWidth / uncroppedWidth),
        height: nextCrop.height / (crop.naturalHeight / uncroppedHeight)
      });
      return;
    }
    if (nextValue !== void 0) {
      const nextWidth = Math.max(
        property === "width" ? nextValue : keepAspectRatio ? nextValue * aspectRatio : origElement.width,
        MIN_WIDTH_OR_HEIGHT
      );
      const nextHeight = Math.max(
        property === "height" ? nextValue : keepAspectRatio ? nextValue / aspectRatio : origElement.height,
        MIN_WIDTH_OR_HEIGHT
      );
      resizeSingleElement(
        nextWidth,
        nextHeight,
        latestElement,
        origElement,
        originalElementsMap,
        scene,
        property === "width" ? "e" : "s",
        {
          shouldMaintainAspectRatio: keepAspectRatio
        }
      );
      if (isFrameLikeElement14(latestElement)) {
        const nextElementsInFrame = getElementsInResizingFrame3(
          scene.getElementsIncludingDeleted(),
          latestElement,
          originalAppState,
          scene.getNonDeletedElementsMap()
        );
        const updatedElements = replaceAllElementsInFrame3(
          scene.getElementsIncludingDeleted(),
          nextElementsInFrame,
          latestElement,
          app
        );
        scene.replaceAllElements(updatedElements);
      }
      return;
    }
    {
      const changeInWidth = property === "width" ? accumulatedChange : 0;
      const changeInHeight = property === "height" ? accumulatedChange : 0;
      let nextWidth = Math.max(0, origElement.width + changeInWidth);
      if (property === "width") {
        if (shouldChangeByStepSize) {
          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
        } else {
          nextWidth = Math.round(nextWidth);
        }
      }
      let nextHeight = Math.max(0, origElement.height + changeInHeight);
      if (property === "height") {
        if (shouldChangeByStepSize) {
          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
        } else {
          nextHeight = Math.round(nextHeight);
        }
      }
      if (keepAspectRatio) {
        if (property === "width") {
          nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
        } else {
          nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
        }
      }
      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
      resizeSingleElement(
        nextWidth,
        nextHeight,
        latestElement,
        origElement,
        originalElementsMap,
        scene,
        property === "width" ? "e" : "s",
        {
          shouldMaintainAspectRatio: keepAspectRatio
        }
      );
      if (isFrameLikeElement14(latestElement)) {
        const nextElementsInFrame = getElementsInResizingFrame3(
          scene.getElementsIncludingDeleted(),
          latestElement,
          originalAppState,
          scene.getNonDeletedElementsMap()
        );
        setAppState({
          elementsToHighlight: nextElementsInFrame
        });
      }
    }
  }
};
var handleDragFinished = ({
  setAppState,
  app,
  originalElements,
  originalAppState
}) => {
  const elementsMap = app.scene.getNonDeletedElementsMap();
  const origElement = originalElements?.[0];
  const latestElement = origElement && elementsMap.get(origElement.id);
  if (latestElement && isFrameLikeElement14(latestElement)) {
    const nextElementsInFrame = getElementsInResizingFrame3(
      app.scene.getElementsIncludingDeleted(),
      latestElement,
      originalAppState,
      app.scene.getNonDeletedElementsMap()
    );
    const updatedElements = replaceAllElementsInFrame3(
      app.scene.getElementsIncludingDeleted(),
      nextElementsInFrame,
      latestElement,
      app
    );
    app.scene.replaceAllElements(updatedElements);
    setAppState({
      elementsToHighlight: null
    });
  }
};
var DimensionDragInput = ({
  property,
  element,
  scene,
  appState
}) => {
  let value = round3(property === "width" ? element.width : element.height, 2);
  if (appState.croppingElementId && appState.croppingElementId === element.id && isImageElement7(element) && element.crop) {
    const { width: uncroppedWidth, height: uncroppedHeight } = getUncroppedWidthAndHeight2(element);
    if (property === "width") {
      const ratio = uncroppedWidth / element.crop.naturalWidth;
      value = round3(element.crop.width * ratio, 2);
    }
    if (property === "height") {
      const ratio = uncroppedHeight / element.crop.naturalHeight;
      value = round3(element.crop.height * ratio, 2);
    }
  }
  return /* @__PURE__ */ jsx162(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements: [element],
      dragInputCallback: handleDimensionChange,
      value,
      editable: isPropertyEditable(element, property),
      scene,
      appState,
      property,
      dragFinishedCallback: handleDragFinished
    }
  );
};
var Dimension_default = DimensionDragInput;

// components/Stats/FontSize.tsx
import {
  getBoundTextElement as getBoundTextElement12,
  redrawTextBoundingBox as redrawTextBoundingBox7
} from "@excalidraw/element";
import { hasBoundTextElement as hasBoundTextElement8, isTextElement as isTextElement17 } from "@excalidraw/element";
import { jsx as jsx163 } from "react/jsx-runtime";
var MIN_FONT_SIZE = 4;
var STEP_SIZE5 = 4;
var handleFontSizeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  if (origElement) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement || !isTextElement17(latestElement)) {
      return;
    }
    let nextFontSize;
    if (nextValue !== void 0) {
      nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE);
    } else if (origElement.type === "text") {
      const originalFontSize = Math.round(origElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      nextFontSize = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE
      );
      if (shouldChangeByStepSize) {
        nextFontSize = getStepSizedValue(nextFontSize, STEP_SIZE5);
      }
    }
    if (nextFontSize) {
      scene.mutateElement(latestElement, {
        fontSize: nextFontSize
      });
      redrawTextBoundingBox7(
        latestElement,
        scene.getContainerElement(latestElement),
        scene
      );
    }
  }
};
var FontSize = ({ element, scene, appState, property }) => {
  const _element = isTextElement17(element) ? element : hasBoundTextElement8(element) ? getBoundTextElement12(element, scene.getNonDeletedElementsMap()) : null;
  if (!_element) {
    return null;
  }
  return /* @__PURE__ */ jsx163(
    DragInput_default,
    {
      label: "F",
      value: Math.round(_element.fontSize * 10) / 10,
      elements: [_element],
      dragInputCallback: handleFontSizeChange,
      icon: fontSizeIcon,
      appState,
      scene,
      property
    }
  );
};
var FontSize_default = FontSize;

// components/Stats/MultiAngle.tsx
import { degreesToRadians as degreesToRadians3, radiansToDegrees as radiansToDegrees2 } from "@excalidraw/math";
import { getBoundTextElement as getBoundTextElement13 } from "@excalidraw/element";
import { isArrowElement as isArrowElement14 } from "@excalidraw/element";
import { isInGroup as isInGroup2 } from "@excalidraw/element";
import { jsx as jsx164 } from "react/jsx-runtime";
var STEP_SIZE6 = 15;
var handleDegreeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const editableLatestIndividualElements = originalElements.map((el) => elementsMap.get(el.id)).filter((el) => el && !isInGroup2(el) && isPropertyEditable(el, property));
  const editableOriginalIndividualElements = originalElements.filter(
    (el) => !isInGroup2(el) && isPropertyEditable(el, property)
  );
  if (nextValue !== void 0) {
    const nextAngle = degreesToRadians3(nextValue);
    for (const element of editableLatestIndividualElements) {
      if (!element) {
        continue;
      }
      scene.mutateElement(element, {
        angle: nextAngle
      });
      const boundTextElement = getBoundTextElement13(element, elementsMap);
      if (boundTextElement && !isArrowElement14(element)) {
        scene.mutateElement(boundTextElement, { angle: nextAngle });
      }
    }
    scene.triggerUpdate();
    return;
  }
  for (let i = 0; i < editableLatestIndividualElements.length; i++) {
    const latestElement = editableLatestIndividualElements[i];
    if (!latestElement) {
      continue;
    }
    const originalElement = editableOriginalIndividualElements[i];
    const originalAngleInDegrees = Math.round(radiansToDegrees2(originalElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE6);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians3(nextAngleInDegrees);
    scene.mutateElement(latestElement, {
      angle: nextAngle
    });
    const boundTextElement = getBoundTextElement13(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement14(latestElement)) {
      scene.mutateElement(boundTextElement, { angle: nextAngle });
    }
  }
  scene.triggerUpdate();
};
var MultiAngle = ({
  elements,
  scene,
  appState,
  property
}) => {
  const editableLatestIndividualElements = elements.filter(
    (el) => !isInGroup2(el) && isPropertyEditable(el, "angle")
  );
  const angles = editableLatestIndividualElements.map(
    (el) => Math.round(radiansToDegrees2(el.angle) % 360 * 100) / 100
  );
  const value = new Set(angles).size === 1 ? angles[0] : "Mixed";
  const editable = editableLatestIndividualElements.some(
    (el) => isPropertyEditable(el, "angle")
  );
  return /* @__PURE__ */ jsx164(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value,
      elements,
      dragInputCallback: handleDegreeChange2,
      editable,
      appState,
      scene,
      property
    }
  );
};
var MultiAngle_default = MultiAngle;

// components/Stats/MultiDimension.tsx
import { pointFrom as pointFrom28 } from "@excalidraw/math";
import { useMemo as useMemo10 } from "react";
import { MIN_WIDTH_OR_HEIGHT as MIN_WIDTH_OR_HEIGHT2 } from "@excalidraw/common";
import {
  getElementsInResizingFrame as getElementsInResizingFrame4,
  isFrameLikeElement as isFrameLikeElement15,
  replaceAllElementsInFrame as replaceAllElementsInFrame4,
  updateBoundElements as updateBoundElements4
} from "@excalidraw/element";
import {
  rescalePointsInElement,
  resizeSingleElement as resizeSingleElement2
} from "@excalidraw/element";
import { getBoundTextElement as getBoundTextElement14, handleBindTextResize as handleBindTextResize2 } from "@excalidraw/element";
import { isTextElement as isTextElement18 } from "@excalidraw/element";

// ../utils/src/index.ts
import { getCommonBounds as getCommonBounds9 } from "@excalidraw/element";

// components/Stats/MultiDimension.tsx
import { jsx as jsx165 } from "react/jsx-runtime";
var STEP_SIZE7 = 10;
var getResizedUpdates = (anchorX, anchorY, scale, origElement) => {
  const offsetX = origElement.x - anchorX;
  const offsetY = origElement.y - anchorY;
  const nextWidth = origElement.width * scale;
  const nextHeight = origElement.height * scale;
  const x = anchorX + offsetX * scale;
  const y = anchorY + offsetY * scale;
  return {
    width: nextWidth,
    height: nextHeight,
    x,
    y,
    ...rescalePointsInElement(origElement, nextWidth, nextHeight, false),
    ...isTextElement18(origElement) ? { fontSize: origElement.fontSize * scale } : {}
  };
};
var resizeElementInGroup = (anchorX, anchorY, property, scale, latestElement, origElement, originalElementsMap, scene) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const updates = getResizedUpdates(anchorX, anchorY, scale, origElement);
  scene.mutateElement(latestElement, updates);
  const boundTextElement = getBoundTextElement14(
    origElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const newFontSize = boundTextElement.fontSize * scale;
    updateBoundElements4(latestElement, scene);
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    if (latestBoundTextElement && isTextElement18(latestBoundTextElement)) {
      scene.mutateElement(latestBoundTextElement, {
        fontSize: newFontSize
      });
      handleBindTextResize2(
        latestElement,
        scene,
        property === "width" ? "e" : "s",
        true
      );
    }
  }
};
var resizeGroup = (nextWidth, nextHeight, initialHeight, aspectRatio, anchor, property, latestElements, originalElements, originalElementsMap, scene) => {
  if (property === "width") {
    nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
  } else {
    nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
  }
  const scale = nextHeight / initialHeight;
  for (let i = 0; i < originalElements.length; i++) {
    const origElement = originalElements[i];
    const latestElement = latestElements[i];
    resizeElementInGroup(
      anchor[0],
      anchor[1],
      property,
      scale,
      latestElement,
      origElement,
      originalElementsMap,
      scene
    );
  }
};
var handleDimensionChange2 = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  originalAppState,
  shouldChangeByStepSize,
  nextValue,
  scene,
  property,
  setAppState,
  app
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const atomicUnits = getAtomicUnits(originalElements, originalAppState);
  if (nextValue !== void 0) {
    for (const atomicUnit of atomicUnits) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const latestElements = elementsInUnit.map((el) => el.latest);
        const originalElements2 = elementsInUnit.map((el) => el.original);
        const [x1, y1, x2, y2] = getCommonBounds9(originalElements2);
        const initialWidth = x2 - x1;
        const initialHeight = y2 - y1;
        const aspectRatio = initialWidth / initialHeight;
        const nextWidth = Math.max(
          MIN_WIDTH_OR_HEIGHT2,
          property === "width" ? Math.max(0, nextValue) : initialWidth
        );
        const nextHeight = Math.max(
          MIN_WIDTH_OR_HEIGHT2,
          property === "height" ? Math.max(0, nextValue) : initialHeight
        );
        resizeGroup(
          nextWidth,
          nextHeight,
          initialHeight,
          aspectRatio,
          pointFrom28(x1, y1),
          property,
          latestElements,
          originalElements2,
          originalElementsMap,
          scene
        );
      } else {
        const [el] = elementsInUnit;
        const latestElement = el?.latest;
        const origElement = el?.original;
        if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
          let nextWidth = property === "width" ? Math.max(0, nextValue) : latestElement.width;
          if (property === "width") {
            if (shouldChangeByStepSize) {
              nextWidth = getStepSizedValue(nextWidth, STEP_SIZE7);
            } else {
              nextWidth = Math.round(nextWidth);
            }
          }
          let nextHeight = property === "height" ? Math.max(0, nextValue) : latestElement.height;
          if (property === "height") {
            if (shouldChangeByStepSize) {
              nextHeight = getStepSizedValue(nextHeight, STEP_SIZE7);
            } else {
              nextHeight = Math.round(nextHeight);
            }
          }
          nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT2, nextWidth);
          nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT2, nextHeight);
          resizeSingleElement2(
            nextWidth,
            nextHeight,
            latestElement,
            origElement,
            originalElementsMap,
            scene,
            property === "width" ? "e" : "s",
            {
              shouldInformMutation: false
            }
          );
          if (isFrameLikeElement15(latestElement)) {
            const nextElementsInFrame = getElementsInResizingFrame4(
              scene.getElementsIncludingDeleted(),
              latestElement,
              originalAppState,
              scene.getNonDeletedElementsMap()
            );
            const updatedElements = replaceAllElementsInFrame4(
              scene.getElementsIncludingDeleted(),
              nextElementsInFrame,
              latestElement,
              app
            );
            scene.replaceAllElements(updatedElements);
          }
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const changeInWidth = property === "width" ? accumulatedChange : 0;
  const changeInHeight = property === "height" ? accumulatedChange : 0;
  const elementsToHighlight = [];
  for (const atomicUnit of atomicUnits) {
    const elementsInUnit = getElementsInAtomicUnit(
      atomicUnit,
      elementsMap,
      originalElementsMap
    );
    if (elementsInUnit.length > 1) {
      const latestElements = elementsInUnit.map((el) => el.latest);
      const originalElements2 = elementsInUnit.map((el) => el.original);
      const [x1, y1, x2, y2] = getCommonBounds9(originalElements2);
      const initialWidth = x2 - x1;
      const initialHeight = y2 - y1;
      const aspectRatio = initialWidth / initialHeight;
      let nextWidth = Math.max(0, initialWidth + changeInWidth);
      if (property === "width") {
        if (shouldChangeByStepSize) {
          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE7);
        } else {
          nextWidth = Math.round(nextWidth);
        }
      }
      let nextHeight = Math.max(0, initialHeight + changeInHeight);
      if (property === "height") {
        if (shouldChangeByStepSize) {
          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE7);
        } else {
          nextHeight = Math.round(nextHeight);
        }
      }
      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT2, nextWidth);
      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT2, nextHeight);
      resizeGroup(
        nextWidth,
        nextHeight,
        initialHeight,
        aspectRatio,
        pointFrom28(x1, y1),
        property,
        latestElements,
        originalElements2,
        originalElementsMap,
        scene
      );
    } else {
      const [el] = elementsInUnit;
      const latestElement = el?.latest;
      const origElement = el?.original;
      if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
        let nextWidth = Math.max(0, origElement.width + changeInWidth);
        if (property === "width") {
          if (shouldChangeByStepSize) {
            nextWidth = getStepSizedValue(nextWidth, STEP_SIZE7);
          } else {
            nextWidth = Math.round(nextWidth);
          }
        }
        let nextHeight = Math.max(0, origElement.height + changeInHeight);
        if (property === "height") {
          if (shouldChangeByStepSize) {
            nextHeight = getStepSizedValue(nextHeight, STEP_SIZE7);
          } else {
            nextHeight = Math.round(nextHeight);
          }
        }
        nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT2, nextWidth);
        nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT2, nextHeight);
        resizeSingleElement2(
          nextWidth,
          nextHeight,
          latestElement,
          origElement,
          originalElementsMap,
          scene,
          property === "width" ? "e" : "s",
          {
            shouldInformMutation: false
          }
        );
        if (isFrameLikeElement15(latestElement)) {
          const nextElementsInFrame = getElementsInResizingFrame4(
            scene.getElementsIncludingDeleted(),
            latestElement,
            originalAppState,
            scene.getNonDeletedElementsMap()
          );
          elementsToHighlight.push(...nextElementsInFrame);
        }
      }
    }
  }
  setAppState({
    elementsToHighlight
  });
  scene.triggerUpdate();
};
var handleDragFinished2 = ({
  setAppState,
  app,
  originalElements,
  originalAppState
}) => {
  const elementsMap = app.scene.getNonDeletedElementsMap();
  const origElement = originalElements?.[0];
  const latestElement = origElement && elementsMap.get(origElement.id);
  if (latestElement && isFrameLikeElement15(latestElement)) {
    const nextElementsInFrame = getElementsInResizingFrame4(
      app.scene.getElementsIncludingDeleted(),
      latestElement,
      originalAppState,
      app.scene.getNonDeletedElementsMap()
    );
    const updatedElements = replaceAllElementsInFrame4(
      app.scene.getElementsIncludingDeleted(),
      nextElementsInFrame,
      latestElement,
      app
    );
    app.scene.replaceAllElements(updatedElements);
    setAppState({
      elementsToHighlight: null
    });
  }
};
var MultiDimension = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const sizes = useMemo10(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = getElementsInAtomicUnit(atomicUnit, elementsMap);
      if (elementsInUnit.length > 1) {
        const [x1, y1, x2, y2] = getCommonBounds9(
          elementsInUnit.map((el2) => el2.latest)
        );
        return Math.round((property === "width" ? x2 - x1 : y2 - y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      return Math.round(
        (property === "width" ? el.latest.width : el.latest.height) * 100
      ) / 100;
    }),
    [elementsMap, atomicUnits, property]
  );
  const value = new Set(sizes).size === 1 ? Math.round(sizes[0] * 100) / 100 : "Mixed";
  const editable = sizes.length > 0;
  return /* @__PURE__ */ jsx165(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements,
      dragInputCallback: handleDimensionChange2,
      value,
      editable,
      appState,
      property,
      scene,
      dragFinishedCallback: handleDragFinished2
    }
  );
};
var MultiDimension_default = MultiDimension;

// components/Stats/MultiFontSize.tsx
import {
  getBoundTextElement as getBoundTextElement15,
  redrawTextBoundingBox as redrawTextBoundingBox8
} from "@excalidraw/element";
import { hasBoundTextElement as hasBoundTextElement9, isTextElement as isTextElement19 } from "@excalidraw/element";
import { isInGroup as isInGroup3 } from "@excalidraw/element";
import { jsx as jsx166 } from "react/jsx-runtime";
var MIN_FONT_SIZE2 = 4;
var STEP_SIZE8 = 4;
var getApplicableTextElements = (elements, elementsMap) => elements.reduce(
  (acc, el) => {
    if (!el || isInGroup3(el)) {
      return acc;
    }
    if (isTextElement19(el)) {
      acc.push(el);
      return acc;
    }
    if (hasBoundTextElement9(el)) {
      const boundTextElement = getBoundTextElement15(el, elementsMap);
      if (boundTextElement) {
        acc.push(boundTextElement);
        return acc;
      }
    }
    return acc;
  },
  []
);
var handleFontSizeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const latestTextElements = originalElements.map(
    (el) => elementsMap.get(el.id)
  );
  let nextFontSize;
  if (nextValue) {
    nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE2);
    for (const textElement of latestTextElements) {
      scene.mutateElement(textElement, {
        fontSize: nextFontSize
      });
      redrawTextBoundingBox8(
        textElement,
        scene.getContainerElement(textElement),
        scene
      );
    }
    scene.triggerUpdate();
  } else {
    const originalTextElements = originalElements;
    for (let i = 0; i < latestTextElements.length; i++) {
      const latestElement = latestTextElements[i];
      const originalElement = originalTextElements[i];
      const originalFontSize = Math.round(originalElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      let nextFontSize2 = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE2
      );
      if (shouldChangeByStepSize) {
        nextFontSize2 = getStepSizedValue(nextFontSize2, STEP_SIZE8);
      }
      scene.mutateElement(latestElement, {
        fontSize: nextFontSize2
      });
      redrawTextBoundingBox8(
        latestElement,
        scene.getContainerElement(latestElement),
        scene
      );
    }
    scene.triggerUpdate();
  }
};
var MultiFontSize = ({
  elements,
  scene,
  appState,
  property,
  elementsMap
}) => {
  const latestTextElements = getApplicableTextElements(elements, elementsMap);
  if (!latestTextElements.length) {
    return null;
  }
  const fontSizes = latestTextElements.map(
    (textEl) => Math.round(textEl.fontSize * 10) / 10
  );
  const value = new Set(fontSizes).size === 1 ? fontSizes[0] : "Mixed";
  const editable = fontSizes.length > 0;
  return /* @__PURE__ */ jsx166(
    DragInput_default,
    {
      label: "F",
      icon: fontSizeIcon,
      elements: latestTextElements,
      dragInputCallback: handleFontSizeChange2,
      value,
      editable,
      scene,
      property,
      appState
    }
  );
};
var MultiFontSize_default = MultiFontSize;

// components/Stats/MultiPosition.tsx
import { pointFrom as pointFrom29, pointRotateRads as pointRotateRads20 } from "@excalidraw/math";
import { useMemo as useMemo11 } from "react";
import { isTextElement as isTextElement20 } from "@excalidraw/element";
import { getCommonBounds as getCommonBounds10 } from "@excalidraw/element";
import { jsx as jsx167 } from "react/jsx-runtime";
var moveElements = (property, changeInTopX, changeInTopY, originalElements, originalElementsMap, scene, appState) => {
  for (let i = 0; i < originalElements.length; i++) {
    const origElement = originalElements[i];
    const [cx, cy] = [
      origElement.x + origElement.width / 2,
      origElement.y + origElement.height / 2
    ];
    const [topLeftX, topLeftY] = pointRotateRads20(
      pointFrom29(origElement.x, origElement.y),
      pointFrom29(cx, cy),
      origElement.angle
    );
    const newTopLeftX = property === "x" ? Math.round(topLeftX + changeInTopX) : topLeftX;
    const newTopLeftY = property === "y" ? Math.round(topLeftY + changeInTopY) : topLeftY;
    moveElement(
      newTopLeftX,
      newTopLeftY,
      origElement,
      scene,
      appState,
      originalElementsMap,
      false
    );
  }
};
var moveGroupTo = (nextX, nextY, originalElements, originalElementsMap, scene, appState) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const [x1, y1, ,] = getCommonBounds10(originalElements);
  const offsetX = nextX - x1;
  const offsetY = nextY - y1;
  for (let i = 0; i < originalElements.length; i++) {
    const origElement = originalElements[i];
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      continue;
    }
    if (!isTextElement20(latestElement) || !latestElement.containerId) {
      const [cx, cy] = [
        latestElement.x + latestElement.width / 2,
        latestElement.y + latestElement.height / 2
      ];
      const [topLeftX, topLeftY] = pointRotateRads20(
        pointFrom29(latestElement.x, latestElement.y),
        pointFrom29(cx, cy),
        latestElement.angle
      );
      moveElement(
        topLeftX + offsetX,
        topLeftY + offsetY,
        origElement,
        scene,
        appState,
        originalElementsMap,
        false
      );
    }
  }
};
var handlePositionChange = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene,
  originalAppState,
  app
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  if (nextValue !== void 0) {
    for (const atomicUnit of getAtomicUnits(
      originalElements,
      originalAppState
    )) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const [x1, y1, ,] = getCommonBounds10(
          elementsInUnit.map((el) => el.latest)
        );
        const newTopLeftX = property === "x" ? nextValue : x1;
        const newTopLeftY = property === "y" ? nextValue : y1;
        moveGroupTo(
          newTopLeftX,
          newTopLeftY,
          elementsInUnit.map((el) => el.original),
          originalElementsMap,
          scene,
          app.state
        );
      } else {
        const origElement = elementsInUnit[0]?.original;
        const latestElement = elementsInUnit[0]?.latest;
        if (origElement && latestElement && isPropertyEditable(latestElement, property)) {
          const [cx, cy] = [
            origElement.x + origElement.width / 2,
            origElement.y + origElement.height / 2
          ];
          const [topLeftX, topLeftY] = pointRotateRads20(
            pointFrom29(origElement.x, origElement.y),
            pointFrom29(cx, cy),
            origElement.angle
          );
          const newTopLeftX = property === "x" ? nextValue : topLeftX;
          const newTopLeftY = property === "y" ? nextValue : topLeftY;
          moveElement(
            newTopLeftX,
            newTopLeftY,
            origElement,
            scene,
            app.state,
            originalElementsMap,
            false
          );
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const change = shouldChangeByStepSize ? getStepSizedValue(accumulatedChange, STEP_SIZE) : accumulatedChange;
  const changeInTopX = property === "x" ? change : 0;
  const changeInTopY = property === "y" ? change : 0;
  moveElements(
    property,
    changeInTopX,
    changeInTopY,
    originalElements,
    originalElementsMap,
    scene,
    app.state
  );
  scene.triggerUpdate();
};
var MultiPosition = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const positions = useMemo11(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = Object.keys(atomicUnit).map((id) => elementsMap.get(id)).filter((el2) => el2 !== void 0);
      if (elementsInUnit.length > 1) {
        const [x1, y1] = getCommonBounds10(elementsInUnit);
        return Math.round((property === "x" ? x1 : y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      const [cx, cy] = [el.x + el.width / 2, el.y + el.height / 2];
      const [topLeftX, topLeftY] = pointRotateRads20(
        pointFrom29(el.x, el.y),
        pointFrom29(cx, cy),
        el.angle
      );
      return Math.round((property === "x" ? topLeftX : topLeftY) * 100) / 100;
    }),
    [atomicUnits, elementsMap, property]
  );
  const value = new Set(positions).size === 1 ? positions[0] : "Mixed";
  return /* @__PURE__ */ jsx167(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements,
      dragInputCallback: handlePositionChange,
      value,
      property,
      scene,
      appState
    }
  );
};
var MultiPosition_default = MultiPosition;

// components/Stats/Position.tsx
import { clamp as clamp8, pointFrom as pointFrom30, pointRotateRads as pointRotateRads21, round as round4 } from "@excalidraw/math";
import {
  getFlipAdjustedCropPosition,
  getUncroppedWidthAndHeight as getUncroppedWidthAndHeight3
} from "@excalidraw/element";
import { isImageElement as isImageElement8 } from "@excalidraw/element";
import { jsx as jsx168 } from "react/jsx-runtime";
var handlePositionChange2 = ({
  accumulatedChange,
  instantChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene,
  originalAppState,
  app
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  const [cx, cy] = [
    origElement.x + origElement.width / 2,
    origElement.y + origElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads21(
    pointFrom30(origElement.x, origElement.y),
    pointFrom30(cx, cy),
    origElement.angle
  );
  if (originalAppState.croppingElementId === origElement.id) {
    const element = elementsMap.get(origElement.id);
    if (!element || !isImageElement8(element) || !element.crop) {
      return;
    }
    const crop = element.crop;
    let nextCrop = crop;
    const isFlippedByX = element.scale[0] === -1;
    const isFlippedByY = element.scale[1] === -1;
    const { width: uncroppedWidth, height: uncroppedHeight } = getUncroppedWidthAndHeight3(element);
    if (nextValue !== void 0) {
      if (property === "x") {
        const nextValueInNatural = nextValue * (crop.naturalWidth / uncroppedWidth);
        if (isFlippedByX) {
          nextCrop = {
            ...crop,
            x: clamp8(
              crop.naturalWidth - nextValueInNatural - crop.width,
              0,
              crop.naturalWidth - crop.width
            )
          };
        } else {
          nextCrop = {
            ...crop,
            x: clamp8(
              nextValue * (crop.naturalWidth / uncroppedWidth),
              0,
              crop.naturalWidth - crop.width
            )
          };
        }
      }
      if (property === "y") {
        nextCrop = {
          ...crop,
          y: clamp8(
            nextValue * (crop.naturalHeight / uncroppedHeight),
            0,
            crop.naturalHeight - crop.height
          )
        };
      }
      scene.mutateElement(element, {
        crop: nextCrop
      });
      return;
    }
    const changeInX = (property === "x" ? instantChange : 0) * (isFlippedByX ? -1 : 1);
    const changeInY = (property === "y" ? instantChange : 0) * (isFlippedByY ? -1 : 1);
    nextCrop = {
      ...crop,
      x: clamp8(crop.x + changeInX, 0, crop.naturalWidth - crop.width),
      y: clamp8(crop.y + changeInY, 0, crop.naturalHeight - crop.height)
    };
    scene.mutateElement(element, {
      crop: nextCrop
    });
    return;
  }
  if (nextValue !== void 0) {
    const newTopLeftX2 = property === "x" ? nextValue : topLeftX;
    const newTopLeftY2 = property === "y" ? nextValue : topLeftY;
    moveElement(
      newTopLeftX2,
      newTopLeftY2,
      origElement,
      scene,
      app.state,
      originalElementsMap
    );
    return;
  }
  const changeInTopX = property === "x" ? accumulatedChange : 0;
  const changeInTopY = property === "y" ? accumulatedChange : 0;
  const newTopLeftX = property === "x" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.x + changeInTopX, STEP_SIZE) : topLeftX + changeInTopX
  ) : topLeftX;
  const newTopLeftY = property === "y" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.y + changeInTopY, STEP_SIZE) : topLeftY + changeInTopY
  ) : topLeftY;
  moveElement(
    newTopLeftX,
    newTopLeftY,
    origElement,
    scene,
    app.state,
    originalElementsMap
  );
};
var Position = ({
  property,
  element,
  elementsMap,
  scene,
  appState
}) => {
  const [topLeftX, topLeftY] = pointRotateRads21(
    pointFrom30(element.x, element.y),
    pointFrom30(element.x + element.width / 2, element.y + element.height / 2),
    element.angle
  );
  let value = round4(property === "x" ? topLeftX : topLeftY, 2);
  if (appState.croppingElementId === element.id && isImageElement8(element) && element.crop) {
    const flipAdjustedPosition = getFlipAdjustedCropPosition(element);
    if (flipAdjustedPosition) {
      value = round4(
        property === "x" ? flipAdjustedPosition.x : flipAdjustedPosition.y,
        2
      );
    }
  }
  return /* @__PURE__ */ jsx168(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements: [element],
      dragInputCallback: handlePositionChange2,
      scene,
      value,
      property,
      appState
    }
  );
};
var Position_default = Position;

// components/Stats/index.tsx
import { Fragment as Fragment30, jsx as jsx169, jsxs as jsxs94 } from "react/jsx-runtime";
var STATS_TIMEOUT = 50;
var Stats = (props) => {
  const appState = useExcalidrawAppState();
  const sceneNonce = props.app.scene.getSceneNonce() || 1;
  const selectedElements = props.app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: false
  });
  const gridModeEnabled = isGridModeEnabled(props.app);
  return /* @__PURE__ */ jsx169(
    StatsInner,
    {
      ...props,
      appState,
      sceneNonce,
      selectedElements,
      gridModeEnabled
    }
  );
};
var StatsRow = ({
  children,
  columns = 1,
  heading,
  style,
  ...rest
}) => /* @__PURE__ */ jsx169(
  "div",
  {
    className: clsx66("exc-stats__row", { "exc-stats__row--heading": heading }),
    style: {
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      ...style
    },
    ...rest,
    children
  }
);
StatsRow.displayName = "StatsRow";
var StatsRows = ({
  children,
  order,
  style,
  ...rest
}) => /* @__PURE__ */ jsx169("div", { className: "exc-stats__rows", style: { order, ...style }, ...rest, children });
StatsRows.displayName = "StatsRows";
Stats.StatsRow = StatsRow;
Stats.StatsRows = StatsRows;
var StatsInner = memo5(
  ({
    app,
    onClose,
    renderCustomStats,
    selectedElements,
    appState,
    sceneNonce,
    gridModeEnabled
  }) => {
    const scene = app.scene;
    const elements = scene.getNonDeletedElements();
    const elementsMap = scene.getNonDeletedElementsMap();
    const setAppState = useExcalidrawSetAppState();
    const singleElement = selectedElements.length === 1 ? selectedElements[0] : null;
    const multipleElements = selectedElements.length > 1 ? selectedElements : null;
    const cropMode = appState.croppingElementId && isImageElement9(singleElement);
    const unCroppedDimension = cropMode ? getUncroppedWidthAndHeight4(singleElement) : null;
    const [sceneDimension, setSceneDimension] = useState44({
      width: 0,
      height: 0
    });
    const throttledSetSceneDimension = useMemo12(
      () => throttle4((elements2) => {
        const boundingBox = getCommonBounds11(elements2);
        setSceneDimension({
          width: Math.round(boundingBox[2]) - Math.round(boundingBox[0]),
          height: Math.round(boundingBox[3]) - Math.round(boundingBox[1])
        });
      }, STATS_TIMEOUT),
      []
    );
    useEffect50(() => {
      throttledSetSceneDimension(elements);
    }, [sceneNonce, elements, throttledSetSceneDimension]);
    useEffect50(
      () => () => throttledSetSceneDimension.cancel(),
      [throttledSetSceneDimension]
    );
    const atomicUnits = useMemo12(() => {
      return getAtomicUnits(selectedElements, appState);
    }, [selectedElements, appState]);
    const _frameAndChildrenSelectedTogether = useMemo12(() => {
      return frameAndChildrenSelectedTogether2(selectedElements);
    }, [selectedElements]);
    return /* @__PURE__ */ jsx169("div", { className: "exc-stats", children: /* @__PURE__ */ jsxs94(Island, { padding: 3, children: [
      /* @__PURE__ */ jsxs94("div", { className: "title", children: [
        /* @__PURE__ */ jsx169("h2", { children: t("stats.title") }),
        /* @__PURE__ */ jsx169("div", { className: "close", onClick: onClose, children: CloseIcon })
      ] }),
      /* @__PURE__ */ jsxs94(
        Collapsible_default,
        {
          label: /* @__PURE__ */ jsx169("h3", { children: t("stats.generalStats") }),
          open: !!(appState.stats.panels & STATS_PANELS.generalStats),
          openTrigger: () => setAppState((state) => {
            return {
              stats: {
                open: true,
                panels: state.stats.panels ^ STATS_PANELS.generalStats
              }
            };
          }),
          children: [
            /* @__PURE__ */ jsxs94(StatsRows, { children: [
              /* @__PURE__ */ jsx169(StatsRow, { heading: true, children: t("stats.scene") }),
              /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx169("div", { children: t("stats.shapes") }),
                /* @__PURE__ */ jsx169("div", { children: elements.length })
              ] }),
              /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx169("div", { children: t("stats.width") }),
                /* @__PURE__ */ jsx169("div", { children: sceneDimension.width })
              ] }),
              /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx169("div", { children: t("stats.height") }),
                /* @__PURE__ */ jsx169("div", { children: sceneDimension.height })
              ] }),
              gridModeEnabled && /* @__PURE__ */ jsxs94(Fragment30, { children: [
                /* @__PURE__ */ jsx169(StatsRow, { heading: true, children: "Canvas" }),
                /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                  CanvasGrid_default,
                  {
                    property: "gridStep",
                    scene,
                    appState,
                    setAppState
                  }
                ) })
              ] })
            ] }),
            renderCustomStats?.(elements, appState)
          ]
        }
      ),
      !_frameAndChildrenSelectedTogether && selectedElements.length > 0 && /* @__PURE__ */ jsx169(
        "div",
        {
          id: "elementStats",
          style: {
            marginTop: 12
          },
          children: /* @__PURE__ */ jsx169(
            Collapsible_default,
            {
              label: /* @__PURE__ */ jsx169("h3", { children: t("stats.elementProperties") }),
              open: !!(appState.stats.panels & STATS_PANELS.elementProperties),
              openTrigger: () => setAppState((state) => {
                return {
                  stats: {
                    open: true,
                    panels: state.stats.panels ^ STATS_PANELS.elementProperties
                  }
                };
              }),
              children: /* @__PURE__ */ jsxs94(StatsRows, { children: [
                singleElement && /* @__PURE__ */ jsxs94(Fragment30, { children: [
                  cropMode && /* @__PURE__ */ jsx169(StatsRow, { heading: true, children: t("labels.unCroppedDimension") }),
                  appState.croppingElementId && isImageElement9(singleElement) && unCroppedDimension && /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, children: [
                    /* @__PURE__ */ jsx169("div", { children: t("stats.width") }),
                    /* @__PURE__ */ jsx169("div", { children: round5(unCroppedDimension.width, 2) })
                  ] }),
                  appState.croppingElementId && isImageElement9(singleElement) && unCroppedDimension && /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, children: [
                    /* @__PURE__ */ jsx169("div", { children: t("stats.height") }),
                    /* @__PURE__ */ jsx169("div", { children: round5(unCroppedDimension.height, 2) })
                  ] }),
                  /* @__PURE__ */ jsx169(
                    StatsRow,
                    {
                      heading: true,
                      "data-testid": "stats-element-type",
                      style: { margin: "0.3125rem 0" },
                      children: appState.croppingElementId ? t("labels.imageCropping") : t(`element.${singleElement.type}`)
                    }
                  ),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    Position_default,
                    {
                      element: singleElement,
                      property: "x",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    Position_default,
                    {
                      element: singleElement,
                      property: "y",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    Dimension_default,
                    {
                      property: "width",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    Dimension_default,
                    {
                      property: "height",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    Angle_default,
                    {
                      property: "angle",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    FontSize_default,
                    {
                      property: "fontSize",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) })
                ] }),
                multipleElements && /* @__PURE__ */ jsxs94(Fragment30, { children: [
                  elementsAreInSameGroup2(multipleElements) && /* @__PURE__ */ jsx169(StatsRow, { heading: true, children: t("element.group") }),
                  /* @__PURE__ */ jsxs94(StatsRow, { columns: 2, style: { margin: "0.3125rem 0" }, children: [
                    /* @__PURE__ */ jsx169("div", { children: t("stats.shapes") }),
                    /* @__PURE__ */ jsx169("div", { children: selectedElements.length })
                  ] }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiPosition_default,
                    {
                      property: "x",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiPosition_default,
                    {
                      property: "y",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiDimension_default,
                    {
                      property: "width",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiDimension_default,
                    {
                      property: "height",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiAngle_default,
                    {
                      property: "angle",
                      elements: multipleElements,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx169(StatsRow, { children: /* @__PURE__ */ jsx169(
                    MultiFontSize_default,
                    {
                      property: "fontSize",
                      elements: multipleElements,
                      scene,
                      appState,
                      elementsMap
                    }
                  ) })
                ] })
              ] })
            }
          )
        }
      )
    ] }) });
  },
  (prev, next) => {
    return prev.sceneNonce === next.sceneNonce && prev.selectedElements === next.selectedElements && prev.appState.stats.panels === next.appState.stats.panels && prev.gridModeEnabled === next.gridModeEnabled && prev.appState.gridStep === next.appState.gridStep && prev.appState.croppingElementId === next.appState.croppingElementId;
  }
);

// components/TTDDialog/TTDDialogTrigger.tsx
import { jsx as jsx170 } from "react/jsx-runtime";
var TTDDialogTrigger = ({
  children,
  icon
}) => {
  const { t: t2 } = useI18n();
  const { TTDDialogTriggerTunnel } = useTunnels();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx170(TTDDialogTriggerTunnel.In, { children: /* @__PURE__ */ jsx170(
    DropdownMenu_default.Item,
    {
      onSelect: () => {
        trackEvent("ai", "dialog open", "ttd");
        setAppState({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
      },
      icon: icon ?? brainIcon,
      badge: /* @__PURE__ */ jsx170(DropdownMenu_default.Item.Badge, { children: "AI" }),
      children: children ?? t2("labels.textToDiagram")
    }
  ) });
};
TTDDialogTrigger.displayName = "TTDDialogTrigger";

// components/TTDDialog/utils/TTDStreamFetch.ts
function extractRateLimitHeaders(headers) {
  const rateLimit = headers.get("X-Ratelimit-Limit");
  const rateLimitRemaining = headers.get("X-Ratelimit-Remaining");
  return {
    rateLimit: rateLimit ? parseInt(rateLimit, 10) : void 0,
    rateLimitRemaining: rateLimitRemaining ? parseInt(rateLimitRemaining, 10) : void 0
  };
}
async function* parseSSEStream(reader) {
  const decoder = new TextDecoder();
  let buffer = "";
  try {
    while (true) {
      const { done: done2, value } = await reader.read();
      if (done2) {
        break;
      }
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
          continue;
        }
        if (trimmedLine.startsWith("data: ")) {
          const data = trimmedLine.slice(6);
          yield data;
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}
async function TTDStreamFetch(options) {
  const {
    url,
    messages,
    onChunk,
    onStreamCreated,
    extractRateLimits = true,
    signal
  } = options;
  try {
    let fullResponse = "";
    let rateLimitInfo = {};
    let error = null;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        Accept: "text/event-stream",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ messages }),
      signal
    });
    if (extractRateLimits) {
      rateLimitInfo = extractRateLimitHeaders(response.headers);
    }
    if (!response.ok) {
      if (response.status === 429) {
        return {
          ...rateLimitInfo,
          error: new RequestError({
            message: "Rate limit exceeded",
            status: 429
          })
        };
      }
      const text = await response.text();
      throw new RequestError({
        message: text || "Generation failed...",
        status: response.status
      });
    }
    const reader = response.body?.getReader();
    if (!reader) {
      throw new RequestError({
        message: "Couldn't get reader from response body",
        status: 500
      });
    }
    onStreamCreated?.();
    try {
      for await (const data of parseSSEStream(reader)) {
        if (data === "[DONE]") {
          break;
        }
        try {
          const chunk2 = JSON.parse(data);
          if (chunk2 === null) {
            break;
          }
          switch (chunk2.type) {
            case "content": {
              const delta = chunk2.delta;
              if (delta) {
                fullResponse += delta;
                onChunk?.(delta);
              }
              break;
            }
            case "error":
              error = new RequestError({
                message: chunk2.error.message,
                status: 500
              });
              break;
            case "done":
              break;
          }
        } catch (e) {
          console.warn("Failed to parse SSE data:", data, e);
        }
      }
    } catch (streamError) {
      if (streamError.name === "AbortError") {
        error = new RequestError({ message: "Request aborted", status: 499 });
      } else {
        error = new RequestError({
          message: streamError.message || "Streaming error",
          status: 500
        });
      }
    }
    if (error) {
      return {
        ...rateLimitInfo,
        error
      };
    }
    if (!fullResponse) {
      return {
        ...rateLimitInfo,
        error: new RequestError({
          message: "Generation failed...",
          status: response.status
        })
      };
    }
    return {
      generatedResponse: fullResponse,
      error: null,
      ...rateLimitInfo
    };
  } catch (err) {
    if (err.name === "AbortError") {
      return {
        error: new RequestError({ message: "Request aborted", status: 499 })
      };
    }
    return {
      error: new RequestError({
        message: err.message || "Request failed",
        status: 500
      })
    };
  }
}

// index.tsx
import {
  getCommonBounds as getCommonBounds12,
  getVisibleSceneBounds as getVisibleSceneBounds2,
  convertToExcalidrawElements
} from "@excalidraw/element";

// components/DiagramToCodePlugin/DiagramToCodePlugin.tsx
import { useLayoutEffect as useLayoutEffect10 } from "react";
var DiagramToCodePlugin = (props) => {
  const app = useApp();
  useLayoutEffect10(() => {
    app.setPlugins({
      diagramToCode: { generate: props.generate }
    });
  }, [app, props.generate]);
  return null;
};

// index.tsx
import { isElementLink as isElementLink3 } from "@excalidraw/element";
import { setCustomTextMetricsProvider } from "@excalidraw/element";
import { jsx as jsx171 } from "react/jsx-runtime";
polyfill_default();
var ExcalidrawBase = (props) => {
  const {
    onChange,
    onIncrement,
    initialData,
    excalidrawAPI,
    isCollaborating = false,
    onPointerUpdate,
    renderTopLeftUI,
    renderTopRightUI,
    langCode = defaultLang.code,
    viewModeEnabled,
    zenModeEnabled,
    gridModeEnabled,
    libraryReturnUrl,
    theme,
    name,
    renderCustomStats,
    onPaste,
    detectScroll = true,
    handleKeyboardGlobally = false,
    onLibraryChange,
    autoFocus = false,
    generateIdForFile,
    onLinkOpen,
    generateLinkForSelection,
    onPointerDown,
    onPointerUp,
    onScrollChange,
    onDuplicate,
    children,
    validateEmbeddable,
    renderEmbeddable,
    aiEnabled,
    showDeprecatedFonts,
    renderScrollbars,
    onQuickAddHandleActivate
  } = props;
  const canvasActions = props.UIOptions?.canvasActions;
  const UIOptions = {
    ...props.UIOptions,
    canvasActions: {
      ...DEFAULT_UI_OPTIONS.canvasActions,
      ...canvasActions
    },
    tools: {
      image: props.UIOptions?.tools?.image ?? true,
      selection: props.UIOptions?.tools?.selection ?? true
    }
  };
  if (canvasActions?.export) {
    UIOptions.canvasActions.export.saveFileToDisk = canvasActions.export?.saveFileToDisk ?? DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;
  }
  if (UIOptions.canvasActions.toggleTheme === null && typeof theme === "undefined") {
    UIOptions.canvasActions.toggleTheme = true;
  }
  useEffect51(() => {
    const importPolyfill = async () => {
      await import("canvas-roundrect-polyfill");
    };
    importPolyfill();
    const handleTouchMove = (event) => {
      if (typeof event.scale === "number" && event.scale !== 1) {
        event.preventDefault();
      }
    };
    document.addEventListener("touchmove", handleTouchMove, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", handleTouchMove);
    };
  }, []);
  return /* @__PURE__ */ jsx171(EditorJotaiProvider, { store: editorJotaiStore, children: /* @__PURE__ */ jsx171(InitializeApp, { langCode, theme, children: /* @__PURE__ */ jsx171(
    App_default,
    {
      onChange,
      onIncrement,
      initialData,
      excalidrawAPI,
      isCollaborating,
      onPointerUpdate,
      renderTopLeftUI,
      renderTopRightUI,
      langCode,
      viewModeEnabled,
      zenModeEnabled,
      gridModeEnabled,
      libraryReturnUrl,
      theme,
      name,
      renderCustomStats,
      UIOptions,
      onPaste,
      detectScroll,
      handleKeyboardGlobally,
      onLibraryChange,
      autoFocus,
      generateIdForFile,
      onLinkOpen,
      generateLinkForSelection,
      onPointerDown,
      onPointerUp,
      onScrollChange,
      onDuplicate,
      validateEmbeddable,
      renderEmbeddable,
      aiEnabled: aiEnabled !== false,
      showDeprecatedFonts,
      renderScrollbars,
      onQuickAddHandleActivate,
      children
    }
  ) }) });
};
var areEqual5 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const {
    initialData: prevInitialData,
    UIOptions: prevUIOptions = {},
    ...prev
  } = prevProps;
  const {
    initialData: nextInitialData,
    UIOptions: nextUIOptions = {},
    ...next
  } = nextProps;
  const prevUIOptionsKeys = Object.keys(prevUIOptions);
  const nextUIOptionsKeys = Object.keys(nextUIOptions);
  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {
    return false;
  }
  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {
    if (key === "getFormFactor") {
      return true;
    }
    if (key === "canvasActions") {
      const canvasOptionKeys = Object.keys(
        prevUIOptions.canvasActions
      );
      return canvasOptionKeys.every((key2) => {
        if (key2 === "export" && prevUIOptions?.canvasActions?.export && nextUIOptions?.canvasActions?.export) {
          return prevUIOptions.canvasActions.export.saveFileToDisk === nextUIOptions.canvasActions.export.saveFileToDisk;
        }
        return prevUIOptions?.canvasActions?.[key2] === nextUIOptions?.canvasActions?.[key2];
      });
    }
    return prevUIOptions[key] === nextUIOptions[key];
  });
  return isUIOptionsSame && isShallowEqual10(prev, next);
};
var Excalidraw = React49.memo(ExcalidrawBase, areEqual5);
Excalidraw.displayName = "Excalidraw";
export {
  Button,
  CaptureUpdateAction38 as CaptureUpdateAction,
  CommandPalette,
  DEFAULT_LASER_COLOR2 as DEFAULT_LASER_COLOR,
  DefaultSidebar,
  DiagramToCodePlugin,
  Ellipsify,
  Excalidraw,
  FONT_FAMILY5 as FONT_FAMILY,
  FooterCenter_default as Footer,
  LiveCollaborationTrigger_default as LiveCollaborationTrigger,
  MIME_TYPES10 as MIME_TYPES,
  MainMenu_default as MainMenu,
  ROUNDNESS3 as ROUNDNESS,
  Sidebar,
  Stats,
  THEME15 as THEME,
  TTDDialog,
  TTDDialogTrigger,
  TTDStreamFetch,
  UserIdleState2 as UserIdleState,
  WelcomeScreen_default as WelcomeScreen,
  bumpVersion,
  convertToExcalidrawElements,
  defaultLang,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsOverlappingBBox,
  exportToBlob,
  exportToCanvas2 as exportToCanvas,
  exportToClipboard,
  exportToSvg2 as exportToSvg,
  getCommonBounds12 as getCommonBounds,
  getDataURL,
  getFormFactor2 as getFormFactor,
  getLibraryItemsHash,
  getNonDeletedElements13 as getNonDeletedElements,
  getSceneVersion,
  getTextFromElements3 as getTextFromElements,
  getVisibleSceneBounds2 as getVisibleSceneBounds,
  hashElementsVersion2 as hashElementsVersion,
  hashString2 as hashString,
  isElementInsideBBox,
  isElementLink3 as isElementLink,
  isInvisiblySmallElement4 as isInvisiblySmallElement,
  isLinearElement13 as isLinearElement,
  languages,
  loadFromBlob,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  mergeLibraryItems,
  mutateElement2 as mutateElement,
  newElementWith12 as newElementWith,
  normalizeLink4 as normalizeLink,
  parseLibraryTokensFromUrl,
  reconcileElements,
  restoreAppState,
  restoreElement,
  restoreElements,
  restoreLibraryItems,
  sceneCoordsToViewportCoords2 as sceneCoordsToViewportCoords,
  serializeAsJSON,
  serializeLibraryAsJSON,
  setCustomTextMetricsProvider,
  useEditorInterface,
  useHandleLibrary,
  useI18n,
  useStylesPanelMode,
  viewportCoordsToSceneCoords4 as viewportCoordsToSceneCoords,
  zoomToFitBounds
};
//# sourceMappingURL=index.js.map
