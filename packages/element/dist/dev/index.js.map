{
  "version": 3,
  "sources": ["<define:import.meta.env>", "../../../../node_modules/lodash.throttle/index.js", "../../src/index.ts", "../../src/sizeHelpers.ts", "../../src/bounds.ts", "../../../../node_modules/roughjs/bin/rough.js", "../../../../node_modules/roughjs/bin/canvas.js", "../../../../node_modules/roughjs/bin/generator.js", "../../../../node_modules/roughjs/bin/renderer.js", "../../../../node_modules/roughjs/bin/fillers/filler.js", "../../../../node_modules/roughjs/bin/fillers/hachure-filler.js", "../../../../node_modules/roughjs/bin/fillers/scan-line-hachure.js", "../../../../node_modules/hachure-fill/bin/hachure.js", "../../../../node_modules/roughjs/bin/fillers/zigzag-filler.js", "../../../../node_modules/roughjs/bin/geometry.js", "../../../../node_modules/roughjs/bin/fillers/hatch-filler.js", "../../../../node_modules/roughjs/bin/fillers/dot-filler.js", "../../../../node_modules/roughjs/bin/fillers/dashed-filler.js", "../../../../node_modules/roughjs/bin/fillers/zigzag-line-filler.js", "../../../../node_modules/roughjs/bin/math.js", "../../../../node_modules/path-data-parser/lib/index.js", "../../../../node_modules/path-data-parser/lib/parser.js", "../../../../node_modules/path-data-parser/lib/absolutize.js", "../../../../node_modules/path-data-parser/lib/normalize.js", "../../../../node_modules/points-on-curve/lib/curve-to-bezier.js", "../../../../node_modules/points-on-curve/lib/index.js", "../../../../node_modules/points-on-path/lib/index.js", "../../../../node_modules/roughjs/bin/svg.js", "../../../../node_modules/roughjs/bin/core.js", "../../../utils/src/shape.ts", "../../src/shape.ts", "../../../../node_modules/perfect-freehand/dist/esm/index.js", "../../src/renderElement.ts", "../../src/cropElement.ts", "../../src/linearElementEditor.ts", "../../src/binding.ts", "../../src/collision.ts", "../../src/utils.ts", "../../src/typeChecks.ts", "../../src/textElement.ts", "../../src/containerCache.ts", "../../src/textMeasurements.ts", "../../src/textWrapping.ts", "../../src/distance.ts", "../../src/heading.ts", "../../src/mutateElement.ts", "../../src/elbowArrow.ts", "../../src/frame.ts", "../../../utils/src/bbox.ts", "../../../utils/src/withinBounds.ts", "../../src/selection.ts", "../../src/groups.ts", "../../src/comparisons.ts", "../../src/align.ts", "../../src/delta.ts", "../../src/store.ts", "../../src/duplicate.ts", "../../src/sortElements.ts", "../../src/fractionalIndex.ts", "../../../../node_modules/fractional-indexing/src/index.js", "../../src/Scene.ts", "../../src/distribute.ts", "../../src/dragElements.ts", "../../src/elementLink.ts", "../../src/embeddable.ts", "../../src/newElement.ts", "../../src/flowchart.ts", "../../src/arrows/focus.ts", "../../src/zindex.ts", "../../src/image.ts", "../../src/positionElementsOnGrid.ts", "../../src/resizeElements.ts", "../../src/resizeTest.ts", "../../src/transformHandles.ts", "../../src/showSelectedShapeActions.ts", "../../src/transform.ts", "../../src/arrows/helpers.ts"],
  "sourcesContent": ["", "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n", "import { toIterable } from \"@excalidraw/common\";\n\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ElementsMapOrArray,\n} from \"./types\";\n\n/**\n * @deprecated unsafe, use hashElementsVersion instead\n */\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\n/**\n * Hashes elements' versionNonce (using djb2 algo). Order of elements matters.\n */\nexport const hashElementsVersion = (elements: ElementsMapOrArray): number => {\n  let hash = 5381;\n  for (const element of toIterable(elements)) {\n    hash = (hash << 5) + hash + element.versionNonce;\n  }\n  return hash >>> 0; // Ensure unsigned 32-bit integer\n};\n\n// string hash function (using djb2). Not cryptographically secure, use only\n// for versioning and such.\n// note: hashes individual code units (not code points),\n// but for hashing purposes this is fine as it iterates through every code unit\n// (as such, no need to encode to byte string first)\nexport const hashString = (s: string): number => {\n  let hash: number = 5381;\n  for (let i = 0; i < s.length; i++) {\n    const char: number = s.charCodeAt(i);\n    hash = (hash << 5) + hash + char;\n  }\n  return hash >>> 0; // Ensure unsigned 32-bit integer\n};\n\nexport const getVisibleElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (el) => !el.isDeleted && !isInvisiblySmallElement(el),\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const getNonDeletedElements = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n) =>\n  elements.filter((element) => !element.isDeleted) as readonly NonDeleted<T>[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nexport * from \"./align\";\nexport * from \"./binding\";\nexport * from \"./bounds\";\nexport * from \"./collision\";\nexport * from \"./comparisons\";\nexport * from \"./containerCache\";\nexport * from \"./cropElement\";\nexport * from \"./delta\";\nexport * from \"./distance\";\nexport * from \"./distribute\";\nexport * from \"./dragElements\";\nexport * from \"./duplicate\";\nexport * from \"./elbowArrow\";\nexport * from \"./elementLink\";\nexport * from \"./embeddable\";\nexport * from \"./flowchart\";\nexport * from \"./arrows/focus\";\nexport * from \"./fractionalIndex\";\nexport * from \"./frame\";\nexport * from \"./groups\";\nexport * from \"./heading\";\nexport * from \"./image\";\nexport * from \"./linearElementEditor\";\nexport * from \"./mutateElement\";\nexport * from \"./newElement\";\nexport * from \"./positionElementsOnGrid\";\nexport * from \"./renderElement\";\nexport * from \"./resizeElements\";\nexport * from \"./resizeTest\";\nexport * from \"./Scene\";\nexport * from \"./selection\";\nexport * from \"./shape\";\nexport * from \"./showSelectedShapeActions\";\nexport * from \"./sizeHelpers\";\nexport * from \"./sortElements\";\nexport * from \"./store\";\nexport * from \"./textElement\";\nexport * from \"./textMeasurements\";\nexport * from \"./textWrapping\";\nexport * from \"./transform\";\nexport * from \"./transformHandles\";\nexport * from \"./typeChecks\";\nexport * from \"./utils\";\nexport * from \"./zindex\";\nexport * from \"./arrows/helpers\";\n", "import {\n  SHIFT_LOCKING_ANGLE,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\nimport {\n  normalizeRadians,\n  radiansBetweenAngles,\n  radiansDifference,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { AppState, Offsets, Zoom } from \"@excalidraw/excalidraw/types\";\n\nimport { getCommonBounds, getElementBounds } from \"./bounds\";\nimport {\n  isArrowElement,\n  isFreeDrawElement,\n  isLinearElement,\n} from \"./typeChecks\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"./types\";\n\nexport const INVISIBLY_SMALL_ELEMENT_SIZE = 0.1;\n\n// TODO:  remove invisible elements consistently actions, so that invisible elements are not recorded by the store, exported, broadcasted or persisted\n//        - perhaps could be as part of a standalone 'cleanup' action, in addition to 'finalize'\n//        - could also be part of `_clearElements`\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return (\n      element.points.length < 2 ||\n      (element.points.length === 2 &&\n        isArrowElement(element) &&\n        pointsEqual(\n          element.points[0],\n          element.points[element.points.length - 1],\n          INVISIBLY_SMALL_ELEMENT_SIZE,\n        ))\n    );\n  }\n\n  return element.width === 0 && element.height === 0;\n};\n\nexport const isElementInViewport = (\n  element: ExcalidrawElement,\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width,\n      clientY: viewTransformations.offsetTop + height,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\nexport const isElementCompletelyInViewport = (\n  elements: ExcalidrawElement[],\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n  padding?: Offsets,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + (padding?.left || 0),\n      clientY: viewTransformations.offsetTop + (padding?.top || 0),\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width - (padding?.right || 0),\n      clientY: viewTransformations.offsetTop + height - (padding?.bottom || 0),\n    },\n    viewTransformations,\n  );\n\n  return (\n    x1 >= topLeftSceneCoords.x &&\n    y1 >= topLeftSceneCoords.y &&\n    x2 <= bottomRightSceneCoords.x &&\n    y2 <= bottomRightSceneCoords.y\n  );\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: AppState[\"activeTool\"][\"type\"],\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const getLockedLinearCursorAlignSize = (\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  customAngle?: number,\n) => {\n  let width = x - originX;\n  let height = y - originY;\n\n  const angle = Math.atan2(height, width) as Radians;\n  let lockedAngle = (Math.round(angle / SHIFT_LOCKING_ANGLE) *\n    SHIFT_LOCKING_ANGLE) as Radians;\n\n  if (customAngle) {\n    // If custom angle is provided, we check if the angle is close to the\n    // custom angle, snap to that if close engough, otherwise snap to the\n    // higher or lower angle depending on the current angle vs custom angle.\n    const lower = (Math.floor(customAngle / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE) as Radians;\n    if (\n      radiansBetweenAngles(\n        angle,\n        lower,\n        (lower + SHIFT_LOCKING_ANGLE) as Radians,\n      )\n    ) {\n      if (\n        radiansDifference(angle, customAngle as Radians) <\n        SHIFT_LOCKING_ANGLE / 6\n      ) {\n        lockedAngle = customAngle as Radians;\n      } else if (\n        normalizeRadians(angle) > normalizeRadians(customAngle as Radians)\n      ) {\n        lockedAngle = (lower + SHIFT_LOCKING_ANGLE) as Radians;\n      } else {\n        lockedAngle = lower;\n      }\n    }\n  }\n\n  if (lockedAngle === 0) {\n    height = 0;\n  } else if (lockedAngle === Math.PI / 2) {\n    width = 0;\n  } else {\n    // locked angle line, y = mx + b => mx - y + b = 0\n    const a1 = Math.tan(lockedAngle);\n    const b1 = -1;\n    const c1 = originY - a1 * originX;\n\n    // line through cursor, perpendicular to locked angle line\n    const a2 = -1 / a1;\n    const b2 = -1;\n    const c2 = y - a2 * x;\n\n    // intersection of the two lines above\n    const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n    // delta\n    width = intersectX - originX;\n    height = intersectY - originY;\n  }\n\n  return { width, height };\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n", "import rough from \"roughjs/bin/rough\";\n\nimport {\n  arrayToMap,\n  type Bounds,\n  invariant,\n  rescalePoints,\n  sizeOf,\n} from \"@excalidraw/common\";\n\nimport {\n  degreesToRadians,\n  lineSegment,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport type {\n  Curve,\n  Degrees,\n  GlobalPoint,\n  LineSegment,\n  LocalPoint,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { generateRoughOptions } from \"./shape\";\nimport { ShapeCache } from \"./shape\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isFreeDrawElement,\n  isLinearElement,\n  isLineElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { getElementShape } from \"./shape\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeleted,\n} from \"./types\";\n\nexport type RectangleBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\ntype MaybeQuadraticSolution = [number | null, number | null] | false;\n\nexport type SceneBounds = readonly [\n  sceneX: number,\n  sceneY: number,\n  sceneX2: number,\n  sceneY2: number,\n];\n\nexport class ElementBounds {\n  private static boundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n  private static nonRotatedBoundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n\n  static getBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n    nonRotated: boolean = false,\n  ) {\n    const cachedBounds =\n      nonRotated && element.angle !== 0\n        ? ElementBounds.nonRotatedBoundsCache.get(element)\n        : ElementBounds.boundsCache.get(element);\n\n    if (\n      cachedBounds?.version &&\n      cachedBounds.version === element.version &&\n      // we don't invalidate cache when we update containers and not labels,\n      // which is causing problems down the line. Fix TBA.\n      !isBoundToContainer(element)\n    ) {\n      return cachedBounds.bounds;\n    }\n\n    if (nonRotated && element.angle !== 0) {\n      const nonRotatedBounds = ElementBounds.calculateBounds(\n        {\n          ...element,\n          angle: 0 as Radians,\n        },\n        elementsMap,\n      );\n      ElementBounds.nonRotatedBoundsCache.set(element, {\n        version: element.version,\n        bounds: nonRotatedBounds,\n      });\n\n      return nonRotatedBounds;\n    }\n\n    const bounds = ElementBounds.calculateBounds(element, elementsMap);\n\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds,\n    });\n\n    return bounds;\n  }\n\n  private static calculateBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n  ): Bounds {\n    let bounds: Bounds;\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n        element.points.map(([x, y]) =>\n          pointRotateRads(\n            pointFrom(x, y),\n            pointFrom(cx - element.x, cy - element.y),\n            element.angle,\n          ),\n        ),\n      );\n\n      return [\n        minX + element.x,\n        minY + element.y,\n        maxX + element.x,\n        maxY + element.y,\n      ];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(cx, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(cx, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x1, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(x1, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(x1, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x2, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  includeBoundText: boolean = false,\n): [number, number, number, number, number, number] => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(\n      element,\n      elementsMap,\n      includeBoundText,\n    );\n  } else if (isTextElement(element)) {\n    const container = elementsMap\n      ? getContainerElement(element, elementsMap)\n      : null;\n    if (isArrowElement(container)) {\n      const { x, y } = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n        elementsMap,\n      );\n      return [\n        x,\n        y,\n        x + element.width,\n        y + element.height,\n        x + element.width / 2,\n        y + element.height / 2,\n      ];\n    }\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\n/*\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\n/**\n * Given an element, return the line segments that make up the element.\n *\n * Uses helpers from /math\n */\nexport const getElementLineSegments = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): LineSegment<GlobalPoint>[] => {\n  const shape = getElementShape(element, elementsMap);\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n  );\n  const center = pointFrom<GlobalPoint>(cx, cy);\n\n  if (shape.type === \"polycurve\") {\n    const curves = shape.data;\n    const pointsOnCurves = curves.map((curve) =>\n      pointsOnBezierCurves(curve, 10),\n    );\n\n    const segments: LineSegment<GlobalPoint>[] = [];\n\n    if (\n      (isLineElement(element) && !element.polygon) ||\n      isArrowElement(element)\n    ) {\n      for (const points of pointsOnCurves) {\n        let i = 0;\n\n        while (i < points.length - 1) {\n          segments.push(\n            lineSegment(\n              pointFrom(points[i][0], points[i][1]),\n              pointFrom(points[i + 1][0], points[i + 1][1]),\n            ),\n          );\n          i++;\n        }\n      }\n    } else {\n      const points = pointsOnCurves.flat();\n      let i = 0;\n\n      while (i < points.length - 1) {\n        segments.push(\n          lineSegment(\n            pointFrom(points[i][0], points[i][1]),\n            pointFrom(points[i + 1][0], points[i + 1][1]),\n          ),\n        );\n        i++;\n      }\n    }\n\n    return segments;\n  } else if (shape.type === \"polyline\") {\n    return shape.data as LineSegment<GlobalPoint>[];\n  } else if (_isRectanguloidElement(element)) {\n    const [sides, corners] = deconstructRectanguloidElement(element);\n    const cornerSegments: LineSegment<GlobalPoint>[] = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n    return [...rotatedSides, ...cornerSegments];\n  } else if (element.type === \"diamond\") {\n    const [sides, corners] = deconstructDiamondElement(element);\n    const cornerSegments = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n\n    return [...rotatedSides, ...cornerSegments];\n  } else if (shape.type === \"polygon\") {\n    if (isTextElement(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (container && isLinearElement(container)) {\n        const segments: LineSegment<GlobalPoint>[] = [\n          lineSegment(pointFrom(x1, y1), pointFrom(x2, y1)),\n          lineSegment(pointFrom(x2, y1), pointFrom(x2, y2)),\n          lineSegment(pointFrom(x2, y2), pointFrom(x1, y2)),\n          lineSegment(pointFrom(x1, y2), pointFrom(x1, y1)),\n        ];\n        return segments;\n      }\n    }\n\n    const points = shape.data as GlobalPoint[];\n    const segments: LineSegment<GlobalPoint>[] = [];\n    for (let i = 0; i < points.length - 1; i++) {\n      segments.push(lineSegment(points[i], points[i + 1]));\n    }\n    return segments;\n  } else if (shape.type === \"ellipse\") {\n    return getSegmentsOnEllipse(element as ExcalidrawEllipseElement);\n  }\n\n  const [nw, ne, sw, se, , , w, e] = (\n    [\n      [x1, y1],\n      [x2, y1],\n      [x1, y2],\n      [x2, y2],\n      [cx, y1],\n      [cx, y2],\n      [x1, cy],\n      [x2, cy],\n    ] as GlobalPoint[]\n  ).map((point) => pointRotateRads(point, center, element.angle));\n\n  return [\n    lineSegment(nw, ne),\n    lineSegment(sw, se),\n    lineSegment(nw, sw),\n    lineSegment(ne, se),\n    lineSegment(nw, e),\n    lineSegment(sw, e),\n    lineSegment(ne, w),\n    lineSegment(se, w),\n  ];\n};\n\nconst _isRectanguloidElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawRectanguloidElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nconst getRotatedSides = (\n  sides: LineSegment<GlobalPoint>[],\n  center: GlobalPoint,\n  angle: Radians,\n) => {\n  return sides.map((side) => {\n    return lineSegment(\n      pointRotateRads<GlobalPoint>(side[0], center, angle),\n      pointRotateRads<GlobalPoint>(side[1], center, angle),\n    );\n  });\n};\n\nconst getSegmentsOnCurve = (\n  curve: Curve<GlobalPoint>,\n  center: GlobalPoint,\n  angle: Radians,\n): LineSegment<GlobalPoint>[] => {\n  const points = pointsOnBezierCurves(curve, 10);\n  let i = 0;\n  const segments: LineSegment<GlobalPoint>[] = [];\n  while (i < points.length - 1) {\n    segments.push(\n      lineSegment(\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i][0], points[i][1]),\n          center,\n          angle,\n        ),\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i + 1][0], points[i + 1][1]),\n          center,\n          angle,\n        ),\n      ),\n    );\n    i++;\n  }\n\n  return segments;\n};\n\nconst getSegmentsOnEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n): LineSegment<GlobalPoint>[] => {\n  const center = pointFrom<GlobalPoint>(\n    ellipse.x + ellipse.width / 2,\n    ellipse.y + ellipse.height / 2,\n  );\n\n  const a = ellipse.width / 2;\n  const b = ellipse.height / 2;\n\n  const segments: LineSegment<GlobalPoint>[] = [];\n  const points: GlobalPoint[] = [];\n  const n = 90;\n  const deltaT = (Math.PI * 2) / n;\n\n  for (let i = 0; i < n; i++) {\n    const t = i * deltaT;\n    const x = center[0] + a * Math.cos(t);\n    const y = center[1] + b * Math.sin(t);\n    points.push(pointRotateRads(pointFrom(x, y), center, ellipse.angle));\n  }\n\n  for (let i = 0; i < points.length - 1; i++) {\n    segments.push(lineSegment(points[i], points[i + 1]));\n  }\n\n  segments.push(lineSegment(points[points.length - 1], points[0]));\n  return segments;\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = (boxSceneCoords: RectangleBox) => {\n  return [\n    boxSceneCoords.x,\n    boxSceneCoords.y,\n    boxSceneCoords.x + boxSceneCoords.width,\n    boxSceneCoords.y + boxSceneCoords.height,\n    boxSceneCoords.x + boxSceneCoords.width / 2,\n    boxSceneCoords.y + boxSceneCoords.height / 2,\n  ];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (\n  t: number,\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n) => {\n  const oneMinusT = 1 - t;\n  return (\n    Math.pow(oneMinusT, 3) * p0 +\n    3 * Math.pow(oneMinusT, 2) * t * p1 +\n    3 * oneMinusT * Math.pow(t, 2) * p2 +\n    Math.pow(t, 3) * p3\n  );\n};\n\nconst solveQuadratic = (\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n): MaybeQuadraticSolution => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n\n  if (!hasSolution) {\n    return false;\n  }\n\n  let s1 = null;\n  let s2 = null;\n\n  let t1 = Infinity;\n  let t2 = Infinity;\n\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n\n  return [s1, s2];\n};\n\nexport const getCubicBezierCurveBound = (\n  p0: GlobalPoint,\n  p1: GlobalPoint,\n  p2: GlobalPoint,\n  p3: GlobalPoint,\n): Bounds => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n\n  if (solX) {\n    const xs = solX.filter((x) => x !== null) as number[];\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter((y) => y !== null) as number[];\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (p: GlobalPoint) => GlobalPoint,\n): Bounds => {\n  let currentP: GlobalPoint = pointFrom(0, 0);\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        const p: GlobalPoint | undefined = pointFromArray(data);\n        invariant(p != null, \"Op data is not a point\");\n        currentP = p;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        const _p1 = pointFrom<GlobalPoint>(data[0], data[1]);\n        const _p2 = pointFrom<GlobalPoint>(data[2], data[3]);\n        const _p3 = pointFrom<GlobalPoint>(data[4], data[5]);\n\n        const p1 = transformXY ? transformXY(_p1) : _p1;\n        const p2 = transformXY ? transformXY(_p2) : _p2;\n        const p3 = transformXY ? transformXY(_p3) : _p3;\n\n        const p0 = transformXY ? transformXY(currentP) : currentP;\n        currentP = _p3;\n\n        const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(\n          p0,\n          p1,\n          p2,\n          p3,\n        );\n\n        limits.minX = Math.min(limits.minX, minX);\n        limits.minY = Math.min(limits.minY, minY);\n\n        limits.maxX = Math.max(limits.maxX, maxX);\n        limits.maxY = Math.max(limits.maxY, maxY);\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): Bounds => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\n/** @returns number in pixels */\nexport const getArrowheadSize = (arrowhead: Arrowhead): number => {\n  switch (arrowhead) {\n    case \"arrow\":\n      return 25;\n    case \"diamond\":\n    case \"diamond_outline\":\n      return 12;\n    case \"crowfoot_many\":\n    case \"crowfoot_one\":\n    case \"crowfoot_one_or_many\":\n      return 20;\n    default:\n      return 15;\n  }\n};\n\n/** @returns number in degrees */\nexport const getArrowheadAngle = (arrowhead: Arrowhead): Degrees => {\n  switch (arrowhead) {\n    case \"bar\":\n      return 90 as Degrees;\n    case \"arrow\":\n      return 20 as Degrees;\n    default:\n      return 25 as Degrees;\n  }\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  if (shape.length < 1) {\n    return null;\n  }\n\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n\n  invariant(data.length === 6, \"Op data length is not 6\");\n\n  const p3 = pointFrom(data[4], data[5]);\n  const p2 = pointFrom(data[2], data[3]);\n  const p1 = pointFrom(data[0], data[1]);\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0 = pointFrom(0, 0);\n  if (prevOp.op === \"move\") {\n    const p = pointFromArray(prevOp.data);\n    invariant(p != null, \"Op data is not a point\");\n    p0 = p;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = pointFrom(prevOp.data[4], prevOp.data[5]);\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = getArrowheadSize(arrowhead);\n\n  let length = 0;\n\n  {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] =\n      position === \"end\"\n        ? element.points[element.points.length - 1]\n        : element.points[0];\n    const [px, py] =\n      element.points.length > 1\n        ? position === \"end\"\n          ? element.points[element.points.length - 2]\n          : element.points[1]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const lengthMultiplier =\n    arrowhead === \"diamond\" || arrowhead === \"diamond_outline\" ? 0.25 : 0.5;\n  const minSize = Math.min(size, length * lengthMultiplier);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (\n    arrowhead === \"dot\" ||\n    arrowhead === \"circle\" ||\n    arrowhead === \"circle_outline\"\n  ) {\n    const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;\n    return [x2, y2, diameter];\n  }\n\n  const angle = getArrowheadAngle(arrowhead);\n\n  if (arrowhead === \"crowfoot_many\" || arrowhead === \"crowfoot_one_or_many\") {\n    // swap (xs, ys) with (x2, y2)\n    const [x3, y3] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(-angle as Degrees),\n    );\n    const [x4, y4] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(angle),\n    );\n    return [xs, ys, x3, y3, x4, y4];\n  }\n\n  // Return points\n  const [x3, y3] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    ((-angle * Math.PI) / 180) as Radians,\n  );\n  const [x4, y4] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    degreesToRadians(angle),\n  );\n\n  if (arrowhead === \"diamond\" || arrowhead === \"diamond_outline\") {\n    // point opposite to the arrowhead point\n    let ox;\n    let oy;\n\n    if (position === \"start\") {\n      const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 + minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(py - y2, px - x2) as Radians,\n      );\n    } else {\n      const [px, py] =\n        element.points.length > 1\n          ? element.points[element.points.length - 2]\n          : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 - minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(y2 - py, x2 - px) as Radians,\n      );\n    }\n\n    return [x2, y2, x3, y3, ox, oy, x4, y4];\n  }\n\n  return [x2, y2, x3, y3, x4, y4];\n};\n\n// TODO reuse shape.ts\nconst generateLinearElementShape = (\n  element: ExcalidrawLinearElement,\n): Drawable => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n\n  return generator[method](\n    element.points as Mutable<LocalPoint>[] as RoughPoint[],\n    options,\n  );\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n  elementsMap: ElementsMap,\n): Bounds => {\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = pointRotateRads(\n      pointFrom(element.x + pointX, element.y + pointY),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n\n    let coords: Bounds = [x, y, x, y];\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x, y, x, y],\n        boundTextElement,\n      );\n      coords = [\n        coordsWithBoundText[0],\n        coordsWithBoundText[1],\n        coordsWithBoundText[2],\n        coordsWithBoundText[3],\n      ];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = ShapeCache.get(element, null)?.[0];\n  const shape = cachedShape ?? generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = ([x, y]: GlobalPoint) =>\n    pointRotateRads<GlobalPoint>(\n      pointFrom(element.x + x, element.y + y),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords: Bounds = [res[0], res[1], res[2], res[3]];\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n      element,\n      elementsMap,\n      coords,\n      boundTextElement,\n    );\n    coords = [\n      coordsWithBoundText[0],\n      coordsWithBoundText[1],\n      coordsWithBoundText[2],\n      coordsWithBoundText[3],\n    ];\n  }\n  return coords;\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  nonRotated: boolean = false,\n): Bounds => {\n  return ElementBounds.getBounds(element, elementsMap, nonRotated);\n};\n\nexport const getCommonBounds = (\n  elements: ElementsMapOrArray,\n  elementsMap?: ElementsMap,\n): Bounds => {\n  if (!sizeOf(elements)) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  const _elementsMap = elementsMap || arrayToMap(elements);\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, _elementsMap);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getDraggedElementsBounds = (\n  elements: ExcalidrawElement[],\n  dragOffset: { x: number; y: number },\n) => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return [\n    minX + dragOffset.x,\n    minY + dragOffset.y,\n    maxX + dragOffset.x,\n    maxY + dragOffset.y,\n  ];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n  normalizePoints: boolean,\n): Bounds => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points, normalizePoints),\n    normalizePoints,\n  );\n\n  let bounds: Bounds;\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): Bounds => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    element.roundness == null\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n  const elementsMap = arrayToMap(elements);\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n    const distance = pointDistance(\n      pointFrom((x1 + x2) / 2, (y1 + y2) / 2),\n      pointFrom(from.x, from.y),\n    );\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement, elementsMap);\n};\n\nexport interface BoundingBox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport const getCommonBoundingBox = (\n  elements:\n    | readonly ExcalidrawElement[]\n    | readonly NonDeleted<ExcalidrawElement>[],\n): BoundingBox => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n\n/**\n * returns scene coords of user's editor viewport (visible canvas area) bounds\n */\nexport const getVisibleSceneBounds = ({\n  scrollX,\n  scrollY,\n  width,\n  height,\n  zoom,\n}: AppState): SceneBounds => {\n  return [\n    -scrollX,\n    -scrollY,\n    -scrollX + width / zoom.value,\n    -scrollY + height / zoom.value,\n  ];\n};\n\nexport const getCenterForBounds = (bounds: Bounds): GlobalPoint =>\n  pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n\n/**\n * Get the axis-aligned bounding box for a given element\n */\nexport const aabbForElement = (\n  element: Readonly<ExcalidrawElement>,\n  elementsMap: ElementsMap,\n  offset?: [number, number, number, number],\n) => {\n  const bbox = {\n    minX: element.x,\n    minY: element.y,\n    maxX: element.x + element.width,\n    maxY: element.y + element.height,\n    midX: element.x + element.width / 2,\n    midY: element.y + element.height / 2,\n  };\n\n  const center = elementCenterPoint(element, elementsMap);\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [topRightX, topRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [bottomRightX, bottomRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.maxY),\n    center,\n    element.angle,\n  );\n  const [bottomLeftX, bottomLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.maxY),\n    center,\n    element.angle,\n  );\n\n  const bounds = [\n    Math.min(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.min(topLeftY, topRightY, bottomRightY, bottomLeftY),\n    Math.max(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.max(topLeftY, topRightY, bottomRightY, bottomLeftY),\n  ] as Bounds;\n\n  if (offset) {\n    const [topOffset, rightOffset, downOffset, leftOffset] = offset;\n    return [\n      bounds[0] - leftOffset,\n      bounds[1] - topOffset,\n      bounds[2] + rightOffset,\n      bounds[3] + downOffset,\n    ] as Bounds;\n  }\n\n  return bounds;\n};\n\nexport const pointInsideBounds = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  bounds: Bounds,\n): boolean =>\n  p[0] > bounds[0] && p[0] < bounds[2] && p[1] > bounds[1] && p[1] < bounds[3];\n\nexport const doBoundsIntersect = (\n  bounds1: Bounds | null,\n  bounds2: Bounds | null,\n): boolean => {\n  if (bounds1 == null || bounds2 == null) {\n    return false;\n  }\n\n  const [minX1, minY1, maxX1, maxY1] = bounds1;\n  const [minX2, minY2, maxX2, maxY2] = bounds2;\n\n  return minX1 < maxX2 && maxX1 > minX2 && minY1 < maxY2 && maxY1 > minY2;\n};\n\nexport const elementCenterPoint = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  xOffset: number = 0,\n  yOffset: number = 0,\n) => {\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const [x, y] = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n\n    return pointFrom<GlobalPoint>(x + xOffset, y + yOffset);\n  }\n\n  const [x, y] = getCenterForBounds(getElementBounds(element, elementsMap));\n\n  return pointFrom<GlobalPoint>(x + xOffset, y + yOffset);\n};\n", "import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughSVG } from './svg';\nexport default {\n    canvas(canvas, config) {\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new RoughGenerator(config);\n    },\n    newSeed() {\n        return RoughGenerator.newSeed();\n    },\n};\n", "import { RoughGenerator } from './generator';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n", "import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = curve(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const bcurve = curveToBezier(points);\n                const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        const shape = svgPath(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = svgPath(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push(solidFillPolygon(sets, o));\n                }\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n", "import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n", "import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nimport { DashedFiller } from './dashed-filler';\nimport { ZigZagLineFiller } from './zigzag-line-filler';\nconst fillers = {};\nexport function getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n", "import { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n", "import { hachureLines } from 'hachure-fill';\nexport function polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.max(gap, 0.1);\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return hachureLines(polygonList, gap, angle, skipOffset || 1);\n}\n", "function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nexport function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n", "import { HachureFiller } from './hachure-filler';\nimport { polygonHachureLines } from './scan-line-hachure';\nimport { lineLength } from '../geometry';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = polygonHachureLines(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if (lineLength([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n", "export function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n", "import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = polygonHachureLines(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n", "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n", "export function randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nexport class Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n", "export { parsePath, serialize } from './parser.js';\nexport { absolutize } from './absolutize.js';\nexport { normalize } from './normalize.js';\n", "const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n", "// Translate relative commands to absolute commands\nexport function absolutize(segments) {\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    const out = [];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'm':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'M', data: [cx, cy] });\n                subx = cx;\n                suby = cy;\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'l':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                break;\n            case 'c': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'C', data: newdata });\n                cx = newdata[4];\n                cy = newdata[5];\n                break;\n            }\n            case 'Q':\n                out.push({ key: 'Q', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 'q': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'Q', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'A':\n                out.push({ key: 'A', data: [...data] });\n                cx = data[5];\n                cy = data[6];\n                break;\n            case 'a':\n                cx += data[5];\n                cy += data[6];\n                out.push({ key: 'A', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\n                break;\n            case 'H':\n                out.push({ key: 'H', data: [...data] });\n                cx = data[0];\n                break;\n            case 'h':\n                cx += data[0];\n                out.push({ key: 'H', data: [cx] });\n                break;\n            case 'V':\n                out.push({ key: 'V', data: [...data] });\n                cy = data[0];\n                break;\n            case 'v':\n                cy += data[0];\n                out.push({ key: 'V', data: [cy] });\n                break;\n            case 'S':\n                out.push({ key: 'S', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 's': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'S', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'T':\n                out.push({ key: 'T', data: [...data] });\n                cx = data[0];\n                cy = data[1];\n                break;\n            case 't':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'T', data: [cx, cy] });\n                break;\n            case 'Z':\n            case 'z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n    }\n    return out;\n}\n", "// Normalize path to include only M, L, C, and Z commands\nexport function normalize(segments) {\n    const out = [];\n    let lastType = '';\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    let lcx = 0, lcy = 0;\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                lcx = data[2];\n                lcy = data[3];\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'H':\n                cx = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'V':\n                cy = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'S': {\n                let cx1 = 0, cy1 = 0;\n                if (lastType === 'C' || lastType === 'S') {\n                    cx1 = cx + (cx - lcx);\n                    cy1 = cy + (cy - lcy);\n                }\n                else {\n                    cx1 = cx;\n                    cy1 = cy;\n                }\n                out.push({ key: 'C', data: [cx1, cy1, ...data] });\n                lcx = data[0];\n                lcy = data[1];\n                cx = data[2];\n                cy = data[3];\n                break;\n            }\n            case 'T': {\n                const [x, y] = data;\n                let x1 = 0, y1 = 0;\n                if (lastType === 'Q' || lastType === 'T') {\n                    x1 = cx + (cx - lcx);\n                    y1 = cy + (cy - lcy);\n                }\n                else {\n                    x1 = cx;\n                    y1 = cy;\n                }\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'Q': {\n                const [x1, y1, x, y] = data;\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'A': {\n                const r1 = Math.abs(data[0]);\n                const r2 = Math.abs(data[1]);\n                const angle = data[2];\n                const largeArcFlag = data[3];\n                const sweepFlag = data[4];\n                const x = data[5];\n                const y = data[6];\n                if (r1 === 0 || r2 === 0) {\n                    out.push({ key: 'C', data: [cx, cy, x, y, x, y] });\n                    cx = x;\n                    cy = y;\n                }\n                else {\n                    if (cx !== x || cy !== y) {\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n                        curves.forEach(function (curve) {\n                            out.push({ key: 'C', data: curve });\n                        });\n                        cx = x;\n                        cy = y;\n                    }\n                }\n                break;\n            }\n            case 'Z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n        lastType = key;\n    }\n    return out;\n}\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return [X, Y];\n}\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\n    const angleRad = degToRad(angle);\n    let params = [];\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\n    if (recursive) {\n        [f1, f2, cx, cy] = recursive;\n    }\n    else {\n        [x1, y1] = rotate(x1, y1, -angleRad);\n        [x2, y2] = rotate(x2, y2, -angleRad);\n        const x = (x1 - x2) / 2;\n        const y = (y1 - y2) / 2;\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            r1 = h * r1;\n            r2 = h * r2;\n        }\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\n        const r1Pow = r1 * r1;\n        const r2Pow = r2 * r2;\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n        const right = r1Pow * y * y + r2Pow * x * x;\n        const k = sign * Math.sqrt(Math.abs(left / right));\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n        if (x1 < cx) {\n            f1 = Math.PI - f1;\n        }\n        if (x2 < cx) {\n            f2 = Math.PI - f2;\n        }\n        if (f1 < 0) {\n            f1 = Math.PI * 2 + f1;\n        }\n        if (f2 < 0) {\n            f2 = Math.PI * 2 + f2;\n        }\n        if (sweepFlag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweepFlag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    let df = f2 - f1;\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\n        const f2old = f2;\n        const x2old = x2;\n        const y2old = y2;\n        if (sweepFlag && f2 > f1) {\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\n        }\n        else {\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\n        }\n        x2 = cx + r1 * Math.cos(f2);\n        y2 = cy + r2 * Math.sin(f2);\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    const c1 = Math.cos(f1);\n    const s1 = Math.sin(f1);\n    const c2 = Math.cos(f2);\n    const s2 = Math.sin(f2);\n    const t = Math.tan(df / 4);\n    const hx = 4 / 3 * r1 * t;\n    const hy = 4 / 3 * r2 * t;\n    const m1 = [x1, y1];\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\n    const m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(params);\n    }\n    else {\n        params = [m2, m3, m4].concat(params);\n        const curves = [];\n        for (let i = 0; i < params.length; i += 3) {\n            const r1 = rotate(params[i][0], params[i][1], angleRad);\n            const r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n            const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\n        }\n        return curves;\n    }\n}\n", "function clone(p) {\n    return [...p];\n}\nexport function curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n", "// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer\u2013Douglas\u2013Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n", "import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n", "import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nexport class RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n", "export const SVGNS = 'http://www.w3.org/2000/svg';\n", "/**\n * this file defines pure geometric shapes\n *\n * for instance, a cubic bezier curve is specified by its four control points and\n * an ellipse is defined by its center, angle, semi major axis and semi minor axis\n * (but in semi-width and semi-height so it's more relevant to Excalidraw)\n *\n * the idea with pure shapes is so that we can provide collision and other geoemtric methods not depending on\n * the specifics of roughjs or elements in Excalidraw; instead, we can focus on the pure shapes themselves\n *\n * also included in this file are methods for converting an Excalidraw element or a Drawable from roughjs\n * to pure shapes\n */\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport { invariant } from \"@excalidraw/common\";\nimport {\n  curve,\n  lineSegment,\n  pointFrom,\n  pointDistance,\n  pointFromArray,\n  pointFromVector,\n  pointRotateRads,\n  polygon,\n  polygonFromPoints,\n  PRECISION,\n  segmentsIntersectAt,\n  vector,\n  vectorAdd,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawBindableElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawIframeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\nimport type { Curve, LineSegment, Polygon, Radians } from \"@excalidraw/math\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\n\n// a polyline (made up term here) is a line consisting of other line segments\n// this corresponds to a straight line element in the editor but it could also\n// be used to model other elements\nexport type Polyline<Point extends GlobalPoint | LocalPoint> =\n  LineSegment<Point>[];\n\n// a polycurve is a curve consisting of ther curves, this corresponds to a complex\n// curve on the canvas\nexport type Polycurve<Point extends GlobalPoint | LocalPoint> = Curve<Point>[];\n\n// an ellipse is specified by its center, angle, and its major and minor axes\n// but for the sake of simplicity, we've used halfWidth and halfHeight instead\n// in replace of semi major and semi minor axes\nexport type Ellipse<Point extends GlobalPoint | LocalPoint> = {\n  center: Point;\n  angle: Radians;\n  halfWidth: number;\n  halfHeight: number;\n};\n\nexport type GeometricShape<Point extends GlobalPoint | LocalPoint> =\n  | {\n      type: \"line\";\n      data: LineSegment<Point>;\n    }\n  | {\n      type: \"polygon\";\n      data: Polygon<Point>;\n    }\n  | {\n      type: \"curve\";\n      data: Curve<Point>;\n    }\n  | {\n      type: \"ellipse\";\n      data: Ellipse<Point>;\n    }\n  | {\n      type: \"polyline\";\n      data: Polyline<Point>;\n    }\n  | {\n      type: \"polycurve\";\n      data: Polycurve<Point>;\n    };\n\ntype RectangularElement =\n  | ExcalidrawRectangleElement\n  | ExcalidrawDiamondElement\n  | ExcalidrawFrameLikeElement\n  | ExcalidrawEmbeddableElement\n  | ExcalidrawImageElement\n  | ExcalidrawIframeElement\n  | ExcalidrawTextElement\n  | ExcalidrawSelectionElement;\n\n// polygon\nexport const getPolygonShape = <Point extends GlobalPoint | LocalPoint>(\n  element: RectangularElement,\n): GeometricShape<Point> => {\n  const { angle, width, height, x, y } = element;\n\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n\n  const center: Point = pointFrom(cx, cy);\n\n  let data: Polygon<Point>;\n\n  if (element.type === \"diamond\") {\n    data = polygon(\n      pointRotateRads(pointFrom(cx, y), center, angle),\n      pointRotateRads(pointFrom(x + width, cy), center, angle),\n      pointRotateRads(pointFrom(cx, y + height), center, angle),\n      pointRotateRads(pointFrom(x, cy), center, angle),\n    );\n  } else {\n    data = polygon(\n      pointRotateRads(pointFrom(x, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y + height), center, angle),\n      pointRotateRads(pointFrom(x, y + height), center, angle),\n    );\n  }\n\n  return {\n    type: \"polygon\",\n    data,\n  };\n};\n\n// return the selection box for an element, possibly rotated as well\nexport const getSelectionBoxShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  padding = 10,\n) => {\n  let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n    true,\n  );\n\n  x1 -= padding;\n  x2 += padding;\n  y1 -= padding;\n  y2 += padding;\n\n  //const angleInDegrees = angleToDegrees(element.angle);\n  const center = pointFrom(cx, cy);\n  const topLeft = pointRotateRads(pointFrom(x1, y1), center, element.angle);\n  const topRight = pointRotateRads(pointFrom(x2, y1), center, element.angle);\n  const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, element.angle);\n  const bottomRight = pointRotateRads(pointFrom(x2, y2), center, element.angle);\n\n  return {\n    type: \"polygon\",\n    data: [topLeft, topRight, bottomRight, bottomLeft],\n  } as GeometricShape<Point>;\n};\n\n// ellipse\nexport const getEllipseShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawEllipseElement,\n): GeometricShape<Point> => {\n  const { width, height, angle, x, y } = element;\n\n  return {\n    type: \"ellipse\",\n    data: {\n      center: pointFrom(x + width / 2, y + height / 2),\n      angle,\n      halfWidth: width / 2,\n      halfHeight: height / 2,\n    },\n  };\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  // NOTE (mtolmacs): Temporary fix for extremely large elements\n  if (!shape) {\n    return [];\n  }\n\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// linear\nexport const getCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point): Point =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  const ops = getCurvePathOps(roughShape);\n  const polycurve: Polycurve<Point> = [];\n  let p0 = pointFrom<Point>(0, 0);\n\n  for (const op of ops) {\n    if (op.op === \"move\") {\n      const p = pointFromArray<Point>(op.data);\n      invariant(p != null, \"Ops data is not a point\");\n      p0 = transform(p);\n    }\n    if (op.op === \"bcurveTo\") {\n      const p1 = transform(pointFrom<Point>(op.data[0], op.data[1]));\n      const p2 = transform(pointFrom<Point>(op.data[2], op.data[3]));\n      const p3 = transform(pointFrom<Point>(op.data[4], op.data[5]));\n      polycurve.push(curve<Point>(p0, p1, p2, p3));\n      p0 = p3;\n    }\n  }\n\n  return {\n    type: \"polycurve\",\n    data: polycurve,\n  };\n};\n\nconst polylineFromPoints = <Point extends GlobalPoint | LocalPoint>(\n  points: Point[],\n): Polyline<Point> => {\n  let previousPoint: Point = points[0];\n  const polyline: LineSegment<Point>[] = [];\n\n  for (let i = 1; i < points.length; i++) {\n    const nextPoint = points[i];\n    polyline.push(lineSegment<Point>(previousPoint, nextPoint));\n    previousPoint = nextPoint;\n  }\n\n  return polyline;\n};\n\nexport const getFreedrawShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawFreeDrawElement,\n  center: Point,\n  isClosed: boolean = false,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFromVector(\n        vectorAdd(vectorFromPoint(p), vector(element.x, element.y)),\n      ),\n      center,\n      element.angle,\n    );\n\n  const polyline = polylineFromPoints(\n    element.points.map((p) => transform(p as Point)),\n  );\n\n  return (\n    isClosed\n      ? {\n          type: \"polygon\",\n          data: polygonFromPoints(polyline.flat()),\n        }\n      : {\n          type: \"polyline\",\n          data: polyline,\n        }\n  ) as GeometricShape<Point>;\n};\n\nexport const getClosedCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawLinearElement,\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom<Point>(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  if (element.roundness === null) {\n    return {\n      type: \"polygon\",\n      data: polygonFromPoints(\n        element.points.map((p) => transform(p as Point)) as Point[],\n      ),\n    };\n  }\n\n  const ops = getCurvePathOps(roughShape);\n\n  const points: Point[] = [];\n  let odd = false;\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n        points.push(pointFrom(operation.data[2], operation.data[3]));\n        points.push(pointFrom(operation.data[4], operation.data[5]));\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    }\n  }\n\n  const polygonPoints = pointsOnBezierCurves(points, 10, 5).map((p) =>\n    transform(p as Point),\n  ) as Point[];\n\n  return {\n    type: \"polygon\",\n    data: polygonFromPoints<Point>(polygonPoints),\n  };\n};\n\n/**\n * Determine intersection of a rectangular shaped element and a\n * line segment.\n *\n * @param element The rectangular element to test against\n * @param segment The segment intersecting the element\n * @param gap Optional value to inflate the shape before testing\n * @returns An array of intersections\n */\n// TODO: Replace with final rounded rectangle code\nexport const segmentIntersectRectangleElement = <\n  Point extends LocalPoint | GlobalPoint,\n>(\n  element: ExcalidrawBindableElement,\n  segment: LineSegment<Point>,\n  gap: number = 0,\n): Point[] => {\n  const bounds = [\n    element.x - gap,\n    element.y - gap,\n    element.x + element.width + gap,\n    element.y + element.height + gap,\n  ];\n  const center = pointFrom(\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n  );\n\n  return [\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n    ),\n  ]\n    .map((s) => segmentsIntersectAt(segment, s))\n    .filter((i): i is Point => !!i);\n};\n\nconst distanceToEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { angle, halfWidth, halfHeight, center } = ellipse;\n  const a = halfWidth;\n  const b = halfHeight;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  const px = Math.abs(rotatedPointX);\n  const py = Math.abs(rotatedPointY);\n\n  let tx = 0.707;\n  let ty = 0.707;\n\n  for (let i = 0; i < 3; i++) {\n    const x = a * tx;\n    const y = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = x - ex;\n    const ry = y - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  }\n\n  const [minX, minY] = [\n    a * tx * Math.sign(rotatedPointX),\n    b * ty * Math.sign(rotatedPointY),\n  ];\n\n  return pointDistance(\n    pointFrom(rotatedPointX, rotatedPointY),\n    pointFrom(minX, minY),\n  );\n};\n\nexport const pointOnEllipse = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  ellipse: Ellipse<Point>,\n  threshold = PRECISION,\n) => {\n  return distanceToEllipse(point, ellipse) <= threshold;\n};\n\nexport const pointInEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle, halfWidth, halfHeight } = ellipse;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  return (\n    (rotatedPointX / halfWidth) * (rotatedPointX / halfWidth) +\n      (rotatedPointY / halfHeight) * (rotatedPointY / halfHeight) <=\n    1\n  );\n};\n\nexport const ellipseAxes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const widthGreaterThanHeight = ellipse.halfWidth > ellipse.halfHeight;\n\n  const majorAxis = widthGreaterThanHeight\n    ? ellipse.halfWidth * 2\n    : ellipse.halfHeight * 2;\n  const minorAxis = widthGreaterThanHeight\n    ? ellipse.halfHeight * 2\n    : ellipse.halfWidth * 2;\n\n  return {\n    majorAxis,\n    minorAxis,\n  };\n};\n\nexport const ellipseFocusToCenter = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  return Math.sqrt(majorAxis ** 2 - minorAxis ** 2);\n};\n\nexport const ellipseExtremes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle } = ellipse;\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n\n  const sqSum = majorAxis ** 2 + minorAxis ** 2;\n  const sqDiff = (majorAxis ** 2 - minorAxis ** 2) * Math.cos(2 * angle);\n\n  const yMax = Math.sqrt((sqSum - sqDiff) / 2);\n  const xAtYMax =\n    (yMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * sin ** 2 + minorAxis ** 2 * cos ** 2);\n\n  const xMax = Math.sqrt((sqSum + sqDiff) / 2);\n  const yAtXMax =\n    (xMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * cos ** 2 + minorAxis ** 2 * sin ** 2);\n  const centerVector = vectorFromPoint(center);\n\n  return [\n    vectorAdd(vector(xAtYMax, yMax), centerVector),\n    vectorAdd(vectorScale(vector(xAtYMax, yMax), -1), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n  ];\n};\n", "import { simplify } from \"points-on-curve\";\nimport { getStroke } from \"perfect-freehand\";\n\nimport {\n  type GeometricShape,\n  getClosedCurveShape,\n  getCurveShape,\n  getEllipseShape,\n  getFreedrawShape,\n  getPolygonShape,\n} from \"@excalidraw/utils/shape\";\n\nimport {\n  pointFrom,\n  pointDistance,\n  type LocalPoint,\n  pointRotateRads,\n} from \"@excalidraw/math\";\nimport {\n  ROUGHNESS,\n  THEME,\n  isTransparent,\n  assertNever,\n  COLOR_PALETTE,\n  LINE_POLYGON_POINT_MERGE_DISTANCE,\n  applyDarkModeFilter,\n} from \"@excalidraw/common\";\n\nimport { RoughGenerator } from \"roughjs/bin/generator\";\n\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type {\n  AppState,\n  EmbedsValidationStatus,\n} from \"@excalidraw/excalidraw/types\";\nimport type {\n  ElementShape,\n  ElementShapes,\n  SVGPathString,\n} from \"@excalidraw/excalidraw/scene/types\";\n\nimport { elementWithCanvasCache } from \"./renderElement\";\n\nimport {\n  canBecomePolygon,\n  isElbowArrow,\n  isEmbeddableElement,\n  isIframeElement,\n  isIframeLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport { getCornerRadius, isPathALoop } from \"./utils\";\nimport { headingForPointIsHorizontal } from \"./heading\";\n\nimport { canChangeRoundness } from \"./comparisons\";\nimport {\n  getArrowheadPoints,\n  getCenterForBounds,\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { shouldTestInside } from \"./collision\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  ElementsMap,\n  ExcalidrawLineElement,\n} from \"./types\";\n\nimport type { Drawable, Options } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\n\nexport class ShapeCache {\n  private static rg = new RoughGenerator();\n  private static cache = new WeakMap<\n    ExcalidrawElement,\n    { shape: ElementShape; theme: AppState[\"theme\"] }\n  >();\n\n  /**\n   * Retrieves shape from cache if available. Use this only if shape\n   * is optional and you have a fallback in case it's not cached.\n   */\n  public static get = <T extends ExcalidrawElement>(\n    element: T,\n    theme: AppState[\"theme\"] | null,\n  ) => {\n    const cached = ShapeCache.cache.get(element);\n    if (cached && (theme === null || cached.theme === theme)) {\n      return cached.shape as T[\"type\"] extends keyof ElementShapes\n        ? ElementShapes[T[\"type\"]] | undefined\n        : ElementShape | undefined;\n    }\n    return undefined;\n  };\n\n  public static delete = (element: ExcalidrawElement) => {\n    ShapeCache.cache.delete(element);\n    elementWithCanvasCache.delete(element);\n  };\n\n  public static destroy = () => {\n    ShapeCache.cache = new WeakMap();\n  };\n\n  /**\n   * Generates & caches shape for element if not already cached, otherwise\n   * returns cached shape.\n   */\n  public static generateElementShape = <\n    T extends Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n  >(\n    element: T,\n    renderConfig: {\n      isExporting: boolean;\n      canvasBackgroundColor: AppState[\"viewBackgroundColor\"];\n      embedsValidationStatus: EmbedsValidationStatus;\n      theme: AppState[\"theme\"];\n    } | null,\n  ) => {\n    // when exporting, always regenerated to guarantee the latest shape\n    const cachedShape = renderConfig?.isExporting\n      ? undefined\n      : ShapeCache.get(element, renderConfig ? renderConfig.theme : null);\n\n    // `null` indicates no rc shape applicable for this element type,\n    // but it's considered a valid cache value (= do not regenerate)\n    if (cachedShape !== undefined) {\n      return cachedShape;\n    }\n\n    elementWithCanvasCache.delete(element);\n\n    const shape = _generateElementShape(\n      element,\n      ShapeCache.rg,\n      renderConfig || {\n        isExporting: false,\n        canvasBackgroundColor: COLOR_PALETTE.white,\n        embedsValidationStatus: null,\n        theme: THEME.LIGHT,\n      },\n    ) as T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]]\n      : Drawable | null;\n\n    if (!renderConfig?.isExporting) {\n      ShapeCache.cache.set(element, {\n        shape,\n        theme: renderConfig?.theme || THEME.LIGHT,\n      });\n    }\n\n    return shape;\n  };\n}\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nfunction adjustRoughness(element: ExcalidrawElement): number {\n  const roughness = element.roughness;\n\n  const maxSize = Math.max(element.width, element.height);\n  const minSize = Math.min(element.width, element.height);\n\n  // don't reduce roughness if\n  if (\n    // both sides relatively big\n    (minSize >= 20 && maxSize >= 50) ||\n    // is round & both sides above 15px\n    (minSize >= 15 &&\n      !!element.roundness &&\n      canChangeRoundness(element.type)) ||\n    // relatively long linear element\n    (isLinearElement(element) && maxSize >= 50)\n  ) {\n    return roughness;\n  }\n\n  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);\n}\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n  isDarkMode: boolean = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: adjustRoughness(element),\n    stroke: isDarkMode\n      ? applyDarkModeFilter(element.strokeColor)\n      : element.strokeColor,\n    preserveVertices:\n      continuousPath || element.roughness < ROUGHNESS.cartoonist,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill = isTransparent(element.backgroundColor)\n        ? undefined\n        : isDarkMode\n        ? applyDarkModeFilter(element.backgroundColor)\n        : element.backgroundColor;\n      // Sticky note: no border (only when explicitly marked)\n      if (\n        element.type === \"rectangle\" &&\n        element.customData?.isStickyNote === true\n      ) {\n        options.stroke = \"none\";\n      }\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"freedraw\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : isDarkMode\n            ? applyDarkModeFilter(element.backgroundColor)\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst modifyIframeLikeForRoughOptions = (\n  element: NonDeletedExcalidrawElement,\n  isExporting: boolean,\n  embedsValidationStatus: EmbedsValidationStatus | null,\n) => {\n  if (\n    isIframeLikeElement(element) &&\n    (isExporting ||\n      (isEmbeddableElement(element) &&\n        embedsValidationStatus?.get(element.id) !== true)) &&\n    isTransparent(element.backgroundColor) &&\n    isTransparent(element.strokeColor)\n  ) {\n    return {\n      ...element,\n      roughness: 0,\n      backgroundColor: \"#d3d3d3\",\n      fillStyle: \"solid\",\n    } as const;\n  } else if (isIframeElement(element)) {\n    return {\n      ...element,\n      strokeColor: isTransparent(element.strokeColor)\n        ? \"#000000\"\n        : element.strokeColor,\n      backgroundColor: isTransparent(element.backgroundColor)\n        ? \"#f4f4f6\"\n        : element.backgroundColor,\n    };\n  }\n  return element;\n};\n\nconst getArrowheadShapes = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n  generator: RoughGenerator,\n  options: Options,\n  canvasBackgroundColor: string,\n  isDarkMode: boolean,\n) => {\n  const arrowheadPoints = getArrowheadPoints(\n    element,\n    shape,\n    position,\n    arrowhead,\n  );\n\n  if (arrowheadPoints === null) {\n    return [];\n  }\n\n  const generateCrowfootOne = (\n    arrowheadPoints: number[] | null,\n    options: Options,\n  ) => {\n    if (arrowheadPoints === null) {\n      return [];\n    }\n\n    const [, , x3, y3, x4, y4] = arrowheadPoints;\n\n    return [generator.line(x3, y3, x4, y4, options)];\n  };\n\n  const strokeColor = isDarkMode\n    ? applyDarkModeFilter(element.strokeColor)\n    : element.strokeColor;\n\n  switch (arrowhead) {\n    case \"dot\":\n    case \"circle\":\n    case \"circle_outline\": {\n      const [x, y, diameter] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.circle(x, y, diameter, {\n          ...options,\n          fill:\n            arrowhead === \"circle_outline\"\n              ? canvasBackgroundColor\n              : strokeColor,\n\n          fillStyle: \"solid\",\n          stroke: strokeColor,\n          roughness: Math.min(0.5, options.roughness || 0),\n        }),\n      ];\n    }\n    case \"triangle\":\n    case \"triangle_outline\": {\n      const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"triangle_outline\"\n                ? canvasBackgroundColor\n                : strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"diamond\":\n    case \"diamond_outline\": {\n      const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x4, y4],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"diamond_outline\"\n                ? canvasBackgroundColor\n                : strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"crowfoot_one\":\n      return generateCrowfootOne(arrowheadPoints, options);\n    case \"bar\":\n    case \"arrow\":\n    case \"crowfoot_many\":\n    case \"crowfoot_one_or_many\":\n    default: {\n      const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      if (element.strokeStyle === \"dotted\") {\n        // for dotted arrows caps, reduce gap to make it more legible\n        const dash = getDashArrayDotted(element.strokeWidth - 1);\n        options.strokeLineDash = [dash[0], dash[1] - 1];\n      } else {\n        // for solid/dashed, keep solid arrow cap\n        delete options.strokeLineDash;\n      }\n      options.roughness = Math.min(1, options.roughness || 0);\n      return [\n        generator.line(x3, y3, x2, y2, options),\n        generator.line(x4, y4, x2, y2, options),\n        ...(arrowhead === \"crowfoot_one_or_many\"\n          ? generateCrowfootOne(\n              getArrowheadPoints(element, shape, position, \"crowfoot_one\"),\n              options,\n            )\n          : []),\n      ];\n    }\n  }\n};\n\nexport const generateLinearCollisionShape = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n) => {\n  const generator = new RoughGenerator();\n  const options: Options = {\n    seed: element.seed,\n    disableMultiStroke: true,\n    disableMultiStrokeFill: true,\n    roughness: 0,\n    preserveVertices: true,\n  };\n  const center = getCenterForBounds(\n    // Need a non-rotated center point\n    element.points.reduce(\n      (acc, point) => {\n        return [\n          Math.min(element.x + point[0], acc[0]),\n          Math.min(element.y + point[1], acc[1]),\n          Math.max(element.x + point[0], acc[2]),\n          Math.max(element.y + point[1], acc[3]),\n        ];\n      },\n      [Infinity, Infinity, -Infinity, -Infinity],\n    ),\n  );\n\n  switch (element.type) {\n    case \"line\":\n    case \"arrow\": {\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        return generator.path(generateElbowArrowShape(points, 16), options)\n          .sets[0].ops;\n      } else if (!element.roundness) {\n        return points.map((point, idx) => {\n          const p = pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + point[0], element.y + point[1]),\n            center,\n            element.angle,\n          );\n\n          return {\n            op: idx === 0 ? \"move\" : \"lineTo\",\n            data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n          };\n        });\n      }\n\n      return generator\n        .curve(points as unknown as RoughPoint[], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n    case \"freedraw\": {\n      if (element.points.length < 2) {\n        return [];\n      }\n\n      const simplifiedPoints = simplify(\n        element.points as Mutable<LocalPoint[]>,\n        0.75,\n      );\n\n      return generator\n        .curve(simplifiedPoints as [number, number][], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n  }\n};\n\n/**\n * Generates the roughjs shape for given element.\n *\n * Low-level. Use `ShapeCache.generateElementShape` instead.\n *\n * @private\n */\nconst _generateElementShape = (\n  element: Exclude<NonDeletedExcalidrawElement, ExcalidrawSelectionElement>,\n  generator: RoughGenerator,\n  {\n    isExporting,\n    canvasBackgroundColor,\n    embedsValidationStatus,\n    theme,\n  }: {\n    isExporting: boolean;\n    canvasBackgroundColor: string;\n    embedsValidationStatus: EmbedsValidationStatus | null;\n    theme?: AppState[\"theme\"];\n  },\n): ElementShape => {\n  const isDarkMode = theme === THEME.DARK;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\": {\n      let shape: ElementShapes[typeof element.type];\n      // this is for rendering the stroke/bg of the embeddable, especially\n      // when the src url is not set\n\n      if (element.roundness) {\n        const w = element.width;\n        const h = element.height;\n        const r = getCornerRadius(Math.min(w, h), element);\n        shape = generator.path(\n          `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n            h - r\n          } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n            h - r\n          } L 0 ${r} Q 0 0, ${r} 0`,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            true,\n            isDarkMode,\n          ),\n        );\n      } else {\n        shape = generator.rectangle(\n          0,\n          0,\n          element.width,\n          element.height,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            false,\n            isDarkMode,\n          ),\n        );\n      }\n      return shape;\n    }\n    case \"diamond\": {\n      let shape: ElementShapes[typeof element.type];\n\n      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n        getDiamondPoints(element);\n      if (element.roundness) {\n        const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);\n\n        const horizontalRadius = getCornerRadius(\n          Math.abs(rightY - topY),\n          element,\n        );\n\n        shape = generator.path(\n          `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${\n            rightX - verticalRadius\n          } ${rightY - horizontalRadius}\n            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${\n            rightX - verticalRadius\n          } ${rightY + horizontalRadius}\n            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}\n            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${\n            bottomX - verticalRadius\n          } ${bottomY - horizontalRadius}\n            L ${leftX + verticalRadius} ${leftY + horizontalRadius}\n            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${\n            leftY - horizontalRadius\n          }\n            L ${topX - verticalRadius} ${topY + horizontalRadius}\n            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${\n            topY + horizontalRadius\n          }`,\n          generateRoughOptions(element, true, isDarkMode),\n        );\n      } else {\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element, false, isDarkMode),\n        );\n      }\n      return shape;\n    }\n    case \"ellipse\": {\n      const shape: ElementShapes[typeof element.type] = generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        generateRoughOptions(element, false, isDarkMode),\n      );\n      return shape;\n    }\n    case \"line\":\n    case \"arrow\": {\n      let shape: ElementShapes[typeof element.type];\n      const options = generateRoughOptions(element, false, isDarkMode);\n\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        // NOTE (mtolmacs): Temporary fix for extremely big arrow shapes\n        if (\n          !points.every(\n            (point) => Math.abs(point[0]) <= 1e6 && Math.abs(point[1]) <= 1e6,\n          )\n        ) {\n          console.error(\n            `Elbow arrow with extreme point positions detected. Arrow not rendered.`,\n            element.id,\n            JSON.stringify(points),\n          );\n          shape = [];\n        } else {\n          shape = [\n            generator.path(\n              generateElbowArrowShape(points, 16),\n              generateRoughOptions(element, true, isDarkMode),\n            ),\n          ];\n        }\n      } else if (!element.roundness) {\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (options.fill) {\n          shape = [\n            generator.polygon(points as unknown as RoughPoint[], options),\n          ];\n        } else {\n          shape = [\n            generator.linearPath(points as unknown as RoughPoint[], options),\n          ];\n        }\n      } else {\n        shape = [generator.curve(points as unknown as RoughPoint[], options)];\n      }\n\n      // add lines only in arrow\n      if (element.type === \"arrow\") {\n        const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n        if (startArrowhead !== null) {\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"start\",\n            startArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n            isDarkMode,\n          );\n          shape.push(...shapes);\n        }\n\n        if (endArrowhead !== null) {\n          if (endArrowhead === undefined) {\n            // Hey, we have an old arrow here!\n          }\n\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"end\",\n            endArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n            isDarkMode,\n          );\n          shape.push(...shapes);\n        }\n      }\n      return shape;\n    }\n    case \"freedraw\": {\n      // oredered in terms of z-index [background, stroke]\n      const shapes: ElementShapes[typeof element.type] = [];\n\n      // (1) background fill (rc shape), optional\n      if (isPathALoop(element.points)) {\n        // generate rough polygon to fill freedraw shape\n        const simplifiedPoints = simplify(\n          element.points as Mutable<LocalPoint[]>,\n          0.75,\n        );\n        shapes.push(\n          generator.curve(simplifiedPoints as [number, number][], {\n            ...generateRoughOptions(element, false, isDarkMode),\n            stroke: \"none\",\n          }),\n        );\n      }\n\n      // (2) stroke\n      shapes.push(getFreeDrawSvgPath(element));\n\n      return shapes;\n    }\n    case \"frame\":\n    case \"magicframe\":\n    case \"text\":\n    case \"image\": {\n      const shape: ElementShapes[typeof element.type] = null;\n      // we return (and cache) `null` to make sure we don't regenerate\n      // `element.canvas` on rerenders\n      return shape;\n    }\n    default: {\n      assertNever(\n        element,\n        `generateElementShape(): Unimplemented type ${(element as any)?.type}`,\n      );\n      return null;\n    }\n  }\n};\n\nconst generateElbowArrowShape = (\n  points: readonly LocalPoint[],\n  radius: number,\n) => {\n  const subpoints = [] as [number, number][];\n  for (let i = 1; i < points.length - 1; i += 1) {\n    const prev = points[i - 1];\n    const next = points[i + 1];\n    const point = points[i];\n    const prevIsHorizontal = headingForPointIsHorizontal(point, prev);\n    const nextIsHorizontal = headingForPointIsHorizontal(next, point);\n    const corner = Math.min(\n      radius,\n      pointDistance(points[i], next) / 2,\n      pointDistance(points[i], prev) / 2,\n    );\n\n    if (prevIsHorizontal) {\n      if (prev[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (prev[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n\n    subpoints.push(points[i] as [number, number]);\n\n    if (nextIsHorizontal) {\n      if (next[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (next[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      // DOWN\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n  }\n\n  const d = [`M ${points[0][0]} ${points[0][1]}`];\n  for (let i = 0; i < subpoints.length; i += 3) {\n    d.push(`L ${subpoints[i][0]} ${subpoints[i][1]}`);\n    d.push(\n      `Q ${subpoints[i + 1][0]} ${subpoints[i + 1][1]}, ${\n        subpoints[i + 2][0]\n      } ${subpoints[i + 2][1]}`,\n    );\n  }\n  d.push(`L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`);\n\n  return d.join(\" \");\n};\n\n/**\n * get the pure geometric shape of an excalidraw elementw\n * which is then used for hit detection\n */\nexport const getElementShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): GeometricShape<Point> => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"embeddable\":\n    case \"image\":\n    case \"iframe\":\n    case \"text\":\n    case \"selection\":\n      return getPolygonShape(element);\n    case \"arrow\":\n    case \"line\": {\n      const roughShape = ShapeCache.generateElementShape(element, null)[0];\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n\n      return shouldTestInside(element)\n        ? getClosedCurveShape<Point>(\n            element,\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          )\n        : getCurveShape<Point>(\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          );\n    }\n\n    case \"ellipse\":\n      return getEllipseShape(element);\n\n    case \"freedraw\": {\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n      return getFreedrawShape(\n        element,\n        pointFrom(cx, cy),\n        shouldTestInside(element),\n      );\n    }\n  }\n};\n\nexport const toggleLinePolygonState = (\n  element: ExcalidrawLineElement,\n  nextPolygonState: boolean,\n): {\n  polygon: ExcalidrawLineElement[\"polygon\"];\n  points: ExcalidrawLineElement[\"points\"];\n} | null => {\n  const updatedPoints = [...element.points];\n\n  if (nextPolygonState) {\n    if (!canBecomePolygon(element.points)) {\n      return null;\n    }\n\n    const firstPoint = updatedPoints[0];\n    const lastPoint = updatedPoints[updatedPoints.length - 1];\n\n    const distance = Math.hypot(\n      firstPoint[0] - lastPoint[0],\n      firstPoint[1] - lastPoint[1],\n    );\n\n    if (\n      distance > LINE_POLYGON_POINT_MERGE_DISTANCE ||\n      updatedPoints.length < 4\n    ) {\n      updatedPoints.push(pointFrom(firstPoint[0], firstPoint[1]));\n    } else {\n      updatedPoints[updatedPoints.length - 1] = pointFrom(\n        firstPoint[0],\n        firstPoint[1],\n      );\n    }\n  }\n\n  // TODO: satisfies ElementUpdate<ExcalidrawLineElement>\n  const ret = {\n    polygon: nextPolygonState,\n    points: updatedPoints,\n  };\n\n  return ret;\n};\n\n// -----------------------------------------------------------------------------\n//                         freedraw shape helper\n// -----------------------------------------------------------------------------\n\n// NOTE not cached (-> for SVG export)\nconst getFreeDrawSvgPath = (element: ExcalidrawFreeDrawElement) => {\n  return getSvgPathFromStroke(\n    getFreedrawOutlinePoints(element),\n  ) as SVGPathString;\n};\n\nexport const getFreedrawOutlinePoints = (\n  element: ExcalidrawFreeDrawElement,\n) => {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0.5]];\n\n  return getStroke(inputPoints as number[][], {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t) => Math.sin((t * Math.PI) / 2), // https://easings.net/#easeOutSine\n    last: true,\n  }) as [number, number][];\n};\n\nconst med = (A: number[], B: number[]) => {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n};\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\n\nconst getSvgPathFromStroke = (points: number[][]): string => {\n  if (!points.length) {\n    return \"\";\n  }\n\n  const max = points.length - 1;\n\n  return points\n    .reduce(\n      (acc, point, i, arr) => {\n        if (i === max) {\n          acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n        } else {\n          acc.push(point, med(point, arr[i + 1]));\n        }\n        return acc;\n      },\n      [\"M\", points[0], \"Q\"],\n    )\n    .join(\" \")\n    .replace(TO_FIXED_PRECISION, \"$1\");\n};\n\n// -----------------------------------------------------------------------------\n", "function $(e,t,u,x=h=>h){return e*x(.5-t*(.5-u))}function se(e){return[-e[0],-e[1]]}function l(e,t){return[e[0]+t[0],e[1]+t[1]]}function a(e,t){return[e[0]-t[0],e[1]-t[1]]}function b(e,t){return[e[0]*t,e[1]*t]}function he(e,t){return[e[0]/t,e[1]/t]}function R(e){return[e[1],-e[0]]}function B(e,t){return e[0]*t[0]+e[1]*t[1]}function ue(e,t){return e[0]===t[0]&&e[1]===t[1]}function ge(e){return Math.hypot(e[0],e[1])}function de(e){return e[0]*e[0]+e[1]*e[1]}function A(e,t){return de(a(e,t))}function G(e){return he(e,ge(e))}function ie(e,t){return Math.hypot(e[1]-t[1],e[0]-t[0])}function L(e,t,u){let x=Math.sin(u),h=Math.cos(u),y=e[0]-t[0],n=e[1]-t[1],f=y*h-n*x,d=y*x+n*h;return[f+t[0],d+t[1]]}function K(e,t,u){return l(e,b(a(t,e),u))}function ee(e,t,u){return l(e,b(t,u))}var{min:C,PI:xe}=Math,pe=.275,V=xe+1e-4;function ce(e,t={}){let{size:u=16,smoothing:x=.5,thinning:h=.5,simulatePressure:y=!0,easing:n=r=>r,start:f={},end:d={},last:D=!1}=t,{cap:S=!0,easing:j=r=>r*(2-r)}=f,{cap:q=!0,easing:c=r=>--r*r*r+1}=d;if(e.length===0||u<=0)return[];let p=e[e.length-1].runningLength,g=f.taper===!1?0:f.taper===!0?Math.max(u,p):f.taper,T=d.taper===!1?0:d.taper===!0?Math.max(u,p):d.taper,te=Math.pow(u*x,2),_=[],M=[],H=e.slice(0,10).reduce((r,i)=>{let o=i.pressure;if(y){let s=C(1,i.distance/u),W=C(1,1-s);o=C(1,r+(W-r)*(s*pe))}return(r+o)/2},e[0].pressure),m=$(u,h,e[e.length-1].pressure,n),U,X=e[0].vector,z=e[0].point,F=z,O=z,E=F,J=!1;for(let r=0;r<e.length;r++){let{pressure:i}=e[r],{point:o,vector:s,distance:W,runningLength:I}=e[r];if(r<e.length-1&&p-I<3)continue;if(h){if(y){let v=C(1,W/u),Z=C(1,1-v);i=C(1,H+(Z-H)*(v*pe))}m=$(u,h,i,n)}else m=u/2;U===void 0&&(U=m);let le=I<g?j(I/g):1,fe=p-I<T?c((p-I)/T):1;m=Math.max(.01,m*Math.min(le,fe));let re=(r<e.length-1?e[r+1]:e[r]).vector,Y=r<e.length-1?B(s,re):1,be=B(s,X)<0&&!J,ne=Y!==null&&Y<0;if(be||ne){let v=b(R(X),m);for(let Z=1/13,w=0;w<=1;w+=Z)O=L(a(o,v),o,V*w),_.push(O),E=L(l(o,v),o,V*-w),M.push(E);z=O,F=E,ne&&(J=!0);continue}if(J=!1,r===e.length-1){let v=b(R(s),m);_.push(a(o,v)),M.push(l(o,v));continue}let oe=b(R(K(re,s,Y)),m);O=a(o,oe),(r<=1||A(z,O)>te)&&(_.push(O),z=O),E=l(o,oe),(r<=1||A(F,E)>te)&&(M.push(E),F=E),H=i,X=s}let P=e[0].point.slice(0,2),k=e.length>1?e[e.length-1].point.slice(0,2):l(e[0].point,[1,1]),Q=[],N=[];if(e.length===1){if(!(g||T)||D){let r=ee(P,G(R(a(P,k))),-(U||m)),i=[];for(let o=1/13,s=o;s<=1;s+=o)i.push(L(r,P,V*2*s));return i}}else{if(!(g||T&&e.length===1))if(S)for(let i=1/13,o=i;o<=1;o+=i){let s=L(M[0],P,V*o);Q.push(s)}else{let i=a(_[0],M[0]),o=b(i,.5),s=b(i,.51);Q.push(a(P,o),a(P,s),l(P,s),l(P,o))}let r=R(se(e[e.length-1].vector));if(T||g&&e.length===1)N.push(k);else if(q){let i=ee(k,r,m);for(let o=1/29,s=o;s<1;s+=o)N.push(L(i,k,V*3*s))}else N.push(l(k,b(r,m)),l(k,b(r,m*.99)),a(k,b(r,m*.99)),a(k,b(r,m)))}return _.concat(N,M.reverse(),Q)}function me(e,t={}){var q;let{streamline:u=.5,size:x=16,last:h=!1}=t;if(e.length===0)return[];let y=.15+(1-u)*.85,n=Array.isArray(e[0])?e:e.map(({x:c,y:p,pressure:g=.5})=>[c,p,g]);if(n.length===2){let c=n[1];n=n.slice(0,-1);for(let p=1;p<5;p++)n.push(K(n[0],c,p/4))}n.length===1&&(n=[...n,[...l(n[0],[1,1]),...n[0].slice(2)]]);let f=[{point:[n[0][0],n[0][1]],pressure:n[0][2]>=0?n[0][2]:.25,vector:[1,1],distance:0,runningLength:0}],d=!1,D=0,S=f[0],j=n.length-1;for(let c=1;c<n.length;c++){let p=h&&c===j?n[c].slice(0,2):K(S.point,n[c],y);if(ue(S.point,p))continue;let g=ie(p,S.point);if(D+=g,c<j&&!d){if(D<x)continue;d=!0}S={point:p,pressure:n[c][2]>=0?n[c][2]:.5,vector:G(a(S.point,p)),distance:g,runningLength:D},f.push(S)}return f[0].vector=((q=f[1])==null?void 0:q.vector)||[0,0],f}function ae(e,t={}){return ce(me(e,t),t)}var _e=ae;export{_e as default,ae as getStroke,ce as getStrokeOutlinePoints,me as getStrokePoints};\n", "import rough from \"roughjs/bin/rough\";\n\nimport {\n  type GlobalPoint,\n  isRightAngleRads,\n  lineSegment,\n  pointFrom,\n  pointRotateRads,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_REDUCED_GLOBAL_ALPHA,\n  ELEMENT_READY_TO_ERASE_OPACITY,\n  FRAME_STYLE,\n  DARK_THEME_FILTER,\n  MIME_TYPES,\n  STICKY_NOTE_PADDING,\n  THEME,\n  distance,\n  getFontString,\n  isRTL,\n  getVerticalOffset,\n  invariant,\n  applyDarkModeFilter,\n  isSafari,\n} from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  StaticCanvasAppState,\n  Zoom,\n  InteractiveCanvasAppState,\n  ElementsPendingErasure,\n  PendingExcalidrawElements,\n  NormalizedZoomValue,\n} from \"@excalidraw/excalidraw/types\";\n\nimport type {\n  StaticCanvasRenderConfig,\n  RenderableElementsMap,\n  InteractiveCanvasRenderConfig,\n} from \"@excalidraw/excalidraw/scene/types\";\n\nimport { getElementAbsoluteCoords, getElementBounds } from \"./bounds\";\nimport { getUncroppedImageElement } from \"./cropElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport {\n  getBoundTextElement,\n  getContainerCoords,\n  getContainerElement,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n} from \"./textElement\";\nimport { getLineHeightInPx } from \"./textMeasurements\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n  isInitializedImageElement,\n  isArrowElement,\n  hasBoundTextElement,\n  isMagicFrameElement,\n  isImageElement,\n} from \"./typeChecks\";\nimport { getContainingFrame } from \"./frame\";\nimport { getCornerRadius } from \"./utils\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawFrameLikeElement,\n  NonDeletedSceneElementsMap,\n  ElementsMap,\n} from \"./types\";\n\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\n\nconst isPendingImageElement = (\n  element: ExcalidrawElement,\n  renderConfig: StaticCanvasRenderConfig,\n) =>\n  isInitializedImageElement(element) &&\n  !renderConfig.imageCache.has(element.fileId);\n\nconst getCanvasPadding = (element: ExcalidrawElement) => {\n  switch (element.type) {\n    case \"freedraw\":\n      return element.strokeWidth * 12;\n    case \"text\":\n      return element.fontSize / 2;\n    case \"arrow\":\n      if (element.startArrowhead || element.endArrowhead) {\n        return 40;\n      }\n      return 20;\n    default:\n      return 20;\n  }\n};\n\nexport const getRenderOpacity = (\n  element: ExcalidrawElement,\n  containingFrame: ExcalidrawFrameLikeElement | null,\n  elementsPendingErasure: ElementsPendingErasure,\n  pendingNodes: Readonly<PendingExcalidrawElements> | null,\n  globalAlpha: number = 1,\n) => {\n  // multiplying frame opacity with element opacity to combine them\n  // (e.g. frame 50% and element 50% opacity should result in 25% opacity)\n  let opacity =\n    (((containingFrame?.opacity ?? 100) * element.opacity) / 10000) *\n    globalAlpha;\n\n  // if pending erasure, multiply again to combine further\n  // (so that erasing always results in lower opacity than original)\n  if (\n    elementsPendingErasure.has(element.id) ||\n    (pendingNodes && pendingNodes.some((node) => node.id === element.id)) ||\n    (containingFrame && elementsPendingErasure.has(containingFrame.id))\n  ) {\n    opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;\n  }\n\n  return opacity;\n};\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  theme: AppState[\"theme\"];\n  scale: number;\n  angle: number;\n  zoomValue: AppState[\"zoom\"][\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n  boundTextElementVersion: number | null;\n  imageCrop: ExcalidrawImageElement[\"crop\"] | null;\n  containingFrameOpacity: number;\n  boundTextCanvas: HTMLCanvasElement;\n  editingTextElementId?: ExcalidrawElement[\"id\"] | null;\n}\n\nconst cappedElementCanvasSize = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  zoom: Zoom,\n): {\n  width: number;\n  height: number;\n  scale: number;\n} => {\n  // these limits are ballpark, they depend on specific browsers and device.\n  // We've chosen lower limits to be safe. We might want to change these limits\n  // based on browser/device type, if we get reports of low quality rendering\n  // on zoom.\n  //\n  // ~ safari mobile canvas area limit\n  const AREA_LIMIT = 16777216;\n  // ~ safari width/height limit based on developer.mozilla.org.\n  const WIDTH_HEIGHT_LIMIT = 32767;\n\n  const padding = getCanvasPadding(element);\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n  const elementWidth =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(x1, x2)\n      : element.width;\n  const elementHeight =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(y1, y2)\n      : element.height;\n\n  let width = elementWidth * window.devicePixelRatio + padding * 2;\n  let height = elementHeight * window.devicePixelRatio + padding * 2;\n\n  let scale: number = zoom.value;\n\n  // rescale to ensure width and height is within limits\n  if (\n    width * scale > WIDTH_HEIGHT_LIMIT ||\n    height * scale > WIDTH_HEIGHT_LIMIT\n  ) {\n    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);\n  }\n\n  // rescale to ensure canvas area is within limits\n  if (width * height * scale * scale > AREA_LIMIT) {\n    scale = Math.sqrt(AREA_LIMIT / (width * height));\n  }\n\n  width = Math.floor(width * scale);\n  height = Math.floor(height * scale);\n\n  return { width, height, scale };\n};\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom: Zoom,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState | InteractiveCanvasAppState,\n): ExcalidrawElementWithCanvas | null => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  const { width, height, scale } = cappedElementCanvasSize(\n    element,\n    elementsMap,\n    zoom,\n  );\n\n  if (!width || !height) {\n    return null;\n  }\n\n  canvas.width = width;\n  canvas.height = height;\n\n  let canvasOffsetX = -100;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n\n    canvasOffsetX =\n      element.x > x1\n        ? distance(element.x, x1) * window.devicePixelRatio * scale\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? distance(element.y, y1) * window.devicePixelRatio * scale\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  }\n\n  context.save();\n  context.translate(padding * scale, padding * scale);\n  context.scale(\n    window.devicePixelRatio * scale,\n    window.devicePixelRatio * scale,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  drawElementOnCanvas(element, rc, context, renderConfig, elementsMap);\n\n  context.restore();\n\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextCanvas = document.createElement(\"canvas\");\n  const boundTextCanvasContext = boundTextCanvas.getContext(\"2d\")!;\n\n  if (isArrowElement(element) && boundTextElement) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    // Take max dimensions of arrow canvas so that when canvas is rotated\n    // the arrow doesn't get clipped\n    const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n    boundTextCanvas.width =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvas.height =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvasContext.translate(\n      boundTextCanvas.width / 2,\n      boundTextCanvas.height / 2,\n    );\n    boundTextCanvasContext.rotate(element.angle);\n    boundTextCanvasContext.drawImage(\n      canvas!,\n      -canvas.width / 2,\n      -canvas.height / 2,\n      canvas.width,\n      canvas.height,\n    );\n\n    const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n      boundTextElement,\n      elementsMap,\n    );\n\n    boundTextCanvasContext.rotate(-element.angle);\n    const offsetX = (boundTextCanvas.width - canvas!.width) / 2;\n    const offsetY = (boundTextCanvas.height - canvas!.height) / 2;\n    const shiftX =\n      boundTextCanvas.width / 2 -\n      (boundTextCx - x1) * window.devicePixelRatio * scale -\n      offsetX -\n      padding * scale;\n\n    const shiftY =\n      boundTextCanvas.height / 2 -\n      (boundTextCy - y1) * window.devicePixelRatio * scale -\n      offsetY -\n      padding * scale;\n    boundTextCanvasContext.translate(-shiftX, -shiftY);\n    // Clear the bound text area\n    boundTextCanvasContext.clearRect(\n      -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.width + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.height + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n    );\n  }\n\n  return {\n    element,\n    canvas,\n    theme: appState.theme,\n    scale,\n    zoomValue: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n    boundTextElementVersion:\n      getBoundTextElement(element, elementsMap)?.version || null,\n    containingFrameOpacity:\n      getContainingFrame(element, elementsMap)?.opacity || 100,\n    boundTextCanvas,\n    angle: element.angle,\n    imageCrop: isImageElement(element) ? element.crop : null,\n    editingTextElementId: renderConfig.editingTextElementId,\n  };\n};\n\nexport const DEFAULT_LINK_SIZE = 14;\n\nconst IMAGE_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`,\n)}`;\n\nconst IMAGE_ERROR_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`,\n)}`;\n\nconst drawImagePlaceholder = (\n  element: ExcalidrawImageElement,\n  context: CanvasRenderingContext2D,\n  theme: StaticCanvasRenderConfig[\"theme\"],\n) => {\n  context.fillStyle = theme === THEME.DARK ? \"#2E2E2E\" : \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n\n  const size = Math.min(\n    imageMinWidthOrHeight,\n    Math.min(imageMinWidthOrHeight * 0.4, 100),\n  );\n\n  context.drawImage(\n    element.status === \"error\"\n      ? IMAGE_ERROR_PLACEHOLDER_IMG\n      : IMAGE_PLACEHOLDER_IMG,\n    element.width / 2 - size / 2,\n    element.height / 2 - size / 2,\n    size,\n    size,\n  );\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  elementsMap?: ElementsMap,\n) => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      const shape = ShapeCache.generateElementShape(element, renderConfig);\n      // Sticky note: no border, even drop shadow (only when explicitly marked)\n      const isStickyNote =\n        element.type === \"rectangle\" &&\n        element.customData?.isStickyNote === true;\n      if (isStickyNote) {\n        context.save();\n        context.shadowColor = \"rgba(0, 0, 0, 0.18)\";\n        context.shadowBlur = 8;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n        rc.draw(shape);\n        context.restore();\n        // When out of focus and no content, show \"Add text\" ghost placeholder (sticky notes only).\n        // Draw at top-left (same position as bound text) so it aligns with the other placeholder\n        // and persists in the same spot when that one hides.\n        if (!renderConfig.isExporting && elementsMap) {\n          const boundText = getBoundTextElement(element, elementsMap);\n          const isBoundTextBeingEdited =\n            boundText?.id != null &&\n            renderConfig.editingTextElementId === boundText.id;\n          const showGhost =\n            !isBoundTextBeingEdited &&\n            (!boundText || !boundText.originalText.trim());\n          if (showGhost) {\n            const placeholder =\n              renderConfig.stickyNotePlaceholder || \"Add text\";\n            const font = boundText\n              ? getFontString(boundText)\n              : getFontString({\n                  fontFamily: DEFAULT_FONT_FAMILY,\n                  fontSize: DEFAULT_FONT_SIZE,\n                });\n            context.save();\n            context.font = font;\n            context.textAlign = \"left\";\n            context.textBaseline = \"top\";\n            context.globalAlpha = 0.4;\n            context.fillStyle =\n              renderConfig.theme === THEME.DARK\n                ? applyDarkModeFilter(element.strokeColor)\n                : element.strokeColor;\n            // Slightly lower so this ghost sits behind the other placeholder\n            const ghostOffsetY = 3;\n            context.fillText(\n              placeholder,\n              STICKY_NOTE_PADDING,\n              STICKY_NOTE_PADDING + ghostOffsetY,\n            );\n            context.restore();\n          }\n        }\n        break;\n      }\n      rc.draw(shape);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      ShapeCache.generateElementShape(element, renderConfig).forEach(\n        (shape) => {\n          rc.draw(shape);\n        },\n      );\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n\n      const shapes = ShapeCache.generateElementShape(element, renderConfig);\n\n      for (const shape of shapes) {\n        if (typeof shape === \"string\") {\n          context.fillStyle =\n            renderConfig.theme === THEME.DARK\n              ? applyDarkModeFilter(element.strokeColor)\n              : element.strokeColor;\n          context.fill(new Path2D(shape));\n        } else {\n          rc.draw(shape);\n        }\n      }\n\n      context.restore();\n      break;\n    }\n    case \"image\": {\n      context.save();\n      const cacheEntry =\n        element.fileId !== null\n          ? renderConfig.imageCache.get(element.fileId)\n          : null;\n      const img = isInitializedImageElement(element)\n        ? cacheEntry?.image\n        : undefined;\n\n      if (img != null && !(img instanceof Promise)) {\n        if (element.roundness && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            getCornerRadius(Math.min(element.width, element.height), element),\n          );\n          context.clip();\n        }\n\n        const { x, y, width, height } = element.crop\n          ? element.crop\n          : {\n              x: 0,\n              y: 0,\n              width: img.naturalWidth,\n              height: img.naturalHeight,\n            };\n\n        const shouldInvertImage =\n          renderConfig.theme === THEME.DARK &&\n          cacheEntry?.mimeType === MIME_TYPES.svg;\n\n        if (shouldInvertImage && isSafari) {\n          const devicePixelRatio = window.devicePixelRatio || 1;\n          const tempCanvas = document.createElement(\"canvas\");\n          tempCanvas.width = element.width * devicePixelRatio;\n          tempCanvas.height = element.height * devicePixelRatio;\n          const tempContext = tempCanvas.getContext(\"2d\");\n\n          if (tempContext) {\n            tempContext.scale(devicePixelRatio, devicePixelRatio);\n            tempContext.drawImage(\n              img,\n              x,\n              y,\n              width,\n              height,\n              0,\n              0,\n              element.width,\n              element.height,\n            );\n\n            const imageData = tempContext.getImageData(\n              0,\n              0,\n              tempCanvas.width,\n              tempCanvas.height,\n            );\n\n            const data = imageData.data;\n\n            for (let i = 0; i < data.length; i += 4) {\n              data[i] = 255 - data[i];\n              data[i + 1] = 255 - data[i + 1];\n              data[i + 2] = 255 - data[i + 2];\n            }\n\n            tempContext.putImageData(imageData, 0, 0);\n            context.drawImage(\n              tempCanvas,\n              0,\n              0,\n              tempCanvas.width,\n              tempCanvas.height,\n              0,\n              0,\n              element.width,\n              element.height,\n            );\n          }\n        } else {\n          if (shouldInvertImage) {\n            context.filter = DARK_THEME_FILTER;\n          }\n\n          context.drawImage(\n            img,\n            x,\n            y,\n            width,\n            height,\n            0 /* hardcoded for the selection box*/,\n            0,\n            element.width,\n            element.height,\n          );\n        }\n      } else {\n        drawImagePlaceholder(element, context, renderConfig.theme);\n      }\n      context.restore();\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        context.save();\n        context.font = getFontString(element);\n        context.fillStyle =\n          renderConfig.theme === THEME.DARK\n            ? applyDarkModeFilter(element.strokeColor)\n            : element.strokeColor;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n\n        const lineHeightPx = getLineHeightInPx(\n          element.fontSize,\n          element.lineHeight,\n        );\n\n        const verticalOffset = getVerticalOffset(\n          element.fontFamily,\n          element.fontSize,\n          lineHeightPx,\n        );\n\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            index * lineHeightPx + verticalOffset,\n          );\n        }\n        context.restore();\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState | InteractiveCanvasAppState,\n) => {\n  const zoom: Zoom = renderConfig\n    ? appState.zoom\n    : {\n        value: 1 as NormalizedZoomValue,\n      };\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.zoomValue !== zoom.value &&\n    !appState?.shouldCacheIgnoreZoom;\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextElementVersion = boundTextElement?.version || null;\n  const imageCrop = isImageElement(element) ? element.crop : null;\n\n  const containingFrameOpacity =\n    getContainingFrame(element, elementsMap)?.opacity || 100;\n\n  const isStickyNote =\n    element.type === \"rectangle\" &&\n    element.customData?.isStickyNote === true;\n  const editingTextElementId = renderConfig.editingTextElementId;\n  const shouldRegenerateBecauseEditingText =\n    isStickyNote &&\n    prevElementWithCanvas?.editingTextElementId !== editingTextElementId;\n\n  if (\n    !prevElementWithCanvas ||\n    shouldRegenerateBecauseZoom ||\n    shouldRegenerateBecauseEditingText ||\n    prevElementWithCanvas.theme !== appState.theme ||\n    prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion ||\n    prevElementWithCanvas.imageCrop !== imageCrop ||\n    prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity ||\n    // since we rotate the canvas when copying from cached canvas, we don't\n    // regenerate the cached canvas. But we need to in case of labels which are\n    // cached alongside the arrow, and we want the labels to remain unrotated\n    // with respect to the arrow.\n    (isArrowElement(element) &&\n      boundTextElement &&\n      element.angle !== prevElementWithCanvas.angle)\n  ) {\n    const elementWithCanvas = generateElementCanvas(\n      element,\n      elementsMap,\n      zoom,\n      renderConfig,\n      appState,\n    );\n\n    if (!elementWithCanvas) {\n      return null;\n    }\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState | InteractiveCanvasAppState,\n  allElementsMap: NonDeletedSceneElementsMap,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  const zoom = elementWithCanvas.scale;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, allElementsMap);\n  const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;\n\n  context.save();\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n\n  const boundTextElement = getBoundTextElement(element, allElementsMap);\n\n  if (isArrowElement(element) && boundTextElement) {\n    const offsetX =\n      (elementWithCanvas.boundTextCanvas.width -\n        elementWithCanvas.canvas!.width) /\n      2;\n    const offsetY =\n      (elementWithCanvas.boundTextCanvas.height -\n        elementWithCanvas.canvas!.height) /\n      2;\n    context.translate(cx, cy);\n    context.drawImage(\n      elementWithCanvas.boundTextCanvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - offsetX / zoom - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - offsetY / zoom - padding,\n      elementWithCanvas.boundTextCanvas.width / zoom,\n      elementWithCanvas.boundTextCanvas.height / zoom,\n    );\n  } else {\n    // we translate context to element center so that rotation and scale\n    // originates from the element center\n    context.translate(cx, cy);\n\n    context.rotate(element.angle);\n\n    if (\n      \"scale\" in elementWithCanvas.element &&\n      !isPendingImageElement(element, renderConfig)\n    ) {\n      context.scale(\n        elementWithCanvas.element.scale[0],\n        elementWithCanvas.element.scale[1],\n      );\n    }\n\n    // revert afterwards we don't have account for it during drawing\n    context.translate(-cx, -cy);\n\n    context.drawImage(\n      elementWithCanvas.canvas!,\n      (x1 + appState.scrollX) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      (y1 + appState.scrollY) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.width / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.height / elementWithCanvas.scale,\n    );\n\n    if (\n      import.meta.env.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX ===\n        \"true\" &&\n      hasBoundTextElement(element)\n    ) {\n      const textElement = getBoundTextElement(\n        element,\n        allElementsMap,\n      ) as ExcalidrawTextElementWithContainer;\n      const coords = getContainerCoords(element);\n      context.strokeStyle = \"#c92a2a\";\n      context.lineWidth = 3;\n      context.strokeRect(\n        (coords.x + appState.scrollX) * window.devicePixelRatio,\n        (coords.y + appState.scrollY) * window.devicePixelRatio,\n        getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,\n        getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio,\n      );\n    }\n  }\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderSelectionElement = (\n  element: NonDeletedExcalidrawElement,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  selectionColor: InteractiveCanvasRenderConfig[\"selectionColor\"],\n) => {\n  context.save();\n  context.translate(element.x + appState.scrollX, element.y + appState.scrollY);\n  context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n  // render from 0.5px offset  to get 1px wide line\n  // https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540#7531540\n  // TODO can be be improved by offseting to the negative when user selects\n  // from right to left\n  const offset = 0.5 / appState.zoom.value;\n\n  context.fillRect(offset, offset, element.width, element.height);\n  context.lineWidth = 1 / appState.zoom.value;\n  context.strokeStyle = selectionColor;\n  context.strokeRect(offset, offset, element.width, element.height);\n\n  context.restore();\n};\n\n/**\n * Renders only the background fill of a frame. Called in a separate pass before\n * other elements so the frame background appears behind its contents.\n */\nexport const renderFrameBackground = (\n  frame: ExcalidrawFrameLikeElement,\n  context: CanvasRenderingContext2D,\n  appState: StaticCanvasAppState | InteractiveCanvasAppState,\n) => {\n  if (\n    frame.backgroundColor === \"transparent\" ||\n    !appState.frameRendering?.enabled\n  ) {\n    return;\n  }\n  context.save();\n  context.translate(frame.x + appState.scrollX, frame.y + appState.scrollY);\n\n  const zoom = appState.zoom.value;\n  context.shadowColor = FRAME_STYLE.shadowColor;\n  context.shadowBlur = FRAME_STYLE.shadowBlur / zoom;\n  context.shadowOffsetX = FRAME_STYLE.shadowOffsetX / zoom;\n  context.shadowOffsetY = FRAME_STYLE.shadowOffsetY / zoom;\n\n  context.fillStyle = frame.backgroundColor;\n  if (FRAME_STYLE.radius && context.roundRect) {\n    context.beginPath();\n    context.roundRect(\n      0,\n      0,\n      frame.width,\n      frame.height,\n      FRAME_STYLE.radius / zoom,\n    );\n    context.fill();\n    context.closePath();\n  } else {\n    context.fillRect(0, 0, frame.width, frame.height);\n  }\n\n  context.restore();\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: RenderableElementsMap,\n  allElementsMap: NonDeletedSceneElementsMap,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState | InteractiveCanvasAppState,\n) => {\n  const reduceAlphaForSelection =\n    appState.openDialog?.name === \"elementLinkSelector\" &&\n    !appState.selectedElementIds[element.id] &&\n    !appState.hoveredElementIds[element.id];\n\n  context.globalAlpha = getRenderOpacity(\n    element,\n    getContainingFrame(element, elementsMap),\n    renderConfig.elementsPendingErasure,\n    renderConfig.pendingFlowchartNodes,\n    reduceAlphaForSelection ? DEFAULT_REDUCED_GLOBAL_ALPHA : 1,\n  );\n\n  switch (element.type) {\n    case \"magicframe\":\n    case \"frame\": {\n      if (appState.frameRendering.enabled && appState.frameRendering.outline) {\n        context.save();\n        context.translate(\n          element.x + appState.scrollX,\n          element.y + appState.scrollY,\n        );\n\n        context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;\n        context.strokeStyle =\n          appState.theme === THEME.DARK\n            ? applyDarkModeFilter(FRAME_STYLE.strokeColor)\n            : FRAME_STYLE.strokeColor;\n\n        // TODO change later to only affect AI frames\n        if (isMagicFrameElement(element)) {\n          context.strokeStyle =\n            appState.theme === THEME.LIGHT\n              ? \"#7affd7\"\n              : applyDarkModeFilter(\"#1d8264\");\n        }\n\n        if (FRAME_STYLE.radius && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            FRAME_STYLE.radius / appState.zoom.value,\n          );\n          context.stroke();\n          context.closePath();\n        } else {\n          context.strokeRect(0, 0, element.width, element.height);\n        }\n\n        context.restore();\n      }\n      break;\n    }\n    case \"freedraw\": {\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(\n          element,\n          rc,\n          context,\n          renderConfig,\n          allElementsMap,\n        );\n        context.restore();\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\": {\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        let shiftX = (x2 - x1) / 2 - (element.x - x1);\n        let shiftY = (y2 - y1) / 2 - (element.y - y1);\n        if (isTextElement(element)) {\n          const container = getContainerElement(element, elementsMap);\n          if (isArrowElement(container)) {\n            const boundTextCoords =\n              LinearElementEditor.getBoundTextElementPosition(\n                container,\n                element as ExcalidrawTextElementWithContainer,\n                elementsMap,\n              );\n            shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n            shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n          }\n        }\n        context.save();\n        context.translate(cx, cy);\n\n        const boundTextElement = getBoundTextElement(element, elementsMap);\n\n        if (isArrowElement(element) && boundTextElement) {\n          const tempCanvas = document.createElement(\"canvas\");\n\n          const tempCanvasContext = tempCanvas.getContext(\"2d\")!;\n\n          // Take max dimensions of arrow canvas so that when canvas is rotated\n          // the arrow doesn't get clipped\n          const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n          const padding = getCanvasPadding(element);\n          tempCanvas.width =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n          tempCanvas.height =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n\n          tempCanvasContext.translate(\n            tempCanvas.width / 2,\n            tempCanvas.height / 2,\n          );\n          tempCanvasContext.scale(appState.exportScale, appState.exportScale);\n\n          // Shift the canvas to left most point of the arrow\n          shiftX = element.width / 2 - (element.x - x1);\n          shiftY = element.height / 2 - (element.y - y1);\n\n          tempCanvasContext.rotate(element.angle);\n          const tempRc = rough.canvas(tempCanvas);\n\n          tempCanvasContext.translate(-shiftX, -shiftY);\n\n          drawElementOnCanvas(\n            element,\n            tempRc,\n            tempCanvasContext,\n            renderConfig,\n            elementsMap,\n          );\n\n          tempCanvasContext.translate(shiftX, shiftY);\n\n          tempCanvasContext.rotate(-element.angle);\n\n          // Shift the canvas to center of bound text\n          const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n            boundTextElement,\n            elementsMap,\n          );\n          const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;\n          const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;\n          tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);\n\n          // Clear the bound text area\n          tempCanvasContext.clearRect(\n            -boundTextElement.width / 2,\n            -boundTextElement.height / 2,\n            boundTextElement.width,\n            boundTextElement.height,\n          );\n          context.scale(1 / appState.exportScale, 1 / appState.exportScale);\n          context.drawImage(\n            tempCanvas,\n            -tempCanvas.width / 2,\n            -tempCanvas.height / 2,\n            tempCanvas.width,\n            tempCanvas.height,\n          );\n        } else {\n          context.rotate(element.angle);\n\n          if (element.type === \"image\") {\n            // note: scale must be applied *after* rotating\n            context.scale(element.scale[0], element.scale[1]);\n          }\n\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(\n            element,\n            rc,\n            context,\n            renderConfig,\n            allElementsMap,\n          );\n        }\n\n        context.restore();\n        // not exporting \u2192 optimized rendering (cache & render from element\n        // canvases)\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        const currentImageSmoothingStatus = context.imageSmoothingEnabled;\n\n        if (\n          // do not disable smoothing during zoom as blurry shapes look better\n          // on low resolution (while still zooming in) than sharp ones\n          !appState?.shouldCacheIgnoreZoom &&\n          // angle is 0 -> always disable smoothing\n          (!element.angle ||\n            // or check if angle is a right angle in which case we can still\n            // disable smoothing without adversely affecting the result\n            // We need less-than comparison because of FP artihmetic\n            isRightAngleRads(element.angle))\n        ) {\n          // Disabling smoothing makes output much sharper, especially for\n          // text. Unless for non-right angles, where the aliasing is really\n          // terrible on Chromium.\n          //\n          // Note that `context.imageSmoothingQuality=\"high\"` has almost\n          // zero effect.\n          //\n          context.imageSmoothingEnabled = false;\n        }\n\n        if (\n          element.id === appState.croppingElementId &&\n          isImageElement(elementWithCanvas.element) &&\n          elementWithCanvas.element.crop !== null\n        ) {\n          context.save();\n          context.globalAlpha = 0.1;\n\n          const uncroppedElementCanvas = generateElementCanvas(\n            getUncroppedImageElement(elementWithCanvas.element, elementsMap),\n            allElementsMap,\n            appState.zoom,\n            renderConfig,\n            appState,\n          );\n\n          if (uncroppedElementCanvas) {\n            drawElementFromCanvas(\n              uncroppedElementCanvas,\n              context,\n              renderConfig,\n              appState,\n              allElementsMap,\n            );\n          }\n\n          context.restore();\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n\n        // reset\n        context.imageSmoothingEnabled = currentImageSmoothingStatus;\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n\n  context.globalAlpha = 1;\n};\n\nexport function getFreedrawOutlineAsSegments(\n  element: ExcalidrawFreeDrawElement,\n  points: [number, number][],\n  elementsMap: ElementsMap,\n) {\n  const bounds = getElementBounds(\n    {\n      ...element,\n      angle: 0 as Radians,\n    },\n    elementsMap,\n  );\n  const center = pointFrom<GlobalPoint>(\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n  );\n\n  invariant(points.length >= 2, \"Freepath outline must have at least 2 points\");\n\n  return points.slice(2).reduce(\n    (acc, curr) => {\n      acc.push(\n        lineSegment<GlobalPoint>(\n          acc[acc.length - 1][1],\n          pointRotateRads(\n            pointFrom<GlobalPoint>(curr[0] + element.x, curr[1] + element.y),\n            center,\n            element.angle,\n          ),\n        ),\n      );\n      return acc;\n    },\n    [\n      lineSegment<GlobalPoint>(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            points[0][0] + element.x,\n            points[0][1] + element.y,\n          ),\n          center,\n          element.angle,\n        ),\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            points[1][0] + element.x,\n            points[1][1] + element.y,\n          ),\n          center,\n          element.angle,\n        ),\n      ),\n    ],\n  );\n}\n", "import {\n  type Radians,\n  pointFrom,\n  pointCenter,\n  pointRotateRads,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorSubtract,\n  vectorAdd,\n  vectorScale,\n  pointFromVector,\n  clamp,\n  isCloseTo,\n} from \"@excalidraw/math\";\nimport { type Point } from \"points-on-curve\";\n\nimport {\n  elementCenterPoint,\n  getElementAbsoluteCoords,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\n\nimport type { TransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ImageCrop,\n  NonDeleted,\n} from \"./types\";\n\nexport const MINIMAL_CROP_SIZE = 10;\n\nexport const cropElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n  transformHandle: TransformHandleType,\n  naturalWidth: number,\n  naturalHeight: number,\n  pointerX: number,\n  pointerY: number,\n  widthAspectRatio?: number,\n) => {\n  const { width: uncroppedWidth, height: uncroppedHeight } =\n    getUncroppedWidthAndHeight(element);\n\n  const naturalWidthToUncropped = naturalWidth / uncroppedWidth;\n  const naturalHeightToUncropped = naturalHeight / uncroppedHeight;\n\n  const croppedLeft = (element.crop?.x ?? 0) / naturalWidthToUncropped;\n  const croppedTop = (element.crop?.y ?? 0) / naturalHeightToUncropped;\n\n  /**\n   *      uncropped width\n   * *\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013*\n   * |     (x,y) (natural)    |\n   * |       *\u2013\u2013\u2013\u2013\u2013\u2013\u2013*        |\n   * |       |///////| height | uncropped height\n   * |       *\u2013\u2013\u2013\u2013\u2013\u2013\u2013*        |\n   * |    width (natural)     |\n   * *\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013*\n   */\n\n  const rotatedPointer = pointRotateRads(\n    pointFrom(pointerX, pointerY),\n    elementCenterPoint(element, elementsMap),\n    -element.angle as Radians,\n  );\n\n  pointerX = rotatedPointer[0];\n  pointerY = rotatedPointer[1];\n\n  let nextWidth = element.width;\n  let nextHeight = element.height;\n\n  let crop: ImageCrop | null = element.crop ?? {\n    x: 0,\n    y: 0,\n    width: naturalWidth,\n    height: naturalHeight,\n    naturalWidth,\n    naturalHeight,\n  };\n\n  const previousCropHeight = crop.height;\n  const previousCropWidth = crop.width;\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let changeInHeight = pointerY - element.y;\n  let changeInWidth = pointerX - element.x;\n\n  if (transformHandle.includes(\"n\")) {\n    nextHeight = clamp(\n      element.height - changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? uncroppedHeight - croppedTop : element.height + croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"s\")) {\n    changeInHeight = pointerY - element.y - element.height;\n    nextHeight = clamp(\n      element.height + changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? element.height + croppedTop : uncroppedHeight - croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"e\")) {\n    changeInWidth = pointerX - element.x - element.width;\n\n    nextWidth = clamp(\n      element.width + changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? element.width + croppedLeft : uncroppedWidth - croppedLeft,\n    );\n  }\n\n  if (transformHandle.includes(\"w\")) {\n    nextWidth = clamp(\n      element.width - changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? uncroppedWidth - croppedLeft : element.width + croppedLeft,\n    );\n  }\n\n  const updateCropWidthAndHeight = (crop: ImageCrop) => {\n    crop.height = nextHeight * naturalHeightToUncropped;\n    crop.width = nextWidth * naturalWidthToUncropped;\n  };\n\n  updateCropWidthAndHeight(crop);\n\n  const adjustFlipForHandle = (\n    handle: TransformHandleType,\n    crop: ImageCrop,\n  ) => {\n    updateCropWidthAndHeight(crop);\n    if (handle.includes(\"n\")) {\n      if (!isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"s\")) {\n      if (isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"e\")) {\n      if (isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n    if (handle.includes(\"w\")) {\n      if (!isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n  };\n\n  switch (transformHandle) {\n    case \"n\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"s\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"w\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"e\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"ne\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > -changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"nw\": {\n      if (widthAspectRatio) {\n        if (changeInWidth < changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"se\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"sw\": {\n      if (widthAspectRatio) {\n        if (-changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    default:\n      break;\n  }\n\n  const newOrigin = recomputeOrigin(\n    element,\n    transformHandle,\n    nextWidth,\n    nextHeight,\n    !!widthAspectRatio,\n  );\n\n  // reset crop to null if we're back to orig size\n  if (\n    isCloseTo(crop.width, crop.naturalWidth) &&\n    isCloseTo(crop.height, crop.naturalHeight)\n  ) {\n    crop = null;\n  }\n\n  return {\n    x: newOrigin[0],\n    y: newOrigin[1],\n    width: nextWidth,\n    height: nextHeight,\n    crop,\n  };\n};\n\nconst recomputeOrigin = (\n  stateAtCropStart: NonDeleted<ExcalidrawElement>,\n  transformHandle: TransformHandleType,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio?: boolean,\n) => {\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtCropStart,\n    stateAtCropStart.width,\n    stateAtCropStart.height,\n    true,\n  );\n  const startTopLeft = pointFrom(x1, y1);\n  const startBottomRight = pointFrom(x2, y2);\n  const startCenter: any = pointCenter(startTopLeft, startBottomRight);\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(stateAtCropStart, width, height, true);\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandle)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandle === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandle === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandle)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandle)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtCropStart.angle;\n  const rotatedTopLeft = pointRotateRads(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = pointRotateRads(newCenter, startCenter, angle);\n  newTopLeft = pointRotateRads(\n    rotatedTopLeft,\n    rotatedNewCenter,\n    -angle as Radians,\n  );\n\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtCropStart.x - newBoundsX1;\n  newOrigin[1] += stateAtCropStart.y - newBoundsY1;\n\n  return newOrigin;\n};\n\n// refer to https://link.excalidraw.com/l/6rfy1007QOo/6stx5PmRn0k\nexport const getUncroppedImageElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n) => {\n  if (element.crop) {\n    const { width, height } = getUncroppedWidthAndHeight(element);\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    const topLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topRightVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x2, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topEdgeNormalized = vectorNormalize(\n      vectorSubtract(topRightVector, topLeftVector),\n    );\n    const bottomLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y2), pointFrom(cx, cy), element.angle),\n    );\n    const leftEdgeVector = vectorSubtract(bottomLeftVector, topLeftVector);\n    const leftEdgeNormalized = vectorNormalize(leftEdgeVector);\n\n    const { cropX, cropY } = adjustCropPosition(element.crop, element.scale);\n\n    const rotatedTopLeft = vectorAdd(\n      vectorAdd(\n        topLeftVector,\n        vectorScale(\n          topEdgeNormalized,\n          (-cropX * width) / element.crop.naturalWidth,\n        ),\n      ),\n      vectorScale(\n        leftEdgeNormalized,\n        (-cropY * height) / element.crop.naturalHeight,\n      ),\n    );\n\n    const center = pointFromVector(\n      vectorAdd(\n        vectorAdd(rotatedTopLeft, vectorScale(topEdgeNormalized, width / 2)),\n        vectorScale(leftEdgeNormalized, height / 2),\n      ),\n    );\n\n    const unrotatedTopLeft = pointRotateRads(\n      pointFromVector(rotatedTopLeft),\n      center,\n      -element.angle as Radians,\n    );\n\n    const uncroppedElement: ExcalidrawImageElement = {\n      ...element,\n      x: unrotatedTopLeft[0],\n      y: unrotatedTopLeft[1],\n      width,\n      height,\n      crop: null,\n    };\n\n    return uncroppedElement;\n  }\n\n  return element;\n};\n\nexport const getUncroppedWidthAndHeight = (element: ExcalidrawImageElement) => {\n  if (element.crop) {\n    const width =\n      element.width / (element.crop.width / element.crop.naturalWidth);\n    const height =\n      element.height / (element.crop.height / element.crop.naturalHeight);\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  return {\n    width: element.width,\n    height: element.height,\n  };\n};\n\nconst adjustCropPosition = (\n  crop: ImageCrop,\n  scale: ExcalidrawImageElement[\"scale\"],\n) => {\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  const flipX = scale[0] === -1;\n  const flipY = scale[1] === -1;\n\n  if (flipX) {\n    cropX = crop.naturalWidth - Math.abs(cropX) - crop.width;\n  }\n\n  if (flipY) {\n    cropY = crop.naturalHeight - Math.abs(cropY) - crop.height;\n  }\n\n  return {\n    cropX,\n    cropY,\n  };\n};\n\nexport const getFlipAdjustedCropPosition = (\n  element: ExcalidrawImageElement,\n  natural = false,\n) => {\n  const crop = element.crop;\n  if (!crop) {\n    return null;\n  }\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  if (isFlippedByX) {\n    cropX = crop.naturalWidth - crop.width - crop.x;\n  }\n\n  if (isFlippedByY) {\n    cropY = crop.naturalHeight - crop.height - crop.y;\n  }\n\n  if (natural) {\n    return {\n      x: cropX,\n      y: cropY,\n    };\n  }\n\n  const { width, height } = getUncroppedWidthAndHeight(element);\n\n  return {\n    x: cropX / (crop.naturalWidth / width),\n    y: cropY / (crop.naturalHeight / height),\n  };\n};\n", "import {\n  pointCenter,\n  pointFrom,\n  pointRotateRads,\n  pointsEqual,\n  type GlobalPoint,\n  type LocalPoint,\n  pointDistance,\n  vectorFromPoint,\n  curveLength,\n  curvePointAtLength,\n  lineSegment,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport {\n  DRAGGING_THRESHOLD,\n  KEYS,\n  shouldRotateWithDiscreteAngle,\n  getGridPoint,\n  invariant,\n  isShallowEqual,\n  getFeatureFlag,\n} from \"@excalidraw/common\";\n\nimport {\n  deconstructLinearOrFreeDrawElement,\n  getSnapOutlineMidPoint,\n  isPathALoop,\n  moveArrowAboveBindable,\n  projectFixedPointOntoDiagonal,\n  type Store,\n} from \"@excalidraw/element\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  PointerCoords,\n  InteractiveCanvasAppState,\n  AppClassProperties,\n  NullableGridSize,\n  Zoom,\n} from \"@excalidraw/excalidraw/types\";\nimport type { Bounds } from \"@excalidraw/common\";\n\nimport {\n  calculateFixedPointForNonElbowArrowBinding,\n  getBindingStrategyForDraggingBindingElementEndpoints,\n  isBindingEnabled,\n  snapToMid,\n  updateBoundPoint,\n} from \"./binding\";\nimport {\n  getElementAbsoluteCoords,\n  getElementPointsCoords,\n  getMinMaxXYFromCurvePathOps,\n} from \"./bounds\";\n\nimport { headingIsHorizontal, vectorToHeading } from \"./heading\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport { isArrowElement, isBindingElement, isElbowArrow } from \"./typeChecks\";\n\nimport { ShapeCache, toggleLinePolygonState } from \"./shape\";\n\nimport { getLockedLinearCursorAlignSize } from \"./sizeHelpers\";\n\nimport { isLineElement } from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  ExcalidrawTextElementWithContainer,\n  ElementsMap,\n  NonDeletedSceneElementsMap,\n  FixedPointBinding,\n  FixedSegment,\n  ExcalidrawElbowArrowElement,\n  PointsPositionUpdates,\n  NonDeletedExcalidrawElement,\n  Ordered,\n  ExcalidrawBindableElement,\n} from \"./types\";\n\n/**\n * Normalizes line points so that the start point is at [0,0]. This is\n * expected in various parts of the codebase.\n *\n * Also returns the offsets - [0,0] if no normalization needed.\n *\n * @private\n */\nconst getNormalizedPoints = ({\n  points,\n}: {\n  points: ExcalidrawLinearElement[\"points\"];\n}): {\n  points: LocalPoint[];\n  offsetX: number;\n  offsetY: number;\n} => {\n  const offsetX = points[0][0];\n  const offsetY = points[0][1];\n\n  return {\n    points: points.map((p) => {\n      return pointFrom(p[0] - offsetX, p[1] - offsetY);\n    }),\n    offsetX,\n    offsetY,\n  };\n};\n\ntype PointMoveOtherUpdates = {\n  startBinding?: FixedPointBinding | null;\n  endBinding?: FixedPointBinding | null;\n  moveMidPointsWithElement?: boolean | null;\n  suggestedBinding?: AppState[\"suggestedBinding\"] | null;\n};\n\nexport class LinearElementEditor {\n  public readonly elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  /** indices */\n  public readonly selectedPointsIndices: readonly number[] | null;\n\n  public readonly initialState: Readonly<{\n    prevSelectedPointsIndices: readonly number[] | null;\n    /** index */\n    lastClickedPoint: number;\n    origin: Readonly<GlobalPoint> | null;\n    segmentMidpoint: {\n      value: GlobalPoint | null;\n      index: number | null;\n      added: boolean;\n    };\n    arrowStartIsInside: boolean;\n    altFocusPoint: Readonly<GlobalPoint> | null;\n  }>;\n\n  /** whether you're dragging a point */\n  public readonly isDragging: boolean;\n  public readonly lastUncommittedPoint: LocalPoint | null;\n  public readonly lastCommittedPoint: LocalPoint | null;\n  public readonly pointerOffset: Readonly<{ x: number; y: number }>;\n  public readonly hoverPointIndex: number;\n  public readonly segmentMidPointHoveredCoords: GlobalPoint | null;\n  public readonly hoveredFocusPointBinding: \"start\" | \"end\" | null;\n  public readonly draggedFocusPointBinding: \"start\" | \"end\" | null;\n  public readonly elbowed: boolean;\n  public readonly customLineAngle: number | null;\n  public readonly isEditing: boolean;\n\n  // @deprecated renamed to initialState because the data is used during linear\n  // element click creation as well (with multiple pointer down events)\n  // @ts-ignore\n  public readonly pointerDownState: never;\n\n  constructor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    isEditing: boolean = false,\n  ) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    if (!pointsEqual(element.points[0], pointFrom(0, 0))) {\n      console.error(\"Linear element is not normalized\", Error().stack);\n      mutateElement(\n        element,\n        elementsMap,\n        LinearElementEditor.getNormalizeElementPointsAndCoords(element),\n      );\n    }\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.lastCommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.initialState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      origin: null,\n\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false,\n      },\n      arrowStartIsInside: false,\n      altFocusPoint: null,\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n    this.hoveredFocusPointBinding = null;\n    this.draggedFocusPointBinding = null;\n    this.elbowed = isElbowArrow(element) && element.elbowed;\n    this.customLineAngle = null;\n    this.isEditing = isEditing;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 10;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement<T extends ExcalidrawLinearElement>(\n    id: InstanceType<typeof LinearElementEditor>[\"elementId\"],\n    elementsMap: ElementsMap,\n  ): T | null {\n    const element = elementsMap.get(id);\n    if (element) {\n      return element as NonDeleted<T>;\n    }\n    return null;\n  }\n\n  static handleBoxSelection(\n    event: PointerEvent,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    elementsMap: NonDeletedSceneElementsMap,\n  ) {\n    if (\n      !appState.selectedLinearElement?.isEditing ||\n      !appState.selectionElement\n    ) {\n      return false;\n    }\n    const { selectedLinearElement } = appState;\n    const { selectedPointsIndices, elementId } = selectedLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return false;\n    }\n\n    const [selectionX1, selectionY1, selectionX2, selectionY2] =\n      getElementAbsoluteCoords(appState.selectionElement, elementsMap);\n\n    const pointsSceneCoords = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    const nextSelectedPoints = pointsSceneCoords\n      .reduce((acc: number[], point, index) => {\n        if (\n          (point[0] >= selectionX1 &&\n            point[0] <= selectionX2 &&\n            point[1] >= selectionY1 &&\n            point[1] <= selectionY2) ||\n          (event.shiftKey && selectedPointsIndices?.includes(index))\n        ) {\n          acc.push(index);\n        }\n\n        return acc;\n      }, [])\n      .filter((index) => {\n        if (\n          isElbowArrow(element) &&\n          index !== 0 &&\n          index !== element.points.length - 1\n        ) {\n          return false;\n        }\n        return true;\n      });\n\n    setState({\n      selectedLinearElement: {\n        ...selectedLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length\n          ? nextSelectedPoints\n          : null,\n      },\n    });\n  }\n\n  static handlePointerMove(\n    event: PointerEvent,\n    app: AppClassProperties,\n    scenePointerX: number,\n    scenePointerY: number,\n    linearElementEditor: LinearElementEditor,\n  ): Pick<AppState, \"suggestedBinding\" | \"selectedLinearElement\"> | null {\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const elements = app.scene.getNonDeletedElements();\n    const { elementId } = linearElementEditor;\n\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    invariant(element, \"Element being dragged must exist in the scene\");\n    invariant(element.points.length > 1, \"Element must have at least 2 points\");\n\n    const idx = element.points.length - 1;\n    const point = element.points[idx];\n    const pivotPoint = element.points[idx - 1];\n    const customLineAngle =\n      linearElementEditor.customLineAngle ??\n      determineCustomLinearAngle(pivotPoint, element.points[idx]);\n\n    // Determine if point movement should happen and how much\n    let deltaX = 0;\n    let deltaY = 0;\n    if (shouldRotateWithDiscreteAngle(event)) {\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        elementsMap,\n        pivotPoint,\n        pointFrom(scenePointerX, scenePointerY),\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n        customLineAngle,\n      );\n      const target = pointFrom<LocalPoint>(\n        width + pivotPoint[0],\n        height + pivotPoint[1],\n      );\n\n      deltaX = target[0] - point[0];\n      deltaY = target[1] - point[1];\n    } else {\n      const newDraggingPointPosition = LinearElementEditor.createPointAt(\n        element,\n        elementsMap,\n        scenePointerX - linearElementEditor.pointerOffset.x,\n        scenePointerY - linearElementEditor.pointerOffset.y,\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n      );\n      deltaX = newDraggingPointPosition[0] - point[0];\n      deltaY = newDraggingPointPosition[1] - point[1];\n    }\n\n    // Apply the point movement if needed\n    let suggestedBinding: AppState[\"suggestedBinding\"] = null;\n    const { positions, updates } = pointDraggingUpdates(\n      [idx],\n      deltaX,\n      deltaY,\n      scenePointerX,\n      scenePointerY,\n      elementsMap,\n      element,\n      elements,\n      app,\n      shouldRotateWithDiscreteAngle(event),\n      event.altKey,\n      linearElementEditor,\n    );\n\n    LinearElementEditor.movePoints(element, app.scene, positions, {\n      startBinding: updates?.startBinding,\n      endBinding: updates?.endBinding,\n      moveMidPointsWithElement: updates?.moveMidPointsWithElement,\n    });\n    // Set the suggested binding from the updates if available\n    if (isBindingElement(element, false)) {\n      if (isBindingEnabled(app.state)) {\n        suggestedBinding = updates?.suggestedBinding ?? null;\n      }\n    }\n\n    // Move the arrow over the bindable object in terms of z-index\n    if (isBindingElement(element)) {\n      moveArrowAboveBindable(\n        LinearElementEditor.getPointGlobalCoordinates(\n          element,\n          element.points[element.points.length - 1],\n          elementsMap,\n        ),\n        element,\n        elements,\n        elementsMap,\n        app.scene,\n      );\n    }\n\n    // PERF: Avoid state updates if not absolutely necessary\n    if (\n      app.state.selectedLinearElement?.customLineAngle === customLineAngle &&\n      linearElementEditor.initialState.altFocusPoint &&\n      (!suggestedBinding ||\n        isShallowEqual(app.state.suggestedBinding ?? [], suggestedBinding))\n    ) {\n      return null;\n    }\n\n    const startBindingElement =\n      isBindingElement(element) &&\n      element.startBinding &&\n      (elementsMap.get(\n        element.startBinding.elementId,\n      ) as ExcalidrawBindableElement | null);\n    const newLinearElementEditor = {\n      ...linearElementEditor,\n      customLineAngle,\n      initialState: {\n        ...linearElementEditor.initialState,\n        altFocusPoint:\n          !linearElementEditor.initialState.altFocusPoint &&\n          startBindingElement &&\n          updates?.suggestedBinding?.element.id !== startBindingElement.id\n            ? projectFixedPointOntoDiagonal(\n                element,\n                pointFrom<GlobalPoint>(element.x, element.y),\n                startBindingElement,\n                \"start\",\n                elementsMap,\n                app.state.zoom,\n              )\n            : linearElementEditor.initialState.altFocusPoint,\n      },\n    };\n\n    return {\n      selectedLinearElement: newLinearElementEditor,\n      suggestedBinding,\n    };\n  }\n\n  static handlePointDragging(\n    event: PointerEvent,\n    app: AppClassProperties,\n    scenePointerX: number,\n    scenePointerY: number,\n    linearElementEditor: LinearElementEditor,\n  ): Pick<AppState, \"suggestedBinding\" | \"selectedLinearElement\"> | null {\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const elements = app.scene.getNonDeletedElements();\n    const { elbowed, elementId, initialState } = linearElementEditor;\n    const selectedPointsIndices = Array.from(\n      linearElementEditor.selectedPointsIndices ?? [],\n    );\n    let { lastClickedPoint } = initialState;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    invariant(element, \"Element being dragged must exist in the scene\");\n\n    invariant(element.points.length > 1, \"Element must have at least 2 points\");\n\n    invariant(\n      selectedPointsIndices,\n      \"There must be selected points in order to drag them\",\n    );\n\n    if (elbowed) {\n      selectedPointsIndices.some((pointIdx, idx) => {\n        if (pointIdx > 0 && pointIdx !== element.points.length - 1) {\n          selectedPointsIndices[idx] = element.points.length - 1;\n          lastClickedPoint = element.points.length - 1;\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    invariant(\n      lastClickedPoint > -1 &&\n        selectedPointsIndices.includes(lastClickedPoint) &&\n        element.points[lastClickedPoint],\n      `There must be a valid lastClickedPoint in order to drag it. selectedPointsIndices(${JSON.stringify(\n        selectedPointsIndices,\n      )}) points(0..${\n        element.points.length - 1\n      }) lastClickedPoint(${lastClickedPoint})`,\n    );\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[lastClickedPoint];\n    // The adjacent point to the one dragged point\n    const pivotPoint =\n      element.points[lastClickedPoint === 0 ? 1 : lastClickedPoint - 1];\n    const singlePointDragged = selectedPointsIndices.length === 1;\n    const customLineAngle =\n      linearElementEditor.customLineAngle ??\n      determineCustomLinearAngle(pivotPoint, element.points[lastClickedPoint]);\n    const startIsSelected = selectedPointsIndices.includes(0);\n    const endIsSelected = selectedPointsIndices.includes(\n      element.points.length - 1,\n    );\n\n    // Determine if point movement should happen and how much\n    let deltaX = 0;\n    let deltaY = 0;\n    if (shouldRotateWithDiscreteAngle(event) && singlePointDragged) {\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        elementsMap,\n        pivotPoint,\n        pointFrom(scenePointerX, scenePointerY),\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n        customLineAngle,\n      );\n      const target = pointFrom<LocalPoint>(\n        width + pivotPoint[0],\n        height + pivotPoint[1],\n      );\n      deltaX = target[0] - draggingPoint[0];\n      deltaY = target[1] - draggingPoint[1];\n    } else {\n      const newDraggingPointPosition = LinearElementEditor.createPointAt(\n        element,\n        elementsMap,\n        scenePointerX - linearElementEditor.pointerOffset.x,\n        scenePointerY - linearElementEditor.pointerOffset.y,\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n      );\n      deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n      deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n    }\n\n    // Apply the point movement if needed\n    let suggestedBinding: AppState[\"suggestedBinding\"] = null;\n    const { positions, updates } = pointDraggingUpdates(\n      selectedPointsIndices,\n      deltaX,\n      deltaY,\n      scenePointerX,\n      scenePointerY,\n      elementsMap,\n      element,\n      elements,\n      app,\n      shouldRotateWithDiscreteAngle(event) && singlePointDragged,\n      event.altKey,\n      linearElementEditor,\n    );\n\n    LinearElementEditor.movePoints(element, app.scene, positions, {\n      startBinding: updates?.startBinding,\n      endBinding: updates?.endBinding,\n      moveMidPointsWithElement: updates?.moveMidPointsWithElement,\n    });\n\n    // Set the suggested binding from the updates if available\n    if (isBindingElement(element, false)) {\n      if (isBindingEnabled(app.state) && (startIsSelected || endIsSelected)) {\n        suggestedBinding = updates?.suggestedBinding ?? null;\n      }\n    }\n\n    // Move the arrow over the bindable object in terms of z-index\n    if (isBindingElement(element) && startIsSelected !== endIsSelected) {\n      moveArrowAboveBindable(\n        LinearElementEditor.getPointGlobalCoordinates(\n          element,\n          startIsSelected\n            ? element.points[0]\n            : element.points[element.points.length - 1],\n          elementsMap,\n        ),\n        element,\n        elements,\n        elementsMap,\n        app.scene,\n      );\n    }\n\n    // Attached text might need to update if arrow dimensions change\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      handleBindTextResize(element, app.scene, false);\n    }\n\n    // Update selected points for elbow arrows because elbow arrows add and\n    // remove points as they route\n    const newSelectedPointsIndices = elbowed\n      ? endIsSelected\n        ? [element.points.length - 1]\n        : [0]\n      : selectedPointsIndices;\n\n    const newLastClickedPoint = elbowed\n      ? newSelectedPointsIndices[0]\n      : lastClickedPoint;\n\n    const newSelectedMidPointHoveredCoords =\n      !startIsSelected && !endIsSelected\n        ? LinearElementEditor.getPointGlobalCoordinates(\n            element,\n            draggingPoint,\n            elementsMap,\n          )\n        : null;\n\n    const newHoverPointIndex = newLastClickedPoint;\n    const startBindingElement =\n      isBindingElement(element) &&\n      element.startBinding &&\n      (elementsMap.get(\n        element.startBinding.elementId,\n      ) as ExcalidrawBindableElement | null);\n    const endBindingElement =\n      isBindingElement(element) &&\n      element.endBinding &&\n      (elementsMap.get(\n        element.endBinding.elementId,\n      ) as ExcalidrawBindableElement | null);\n    const altFocusPointBindableElement =\n      endIsSelected && // The \"other\" end (i.e. \"end\") is dragged\n      startBindingElement &&\n      updates?.suggestedBinding?.element.id !== startBindingElement.id // The end point is not hovering the start bindable + it's binding gap\n        ? startBindingElement\n        : startIsSelected && // The \"other\" end (i.e. \"start\") is dragged\n          endBindingElement &&\n          updates?.suggestedBinding?.element.id !== endBindingElement.id // The start point is not hovering the end bindable + it's binding gap\n        ? endBindingElement\n        : null;\n\n    const newLinearElementEditor: LinearElementEditor = {\n      ...linearElementEditor,\n      selectedPointsIndices: newSelectedPointsIndices,\n      initialState: {\n        ...linearElementEditor.initialState,\n        lastClickedPoint: newLastClickedPoint,\n        altFocusPoint:\n          !linearElementEditor.initialState.altFocusPoint && // We only set it once per arrow drag\n          isBindingElement(element) &&\n          altFocusPointBindableElement\n            ? projectFixedPointOntoDiagonal(\n                element,\n                pointFrom<GlobalPoint>(element.x, element.y),\n                altFocusPointBindableElement,\n                \"start\",\n                elementsMap,\n                app.state.zoom,\n              )\n            : linearElementEditor.initialState.altFocusPoint,\n      },\n      segmentMidPointHoveredCoords: newSelectedMidPointHoveredCoords,\n      hoverPointIndex: newHoverPointIndex,\n      isDragging: true,\n      customLineAngle,\n    };\n\n    return {\n      selectedLinearElement: newLinearElementEditor,\n      suggestedBinding,\n    };\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n    scene: Scene,\n  ): LinearElementEditor {\n    const elementsMap = scene.getNonDeletedElementsMap();\n\n    const {\n      elementId,\n      selectedPointsIndices,\n      isDragging,\n      initialState: pointerDownState,\n    } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (\n          selectedPoint === 0 ||\n          selectedPoint === element.points.length - 1\n        ) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            if (isLineElement(element)) {\n              scene.mutateElement(\n                element,\n                {\n                  ...toggleLinePolygonState(element, true),\n                },\n                {\n                  informMutation: false,\n                  isDragging: false,\n                },\n              );\n            }\n            LinearElementEditor.movePoints(\n              element,\n              scene,\n              new Map([\n                [\n                  selectedPoint,\n                  {\n                    point:\n                      selectedPoint === 0\n                        ? element.points[element.points.length - 1]\n                        : element.points[0],\n                  },\n                ],\n              ]),\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      ...editingLinearElement,\n      segmentMidPointHoveredCoords: null,\n      hoverPointIndex: -1,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices:\n        isDragging || event.shiftKey\n          ? !isDragging &&\n            event.shiftKey &&\n            pointerDownState.prevSelectedPointsIndices?.includes(\n              pointerDownState.lastClickedPoint,\n            )\n            ? selectedPointsIndices &&\n              selectedPointsIndices.filter(\n                (pointIndex) =>\n                  pointIndex !== pointerDownState.lastClickedPoint,\n              )\n            : selectedPointsIndices\n          : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint)\n          ? [pointerDownState.lastClickedPoint]\n          : selectedPointsIndices,\n      isDragging: false,\n      customLineAngle: null,\n      initialState: {\n        ...editingLinearElement.initialState,\n        origin: null,\n        arrowStartIsInside: false,\n      },\n    };\n  }\n\n  static getEditorMidPoints = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    appState: InteractiveCanvasAppState,\n  ): (GlobalPoint | null)[] => {\n    const boundText = getBoundTextElement(element, elementsMap);\n\n    // Since its not needed outside editor unless 2 pointer lines or bound text\n    if (\n      !isElbowArrow(element) &&\n      !appState.selectedLinearElement?.isEditing &&\n      element.points.length > 2 &&\n      !boundText\n    ) {\n      return [];\n    }\n\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    let index = 0;\n    const midpoints: (GlobalPoint | null)[] = [];\n    while (index < points.length - 1) {\n      if (\n        LinearElementEditor.isSegmentTooShort(\n          element,\n          element.points[index],\n          element.points[index + 1],\n          index,\n          appState.zoom,\n        )\n      ) {\n        midpoints.push(null);\n        index++;\n        continue;\n      }\n      const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n      midpoints.push(segmentMidPoint);\n      index++;\n    }\n\n    return midpoints;\n  };\n\n  static getSegmentMidpointHitCoords = (\n    linearElementEditor: LinearElementEditor,\n    scenePointer: { x: number; y: number },\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ): GlobalPoint | null => {\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return null;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (!isElbowArrow(element) && clickedPointIndex >= 0) {\n      return null;\n    }\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (\n      points.length >= 3 &&\n      !appState.selectedLinearElement?.isEditing &&\n      !isElbowArrow(element)\n    ) {\n      return null;\n    }\n\n    const threshold =\n      (LinearElementEditor.POINT_HANDLE_SIZE + 1) / appState.zoom.value;\n\n    const existingSegmentMidpointHitCoords =\n      linearElementEditor.segmentMidPointHoveredCoords;\n    if (existingSegmentMidpointHitCoords) {\n      const distance = pointDistance(\n        pointFrom(\n          existingSegmentMidpointHitCoords[0],\n          existingSegmentMidpointHitCoords[1],\n        ),\n        pointFrom(scenePointer.x, scenePointer.y),\n      );\n      if (distance <= threshold) {\n        return existingSegmentMidpointHitCoords;\n      }\n    }\n    let index = 0;\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n\n    while (index < midPoints.length) {\n      if (midPoints[index] !== null) {\n        const distance = pointDistance(\n          midPoints[index]!,\n          pointFrom(scenePointer.x, scenePointer.y),\n        );\n        if (distance <= threshold) {\n          return midPoints[index];\n        }\n      }\n\n      index++;\n    }\n    return null;\n  };\n\n  static isSegmentTooShort<P extends GlobalPoint | LocalPoint>(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: P,\n    endPoint: P,\n    index: number,\n    zoom: Zoom,\n  ) {\n    if (isElbowArrow(element)) {\n      if (index >= 0 && index < element.points.length) {\n        return (\n          pointDistance(startPoint, endPoint) * zoom.value <\n          LinearElementEditor.POINT_HANDLE_SIZE / 2\n        );\n      }\n\n      return false;\n    }\n\n    let distance = pointDistance(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n      invariant(\n        lines.length === 0 && curves.length > 0,\n        \"Only linears built out of curves are supported\",\n      );\n      invariant(\n        lines.length + curves.length >= index,\n        \"Invalid segment index while calculating mid point\",\n      );\n\n      distance = curveLength<GlobalPoint>(curves[index]);\n    }\n\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n\n  static getSegmentMidPoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    index: number,\n  ): GlobalPoint {\n    if (isElbowArrow(element)) {\n      invariant(\n        element.points.length >= index,\n        \"Invalid segment index while calculating elbow arrow mid point\",\n      );\n\n      const p = pointCenter(element.points[index - 1], element.points[index]);\n\n      return pointFrom<GlobalPoint>(element.x + p[0], element.y + p[1]);\n    }\n\n    const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n    invariant(\n      (lines.length === 0 && curves.length > 0) ||\n        (lines.length > 0 && curves.length === 0),\n      \"Only linears built out of either segments or curves are supported\",\n    );\n    invariant(\n      lines.length + curves.length >= index,\n      \"Invalid segment index while calculating mid point\",\n    );\n\n    if (lines.length) {\n      const segment = lines[index - 1];\n      return pointCenter(segment[0], segment[1]);\n    }\n\n    if (curves.length) {\n      const segment = curves[index - 1];\n      return curvePointAtLength(segment, 0.5);\n    }\n\n    invariant(false, \"Invalid segment type while calculating mid point\");\n  }\n\n  static getSegmentMidPointIndex(\n    linearElementEditor: LinearElementEditor,\n    appState: AppState,\n    midPoint: GlobalPoint,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLElement>,\n    app: AppClassProperties,\n    store: Store,\n    scenePointer: { x: number; y: number },\n    linearElementEditor: LinearElementEditor,\n    scene: Scene,\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n    linearElementEditor: LinearElementEditor | null;\n  } {\n    const appState = app.state;\n    const elementsMap = scene.getNonDeletedElementsMap();\n\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null,\n    };\n\n    if (!linearElementEditor) {\n      return ret;\n    }\n\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    if (!element) {\n      return ret;\n    }\n\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(\n      linearElementEditor,\n      scenePointer,\n      appState,\n      elementsMap,\n    );\n    const point = pointFrom<GlobalPoint>(scenePointer.x, scenePointer.y);\n    let segmentMidpointIndex = null;\n\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(\n        linearElementEditor,\n        appState,\n        segmentMidpoint,\n        elementsMap,\n      );\n    } else if (event.altKey && appState.selectedLinearElement?.isEditing) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        scene.mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              elementsMap,\n              scenePointer.x,\n              scenePointer.y,\n              event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n            ),\n          ],\n        });\n        ret.didAddPoint = true;\n      }\n      store.scheduleCapture();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        initialState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          origin: point,\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false,\n          },\n          arrowStartIsInside:\n            !!app.state.newElement &&\n            (app.state.bindMode === \"inside\" || app.state.bindMode === \"skip\"),\n          altFocusPoint: null,\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n      };\n\n      ret.didAddPoint = true;\n\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      pointRotateRads(\n        pointFrom(\n          element.x + element.points[clickedPointIndex][0],\n          element.y + element.points[clickedPointIndex][1],\n        ),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n\n    const nextSelectedPointsIndices =\n      clickedPointIndex > -1 || event.shiftKey\n        ? event.shiftKey ||\n          linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex)\n          ? normalizeSelectedPoints([\n              ...(linearElementEditor.selectedPointsIndices || []),\n              clickedPointIndex,\n            ])\n          : [clickedPointIndex]\n        : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      initialState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        origin: point,\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false,\n        },\n        arrowStartIsInside:\n          !!app.state.newElement &&\n          (app.state.bindMode === \"inside\" || app.state.bindMode === \"skip\"),\n        altFocusPoint: null,\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint\n        ? {\n            x: scenePointer.x - targetPoint[0],\n            y: scenePointer.y - targetPoint[1],\n          }\n        : { x: 0, y: 0 },\n    };\n\n    return ret;\n  }\n\n  static arePointsEqual<Point extends LocalPoint | GlobalPoint>(\n    point1: Point | null,\n    point2: Point | null,\n  ) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return pointsEqual(point1, point2);\n  }\n\n  static handlePointerMoveInEditMode(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    app: AppClassProperties,\n  ): LinearElementEditor | null {\n    const appState = app.state;\n    if (!appState.selectedLinearElement?.isEditing) {\n      return null;\n    }\n    const { elementId, lastUncommittedPoint } = appState.selectedLinearElement;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return appState.selectedLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, app, [points.length - 1]);\n      }\n      return appState.selectedLinearElement?.lastUncommittedPoint\n        ? {\n            ...appState.selectedLinearElement,\n            lastUncommittedPoint: null,\n          }\n        : appState.selectedLinearElement;\n    }\n\n    let newPoint: LocalPoint;\n\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const anchor = points[points.length - 2];\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        elementsMap,\n        anchor,\n        pointFrom(scenePointerX, scenePointerY),\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n      );\n\n      newPoint = pointFrom(width + anchor[0], height + anchor[1]);\n    } else {\n      newPoint = LinearElementEditor.createPointAt(\n        element,\n        elementsMap,\n        scenePointerX - appState.selectedLinearElement.pointerOffset.x,\n        scenePointerY - appState.selectedLinearElement.pointerOffset.y,\n        event[KEYS.CTRL_OR_CMD] || isElbowArrow(element)\n          ? null\n          : app.getEffectiveGridSize(),\n      );\n    }\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(\n        element,\n        app.scene,\n        new Map([\n          [\n            element.points.length - 1,\n            {\n              point: newPoint,\n            },\n          ],\n        ]),\n      );\n    } else {\n      LinearElementEditor.addPoints(element, app.scene, [newPoint]);\n    }\n    return {\n      ...appState.selectedLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    p: LocalPoint,\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const { x, y } = element;\n    return pointRotateRads(\n      pointFrom(x + p[0], y + p[1]),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n  ): GlobalPoint[] {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((p) => {\n      const { x, y } = element;\n      return pointRotateRads(\n        pointFrom(x + p[0], y + p[1]),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n    const center = pointFrom<GlobalPoint>(cx, cy);\n    const p = element.points[index];\n    const { x, y } = element;\n\n    return p\n      ? pointRotateRads(\n          pointFrom<GlobalPoint>(x + p[0], y + p[1]),\n          center,\n          element.angle,\n        )\n      : pointRotateRads(pointFrom<GlobalPoint>(x, y), center, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: GlobalPoint,\n    elementsMap: ElementsMap,\n  ): LocalPoint {\n    if (isElbowArrow(element)) {\n      // No rotation for elbow arrows\n      return pointFrom(\n        absoluteCoords[0] - element.x,\n        absoluteCoords[1] - element.y,\n      );\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = pointRotateRads(\n      pointFrom(absoluteCoords[0], absoluteCoords[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n    return pointFrom(x - element.x, y - element.y);\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const p = pointHandles[idx];\n      if (\n        pointDistance(pointFrom(x, y), pointFrom(p[0], p[1])) * zoom.value <\n        // +1px to account for outline stroke\n        LinearElementEditor.POINT_HANDLE_SIZE + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: NullableGridSize,\n  ): LocalPoint {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = pointRotateRads(\n      pointFrom(pointerOnGrid[0], pointerOnGrid[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n\n    return pointFrom(rotatedX - element.x, rotatedY - element.y);\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase.\n   *\n   * Also returns normalized x and y coords to account for the normalization\n   * of the points.\n   */\n  static getNormalizeElementPointsAndCoords(element: ExcalidrawLinearElement) {\n    const { points, offsetX, offsetY } = getNormalizedPoints(element);\n\n    return {\n      points,\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n  static duplicateSelectedPoints(appState: AppState, scene: Scene): AppState {\n    invariant(\n      appState.selectedLinearElement?.isEditing,\n      \"Not currently editing a linear element\",\n    );\n\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const { selectedPointsIndices, elementId } = appState.selectedLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    invariant(\n      element,\n      \"The linear element does not exist in the provided Scene\",\n    );\n    invariant(\n      selectedPointsIndices != null,\n      \"There are no selected points to duplicate\",\n    );\n\n    const { points } = element;\n\n    const nextSelectedIndices: number[] = [];\n\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc: LocalPoint[], p, index) => {\n      ++indexCursor;\n      acc.push(p);\n\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(\n          nextPoint\n            ? pointFrom((p[0] + nextPoint[0]) / 2, (p[1] + nextPoint[1]) / 2)\n            : pointFrom(p[0], p[1]),\n        );\n\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n\n      return acc;\n    }, []);\n\n    scene.mutateElement(element, { points: nextPoints });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(\n        element,\n        scene,\n        new Map([\n          [\n            element.points.length - 1,\n            { point: pointFrom(lastPoint[0] + 30, lastPoint[1] + 30) },\n          ],\n        ]),\n      );\n    }\n\n    return {\n      ...appState,\n      selectedLinearElement: {\n        ...appState.selectedLinearElement,\n        selectedPointsIndices: nextSelectedIndices,\n      },\n    };\n  }\n\n  static deletePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    app: AppClassProperties,\n    pointIndices: readonly number[],\n  ) {\n    const isUncommittedPoint =\n      app.state.selectedLinearElement?.isEditing &&\n      app.state.selectedLinearElement?.lastUncommittedPoint ===\n        element.points[element.points.length - 1];\n\n    const nextPoints = element.points.filter((_, idx) => {\n      return !pointIndices.includes(idx);\n    });\n\n    const isPolygon = isLineElement(element) && element.polygon;\n\n    // keep polygon intact if deleting start/end point or uncommitted point\n    if (\n      isPolygon &&\n      (isUncommittedPoint ||\n        pointIndices.includes(0) ||\n        pointIndices.includes(element.points.length - 1))\n    ) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      app.scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static addPoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    addedPoints: LocalPoint[],\n  ) {\n    const nextPoints = [...element.points, ...addedPoints];\n\n    if (isLineElement(element) && element.polygon) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static movePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    pointUpdates: PointsPositionUpdates,\n    otherUpdates?: {\n      startBinding?: FixedPointBinding | null;\n      endBinding?: FixedPointBinding | null;\n      moveMidPointsWithElement?: boolean | null;\n    },\n  ) {\n    const { points } = element;\n\n    // if polygon, move start and end points together\n    if (isLineElement(element) && element.polygon) {\n      const firstPointUpdate = pointUpdates.get(0);\n      const lastPointUpdate = pointUpdates.get(points.length - 1);\n\n      if (firstPointUpdate) {\n        pointUpdates.set(points.length - 1, {\n          point: pointFrom(\n            firstPointUpdate.point[0],\n            firstPointUpdate.point[1],\n          ),\n          isDragging: firstPointUpdate.isDragging,\n        });\n      } else if (lastPointUpdate) {\n        pointUpdates.set(0, {\n          point: pointFrom(lastPointUpdate.point[0], lastPointUpdate.point[1]),\n          isDragging: lastPointUpdate.isDragging,\n        });\n      }\n    }\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n\n    const updatedOriginPoint =\n      pointUpdates.get(0)?.point ?? pointFrom<LocalPoint>(0, 0);\n\n    const [offsetX, offsetY] = updatedOriginPoint;\n\n    const nextPoints = isElbowArrow(element)\n      ? [\n          pointUpdates.get(0)?.point ?? points[0],\n          pointUpdates.get(points.length - 1)?.point ??\n            points[points.length - 1],\n        ]\n      : points.map((p, idx) => {\n          const current = pointUpdates.get(idx)?.point ?? p;\n\n          if (\n            otherUpdates?.moveMidPointsWithElement &&\n            idx !== 0 &&\n            idx !== points.length - 1 &&\n            !pointUpdates.has(idx)\n          ) {\n            return current;\n          }\n\n          return pointFrom<LocalPoint>(\n            current[0] - offsetX,\n            current[1] - offsetY,\n          );\n        });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      nextPoints,\n      offsetX,\n      offsetY,\n      otherUpdates,\n      {\n        isDragging: Array.from(pointUpdates.values()).some((t) => t.isDragging),\n      },\n    );\n  }\n\n  static shouldAddMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n\n    // Elbow arrows don't allow midpoints\n    if (element && isElbowArrow(element)) {\n      return false;\n    }\n\n    if (!element) {\n      return false;\n    }\n\n    const { segmentMidpoint } = linearElementEditor.initialState;\n\n    if (\n      segmentMidpoint.added ||\n      segmentMidpoint.value === null ||\n      segmentMidpoint.index === null ||\n      linearElementEditor.initialState.origin === null\n    ) {\n      return false;\n    }\n\n    const origin = linearElementEditor.initialState.origin!;\n    const dist = pointDistance(\n      origin,\n      pointFrom(pointerCoords.x, pointerCoords.y),\n    );\n    if (\n      !appState.selectedLinearElement?.isEditing &&\n      dist < DRAGGING_THRESHOLD / appState.zoom.value\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  static addMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    app: AppClassProperties,\n    snapToGrid: boolean,\n    scene: Scene,\n  ) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return;\n    }\n    const { segmentMidpoint } = linearElementEditor.initialState;\n    const ret: {\n      pointerDownState: LinearElementEditor[\"initialState\"];\n      selectedPointsIndices: LinearElementEditor[\"selectedPointsIndices\"];\n    } = {\n      pointerDownState: linearElementEditor.initialState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices,\n    };\n\n    const midpoint = LinearElementEditor.createPointAt(\n      element,\n      elementsMap,\n      pointerCoords.x,\n      pointerCoords.y,\n      snapToGrid && !isElbowArrow(element) ? app.getEffectiveGridSize() : null,\n    );\n    const points = [\n      ...element.points.slice(0, segmentMidpoint.index!),\n      midpoint,\n      ...element.points.slice(segmentMidpoint.index!),\n    ];\n\n    scene.mutateElement(element, { points });\n\n    ret.pointerDownState = {\n      ...linearElementEditor.initialState,\n      segmentMidpoint: {\n        ...linearElementEditor.initialState.segmentMidpoint,\n        added: true,\n      },\n      lastClickedPoint: segmentMidpoint.index!,\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index!];\n    return ret;\n  }\n\n  private static _updatePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    nextPoints: readonly LocalPoint[],\n    offsetX: number,\n    offsetY: number,\n    otherUpdates?: {\n      startBinding?: FixedPointBinding | null;\n      endBinding?: FixedPointBinding | null;\n    },\n    options?: {\n      isDragging?: boolean;\n      zoom?: AppState[\"zoom\"];\n      sceneElementsMap?: NonDeletedSceneElementsMap;\n    },\n  ) {\n    if (isElbowArrow(element)) {\n      const updates: {\n        startBinding?: FixedPointBinding | null;\n        endBinding?: FixedPointBinding | null;\n        points?: LocalPoint[];\n      } = {};\n      if (otherUpdates?.startBinding !== undefined) {\n        updates.startBinding = otherUpdates.startBinding;\n      }\n      if (otherUpdates?.endBinding !== undefined) {\n        updates.endBinding = otherUpdates.endBinding;\n      }\n\n      updates.points = Array.from(nextPoints);\n\n      scene.mutateElement(element, updates, {\n        informMutation: true,\n        isDragging: options?.isDragging ?? false,\n      });\n    } else {\n      // TODO do we need to get precise coords here just to calc centers?\n      const nextCoords = getElementPointsCoords(element, nextPoints);\n      const prevCoords = getElementPointsCoords(element, element.points);\n      const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n      const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n      const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n      const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n      const dX = prevCenterX - nextCenterX;\n      const dY = prevCenterY - nextCenterY;\n      const rotatedOffset = pointRotateRads(\n        pointFrom(offsetX, offsetY),\n        pointFrom(dX, dY),\n        element.angle,\n      );\n      scene.mutateElement(element, {\n        ...otherUpdates,\n        points: nextPoints,\n        x: element.x + rotatedOffset[0],\n        y: element.y + rotatedOffset[1],\n      });\n    }\n  }\n\n  private static _getShiftLockedDelta(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    referencePoint: LocalPoint,\n    scenePointer: GlobalPoint,\n    gridSize: NullableGridSize,\n    customLineAngle?: number,\n  ) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(\n      element,\n      referencePoint,\n      elementsMap,\n    );\n\n    if (isElbowArrow(element)) {\n      return [\n        scenePointer[0] - referencePointCoords[0],\n        scenePointer[1] - referencePointCoords[1],\n      ];\n    }\n\n    const [gridX, gridY] = getGridPoint(\n      scenePointer[0],\n      scenePointer[1],\n      gridSize,\n    );\n\n    const { width, height } = getLockedLinearCursorAlignSize(\n      referencePointCoords[0],\n      referencePointCoords[1],\n      gridX,\n      gridY,\n      customLineAngle,\n    );\n\n    return pointRotateRads(\n      pointFrom(width, height),\n      pointFrom(0, 0),\n      -element.angle as Radians,\n    );\n  }\n\n  static getBoundTextElementPosition = (\n    element: ExcalidrawLinearElement,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n    elementsMap: ElementsMap,\n  ): { x: number; y: number } => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (points.length < 2) {\n      mutateElement(boundTextElement, elementsMap, { isDeleted: true });\n    }\n    let x = 0;\n    let y = 0;\n    if (element.points.length % 2 === 1) {\n      const index = Math.floor(element.points.length / 2);\n      const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n        element,\n        element.points[index],\n        elementsMap,\n      );\n      x = midPoint[0] - boundTextElement.width / 2;\n      y = midPoint[1] - boundTextElement.height / 2;\n    } else {\n      const index = element.points.length / 2 - 1;\n      const midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n\n      x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n      y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n    }\n    return { x, y };\n  };\n\n  static getMinMaxXYWithBoundText = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    elementBounds: Bounds,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): [number, number, number, number, number, number] => {\n    let [x1, y1, x2, y2] = elementBounds;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const { x: boundTextX1, y: boundTextY1 } =\n      LinearElementEditor.getBoundTextElementPosition(\n        element,\n        boundTextElement,\n        elementsMap,\n      );\n    const boundTextX2 = boundTextX1 + boundTextElement.width;\n    const boundTextY2 = boundTextY1 + boundTextElement.height;\n    const centerPoint = pointFrom(cx, cy);\n\n    const topLeftRotatedPoint = pointRotateRads(\n      pointFrom(x1, y1),\n      centerPoint,\n      element.angle,\n    );\n    const topRightRotatedPoint = pointRotateRads(\n      pointFrom(x2, y1),\n      centerPoint,\n      element.angle,\n    );\n\n    const counterRotateBoundTextTopLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextTopRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n\n    if (\n      topLeftRotatedPoint[0] < topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] >= topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextBottomRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n    } else if (\n      topLeftRotatedPoint[0] >= topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] > topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopLeft[0],\n          counterRotateBoundTextTopRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n      x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n      x1 = Math.min(\n        x1,\n        Math.min(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextTopLeft[0],\n        ),\n      );\n\n      x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n      y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static getElementAbsoluteCoords = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    includeBoundText: boolean = false,\n  ): [number, number, number, number, number, number] => {\n    const shape = ShapeCache.generateElementShape(element, null);\n\n    // first element is always the curve\n    const ops = getCurvePathOps(shape[0]);\n\n    const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n    const x1 = minX + element.x;\n    const y1 = minY + element.y;\n    const x2 = maxX + element.x;\n    const y2 = maxY + element.y;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const boundTextElement =\n      includeBoundText && getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      return LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x1, y1, x2, y2],\n        boundTextElement,\n      );\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static moveFixedSegment(\n    linearElement: LinearElementEditor,\n    index: number,\n    x: number,\n    y: number,\n    scene: Scene,\n  ): Pick<\n    LinearElementEditor,\n    \"segmentMidPointHoveredCoords\" | \"initialState\"\n  > {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElement.elementId,\n      elementsMap,\n    );\n\n    if (!element || !isElbowArrow(element)) {\n      return linearElement;\n    }\n\n    if (index && index > 0 && index < element.points.length) {\n      const isHorizontal = headingIsHorizontal(\n        vectorToHeading(\n          vectorFromPoint(element.points[index], element.points[index - 1]),\n        ),\n      );\n\n      const fixedSegments = (element.fixedSegments ?? []).reduce(\n        (segments, s) => {\n          segments[s.index] = s;\n          return segments;\n        },\n        {} as Record<number, FixedSegment>,\n      );\n      fixedSegments[index] = {\n        index,\n        start: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index - 1][0],\n          isHorizontal ? y - element.y : element.points[index - 1][1],\n        ),\n        end: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index][0],\n          isHorizontal ? y - element.y : element.points[index][1],\n        ),\n      };\n      const nextFixedSegments = Object.values(fixedSegments).sort(\n        (a, b) => a.index - b.index,\n      );\n\n      const offset = nextFixedSegments\n        .map((segment) => segment.index)\n        .reduce((count, idx) => (idx < index ? count + 1 : count), 0);\n\n      scene.mutateElement(element, {\n        fixedSegments: nextFixedSegments,\n      });\n\n      const point = pointFrom<GlobalPoint>(\n        element.x +\n          (element.fixedSegments![offset].start[0] +\n            element.fixedSegments![offset].end[0]) /\n            2,\n        element.y +\n          (element.fixedSegments![offset].start[1] +\n            element.fixedSegments![offset].end[1]) /\n            2,\n      );\n\n      return {\n        ...linearElement,\n        segmentMidPointHoveredCoords: point,\n        initialState: {\n          ...linearElement.initialState,\n          segmentMidpoint: {\n            added: false,\n            index: element.fixedSegments![offset].index,\n            value: point,\n          },\n        },\n      };\n    }\n\n    return linearElement;\n  }\n\n  static deleteFixedSegment(\n    element: ExcalidrawElbowArrowElement,\n    scene: Scene,\n    index: number,\n  ): void {\n    scene.mutateElement(element, {\n      fixedSegments: element.fixedSegments?.filter(\n        (segment) => segment.index !== index,\n      ),\n    });\n  }\n}\n\nconst normalizeSelectedPoints = (\n  points: (number | null)[],\n): number[] | null => {\n  let nextPoints = [\n    ...new Set(points.filter((p) => p !== null && p !== -1)),\n  ] as number[];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};\n\nconst pointDraggingUpdates = (\n  selectedPointsIndices: readonly number[],\n  deltaX: number,\n  deltaY: number,\n  scenePointerX: number,\n  scenePointerY: number,\n  elementsMap: NonDeletedSceneElementsMap,\n  element: NonDeleted<ExcalidrawLinearElement>,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  app: AppClassProperties,\n  angleLocked: boolean,\n  altKey: boolean,\n  linearElementEditor: LinearElementEditor,\n): {\n  positions: PointsPositionUpdates;\n  updates?: PointMoveOtherUpdates;\n} => {\n  const naiveDraggingPoints = new Map(\n    selectedPointsIndices.map((pointIndex) => {\n      return [\n        pointIndex,\n        {\n          point: pointFrom<LocalPoint>(\n            element.points[pointIndex][0] + deltaX,\n            element.points[pointIndex][1] + deltaY,\n          ),\n          isDragging: true,\n        },\n      ];\n    }),\n  );\n\n  // Linear elements have no special logic\n  if (!isArrowElement(element)) {\n    return {\n      positions: naiveDraggingPoints,\n    };\n  }\n\n  const startIsDragged = selectedPointsIndices.includes(0);\n  const endIsDragged = selectedPointsIndices.includes(\n    element.points.length - 1,\n  );\n\n  const { start, end } = getBindingStrategyForDraggingBindingElementEndpoints(\n    element,\n    naiveDraggingPoints,\n    scenePointerX,\n    scenePointerY,\n    elementsMap,\n    elements,\n    app.state,\n    {\n      newArrow: !!app.state.newElement,\n      angleLocked,\n      altKey,\n    },\n  );\n\n  if (isElbowArrow(element)) {\n    const suggestedBindingElement = startIsDragged\n      ? start.element\n      : endIsDragged\n      ? end.element\n      : null;\n\n    return {\n      positions: naiveDraggingPoints,\n      updates: {\n        suggestedBinding: suggestedBindingElement\n          ? {\n              element: suggestedBindingElement,\n              midPoint: snapToMid(\n                suggestedBindingElement,\n                elementsMap,\n                pointFrom<GlobalPoint>(\n                  scenePointerX - linearElementEditor.pointerOffset.x,\n                  scenePointerY - linearElementEditor.pointerOffset.y,\n                ),\n              ),\n            }\n          : null,\n      },\n    };\n  }\n\n  // Handle the case where neither endpoint is being dragged\n  // but we need to update bound endpoints\n  if (!startIsDragged && !endIsDragged) {\n    const nextArrow = {\n      ...element,\n      points: element.points.map((p, idx) => {\n        return naiveDraggingPoints.get(idx)?.point ?? p;\n      }),\n    };\n    const positions = new Map(naiveDraggingPoints);\n\n    if (element.startBinding) {\n      const startBindable = elementsMap.get(element.startBinding.elementId) as\n        | ExcalidrawBindableElement\n        | undefined;\n      if (startBindable) {\n        const startPoint =\n          updateBoundPoint(\n            nextArrow,\n            \"startBinding\",\n            element.startBinding,\n            startBindable,\n            elementsMap,\n          ) ?? null;\n        if (startPoint) {\n          positions.set(0, { point: startPoint, isDragging: true });\n        }\n      }\n    }\n\n    if (element.endBinding) {\n      const endBindable = elementsMap.get(element.endBinding.elementId) as\n        | ExcalidrawBindableElement\n        | undefined;\n      if (endBindable) {\n        const endPoint =\n          updateBoundPoint(\n            nextArrow,\n            \"endBinding\",\n            element.endBinding,\n            endBindable,\n            elementsMap,\n          ) ?? null;\n        if (endPoint) {\n          positions.set(element.points.length - 1, {\n            point: endPoint,\n            isDragging: true,\n          });\n        }\n      }\n    }\n\n    return {\n      positions,\n    };\n  }\n\n  if (startIsDragged === endIsDragged) {\n    return {\n      positions: naiveDraggingPoints,\n    };\n  }\n\n  // Generate the next bindings for the arrow\n  const updates: PointMoveOtherUpdates = {\n    suggestedBinding: null,\n  };\n  if (start.mode === null) {\n    updates.startBinding = null;\n  } else if (start.mode) {\n    updates.startBinding = {\n      elementId: start.element.id,\n      mode: start.mode,\n      ...calculateFixedPointForNonElbowArrowBinding(\n        element,\n        start.element,\n        \"start\",\n        elementsMap,\n        start.focusPoint,\n      ),\n    };\n\n    if (\n      startIsDragged &&\n      (updates.startBinding.mode === \"orbit\" ||\n        !getFeatureFlag(\"COMPLEX_BINDINGS\"))\n    ) {\n      updates.suggestedBinding = start.element\n        ? {\n            element: start.element,\n            midPoint: getSnapOutlineMidPoint(\n              pointFrom<GlobalPoint>(\n                scenePointerX - linearElementEditor.pointerOffset.x,\n                scenePointerY - linearElementEditor.pointerOffset.y,\n              ),\n              start.element,\n              elementsMap,\n              app.state.zoom,\n            ),\n          }\n        : null;\n    }\n  } else if (startIsDragged) {\n    updates.suggestedBinding = app.state.suggestedBinding;\n  }\n\n  if (end.mode === null) {\n    updates.endBinding = null;\n  } else if (end.mode) {\n    updates.endBinding = {\n      elementId: end.element.id,\n      mode: end.mode,\n      ...calculateFixedPointForNonElbowArrowBinding(\n        element,\n        end.element,\n        \"end\",\n        elementsMap,\n        end.focusPoint,\n      ),\n    };\n\n    if (\n      endIsDragged &&\n      (updates.endBinding.mode === \"orbit\" ||\n        !getFeatureFlag(\"COMPLEX_BINDINGS\"))\n    ) {\n      updates.suggestedBinding = end.element\n        ? {\n            element: end.element,\n            midPoint: getSnapOutlineMidPoint(\n              pointFrom<GlobalPoint>(\n                scenePointerX - linearElementEditor.pointerOffset.x,\n                scenePointerY - linearElementEditor.pointerOffset.y,\n              ),\n              end.element,\n              elementsMap,\n              app.state.zoom,\n            ),\n          }\n        : null;\n    }\n  } else if (endIsDragged) {\n    updates.suggestedBinding = app.state.suggestedBinding;\n  }\n\n  // Simulate the updated arrow for the bind point calculation\n  const offsetStartLocalPoint = startIsDragged\n    ? pointFrom<LocalPoint>(\n        element.points[0][0] + deltaX,\n        element.points[0][1] + deltaY,\n      )\n    : element.points[0];\n  const offsetEndLocalPoint = endIsDragged\n    ? pointFrom<LocalPoint>(\n        element.points[element.points.length - 1][0] + deltaX,\n        element.points[element.points.length - 1][1] + deltaY,\n      )\n    : element.points[element.points.length - 1];\n  const nextArrow = {\n    ...element,\n    points: [\n      offsetStartLocalPoint,\n      ...element.points.slice(1, -1),\n      offsetEndLocalPoint,\n    ],\n    startBinding:\n      updates.startBinding === undefined\n        ? element.startBinding\n        : updates.startBinding === null\n        ? null\n        : updates.startBinding,\n    endBinding:\n      updates.endBinding === undefined\n        ? element.endBinding\n        : updates.endBinding === null\n        ? null\n        : updates.endBinding,\n  };\n\n  // We need to use a custom intersector to ensure that if there is a big \"jump\"\n  // in the arrow's position, we can position it with outline avoidance\n  // pixel-perfectly and avoid \"dancing\" arrows.\n  // NOTE: Direction matters here, so we create two intersectors\n  const startCustomIntersector =\n    start.focusPoint && end.focusPoint\n      ? lineSegment(start.focusPoint, end.focusPoint)\n      : undefined;\n  const endCustomIntersector =\n    start.focusPoint && end.focusPoint\n      ? lineSegment(end.focusPoint, start.focusPoint)\n      : undefined;\n\n  // Needed to handle a special case where an existing arrow is dragged over\n  // the same element it is bound to on the other side\n  const startIsDraggingOverEndElement =\n    element.endBinding &&\n    nextArrow.startBinding &&\n    startIsDragged &&\n    nextArrow.startBinding.elementId === element.endBinding.elementId;\n  const endIsDraggingOverStartElement =\n    element.startBinding &&\n    nextArrow.endBinding &&\n    endIsDragged &&\n    element.startBinding.elementId === nextArrow.endBinding.elementId;\n\n  // We need to update the non-dragged point too if bound,\n  // so we look up the old binding to trigger updateBoundPoint\n  const endBindable = nextArrow.endBinding\n    ? end.element ??\n      (elementsMap.get(\n        nextArrow.endBinding.elementId,\n      )! as ExcalidrawBindableElement)\n    : null;\n\n  const endLocalPoint = startIsDraggingOverEndElement\n    ? nextArrow.points[nextArrow.points.length - 1]\n    : endIsDraggingOverStartElement &&\n      app.state.bindMode !== \"inside\" &&\n      getFeatureFlag(\"COMPLEX_BINDINGS\")\n    ? nextArrow.points[0]\n    : endBindable\n    ? updateBoundPoint(\n        element,\n        \"endBinding\",\n        nextArrow.endBinding,\n        endBindable,\n        elementsMap,\n        {\n          customIntersector: endCustomIntersector,\n        },\n      ) || nextArrow.points[nextArrow.points.length - 1]\n    : nextArrow.points[nextArrow.points.length - 1];\n\n  // We need to keep the simulated next arrow up-to-date, because\n  // updateBoundPoint looks at the opposite point\n  nextArrow.points[nextArrow.points.length - 1] = endLocalPoint;\n\n  // We need to update the non-dragged point too if bound,\n  // so we look up the old binding to trigger updateBoundPoint\n  const startBindable = nextArrow.startBinding\n    ? start.element ??\n      (elementsMap.get(\n        nextArrow.startBinding.elementId,\n      )! as ExcalidrawBindableElement)\n    : null;\n\n  const startLocalPoint =\n    endIsDraggingOverStartElement && getFeatureFlag(\"COMPLEX_BINDINGS\")\n      ? nextArrow.points[0]\n      : startIsDraggingOverEndElement &&\n        app.state.bindMode !== \"inside\" &&\n        getFeatureFlag(\"COMPLEX_BINDINGS\")\n      ? endLocalPoint\n      : startBindable\n      ? updateBoundPoint(\n          element,\n          \"startBinding\",\n          nextArrow.startBinding,\n          startBindable,\n          elementsMap,\n          { customIntersector: startCustomIntersector },\n        ) || nextArrow.points[0]\n      : nextArrow.points[0];\n\n  const endChanged =\n    !startIsDraggingOverEndElement &&\n    !(\n      endIsDraggingOverStartElement &&\n      app.state.bindMode !== \"inside\" &&\n      getFeatureFlag(\"COMPLEX_BINDINGS\")\n    ) &&\n    !!endBindable;\n  const startChanged =\n    pointDistance(startLocalPoint, nextArrow.points[0]) !== 0;\n\n  const indicesSet = new Set(selectedPointsIndices);\n  if (startBindable && startChanged) {\n    indicesSet.add(0);\n  }\n  if (endBindable && endChanged) {\n    indicesSet.add(element.points.length - 1);\n  }\n  const indices = Array.from(indicesSet);\n\n  return {\n    updates,\n    positions: new Map(\n      indices.map((idx) => {\n        return [\n          idx,\n          idx === 0\n            ? {\n                point: startLocalPoint,\n                isDragging: true,\n              }\n            : idx === element.points.length - 1\n            ? {\n                point: endLocalPoint,\n                isDragging: true,\n              }\n            : naiveDraggingPoints.get(idx)!,\n        ];\n      }),\n    ),\n  };\n};\n\nconst determineCustomLinearAngle = (\n  pivotPoint: LocalPoint,\n  draggedPoint: LocalPoint,\n) =>\n  Math.atan2(draggedPoint[1] - pivotPoint[1], draggedPoint[0] - pivotPoint[0]);\n", "import {\n  KEYS,\n  arrayToMap,\n  getFeatureFlag,\n  invariant,\n  isTransparent,\n} from \"@excalidraw/common\";\n\nimport {\n  PRECISION,\n  clamp,\n  lineSegment,\n  pointDistance,\n  pointDistanceSq,\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointsEqual,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorScale,\n  type GlobalPoint,\n} from \"@excalidraw/math\";\n\nimport type { LineSegment, LocalPoint, Radians } from \"@excalidraw/math\";\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\nimport type { MapEntry, Mutable } from \"@excalidraw/common/utility-types\";\nimport type { Bounds } from \"@excalidraw/common\";\n\nimport {\n  doBoundsIntersect,\n  getCenterForBounds,\n  getElementBounds,\n} from \"./bounds\";\nimport {\n  getAllHoveredElementAtPoint,\n  getHoveredElementForBinding,\n  hitElementItself,\n  intersectElementWithLineSegment,\n  isBindableElementInsideOtherBindable,\n  isPointInElement,\n} from \"./collision\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  headingForPointFromElement,\n  headingIsHorizontal,\n  vectorToHeading,\n  type Heading,\n} from \"./heading\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBindableElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isRectangularElement,\n  isRectanguloidElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { aabbForElement, elementCenterPoint } from \"./bounds\";\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\nimport {\n  deconstructDiamondElement,\n  deconstructRectanguloidElement,\n  projectFixedPointOntoDiagonal,\n} from \"./utils\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { ElementUpdate } from \"./mutateElement\";\nimport type {\n  BindMode,\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawElement,\n  ExcalidrawRectanguloidElement,\n  ExcalidrawTextElement,\n  FixedPoint,\n  FixedPointBinding,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  NonDeletedSceneElementsMap,\n  Ordered,\n  PointsPositionUpdates,\n} from \"./types\";\n\nexport type BindingStrategy =\n  // Create a new binding with this mode\n  | {\n      mode: BindMode;\n      element: NonDeleted<ExcalidrawBindableElement>;\n      focusPoint: GlobalPoint;\n    }\n  // Break the binding\n  | {\n      mode: null;\n      element?: undefined;\n      focusPoint?: undefined;\n    }\n  // Keep the existing binding\n  | {\n      mode: undefined;\n      element?: undefined;\n      focusPoint?: undefined;\n    };\n\n/**\n * gaps exclude element strokeWidth\n *\n * IMPORTANT: currently must be > 0 (this also applies to the computed gap)\n */\nexport const BASE_BINDING_GAP = 5;\nexport const BASE_BINDING_GAP_ELBOW = 5;\nexport const FOCUS_POINT_SIZE = 10 / 1.5;\n\nexport const getBindingGap = (\n  bindTarget: ExcalidrawBindableElement,\n  opts: Pick<ExcalidrawArrowElement, \"elbowed\">,\n): number => {\n  return (\n    (opts.elbowed ? BASE_BINDING_GAP_ELBOW : BASE_BINDING_GAP) +\n    bindTarget.strokeWidth / 2\n  );\n};\n\nexport const maxBindingDistance_simple = (zoom?: AppState[\"zoom\"]): number => {\n  const BASE_BINDING_DISTANCE = Math.max(BASE_BINDING_GAP, 15);\n  const zoomValue = zoom?.value && zoom.value < 1 ? zoom.value : 1;\n  return clamp(\n    // reducing zoom impact so that the diff between binding distance and\n    // binding gap is kept to minimum when possible\n    BASE_BINDING_DISTANCE / (zoomValue * 1.5),\n    BASE_BINDING_DISTANCE,\n    BASE_BINDING_DISTANCE * 2,\n  );\n};\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: {\n  isBindingEnabled: AppState[\"isBindingEnabled\"];\n}): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindBindingElement = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  scenePointerX: number,\n  scenePointerY: number,\n  scene: Scene,\n  appState: AppState,\n  opts?: {\n    newArrow?: boolean;\n    altKey?: boolean;\n    angleLocked?: boolean;\n    initialBinding?: boolean;\n  },\n) => {\n  const { start, end } = getBindingStrategyForDraggingBindingElementEndpoints(\n    arrow,\n    draggingPoints,\n    scenePointerX,\n    scenePointerY,\n    scene.getNonDeletedElementsMap(),\n    scene.getNonDeletedElements(),\n    appState,\n    {\n      ...opts,\n      finalize: true,\n    },\n  );\n\n  bindOrUnbindBindingElementEdge(arrow, start, \"start\", scene);\n  bindOrUnbindBindingElementEdge(arrow, end, \"end\", scene);\n  if (start.focusPoint || end.focusPoint) {\n    // If the strategy dictates a focus point override, then\n    // update the arrow points to point to the focus point.\n    const updates: PointsPositionUpdates = new Map();\n\n    if (start.focusPoint) {\n      updates.set(0, {\n        point:\n          updateBoundPoint(\n            arrow,\n            \"startBinding\",\n            arrow.startBinding,\n            start.element,\n            scene.getNonDeletedElementsMap(),\n          ) || arrow.points[0],\n      });\n    }\n\n    if (end.focusPoint) {\n      updates.set(arrow.points.length - 1, {\n        point:\n          updateBoundPoint(\n            arrow,\n            \"endBinding\",\n            arrow.endBinding,\n            end.element,\n            scene.getNonDeletedElementsMap(),\n          ) || arrow.points[arrow.points.length - 1],\n      });\n    }\n\n    LinearElementEditor.movePoints(arrow, scene, updates);\n  }\n\n  return { start, end };\n};\n\nconst bindOrUnbindBindingElementEdge = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  { mode, element, focusPoint }: BindingStrategy,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): void => {\n  if (mode === null) {\n    // null means break the binding\n    unbindBindingElement(arrow, startOrEnd, scene);\n  } else if (mode !== undefined) {\n    bindBindingElement(arrow, element, mode, startOrEnd, scene, focusPoint);\n  }\n};\n\nconst bindingStrategyForElbowArrowEndpointDragging = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  zoom?: AppState[\"zoom\"],\n): {\n  start: BindingStrategy;\n  end: BindingStrategy;\n} => {\n  invariant(draggingPoints.size === 1, \"Bound elbow arrows cannot be moved\");\n\n  const update = draggingPoints.entries().next().value;\n\n  invariant(\n    update,\n    \"There should be a position update for dragging an elbow arrow endpoint\",\n  );\n\n  const [pointIdx, { point }] = update;\n  const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n    arrow,\n    point,\n    elementsMap,\n  );\n  const hit = getHoveredElementForBinding(\n    globalPoint,\n    elements,\n    elementsMap,\n    maxBindingDistance_simple(zoom),\n  );\n\n  const current = hit\n    ? {\n        element: hit,\n        mode: \"orbit\" as const,\n        focusPoint: LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          arrow,\n          pointIdx,\n          elementsMap,\n        ),\n      }\n    : {\n        mode: null,\n      };\n  const other = { mode: undefined };\n\n  return pointIdx === 0\n    ? { start: current, end: other }\n    : { start: other, end: current };\n};\n\nconst bindingStrategyForNewSimpleArrowEndpointDragging = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  startDragged: boolean,\n  endDragged: boolean,\n  startIdx: number,\n  endIdx: number,\n  appState: AppState,\n  globalBindMode?: AppState[\"bindMode\"],\n  shiftKey?: boolean,\n): {\n  start: BindingStrategy;\n  end: BindingStrategy;\n} => {\n  let start: BindingStrategy = { mode: undefined };\n  let end: BindingStrategy = { mode: undefined };\n\n  const isMultiPoint = arrow.points.length > 2;\n  const point = LinearElementEditor.getPointGlobalCoordinates(\n    arrow,\n    draggingPoints.get(startDragged ? startIdx : endIdx)!.point,\n    elementsMap,\n  );\n  const hit = getHoveredElementForBinding(point, elements, elementsMap);\n\n  // With new arrows this handles the binding at arrow creation\n  if (startDragged) {\n    if (hit) {\n      start = {\n        element: hit,\n        mode: \"inside\",\n        focusPoint: point,\n      };\n    } else {\n      start = { mode: null };\n    }\n\n    return { start, end };\n  }\n\n  // With new arrows it represents the continuous dragging of the end point\n  if (endDragged) {\n    const origin = appState?.selectedLinearElement?.initialState.origin;\n\n    // Inside -> inside binding\n    if (hit && arrow.startBinding?.elementId === hit.id) {\n      const center = pointFrom<GlobalPoint>(\n        hit.x + hit.width / 2,\n        hit.y + hit.height / 2,\n      );\n\n      return {\n        start: isMultiPoint\n          ? { mode: undefined }\n          : {\n              mode: \"inside\",\n              element: hit,\n              focusPoint: origin ?? center,\n            },\n        end: isMultiPoint\n          ? { mode: \"orbit\", element: hit, focusPoint: point }\n          : { mode: \"inside\", element: hit, focusPoint: point },\n      };\n    }\n\n    // Check and handle nested shapes\n    if (hit && arrow.startBinding) {\n      const startBinding = arrow.startBinding;\n      const allHits = getAllHoveredElementAtPoint(point, elements, elementsMap);\n\n      if (allHits.find((el) => el.id === startBinding.elementId)) {\n        const otherElement = elementsMap.get(\n          arrow.startBinding.elementId,\n        ) as ExcalidrawBindableElement;\n\n        invariant(otherElement, \"Other element must be in the elements map\");\n\n        return {\n          start: isMultiPoint\n            ? { mode: undefined }\n            : {\n                mode: otherElement.id !== hit.id ? \"orbit\" : \"inside\",\n                element: otherElement,\n                focusPoint: origin ?? pointFrom<GlobalPoint>(arrow.x, arrow.y),\n              },\n          end: {\n            mode: \"orbit\",\n            element: hit,\n            focusPoint: point,\n          },\n        };\n      }\n    }\n\n    // Inside -> outside binding\n    if (arrow.startBinding && arrow.startBinding.elementId !== hit?.id) {\n      const otherElement = elementsMap.get(\n        arrow.startBinding.elementId,\n      ) as ExcalidrawBindableElement;\n      invariant(otherElement, \"Other element must be in the elements map\");\n\n      const otherIsInsideBinding =\n        !!appState.selectedLinearElement?.initialState.arrowStartIsInside;\n      const other: BindingStrategy = {\n        mode: otherIsInsideBinding ? \"inside\" : \"orbit\",\n        element: otherElement,\n        focusPoint: shiftKey\n          ? elementCenterPoint(otherElement, elementsMap)\n          : origin ?? pointFrom<GlobalPoint>(arrow.x, arrow.y),\n      };\n\n      // We are hovering another element with the end point\n      const isNested =\n        hit &&\n        isBindableElementInsideOtherBindable(otherElement, hit, elementsMap);\n      let current: BindingStrategy;\n      if (hit) {\n        const isInsideBinding =\n          globalBindMode === \"inside\" || globalBindMode === \"skip\";\n        current = {\n          mode: isInsideBinding && !isNested ? \"inside\" : \"orbit\",\n          element: hit,\n          focusPoint: isInsideBinding || isNested ? point : point,\n        };\n      } else {\n        current = { mode: null };\n      }\n\n      return {\n        start: isMultiPoint ? { mode: undefined } : other,\n        end: current,\n      };\n    }\n\n    // No start binding\n    if (!arrow.startBinding) {\n      if (hit) {\n        const isInsideBinding =\n          globalBindMode === \"inside\" || globalBindMode === \"skip\";\n\n        end = {\n          mode: isInsideBinding ? \"inside\" : \"orbit\",\n          element: hit,\n          focusPoint: point,\n        };\n      } else {\n        end = { mode: null };\n      }\n\n      return { start, end };\n    }\n  }\n\n  invariant(false, \"New arrow creation should not reach here\");\n};\n\nconst bindingStrategyForSimpleArrowEndpointDragging_complex = (\n  point: GlobalPoint,\n  currentBinding: FixedPointBinding | null,\n  oppositeBinding: FixedPointBinding | null,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  globalBindMode: AppState[\"bindMode\"],\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  finalize?: boolean,\n): { current: BindingStrategy; other: BindingStrategy } => {\n  let current: BindingStrategy = { mode: undefined };\n  let other: BindingStrategy = { mode: undefined };\n\n  const isMultiPoint = arrow.points.length > 2;\n  const hit = getHoveredElementForBinding(point, elements, elementsMap);\n  const isOverlapping = oppositeBinding\n    ? getAllHoveredElementAtPoint(point, elements, elementsMap).some(\n        (el) => el.id === oppositeBinding.elementId,\n      )\n    : false;\n  const oppositeElement = oppositeBinding\n    ? (elementsMap.get(oppositeBinding.elementId) as ExcalidrawBindableElement)\n    : null;\n  const otherIsTransparent =\n    isOverlapping && oppositeElement\n      ? isTransparent(oppositeElement.backgroundColor)\n      : false;\n  const isNested =\n    hit &&\n    oppositeElement &&\n    isBindableElementInsideOtherBindable(oppositeElement, hit, elementsMap);\n\n  // If the global bind mode is in free binding mode, just bind\n  // where the pointer is and keep the other end intact\n  if (globalBindMode === \"inside\" || globalBindMode === \"skip\") {\n    current = hit\n      ? {\n          element:\n            !isOverlapping || !oppositeElement || otherIsTransparent\n              ? hit\n              : oppositeElement,\n          focusPoint: point,\n          mode: \"inside\",\n        }\n      : { mode: null };\n    other =\n      finalize && hit && hit.id === oppositeBinding?.elementId\n        ? { mode: null }\n        : other;\n\n    return { current, other };\n  }\n\n  // Dragged point is outside of any bindable element\n  // so we break any existing binding\n  if (!hit) {\n    return { current: { mode: null }, other };\n  }\n\n  // Already inside binding over the same hit element should remain inside bound\n  if (\n    hit.id === currentBinding?.elementId &&\n    currentBinding.mode === \"inside\"\n  ) {\n    return {\n      current: { mode: \"inside\", focusPoint: point, element: hit },\n      other,\n    };\n  }\n\n  // The dragged point is inside the hovered bindable element\n  if (oppositeBinding) {\n    // The opposite binding is on the same element\n    if (oppositeBinding.elementId === hit.id) {\n      // The opposite binding is on the binding gap of the same element\n      if (oppositeBinding.mode === \"orbit\") {\n        current = { element: hit, mode: \"orbit\", focusPoint: point };\n        other = { mode: finalize ? null : undefined };\n\n        return { current, other: isMultiPoint ? { mode: undefined } : other };\n      }\n      // The opposite binding is inside the same element\n      // eslint-disable-next-line no-else-return\n      else {\n        current = { element: hit, mode: \"inside\", focusPoint: point };\n\n        return { current, other: isMultiPoint ? { mode: undefined } : other };\n      }\n    }\n    // The opposite binding is on a different element (or nested)\n    // eslint-disable-next-line no-else-return\n    else {\n      // Handle the nested element case\n      if (isOverlapping && oppositeElement && !otherIsTransparent) {\n        current = {\n          element: oppositeElement,\n          mode: \"inside\",\n          focusPoint: point,\n        };\n      } else {\n        current = {\n          element: hit,\n          mode: \"orbit\",\n          focusPoint: isNested ? point : point,\n        };\n      }\n\n      return { current, other: isMultiPoint ? { mode: undefined } : other };\n    }\n  }\n  // The opposite binding is on a different element or no binding\n  else {\n    current = {\n      element: hit,\n      mode: \"orbit\",\n      focusPoint: point,\n    };\n  }\n\n  // Must return as only one endpoint is dragged, therefore\n  // the end binding strategy might accidentally gets overriden\n  return { current, other: isMultiPoint ? { mode: undefined } : other };\n};\n\nexport const getBindingStrategyForDraggingBindingElementEndpoints = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  screenPointerX: number,\n  screenPointerY: number,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  appState: AppState,\n  opts?: {\n    newArrow?: boolean;\n    angleLocked?: boolean;\n    altKey?: boolean;\n    finalize?: boolean;\n    initialBinding?: boolean;\n    zoom?: AppState[\"zoom\"];\n  },\n): { start: BindingStrategy; end: BindingStrategy } => {\n  if (getFeatureFlag(\"COMPLEX_BINDINGS\")) {\n    return getBindingStrategyForDraggingBindingElementEndpoints_complex(\n      arrow,\n      draggingPoints,\n      elementsMap,\n      elements,\n      appState,\n      opts,\n    );\n  }\n\n  return getBindingStrategyForDraggingBindingElementEndpoints_simple(\n    arrow,\n    draggingPoints,\n    screenPointerX,\n    screenPointerY,\n    elementsMap,\n    elements,\n    appState,\n    opts,\n  );\n};\n\nconst getBindingStrategyForDraggingBindingElementEndpoints_simple = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  scenePointerX: number,\n  scenePointerY: number,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  appState: AppState,\n  opts?: {\n    newArrow?: boolean;\n    angleLocked?: boolean;\n    altKey?: boolean;\n    finalize?: boolean;\n    initialBinding?: boolean;\n    zoom?: AppState[\"zoom\"];\n  },\n): { start: BindingStrategy; end: BindingStrategy } => {\n  const startIdx = 0;\n  const endIdx = arrow.points.length - 1;\n  const startDragged = draggingPoints.has(startIdx);\n  const endDragged = draggingPoints.has(endIdx);\n\n  let start: BindingStrategy = { mode: undefined };\n  let end: BindingStrategy = { mode: undefined };\n\n  invariant(\n    arrow.points.length > 1,\n    \"Do not attempt to bind linear elements with a single point\",\n  );\n\n  // If none of the ends are dragged, we don't change anything\n  if (!startDragged && !endDragged) {\n    return { start, end };\n  }\n\n  // If both ends are dragged, we don't bind to anything\n  // and break existing bindings\n  if (startDragged && endDragged) {\n    return { start: { mode: null }, end: { mode: null } };\n  }\n\n  // If binding is disabled and an endpoint is dragged,\n  // we actively break the end binding\n  if (!isBindingEnabled(appState)) {\n    start = startDragged ? { mode: null } : start;\n    end = endDragged ? { mode: null } : end;\n\n    return { start, end };\n  }\n\n  // Handle simpler elbow arrow binding\n  if (isElbowArrow(arrow)) {\n    return bindingStrategyForElbowArrowEndpointDragging(\n      arrow,\n      draggingPoints,\n      elementsMap,\n      elements,\n      opts?.zoom,\n    );\n  }\n\n  const otherBinding = startDragged ? arrow.endBinding : arrow.startBinding;\n  const localPoint = draggingPoints.get(\n    startDragged ? startIdx : endIdx,\n  )?.point;\n  invariant(\n    localPoint,\n    `Local point must be defined for ${\n      startDragged ? \"start\" : \"end\"\n    } dragging`,\n  );\n  const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n    arrow,\n    localPoint,\n    elementsMap,\n  );\n  const hit = getHoveredElementForBinding(\n    globalPoint,\n    elements,\n    elementsMap,\n    maxBindingDistance_simple(appState.zoom),\n  );\n  const pointInElement =\n    hit &&\n    (opts?.angleLocked\n      ? isPointInElement(\n          pointFrom<GlobalPoint>(scenePointerX, scenePointerY),\n          hit,\n          elementsMap,\n        )\n      : isPointInElement(globalPoint, hit, elementsMap));\n  const otherBindableElement = otherBinding\n    ? (elementsMap.get(\n        otherBinding.elementId,\n      ) as NonDeleted<ExcalidrawBindableElement>)\n    : undefined;\n  const otherFocusPoint =\n    otherBinding &&\n    otherBindableElement &&\n    getGlobalFixedPointForBindableElement(\n      otherBinding.fixedPoint,\n      otherBindableElement,\n      elementsMap,\n    );\n  const otherFocusPointIsInElement =\n    otherBindableElement &&\n    otherFocusPoint &&\n    hitElementItself({\n      point: otherFocusPoint,\n      element: otherBindableElement,\n      elementsMap,\n      threshold: 0,\n      overrideShouldTestInside: true,\n    });\n\n  // Handle outside-outside binding to the same element\n  if (otherBinding && otherBinding.elementId === hit?.id) {\n    invariant(\n      !opts?.newArrow || appState.selectedLinearElement?.initialState.origin,\n      \"appState.selectedLinearElement.initialState.origin must be defined for new arrows\",\n    );\n\n    return {\n      start: {\n        mode: \"inside\",\n        element: hit,\n        focusPoint: startDragged\n          ? globalPoint\n          : // NOTE: Can only affect the start point because new arrows always drag the end point\n          opts?.newArrow\n          ? appState.selectedLinearElement!.initialState.origin!\n          : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n              arrow,\n              0,\n              elementsMap,\n            ), // startFixedPoint,\n      },\n      end: {\n        mode: \"inside\",\n        element: hit,\n        focusPoint: endDragged\n          ? globalPoint\n          : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n              arrow,\n              -1,\n              elementsMap,\n            ), // endFixedPoint\n      },\n    };\n  }\n\n  // Handle special alt key case to inside bind no matter what\n  if (opts?.altKey) {\n    return {\n      start: startDragged\n        ? hit\n          ? {\n              mode: \"inside\",\n              element: hit,\n              focusPoint: globalPoint,\n            }\n          : { mode: null }\n        : start,\n      end: endDragged\n        ? hit\n          ? {\n              mode: \"inside\",\n              element: hit,\n              focusPoint: globalPoint,\n            }\n          : { mode: null }\n        : end,\n    };\n  }\n\n  // Handle normal cases\n  const current: BindingStrategy = hit\n    ? pointInElement\n      ? {\n          mode: \"inside\",\n          element: hit,\n          focusPoint: globalPoint,\n        }\n      : {\n          mode: \"orbit\",\n          element: hit,\n          focusPoint:\n            projectFixedPointOntoDiagonal(\n              arrow,\n              globalPoint,\n              hit,\n              startDragged ? \"start\" : \"end\",\n              elementsMap,\n              appState.zoom,\n            ) || globalPoint,\n        }\n    : { mode: null };\n\n  const otherEndpoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    arrow,\n    startDragged ? -1 : 0,\n    elementsMap,\n  );\n\n  const otherNeverOverride = opts?.newArrow\n    ? appState.selectedLinearElement?.initialState.arrowStartIsInside\n    : otherBinding?.mode === \"inside\";\n  const other: BindingStrategy = !otherNeverOverride\n    ? otherBindableElement &&\n      !otherFocusPointIsInElement &&\n      appState.selectedLinearElement?.initialState.altFocusPoint\n      ? {\n          mode: \"orbit\",\n          element: otherBindableElement,\n          focusPoint: appState.selectedLinearElement.initialState.altFocusPoint,\n        }\n      : opts?.angleLocked && otherBindableElement\n      ? {\n          mode: \"orbit\",\n          element: otherBindableElement,\n          focusPoint:\n            projectFixedPointOntoDiagonal(\n              arrow,\n              otherEndpoint,\n              otherBindableElement,\n              startDragged ? \"end\" : \"start\",\n              elementsMap,\n              appState.zoom,\n            ) || otherEndpoint,\n        }\n      : { mode: undefined }\n    : { mode: undefined };\n\n  return {\n    start: startDragged ? current : other,\n    end: endDragged ? current : other,\n  };\n};\n\nconst getBindingStrategyForDraggingBindingElementEndpoints_complex = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  draggingPoints: PointsPositionUpdates,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  appState: AppState,\n  opts?: {\n    newArrow?: boolean;\n    shiftKey?: boolean;\n    finalize?: boolean;\n    initialBinding?: boolean;\n  },\n): { start: BindingStrategy; end: BindingStrategy } => {\n  const globalBindMode = appState.bindMode || \"orbit\";\n  const startIdx = 0;\n  const endIdx = arrow.points.length - 1;\n  const startDragged = draggingPoints.has(startIdx);\n  const endDragged = draggingPoints.has(endIdx);\n\n  let start: BindingStrategy = { mode: undefined };\n  let end: BindingStrategy = { mode: undefined };\n\n  invariant(\n    arrow.points.length > 1,\n    \"Do not attempt to bind linear elements with a single point\",\n  );\n\n  // If none of the ends are dragged, we don't change anything\n  if (!startDragged && !endDragged) {\n    return { start, end };\n  }\n\n  // If both ends are dragged, we don't bind to anything\n  // and break existing bindings\n  if (startDragged && endDragged) {\n    return { start: { mode: null }, end: { mode: null } };\n  }\n\n  // If binding is disabled and an endpoint is dragged,\n  // we actively break the end binding\n  if (!isBindingEnabled(appState)) {\n    start = startDragged ? { mode: null } : start;\n    end = endDragged ? { mode: null } : end;\n\n    return { start, end };\n  }\n\n  // Handle simpler elbow arrow binding\n  if (isElbowArrow(arrow)) {\n    return bindingStrategyForElbowArrowEndpointDragging(\n      arrow,\n      draggingPoints,\n      elementsMap,\n      elements,\n    );\n  }\n\n  // Handle new arrow creation separately, as it is special\n  if (opts?.newArrow) {\n    const { start, end } = bindingStrategyForNewSimpleArrowEndpointDragging(\n      arrow,\n      draggingPoints,\n      elementsMap,\n      elements,\n      startDragged,\n      endDragged,\n      startIdx,\n      endIdx,\n      appState,\n      globalBindMode,\n      opts?.shiftKey,\n    );\n\n    return { start, end };\n  }\n\n  // Only the start point is dragged\n  if (startDragged) {\n    const localPoint = draggingPoints.get(startIdx)?.point;\n    invariant(localPoint, \"Local point must be defined for start dragging\");\n    const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n      arrow,\n      localPoint,\n      elementsMap,\n    );\n\n    const { current, other } =\n      bindingStrategyForSimpleArrowEndpointDragging_complex(\n        globalPoint,\n        arrow.startBinding,\n        arrow.endBinding,\n        elementsMap,\n        elements,\n        globalBindMode,\n        arrow,\n        opts?.finalize,\n      );\n\n    return { start: current, end: other };\n  }\n\n  // Only the end point is dragged\n  if (endDragged) {\n    const localPoint = draggingPoints.get(endIdx)?.point;\n    invariant(localPoint, \"Local point must be defined for end dragging\");\n    const globalPoint = LinearElementEditor.getPointGlobalCoordinates(\n      arrow,\n      localPoint,\n      elementsMap,\n    );\n    const { current, other } =\n      bindingStrategyForSimpleArrowEndpointDragging_complex(\n        globalPoint,\n        arrow.endBinding,\n        arrow.startBinding,\n        elementsMap,\n        elements,\n        globalBindMode,\n        arrow,\n        opts?.finalize,\n      );\n\n    return { start: other, end: current };\n  }\n\n  return { start, end };\n};\n\nexport const bindOrUnbindBindingElements = (\n  selectedArrows: NonDeleted<ExcalidrawArrowElement>[],\n  scene: Scene,\n  appState: AppState,\n): void => {\n  selectedArrows.forEach((arrow) => {\n    bindOrUnbindBindingElement(\n      arrow,\n      new Map(), // No dragging points in this case\n      Infinity,\n      Infinity,\n      scene,\n      appState,\n    );\n  });\n};\n\nexport const bindBindingElement = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  mode: BindMode,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n  focusPoint?: GlobalPoint,\n): void => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  let binding: FixedPointBinding;\n\n  if (isElbowArrow(arrow)) {\n    binding = {\n      elementId: hoveredElement.id,\n      mode: \"orbit\",\n      ...calculateFixedPointForElbowArrowBinding(\n        arrow,\n        hoveredElement,\n        startOrEnd,\n        elementsMap,\n      ),\n    };\n  } else {\n    binding = {\n      elementId: hoveredElement.id,\n      mode,\n      ...calculateFixedPointForNonElbowArrowBinding(\n        arrow,\n        hoveredElement,\n        startOrEnd,\n        elementsMap,\n        focusPoint,\n      ),\n    };\n  }\n\n  scene.mutateElement(arrow, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding,\n  });\n\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(arrow.id)) {\n    scene.mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: arrow.id,\n        type: \"arrow\",\n      }),\n    });\n  }\n};\n\nexport const unbindBindingElement = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = arrow[field];\n\n  if (binding == null) {\n    return null;\n  }\n\n  const oppositeBinding =\n    arrow[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  if (!oppositeBinding || oppositeBinding.elementId !== binding.elementId) {\n    // Only remove the record on the bound element if the other\n    // end is not bound to the same element\n    const boundElement = scene\n      .getNonDeletedElementsMap()\n      .get(binding.elementId) as ExcalidrawBindableElement;\n    scene.mutateElement(boundElement, {\n      boundElements: boundElement.boundElements?.filter(\n        (element) => element.id !== arrow.id,\n      ),\n    });\n  }\n\n  scene.mutateElement(arrow, { [field]: null });\n\n  return binding.elementId;\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  scene: Scene,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    changedElements?: Map<string, ExcalidrawElement>;\n    indirectArrowUpdate?: boolean;\n  },\n) => {\n  if (!isBindableElement(changedElement)) {\n    return;\n  }\n\n  const { simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n\n  let elementsMap: ElementsMap = scene.getNonDeletedElementsMap();\n  if (options?.changedElements) {\n    elementsMap = new Map(elementsMap) as typeof elementsMap;\n    options.changedElements.forEach((element) => {\n      elementsMap.set(element.id, element);\n    });\n  }\n\n  const visitor = (element: ExcalidrawElement | undefined) => {\n    if (!isArrowElement(element) || element.isDeleted) {\n      return;\n    }\n\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, changedElement)) {\n      return;\n    }\n\n    // Check for intersections before updating bound elements incase connected elements overlap\n    const startBindingElement = element.startBinding\n      ? elementsMap.get(element.startBinding.elementId)\n      : null;\n    const endBindingElement = element.endBinding\n      ? // PERF: If the arrow is bound to the same element on both ends.\n        startBindingElement?.id === element.endBinding.elementId\n        ? startBindingElement\n        : elementsMap.get(element.endBinding.elementId)\n      : null;\n\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      return;\n    }\n\n    const updates = bindableElementsVisitor(\n      elementsMap,\n      element,\n      (bindableElement, bindingProp) => {\n        if (\n          bindableElement &&\n          isBindableElement(bindableElement) &&\n          (bindingProp === \"startBinding\" || bindingProp === \"endBinding\") &&\n          (changedElement.id === element[bindingProp]?.elementId ||\n            changedElement.id ===\n              element[\n                bindingProp === \"startBinding\" ? \"endBinding\" : \"startBinding\"\n              ]?.elementId)\n        ) {\n          const point = updateBoundPoint(\n            element,\n            bindingProp,\n            element[bindingProp],\n            bindableElement,\n            elementsMap,\n          );\n\n          if (point) {\n            return [\n              bindingProp === \"startBinding\" ? 0 : element.points.length - 1,\n              { point },\n            ] as MapEntry<PointsPositionUpdates>;\n          }\n        }\n\n        return null;\n      },\n    ).filter(\n      (update): update is MapEntry<PointsPositionUpdates> => update !== null,\n    );\n\n    LinearElementEditor.movePoints(element, scene, new Map(updates), {\n      moveMidPointsWithElement:\n        !!startBindingElement &&\n        startBindingElement?.id === endBindingElement?.id,\n    });\n\n    const boundText = getBoundTextElement(element, elementsMap);\n    if (boundText && !boundText.isDeleted) {\n      handleBindTextResize(element, scene, false);\n    }\n  };\n\n  boundElementsVisitor(elementsMap, changedElement, visitor);\n\n  if (options?.indirectArrowUpdate) {\n    boundElementsVisitor(elementsMap, changedElement, visitor);\n    boundElementsVisitor(elementsMap, changedElement, visitor);\n  }\n};\n\nconst updateArrowBindings = (\n  latestElement: ExcalidrawArrowElement,\n  startOrEnd: \"startBinding\" | \"endBinding\",\n  elementsMap: NonDeletedSceneElementsMap,\n  scene: Scene,\n  appState: AppState,\n) => {\n  invariant(\n    !isElbowArrow(latestElement),\n    \"Elbow arrows not supported for indirect updates\",\n  );\n\n  const binding = latestElement[startOrEnd];\n  const bindableElement =\n    binding &&\n    (elementsMap.get(binding.elementId) as ExcalidrawBindableElement);\n  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    latestElement,\n    startOrEnd === \"startBinding\" ? 0 : -1,\n    elementsMap,\n  );\n  const hit =\n    bindableElement &&\n    hitElementItself({\n      element: bindableElement,\n      point,\n      elementsMap,\n      threshold: maxBindingDistance_simple(appState.zoom),\n    });\n  const strategyName = startOrEnd === \"startBinding\" ? \"start\" : \"end\";\n  unbindBindingElement(latestElement, strategyName, scene);\n  if (hit) {\n    const pointIdx =\n      startOrEnd === \"startBinding\" ? 0 : latestElement.points.length - 1;\n    const localPoint = latestElement.points[pointIdx];\n    const strategy =\n      getBindingStrategyForDraggingBindingElementEndpoints_simple(\n        latestElement,\n        new Map([[pointIdx, { point: localPoint }]]),\n        point[0],\n        point[1],\n        elementsMap,\n        scene.getNonDeletedElements(),\n        appState,\n      );\n    if (\n      strategy[strategyName] &&\n      strategy[strategyName].element?.id === bindableElement.id &&\n      strategy[strategyName].mode\n    ) {\n      bindBindingElement(\n        latestElement,\n        bindableElement,\n        strategy[strategyName].mode,\n        strategyName,\n        scene,\n        strategy[strategyName].focusPoint,\n      );\n    }\n  }\n};\n\nexport const updateBindings = (\n  latestElement: ExcalidrawElement,\n  scene: Scene,\n  appState: AppState,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  if (isArrowElement(latestElement)) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n\n    if (latestElement.startBinding) {\n      updateArrowBindings(\n        latestElement,\n        \"startBinding\",\n        elementsMap,\n        scene,\n        appState,\n      );\n    }\n\n    if (latestElement.endBinding) {\n      updateArrowBindings(\n        latestElement,\n        \"endBinding\",\n        elementsMap,\n        scene,\n        appState,\n      );\n    }\n  } else {\n    updateBoundElements(latestElement, scene, {\n      ...options,\n      changedElements: new Map([[latestElement.id, latestElement]]),\n    });\n  }\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawArrowElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nexport const getHeadingForElbowArrowSnap = (\n  p: Readonly<GlobalPoint>,\n  otherPoint: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement | undefined | null,\n  aabb: Bounds | undefined | null,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n): Heading => {\n  const otherPointHeading = vectorToHeading(vectorFromPoint(otherPoint, p));\n\n  if (!bindableElement || !aabb) {\n    return otherPointHeading;\n  }\n\n  const distance = getDistanceForBinding(\n    origPoint,\n    bindableElement,\n    elementsMap,\n    zoom,\n  );\n\n  if (!distance) {\n    return vectorToHeading(\n      vectorFromPoint(p, elementCenterPoint(bindableElement, elementsMap)),\n    );\n  }\n\n  return headingForPointFromElement(bindableElement, aabb, p);\n};\n\nconst getDistanceForBinding = (\n  point: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n) => {\n  const distance = distanceToElement(bindableElement, elementsMap, point);\n  const bindDistance = maxBindingDistance_simple(zoom);\n\n  return distance > bindDistance ? null : distance;\n};\n\nexport const bindPointToSnapToElementOutline = (\n  arrowElement: ExcalidrawArrowElement,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n  customIntersector?: LineSegment<GlobalPoint>,\n): GlobalPoint => {\n  const elbowed = isElbowArrow(arrowElement);\n  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    arrowElement,\n    startOrEnd === \"start\" ? 0 : -1,\n    elementsMap,\n  );\n\n  if (arrowElement.points.length < 2) {\n    // New arrow creation, so no snapping\n    return point;\n  }\n\n  const edgePoint =\n    isRectanguloidElement(bindableElement) && elbowed\n      ? avoidRectangularCorner(\n          arrowElement,\n          bindableElement,\n          elementsMap,\n          point,\n        )\n      : point;\n  const adjacentPoint =\n    customIntersector && !elbowed\n      ? customIntersector[1]\n      : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          arrowElement,\n          startOrEnd === \"start\" ? 1 : -2,\n          elementsMap,\n        );\n  const bindingGap = getBindingGap(bindableElement, arrowElement);\n  const aabb = aabbForElement(bindableElement, elementsMap);\n  const bindableCenter = getCenterForBounds(aabb);\n\n  let intersection: GlobalPoint | null = null;\n  if (elbowed) {\n    const isHorizontal = headingIsHorizontal(\n      headingForPointFromElement(bindableElement, aabb, point),\n    );\n    const snapPoint = snapToMid(\n      bindableElement,\n      elementsMap,\n      edgePoint,\n      0.05,\n      arrowElement,\n    );\n    const resolved = snapPoint || point;\n    const otherPoint = pointFrom<GlobalPoint>(\n      isHorizontal ? bindableCenter[0] : resolved[0],\n      !isHorizontal ? bindableCenter[1] : resolved[1],\n    );\n    const intersector =\n      customIntersector ??\n      lineSegment(\n        otherPoint,\n        pointFromVector(\n          vectorScale(\n            vectorNormalize(vectorFromPoint(resolved, otherPoint)),\n            Math.max(bindableElement.width, bindableElement.height) * 2,\n          ),\n          otherPoint,\n        ),\n      );\n    intersection = intersectElementWithLineSegment(\n      bindableElement,\n      elementsMap,\n      intersector,\n      bindingGap,\n    ).sort(pointDistanceSq)[0];\n\n    if (!intersection) {\n      const anotherPoint = pointFrom<GlobalPoint>(\n        !isHorizontal ? bindableCenter[0] : resolved[0],\n        isHorizontal ? bindableCenter[1] : resolved[1],\n      );\n      const anotherIntersector = lineSegment(\n        anotherPoint,\n        pointFromVector(\n          vectorScale(\n            vectorNormalize(vectorFromPoint(resolved, anotherPoint)),\n            Math.max(bindableElement.width, bindableElement.height) * 2,\n          ),\n          anotherPoint,\n        ),\n      );\n      intersection = intersectElementWithLineSegment(\n        bindableElement,\n        elementsMap,\n        anotherIntersector,\n        BASE_BINDING_GAP_ELBOW,\n      ).sort(pointDistanceSq)[0];\n    }\n  } else {\n    let intersector = customIntersector;\n    if (!intersector) {\n      const halfVector = vectorScale(\n        vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n        pointDistance(edgePoint, adjacentPoint) +\n          Math.max(bindableElement.width, bindableElement.height) +\n          bindingGap * 2,\n      );\n      intersector =\n        customIntersector ??\n        lineSegment(\n          pointFromVector(halfVector, adjacentPoint),\n          pointFromVector(vectorScale(halfVector, -1), adjacentPoint),\n        );\n    }\n\n    intersection =\n      pointDistance(edgePoint, adjacentPoint) < 1\n        ? edgePoint\n        : intersectElementWithLineSegment(\n            bindableElement,\n            elementsMap,\n            intersector,\n            bindingGap,\n          ).sort(\n            (g, h) =>\n              pointDistanceSq(g, adjacentPoint) -\n              pointDistanceSq(h, adjacentPoint),\n          )[0];\n  }\n\n  if (\n    !intersection ||\n    // Too close to determine vector from intersection to edgePoint\n    pointDistanceSq(edgePoint, intersection) < PRECISION\n  ) {\n    return edgePoint;\n  }\n\n  return intersection;\n};\n\nexport const avoidRectangularCorner = (\n  arrowElement: ExcalidrawArrowElement,\n  bindTarget: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): GlobalPoint => {\n  const center = elementCenterPoint(bindTarget, elementsMap);\n  const nonRotatedPoint = pointRotateRads(\n    p,\n    center,\n    -bindTarget.angle as Radians,\n  );\n\n  const bindingGap = getBindingGap(bindTarget, arrowElement);\n\n  if (nonRotatedPoint[0] < bindTarget.x && nonRotatedPoint[1] < bindTarget.y) {\n    // Top left\n    if (nonRotatedPoint[1] - bindTarget.y > -bindingGap) {\n      return pointRotateRads<GlobalPoint>(\n        pointFrom(bindTarget.x - bindingGap, bindTarget.y),\n        center,\n        bindTarget.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(bindTarget.x, bindTarget.y - bindingGap),\n      center,\n      bindTarget.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] < bindTarget.x &&\n    nonRotatedPoint[1] > bindTarget.y + bindTarget.height\n  ) {\n    // Bottom left\n    if (nonRotatedPoint[0] - bindTarget.x > -bindingGap) {\n      return pointRotateRads(\n        pointFrom(bindTarget.x, bindTarget.y + bindTarget.height + bindingGap),\n        center,\n        bindTarget.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(bindTarget.x - bindingGap, bindTarget.y + bindTarget.height),\n      center,\n      bindTarget.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > bindTarget.x + bindTarget.width &&\n    nonRotatedPoint[1] > bindTarget.y + bindTarget.height\n  ) {\n    // Bottom right\n    if (nonRotatedPoint[0] - bindTarget.x < bindTarget.width + bindingGap) {\n      return pointRotateRads(\n        pointFrom(\n          bindTarget.x + bindTarget.width,\n          bindTarget.y + bindTarget.height + bindingGap,\n        ),\n        center,\n        bindTarget.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(\n        bindTarget.x + bindTarget.width + bindingGap,\n        bindTarget.y + bindTarget.height,\n      ),\n      center,\n      bindTarget.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > bindTarget.x + bindTarget.width &&\n    nonRotatedPoint[1] < bindTarget.y\n  ) {\n    // Top right\n    if (nonRotatedPoint[0] - bindTarget.x < bindTarget.width + bindingGap) {\n      return pointRotateRads(\n        pointFrom(bindTarget.x + bindTarget.width, bindTarget.y - bindingGap),\n        center,\n        bindTarget.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(bindTarget.x + bindTarget.width + bindingGap, bindTarget.y),\n      center,\n      bindTarget.angle,\n    );\n  }\n\n  return p;\n};\n\nexport const snapToMid = (\n  bindTarget: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n  tolerance: number = 0.05,\n  arrowElement?: ExcalidrawArrowElement,\n): GlobalPoint | undefined => {\n  const { x, y, width, height, angle } = bindTarget;\n  const center = elementCenterPoint(bindTarget, elementsMap, -0.1, -0.1);\n  const nonRotated = pointRotateRads(p, center, -angle as Radians);\n\n  const bindingGap = arrowElement ? getBindingGap(bindTarget, arrowElement) : 0;\n\n  // snap-to-center point is adaptive to element size, but we don't want to go\n  // above and below certain px distance\n  const verticalThreshold = clamp(tolerance * height, 5, 80);\n  const horizontalThreshold = clamp(tolerance * width, 5, 80);\n\n  // Too close to the center makes it hard to resolve direction precisely\n  if (pointDistance(center, nonRotated) < bindingGap) {\n    return undefined;\n  }\n\n  if (\n    nonRotated[0] <= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // LEFT\n    return pointRotateRads(\n      pointFrom<GlobalPoint>(x - bindingGap, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] <= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // TOP\n    return pointRotateRads(\n      pointFrom<GlobalPoint>(center[0], y - bindingGap),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[0] >= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // RIGHT\n    return pointRotateRads(\n      pointFrom<GlobalPoint>(x + width + bindingGap, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] >= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // DOWN\n    return pointRotateRads(\n      pointFrom<GlobalPoint>(center[0], y + height + bindingGap),\n      center,\n      angle,\n    );\n  } else if (bindTarget.type === \"diamond\") {\n    const distance = bindingGap;\n    const topLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + height / 4 - distance,\n    );\n    const topRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + height / 4 - distance,\n    );\n    const bottomLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + (3 * height) / 4 + distance,\n    );\n    const bottomRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + (3 * height) / 4 + distance,\n    );\n\n    if (\n      pointDistance(topLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topLeft, center, angle);\n    }\n    if (\n      pointDistance(topRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topRight, center, angle);\n    }\n    if (\n      pointDistance(bottomLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomLeft, center, angle);\n    }\n    if (\n      pointDistance(bottomRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomRight, center, angle);\n    }\n  }\n\n  return undefined;\n};\n\nconst compareElementArea = (\n  a: ExcalidrawBindableElement,\n  b: ExcalidrawBindableElement,\n) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2);\n\nexport const updateBoundPoint = (\n  arrow: NonDeleted<ExcalidrawArrowElement>,\n  startOrEnd: \"startBinding\" | \"endBinding\",\n  binding: FixedPointBinding | null | undefined,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  opts?: {\n    customIntersector?: LineSegment<GlobalPoint>;\n  },\n): LocalPoint | null => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== bindableElement.id && arrow.points.length > 2) ||\n    // Initial arrow created on pointer down needs to not update the points\n    pointsEqual(\n      arrow.points[arrow.points.length - 1],\n      pointFrom<LocalPoint>(0, 0),\n    )\n  ) {\n    return null;\n  }\n\n  const global = getGlobalFixedPointForBindableElement(\n    normalizeFixedPoint(binding.fixedPoint),\n    bindableElement,\n    elementsMap,\n  );\n  const pointIndex =\n    startOrEnd === \"startBinding\" ? 0 : arrow.points.length - 1;\n  const elbowed = isElbowArrow(arrow);\n  const otherBinding =\n    startOrEnd === \"startBinding\" ? arrow.endBinding : arrow.startBinding;\n  const otherBindableElement =\n    otherBinding &&\n    (elementsMap.get(otherBinding.elementId)! as ExcalidrawBindableElement);\n  const bounds = getElementBounds(bindableElement, elementsMap);\n  const otherBounds =\n    otherBindableElement && getElementBounds(otherBindableElement, elementsMap);\n  const isLargerThanOther =\n    otherBindableElement &&\n    compareElementArea(bindableElement, otherBindableElement) <\n      // if both shapes the same size, pretend the other is larger\n      (startOrEnd === \"endBinding\" ? 1 : 0);\n  const isOverlapping = otherBounds && doBoundsIntersect(bounds, otherBounds);\n\n  // GOAL: If the arrow becomes too short, we want to jump the arrow endpoints\n  // to the exact focus points on the elements.\n  // INTUITION: We're not interested in the exacts length of the arrow (which\n  // will change if we change where we route it), we want to know the length of\n  // the part which lies outside of both shapes and consider that as a trigger\n  // to change where we point the arrow. Avoids jumping the arrow in and out\n  // at every frame.\n  let arrowTooShort = false;\n  if (\n    !isOverlapping &&\n    !elbowed &&\n    arrow.startBinding &&\n    arrow.endBinding &&\n    otherBindableElement &&\n    arrow.points.length === 2\n  ) {\n    const startFocusPoint = getGlobalFixedPointForBindableElement(\n      arrow.startBinding.fixedPoint,\n      startOrEnd === \"startBinding\" ? bindableElement : otherBindableElement,\n      elementsMap,\n    );\n    const endFocusPoint = getGlobalFixedPointForBindableElement(\n      arrow.endBinding.fixedPoint,\n      startOrEnd === \"endBinding\" ? bindableElement : otherBindableElement,\n      elementsMap,\n    );\n    const segment = lineSegment(startFocusPoint, endFocusPoint);\n    const startIntersection = intersectElementWithLineSegment(\n      startOrEnd === \"endBinding\" ? bindableElement : otherBindableElement,\n      elementsMap,\n      segment,\n      0,\n      true,\n    );\n    const endIntersection = intersectElementWithLineSegment(\n      startOrEnd === \"startBinding\" ? bindableElement : otherBindableElement,\n      elementsMap,\n      segment,\n      0,\n      true,\n    );\n    if (startIntersection.length > 0 && endIntersection.length > 0) {\n      const len = pointDistance(startIntersection[0], endIntersection[0]);\n      arrowTooShort = len < 40;\n    }\n  }\n\n  const isNested = (arrowTooShort || isOverlapping) && isLargerThanOther;\n\n  let _customIntersector = opts?.customIntersector;\n  if (!elbowed && !_customIntersector) {\n    const [x1, y1, x2, y2] = LinearElementEditor.getElementAbsoluteCoords(\n      arrow,\n      elementsMap,\n    );\n    const center = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n    const edgePoint = global;\n    const adjacentPoint = pointRotateRads(\n      pointFrom<GlobalPoint>(\n        arrow.x +\n          arrow.points[pointIndex === 0 ? 1 : arrow.points.length - 2][0],\n        arrow.y +\n          arrow.points[pointIndex === 0 ? 1 : arrow.points.length - 2][1],\n      ),\n      center,\n      arrow.angle as Radians,\n    );\n    const bindingGap = getBindingGap(bindableElement, arrow);\n    const halfVector = vectorScale(\n      vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n      pointDistance(edgePoint, adjacentPoint) +\n        Math.max(bindableElement.width, bindableElement.height) +\n        bindingGap * 2,\n    );\n    _customIntersector = lineSegment(\n      pointFromVector(halfVector, adjacentPoint),\n      pointFromVector(vectorScale(halfVector, -1), adjacentPoint),\n    );\n  }\n\n  const maybeOutlineGlobal =\n    binding.mode === \"orbit\" && bindableElement\n      ? isNested\n        ? global\n        : bindPointToSnapToElementOutline(\n            {\n              ...arrow,\n              points: [\n                pointIndex === 0\n                  ? LinearElementEditor.createPointAt(\n                      arrow,\n                      elementsMap,\n                      global[0],\n                      global[1],\n                      null,\n                    )\n                  : arrow.points[0],\n                ...arrow.points.slice(1, -1),\n                pointIndex === arrow.points.length - 1\n                  ? LinearElementEditor.createPointAt(\n                      arrow,\n                      elementsMap,\n                      global[0],\n                      global[1],\n                      null,\n                    )\n                  : arrow.points[arrow.points.length - 1],\n              ],\n            },\n            bindableElement,\n            pointIndex === 0 ? \"start\" : \"end\",\n            elementsMap,\n            _customIntersector,\n          )\n      : global;\n\n  return LinearElementEditor.createPointAt(\n    arrow,\n    elementsMap,\n    maybeOutlineGlobal[0],\n    maybeOutlineGlobal[1],\n    null,\n  );\n};\n\nexport const calculateFixedPointForElbowArrowBinding = (\n  linearElement: NonDeleted<ExcalidrawElbowArrowElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n): { fixedPoint: FixedPoint } => {\n  const bounds = [\n    hoveredElement.x,\n    hoveredElement.y,\n    hoveredElement.x + hoveredElement.width,\n    hoveredElement.y + hoveredElement.height,\n  ] as Bounds;\n  const snappedPoint = bindPointToSnapToElementOutline(\n    linearElement,\n    hoveredElement,\n    startOrEnd,\n    elementsMap,\n  );\n  const globalMidPoint = pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n  const nonRotatedSnappedGlobalPoint = pointRotateRads(\n    snappedPoint,\n    globalMidPoint,\n    -hoveredElement.angle as Radians,\n  );\n\n  return {\n    fixedPoint: normalizeFixedPoint([\n      (nonRotatedSnappedGlobalPoint[0] - hoveredElement.x) /\n        hoveredElement.width,\n      (nonRotatedSnappedGlobalPoint[1] - hoveredElement.y) /\n        hoveredElement.height,\n    ]),\n  };\n};\n\nexport const calculateFixedPointForNonElbowArrowBinding = (\n  linearElement: NonDeleted<ExcalidrawArrowElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n  focusPoint?: GlobalPoint,\n): { fixedPoint: FixedPoint } => {\n  const edgePoint: GlobalPoint = focusPoint\n    ? focusPoint\n    : LinearElementEditor.getPointAtIndexGlobalCoordinates(\n        linearElement,\n        startOrEnd === \"start\" ? 0 : -1,\n        elementsMap,\n      );\n\n  const elementCenter = elementCenterPoint(hoveredElement, elementsMap);\n\n  // Rotate the point to account for element rotation\n  const nonRotatedPoint = pointRotateRads(\n    edgePoint,\n    elementCenter,\n    -hoveredElement.angle as Radians,\n  );\n\n  // Calculate the ratio relative to the element's bounds\n  const fixedPointX =\n    (nonRotatedPoint[0] - hoveredElement.x) / hoveredElement.width;\n  const fixedPointY =\n    (nonRotatedPoint[1] - hoveredElement.y) / hoveredElement.height;\n\n  return {\n    fixedPoint: normalizeFixedPoint([fixedPointX, fixedPointY]),\n  };\n};\n\nexport const fixDuplicatedBindingsAfterDuplication = (\n  duplicatedElements: ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  duplicateElementsMap: NonDeletedSceneElementsMap,\n) => {\n  for (const duplicateElement of duplicatedElements) {\n    if (\"boundElements\" in duplicateElement && duplicateElement.boundElements) {\n      Object.assign(duplicateElement, {\n        boundElements: duplicateElement.boundElements.reduce(\n          (\n            acc: Mutable<NonNullable<ExcalidrawElement[\"boundElements\"]>>,\n            binding,\n          ) => {\n            const newBindingId = origIdToDuplicateId.get(binding.id);\n            if (newBindingId) {\n              acc.push({ ...binding, id: newBindingId });\n            }\n            return acc;\n          },\n          [],\n        ),\n      });\n    }\n\n    if (\"containerId\" in duplicateElement && duplicateElement.containerId) {\n      Object.assign(duplicateElement, {\n        containerId:\n          origIdToDuplicateId.get(duplicateElement.containerId) ?? null,\n      });\n    }\n\n    if (\"endBinding\" in duplicateElement && duplicateElement.endBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.endBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        endBinding: newEndBindingId\n          ? {\n              ...duplicateElement.endBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n    if (\"startBinding\" in duplicateElement && duplicateElement.startBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.startBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        startBinding: newEndBindingId\n          ? {\n              ...duplicateElement.startBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n\n    if (isElbowArrow(duplicateElement)) {\n      Object.assign(\n        duplicateElement,\n        updateElbowArrowPoints(duplicateElement, duplicateElementsMap, {\n          points: [\n            duplicateElement.points[0],\n            duplicateElement.points[duplicateElement.points.length - 1],\n          ],\n        }),\n      );\n    }\n  }\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const elements = arrayToMap(sceneElements);\n\n  for (const element of deletedElements) {\n    BoundElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n    BindableElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n  }\n};\n\nconst newBoundElements = (\n  boundElements: ExcalidrawElement[\"boundElements\"],\n  idsToRemove: Set<ExcalidrawElement[\"id\"]>,\n  elementsToAdd: Array<ExcalidrawElement> = [],\n) => {\n  if (!boundElements) {\n    return null;\n  }\n\n  const nextBoundElements = boundElements.filter(\n    (boundElement) => !idsToRemove.has(boundElement.id),\n  );\n\n  nextBoundElements.push(\n    ...elementsToAdd.map(\n      (x) =>\n        ({ id: x.id, type: x.type } as\n          | ExcalidrawArrowElement\n          | ExcalidrawTextElement),\n    ),\n  );\n\n  return nextBoundElements;\n};\n\nexport const bindingProperties: Set<BindableProp | BindingProp> = new Set([\n  \"boundElements\",\n  \"frameId\",\n  \"containerId\",\n  \"startBinding\",\n  \"endBinding\",\n]);\n\nexport type BindableProp = \"boundElements\";\n\nexport type BindingProp =\n  | \"frameId\"\n  | \"containerId\"\n  | \"startBinding\"\n  | \"endBinding\";\n\ntype BoundElementsVisitingFunc = (\n  boundElement: ExcalidrawElement | undefined,\n  bindingProp: BindableProp,\n  bindingId: string,\n) => void;\n\ntype BindableElementVisitingFunc<T> = (\n  bindableElement: ExcalidrawElement | undefined,\n  bindingProp: BindingProp,\n  bindingId: string,\n) => T;\n\n/**\n * Tries to visit each bound element (does not have to be found).\n */\nconst boundElementsVisitor = (\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BoundElementsVisitingFunc,\n) => {\n  if (isBindableElement(element)) {\n    // create new instance so that possible mutations won't play a role in visiting order\n    const boundElements = element.boundElements?.slice() ?? [];\n\n    // last added text should be the one we keep (~previous are duplicates)\n    boundElements.forEach(({ id }) => {\n      visit(elements.get(id), \"boundElements\", id);\n    });\n  }\n};\n\n/**\n * Tries to visit each bindable element (does not have to be found).\n */\nconst bindableElementsVisitor = <T>(\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BindableElementVisitingFunc<T>,\n): T[] => {\n  const result: T[] = [];\n\n  if (element.frameId) {\n    const id = element.frameId;\n    result.push(visit(elements.get(id), \"frameId\", id));\n  }\n\n  if (isBoundToContainer(element)) {\n    const id = element.containerId;\n    result.push(visit(elements.get(id), \"containerId\", id));\n  }\n\n  if (isArrowElement(element)) {\n    if (element.startBinding) {\n      const id = element.startBinding.elementId;\n      result.push(visit(elements.get(id), \"startBinding\", id));\n    }\n\n    if (element.endBinding) {\n      const id = element.endBinding.elementId;\n      result.push(visit(elements.get(id), \"endBinding\", id));\n    }\n  }\n\n  return result;\n};\n\n/**\n * Bound element containing bindings to `frameId`, `containerId`, `startBinding` or `endBinding`.\n */\nexport class BoundElement {\n  /**\n   * Unbind the affected non deleted bindable elements (removing element from `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to unbind each bindable element's `boundElements` from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!boundElement) {\n      return;\n    }\n\n    bindableElementsVisitor(elements, boundElement, (bindableElement) => {\n      // bindable element is deleted, this is fine\n      if (!bindableElement || bindableElement.isDeleted) {\n        return;\n      }\n\n      boundElementsVisitor(\n        elements,\n        bindableElement,\n        (_, __, boundElementId) => {\n          if (boundElementId === boundElement.id) {\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElementId]),\n              ),\n            });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the next affected non deleted bindable elements (adding element to `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to rebind each bindable element's `boundElements` to the current element\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BoundElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted\n    if (!boundElement || boundElement.isDeleted) {\n      return;\n    }\n\n    bindableElementsVisitor(\n      elements,\n      boundElement,\n      (bindableElement, bindingProp) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!bindableElement || bindableElement.isDeleted) {\n          updateElementWith(boundElement, { [bindingProp]: null });\n          return;\n        }\n\n        // frame bindings are unidirectional, there is nothing to rebind\n        if (bindingProp === \"frameId\") {\n          return;\n        }\n\n        if (\n          bindableElement.boundElements?.find((x) => x.id === boundElement.id)\n        ) {\n          return;\n        }\n\n        if (isArrowElement(boundElement)) {\n          // rebind if not found!\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set(),\n              new Array(boundElement),\n            ),\n          });\n        }\n\n        if (isTextElement(boundElement)) {\n          if (!bindableElement.boundElements?.find((x) => x.type === \"text\")) {\n            // rebind only if there is no other text bound already\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set(),\n                new Array(boundElement),\n              ),\n            });\n          } else {\n            // unbind otherwise\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        }\n      },\n    );\n  };\n}\n\n/**\n * Bindable element containing bindings to `boundElements`.\n */\nexport class BindableElement {\n  /**\n   * Unbind the affected non deleted bound elements (resetting `containerId`, `startBinding`, `endBinding` to `null`).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to unbind each bound element from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!bindableElement) {\n      return;\n    }\n\n    boundElementsVisitor(elements, bindableElement, (boundElement) => {\n      // bound element is deleted, this is fine\n      if (!boundElement || boundElement.isDeleted) {\n        return;\n      }\n\n      bindableElementsVisitor(\n        elements,\n        boundElement,\n        (_, bindingProp, bindableElementId) => {\n          // making sure there is an element to be unbound\n          if (bindableElementId === bindableElement.id) {\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the affected non deleted bound elements (for now setting only `containerId`, as we cannot rebind arrows atm).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to rebind each bound element to the current element or unbind it from `boundElements` in case of conflicts\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BindaleElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted (i.e. updated as deleted)\n    if (!bindableElement || bindableElement.isDeleted) {\n      return;\n    }\n\n    boundElementsVisitor(\n      elements,\n      bindableElement,\n      (boundElement, _, boundElementId) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!boundElement || boundElement.isDeleted) {\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set([boundElementId]),\n            ),\n          });\n          return;\n        }\n\n        if (isTextElement(boundElement)) {\n          const boundElements = bindableElement.boundElements?.slice() ?? [];\n          // check if this is the last element in the array, if not, there is an previously bound text which should be unbound\n          if (\n            boundElements.reverse().find((x) => x.type === \"text\")?.id ===\n            boundElement.id\n          ) {\n            if (boundElement.containerId !== bindableElement.id) {\n              // rebind if not bound already!\n              updateElementWith(boundElement, {\n                containerId: bindableElement.id,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n          } else {\n            if (boundElement.containerId !== null) {\n              // unbind if not unbound already\n              updateElementWith(boundElement, {\n                containerId: null,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n\n            // unbind from boundElements as the element got bound to some other element in the meantime\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElement.id]),\n              ),\n            });\n          }\n        }\n      },\n    );\n  };\n}\n\nexport const getGlobalFixedPointForBindableElement = (\n  fixedPointRatio: FixedPoint,\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): GlobalPoint => {\n  const [fixedX, fixedY] = normalizeFixedPoint(fixedPointRatio);\n\n  return pointRotateRads(\n    pointFrom(\n      element.x + element.width * fixedX,\n      element.y + element.height * fixedY,\n    ),\n    elementCenterPoint(element, elementsMap),\n    element.angle,\n  );\n};\n\nexport const getGlobalFixedPoints = (\n  arrow: ExcalidrawArrowElement,\n  elementsMap: ElementsMap,\n): [GlobalPoint, GlobalPoint] => {\n  const startElement =\n    arrow.startBinding &&\n    (elementsMap.get(arrow.startBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const endElement =\n    arrow.endBinding &&\n    (elementsMap.get(arrow.endBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const startPoint =\n    startElement && arrow.startBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.startBinding.fixedPoint,\n          startElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        );\n  const endPoint =\n    endElement && arrow.endBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.endBinding.fixedPoint,\n          endElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        );\n\n  return [startPoint, endPoint];\n};\n\nexport const getArrowLocalFixedPoints = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: ElementsMap,\n) => {\n  const [startPoint, endPoint] = getGlobalFixedPoints(arrow, elementsMap);\n\n  return [\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, startPoint, elementsMap),\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, endPoint, elementsMap),\n  ];\n};\n\nexport const normalizeFixedPoint = <T extends FixedPoint | null>(\n  fixedPoint: T,\n): T extends null ? null : FixedPoint => {\n  // Do not allow a precise 0.5 for fixed point ratio\n  // to avoid jumping arrow heading due to floating point imprecision\n  if (\n    fixedPoint &&\n    (Math.abs(fixedPoint[0] - 0.5) < 0.0001 ||\n      Math.abs(fixedPoint[1] - 0.5) < 0.0001)\n  ) {\n    return fixedPoint.map((ratio) =>\n      Math.abs(ratio - 0.5) < 0.0001 ? 0.5001 : ratio,\n    ) as T extends null ? null : FixedPoint;\n  }\n  return fixedPoint as any as T extends null ? null : FixedPoint;\n};\n\ntype Side =\n  | \"top\"\n  | \"top-right\"\n  | \"right\"\n  | \"bottom-right\"\n  | \"bottom\"\n  | \"bottom-left\"\n  | \"left\"\n  | \"top-left\";\ntype ShapeType = \"rectangle\" | \"ellipse\" | \"diamond\";\nconst getShapeType = (element: ExcalidrawBindableElement): ShapeType => {\n  if (element.type === \"ellipse\" || element.type === \"diamond\") {\n    return element.type;\n  }\n  return \"rectangle\";\n};\n\ninterface SectorConfig {\n  // center angle of the sector in degrees\n  centerAngle: number;\n  // width of the sector in degrees\n  sectorWidth: number;\n  side: Side;\n}\n\n// Define sector configurations for different shape types\nconst SHAPE_CONFIGS: Record<ShapeType, SectorConfig[]> = {\n  // rectangle: 15\u00B0 corners, 75\u00B0 edges\n  rectangle: [\n    { centerAngle: 0, sectorWidth: 75, side: \"right\" },\n    { centerAngle: 45, sectorWidth: 15, side: \"bottom-right\" },\n    { centerAngle: 90, sectorWidth: 75, side: \"bottom\" },\n    { centerAngle: 135, sectorWidth: 15, side: \"bottom-left\" },\n    { centerAngle: 180, sectorWidth: 75, side: \"left\" },\n    { centerAngle: 225, sectorWidth: 15, side: \"top-left\" },\n    { centerAngle: 270, sectorWidth: 75, side: \"top\" },\n    { centerAngle: 315, sectorWidth: 15, side: \"top-right\" },\n  ],\n\n  // diamond: 15\u00B0 vertices, 75\u00B0 edges\n  diamond: [\n    { centerAngle: 0, sectorWidth: 15, side: \"right\" },\n    { centerAngle: 45, sectorWidth: 75, side: \"bottom-right\" },\n    { centerAngle: 90, sectorWidth: 15, side: \"bottom\" },\n    { centerAngle: 135, sectorWidth: 75, side: \"bottom-left\" },\n    { centerAngle: 180, sectorWidth: 15, side: \"left\" },\n    { centerAngle: 225, sectorWidth: 75, side: \"top-left\" },\n    { centerAngle: 270, sectorWidth: 15, side: \"top\" },\n    { centerAngle: 315, sectorWidth: 75, side: \"top-right\" },\n  ],\n\n  // ellipse: 15\u00B0 cardinal points, 75\u00B0 diagonals\n  ellipse: [\n    { centerAngle: 0, sectorWidth: 15, side: \"right\" },\n    { centerAngle: 45, sectorWidth: 75, side: \"bottom-right\" },\n    { centerAngle: 90, sectorWidth: 15, side: \"bottom\" },\n    { centerAngle: 135, sectorWidth: 75, side: \"bottom-left\" },\n    { centerAngle: 180, sectorWidth: 15, side: \"left\" },\n    { centerAngle: 225, sectorWidth: 75, side: \"top-left\" },\n    { centerAngle: 270, sectorWidth: 15, side: \"top\" },\n    { centerAngle: 315, sectorWidth: 75, side: \"top-right\" },\n  ],\n};\n\nconst getSectorBoundaries = (\n  config: SectorConfig[],\n): Array<{ start: number; end: number; side: Side }> => {\n  return config.map((sector, index) => {\n    const halfWidth = sector.sectorWidth / 2;\n    let start = sector.centerAngle - halfWidth;\n    let end = sector.centerAngle + halfWidth;\n\n    // normalize angles to [0, 360) range\n    start = ((start % 360) + 360) % 360;\n    end = ((end % 360) + 360) % 360;\n\n    return { start, end, side: sector.side };\n  });\n};\n\n// determine which side a point falls into using adaptive sectors\nconst getShapeSideAdaptive = (\n  fixedPoint: FixedPoint,\n  shapeType: ShapeType,\n): Side => {\n  const [x, y] = fixedPoint;\n\n  // convert to centered coordinates\n  const centerX = x - 0.5;\n  const centerY = y - 0.5;\n\n  // calculate angle\n  let angle = Math.atan2(centerY, centerX);\n  if (angle < 0) {\n    angle += 2 * Math.PI;\n  }\n  const degrees = (angle * 180) / Math.PI;\n\n  // get sector configuration for this shape type\n  const config = SHAPE_CONFIGS[shapeType];\n  const boundaries = getSectorBoundaries(config);\n\n  // find which sector the angle falls into\n  for (const boundary of boundaries) {\n    if (boundary.start <= boundary.end) {\n      // Normal case: sector doesn't cross 0\u00B0\n      if (degrees >= boundary.start && degrees <= boundary.end) {\n        return boundary.side;\n      }\n    } else if (degrees >= boundary.start || degrees <= boundary.end) {\n      return boundary.side;\n    }\n  }\n\n  // fallback - find nearest sector center\n  let minDiff = Infinity;\n  let nearestSide = config[0].side;\n\n  for (const sector of config) {\n    let diff = Math.abs(degrees - sector.centerAngle);\n    // handle wraparound\n    if (diff > 180) {\n      diff = 360 - diff;\n    }\n\n    if (diff < minDiff) {\n      minDiff = diff;\n      nearestSide = sector.side;\n    }\n  }\n\n  return nearestSide;\n};\n\nexport const getBindingSideMidPoint = (\n  binding: FixedPointBinding,\n  elementsMap: ElementsMap,\n) => {\n  const bindableElement = elementsMap.get(binding.elementId);\n  if (\n    !bindableElement ||\n    bindableElement.isDeleted ||\n    !isBindableElement(bindableElement)\n  ) {\n    return null;\n  }\n\n  const center = elementCenterPoint(bindableElement, elementsMap);\n  const shapeType = getShapeType(bindableElement);\n  const side = getShapeSideAdaptive(\n    normalizeFixedPoint(binding.fixedPoint),\n    shapeType,\n  );\n\n  // small offset to avoid precision issues in elbow\n  const OFFSET = 0.01;\n\n  if (bindableElement.type === \"diamond\") {\n    const [sides, corners] = deconstructDiamondElement(bindableElement);\n    const [bottomRight, bottomLeft, topLeft, topRight] = sides;\n\n    let x: number;\n    let y: number;\n    switch (side) {\n      case \"left\": {\n        // left vertex - use the center of the left corner curve\n        if (corners.length >= 3) {\n          const leftCorner = corners[2];\n          const midPoint = leftCorner[1];\n          x = midPoint[0] - OFFSET;\n          y = midPoint[1];\n        } else {\n          // fallback for non-rounded diamond\n          const midPoint = getMidPoint(bottomLeft[1], topLeft[0]);\n          x = midPoint[0] - OFFSET;\n          y = midPoint[1];\n        }\n        break;\n      }\n      case \"right\": {\n        if (corners.length >= 1) {\n          const rightCorner = corners[0];\n          const midPoint = rightCorner[1];\n          x = midPoint[0] + OFFSET;\n          y = midPoint[1];\n        } else {\n          const midPoint = getMidPoint(topRight[1], bottomRight[0]);\n          x = midPoint[0] + OFFSET;\n          y = midPoint[1];\n        }\n        break;\n      }\n      case \"top\": {\n        if (corners.length >= 4) {\n          const topCorner = corners[3];\n          const midPoint = topCorner[1];\n          x = midPoint[0];\n          y = midPoint[1] - OFFSET;\n        } else {\n          const midPoint = getMidPoint(topLeft[1], topRight[0]);\n          x = midPoint[0];\n          y = midPoint[1] - OFFSET;\n        }\n        break;\n      }\n      case \"bottom\": {\n        if (corners.length >= 2) {\n          const bottomCorner = corners[1];\n          const midPoint = bottomCorner[1];\n          x = midPoint[0];\n          y = midPoint[1] + OFFSET;\n        } else {\n          const midPoint = getMidPoint(bottomRight[1], bottomLeft[0]);\n          x = midPoint[0];\n          y = midPoint[1] + OFFSET;\n        }\n        break;\n      }\n      case \"top-right\": {\n        const midPoint = getMidPoint(topRight[0], topRight[1]);\n\n        x = midPoint[0] + OFFSET * 0.707;\n        y = midPoint[1] - OFFSET * 0.707;\n        break;\n      }\n      case \"bottom-right\": {\n        const midPoint = getMidPoint(bottomRight[0], bottomRight[1]);\n\n        x = midPoint[0] + OFFSET * 0.707;\n        y = midPoint[1] + OFFSET * 0.707;\n        break;\n      }\n      case \"bottom-left\": {\n        const midPoint = getMidPoint(bottomLeft[0], bottomLeft[1]);\n        x = midPoint[0] - OFFSET * 0.707;\n        y = midPoint[1] + OFFSET * 0.707;\n        break;\n      }\n      case \"top-left\": {\n        const midPoint = getMidPoint(topLeft[0], topLeft[1]);\n        x = midPoint[0] - OFFSET * 0.707;\n        y = midPoint[1] - OFFSET * 0.707;\n        break;\n      }\n      default: {\n        return null;\n      }\n    }\n\n    return pointRotateRads(pointFrom(x, y), center, bindableElement.angle);\n  }\n\n  if (bindableElement.type === \"ellipse\") {\n    const ellipseCenterX = bindableElement.x + bindableElement.width / 2;\n    const ellipseCenterY = bindableElement.y + bindableElement.height / 2;\n    const radiusX = bindableElement.width / 2;\n    const radiusY = bindableElement.height / 2;\n\n    let x: number;\n    let y: number;\n\n    switch (side) {\n      case \"top\": {\n        x = ellipseCenterX;\n        y = ellipseCenterY - radiusY - OFFSET;\n        break;\n      }\n      case \"right\": {\n        x = ellipseCenterX + radiusX + OFFSET;\n        y = ellipseCenterY;\n        break;\n      }\n      case \"bottom\": {\n        x = ellipseCenterX;\n        y = ellipseCenterY + radiusY + OFFSET;\n        break;\n      }\n      case \"left\": {\n        x = ellipseCenterX - radiusX - OFFSET;\n        y = ellipseCenterY;\n        break;\n      }\n      case \"top-right\": {\n        const angle = -Math.PI / 4;\n        const ellipseX = radiusX * Math.cos(angle);\n        const ellipseY = radiusY * Math.sin(angle);\n        x = ellipseCenterX + ellipseX + OFFSET * 0.707;\n        y = ellipseCenterY + ellipseY - OFFSET * 0.707;\n        break;\n      }\n      case \"bottom-right\": {\n        const angle = Math.PI / 4;\n        const ellipseX = radiusX * Math.cos(angle);\n        const ellipseY = radiusY * Math.sin(angle);\n        x = ellipseCenterX + ellipseX + OFFSET * 0.707;\n        y = ellipseCenterY + ellipseY + OFFSET * 0.707;\n        break;\n      }\n      case \"bottom-left\": {\n        const angle = (3 * Math.PI) / 4;\n        const ellipseX = radiusX * Math.cos(angle);\n        const ellipseY = radiusY * Math.sin(angle);\n        x = ellipseCenterX + ellipseX - OFFSET * 0.707;\n        y = ellipseCenterY + ellipseY + OFFSET * 0.707;\n        break;\n      }\n      case \"top-left\": {\n        const angle = (-3 * Math.PI) / 4;\n        const ellipseX = radiusX * Math.cos(angle);\n        const ellipseY = radiusY * Math.sin(angle);\n        x = ellipseCenterX + ellipseX - OFFSET * 0.707;\n        y = ellipseCenterY + ellipseY - OFFSET * 0.707;\n        break;\n      }\n      default: {\n        return null;\n      }\n    }\n\n    return pointRotateRads(pointFrom(x, y), center, bindableElement.angle);\n  }\n\n  if (isRectangularElement(bindableElement)) {\n    const [sides, corners] = deconstructRectanguloidElement(\n      bindableElement as ExcalidrawRectanguloidElement,\n    );\n    const [top, right, bottom, left] = sides;\n\n    let x: number;\n    let y: number;\n    switch (side) {\n      case \"top\": {\n        const midPoint = getMidPoint(top[0], top[1]);\n        x = midPoint[0];\n        y = midPoint[1] - OFFSET;\n        break;\n      }\n      case \"right\": {\n        const midPoint = getMidPoint(right[0], right[1]);\n        x = midPoint[0] + OFFSET;\n        y = midPoint[1];\n        break;\n      }\n      case \"bottom\": {\n        const midPoint = getMidPoint(bottom[0], bottom[1]);\n        x = midPoint[0];\n        y = midPoint[1] + OFFSET;\n        break;\n      }\n      case \"left\": {\n        const midPoint = getMidPoint(left[0], left[1]);\n        x = midPoint[0] - OFFSET;\n        y = midPoint[1];\n        break;\n      }\n      case \"top-left\": {\n        if (corners.length >= 1) {\n          const corner = corners[0];\n\n          const p1 = corner[0];\n          const p2 = corner[3];\n          const midPoint = getMidPoint(p1, p2);\n\n          x = midPoint[0] - OFFSET * 0.707;\n          y = midPoint[1] - OFFSET * 0.707;\n        } else {\n          x = bindableElement.x - OFFSET;\n          y = bindableElement.y - OFFSET;\n        }\n        break;\n      }\n      case \"top-right\": {\n        if (corners.length >= 2) {\n          const corner = corners[1];\n          const p1 = corner[0];\n          const p2 = corner[3];\n          const midPoint = getMidPoint(p1, p2);\n\n          x = midPoint[0] + OFFSET * 0.707;\n          y = midPoint[1] - OFFSET * 0.707;\n        } else {\n          x = bindableElement.x + bindableElement.width + OFFSET;\n          y = bindableElement.y - OFFSET;\n        }\n        break;\n      }\n      case \"bottom-right\": {\n        if (corners.length >= 3) {\n          const corner = corners[2];\n          const p1 = corner[0];\n          const p2 = corner[3];\n          const midPoint = getMidPoint(p1, p2);\n\n          x = midPoint[0] + OFFSET * 0.707;\n          y = midPoint[1] + OFFSET * 0.707;\n        } else {\n          x = bindableElement.x + bindableElement.width + OFFSET;\n          y = bindableElement.y + bindableElement.height + OFFSET;\n        }\n        break;\n      }\n      case \"bottom-left\": {\n        if (corners.length >= 4) {\n          const corner = corners[3];\n          const p1 = corner[0];\n          const p2 = corner[3];\n          const midPoint = getMidPoint(p1, p2);\n\n          x = midPoint[0] - OFFSET * 0.707;\n          y = midPoint[1] + OFFSET * 0.707;\n        } else {\n          x = bindableElement.x - OFFSET;\n          y = bindableElement.y + bindableElement.height + OFFSET;\n        }\n        break;\n      }\n      default: {\n        return null;\n      }\n    }\n\n    return pointRotateRads(pointFrom(x, y), center, bindableElement.angle);\n  }\n\n  return null;\n};\n\nconst getMidPoint = (p1: GlobalPoint, p2: GlobalPoint): GlobalPoint => {\n  return pointFrom((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2);\n};\n", "import { invariant, isTransparent, type Bounds } from \"@excalidraw/common\";\nimport {\n  curveIntersectLineSegment,\n  isPointWithinBounds,\n  lineSegment,\n  lineSegmentIntersectionPoints,\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointsEqual,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport {\n  ellipse,\n  ellipseSegmentInterceptPoints,\n} from \"@excalidraw/math/ellipse\";\n\nimport type {\n  Curve,\n  GlobalPoint,\n  LineSegment,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { FrameNameBounds } from \"@excalidraw/excalidraw/types\";\n\nimport { isPathALoop } from \"./utils\";\nimport {\n  doBoundsIntersect,\n  elementCenterPoint,\n  getCenterForBounds,\n  getCubicBezierCurveBound,\n  getDiamondPoints,\n  getElementBounds,\n  pointInsideBounds,\n} from \"./bounds\";\nimport {\n  hasBoundTextElement,\n  isBindableElement,\n  isFrameLikeElement,\n  isFreeDrawElement,\n  isIframeLikeElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { distanceToElement } from \"./distance\";\n\nimport { getBindingGap } from \"./binding\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  NonDeletedSceneElementsMap,\n  Ordered,\n} from \"./types\";\n\nexport const shouldTestInside = (element: ExcalidrawElement) => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  const isDraggableFromInside =\n    !isTransparent(element.backgroundColor) ||\n    hasBoundTextElement(element) ||\n    isIframeLikeElement(element) ||\n    isTextElement(element);\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  if (element.type === \"freedraw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport type HitTestArgs = {\n  point: GlobalPoint;\n  element: ExcalidrawElement;\n  threshold: number;\n  elementsMap: ElementsMap;\n  frameNameBound?: FrameNameBounds | null;\n  overrideShouldTestInside?: boolean;\n};\n\nlet cachedPoint: GlobalPoint | null = null;\nlet cachedElement: WeakRef<ExcalidrawElement> | null = null;\nlet cachedThreshold: number = Infinity;\nlet cachedHit: boolean = false;\nlet cachedOverrideShouldTestInside = false;\n\nexport const hitElementItself = ({\n  point,\n  element,\n  threshold,\n  elementsMap,\n  frameNameBound = null,\n  overrideShouldTestInside = false,\n}: HitTestArgs) => {\n  // Return cached result if the same point and element version is tested again\n  if (\n    cachedPoint &&\n    pointsEqual(point, cachedPoint) &&\n    cachedThreshold <= threshold &&\n    overrideShouldTestInside === cachedOverrideShouldTestInside\n  ) {\n    const derefElement = cachedElement?.deref();\n    if (\n      derefElement &&\n      derefElement.id === element.id &&\n      derefElement.version === element.version &&\n      derefElement.versionNonce === element.versionNonce\n    ) {\n      return cachedHit;\n    }\n  }\n\n  // Hit test against a frame's name\n  const hitFrameName = frameNameBound\n    ? isPointWithinBounds(\n        pointFrom(frameNameBound.x - threshold, frameNameBound.y - threshold),\n        point,\n        pointFrom(\n          frameNameBound.x + frameNameBound.width + threshold,\n          frameNameBound.y + frameNameBound.height + threshold,\n        ),\n      )\n    : false;\n\n  // Hit test against the extended, rotated bounding box of the element first\n  const bounds = getElementBounds(element, elementsMap, true);\n  const hitBounds = isPointWithinBounds(\n    pointFrom(bounds[0] - threshold, bounds[1] - threshold),\n    pointRotateRads(\n      point,\n      getCenterForBounds(bounds),\n      -element.angle as Radians,\n    ),\n    pointFrom(bounds[2] + threshold, bounds[3] + threshold),\n  );\n\n  // PERF: Bail out early if the point is not even in the\n  // rotated bounding box or not hitting the frame name (saves 99%)\n  if (!hitBounds && !hitFrameName) {\n    return false;\n  }\n\n  // Do the precise (and relatively costly) hit test\n  const hitElement = (\n    overrideShouldTestInside ? true : shouldTestInside(element)\n  )\n    ? // Since `inShape` tests STRICTLY againt the insides of a shape\n      // we would need `onShape` as well to include the \"borders\"\n      isPointInElement(point, element, elementsMap) ||\n      isPointOnElementOutline(point, element, elementsMap, threshold)\n    : isPointOnElementOutline(point, element, elementsMap, threshold);\n\n  const result = hitElement || hitFrameName;\n\n  // Cache end result\n  cachedPoint = point;\n  cachedElement = new WeakRef(element);\n  cachedThreshold = threshold;\n  cachedOverrideShouldTestInside = overrideShouldTestInside;\n  cachedHit = result;\n\n  return result;\n};\n\nexport const hitElementBoundingBox = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 0,\n) => {\n  let [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n  x1 -= tolerance;\n  y1 -= tolerance;\n  x2 += tolerance;\n  y2 += tolerance;\n  return isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2));\n};\n\nexport const hitElementBoundingBoxOnly = (\n  hitArgs: HitTestArgs,\n  elementsMap: ElementsMap,\n) =>\n  !hitElementItself(hitArgs) &&\n  // bound text is considered part of the element (even if it's outside the bounding box)\n  !hitElementBoundText(hitArgs.point, hitArgs.element, elementsMap) &&\n  hitElementBoundingBox(hitArgs.point, hitArgs.element, elementsMap);\n\nexport const hitElementBoundText = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  const boundTextElementCandidate = getBoundTextElement(element, elementsMap);\n\n  if (!boundTextElementCandidate) {\n    return false;\n  }\n  const boundTextElement = isLinearElement(element)\n    ? {\n        ...boundTextElementCandidate,\n        // arrow's bound text accurate position is not stored in the element's property\n        // but rather calculated and returned from the following static method\n        ...LinearElementEditor.getBoundTextElementPosition(\n          element,\n          boundTextElementCandidate,\n          elementsMap,\n        ),\n      }\n    : boundTextElementCandidate;\n\n  return isPointInElement(point, boundTextElement, elementsMap);\n};\n\nconst bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  [x, y]: Readonly<GlobalPoint>,\n  elementsMap: NonDeletedSceneElementsMap,\n  tolerance: number = 0,\n): boolean => {\n  const p = pointFrom<GlobalPoint>(x, y);\n  const shouldTestInside =\n    // disable fullshape snapping for frame elements so we\n    // can bind to frame children\n    !isFrameLikeElement(element);\n\n  // PERF: Run a cheap test to see if the binding element\n  // is even close to the element\n  const t = Math.max(1, tolerance);\n  const bounds = [x - t, y - t, x + t, y + t] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n  if (!doBoundsIntersect(bounds, elementBounds)) {\n    return false;\n  }\n\n  // If the element is inside a frame, we should clip the element\n  if (element.frameId) {\n    const enclosingFrame = elementsMap.get(element.frameId);\n    if (enclosingFrame && isFrameLikeElement(enclosingFrame)) {\n      const enclosingFrameBounds = getElementBounds(\n        enclosingFrame,\n        elementsMap,\n      );\n      if (!pointInsideBounds(p, enclosingFrameBounds)) {\n        return false;\n      }\n    }\n  }\n\n  // Do the intersection test against the element since it's close enough\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    lineSegment(elementCenterPoint(element, elementsMap), p),\n  );\n  const distance = distanceToElement(element, elementsMap, p);\n\n  return shouldTestInside\n    ? intersections.length === 0 || distance <= tolerance\n    : intersections.length > 0 && distance <= t;\n};\n\nexport const getAllHoveredElementAtPoint = (\n  point: Readonly<GlobalPoint>,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  tolerance?: number,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  const candidateElements: NonDeleted<ExcalidrawBindableElement>[] = [];\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n\n    invariant(\n      !element.isDeleted,\n      \"Elements in the function parameter for getAllElementsAtPositionForBinding() should not contain deleted elements\",\n    );\n\n    if (\n      isBindableElement(element, false) &&\n      bindingBorderTest(element, point, elementsMap, tolerance)\n    ) {\n      candidateElements.push(element);\n\n      if (!isTransparent(element.backgroundColor)) {\n        break;\n      }\n    }\n  }\n\n  return candidateElements;\n};\n\nexport const getHoveredElementForBinding = (\n  point: Readonly<GlobalPoint>,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  tolerance?: number,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const candidateElements = getAllHoveredElementAtPoint(\n    point,\n    elements,\n    elementsMap,\n    tolerance,\n  );\n\n  if (!candidateElements || candidateElements.length === 0) {\n    return null;\n  }\n\n  if (candidateElements.length === 1) {\n    return candidateElements[0];\n  }\n\n  // Prefer smaller shapes\n  return candidateElements\n    .sort(\n      (a, b) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2),\n    )\n    .pop() as NonDeleted<ExcalidrawBindableElement>;\n};\n\nexport const getHoveredElementForFocusPoint = (\n  point: GlobalPoint,\n  arrow: ExcalidrawArrowElement,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  tolerance?: number,\n): ExcalidrawBindableElement | null => {\n  const candidateElements: NonDeleted<ExcalidrawBindableElement>[] = [];\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n\n    invariant(\n      !element.isDeleted,\n      \"Elements in the function parameter for getAllElementsAtPositionForBinding() should not contain deleted elements\",\n    );\n\n    if (\n      isBindableElement(element, false) &&\n      bindingBorderTest(element, point, elementsMap, tolerance)\n    ) {\n      candidateElements.push(element);\n    }\n  }\n\n  if (!candidateElements || candidateElements.length === 0) {\n    return null;\n  }\n\n  if (candidateElements.length === 1) {\n    return candidateElements[0];\n  }\n\n  const distanceFilteredCandidateElements = candidateElements\n    // Resolve by distance\n    .filter(\n      (el) =>\n        distanceToElement(el, elementsMap, point) <= getBindingGap(el, arrow) ||\n        isPointInElement(point, el, elementsMap),\n    );\n\n  if (distanceFilteredCandidateElements.length === 0) {\n    return null;\n  }\n\n  return distanceFilteredCandidateElements[0] as NonDeleted<ExcalidrawBindableElement>;\n};\n\n/**\n * Intersect a line with an element for binding test\n *\n * @param element\n * @param line\n * @param offset\n * @returns\n */\nexport const intersectElementWithLineSegment = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  line: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // First check if the line intersects the element's axis-aligned bounding box\n  // as it is much faster than checking intersection against the element's shape\n  const intersectorBounds = [\n    Math.min(line[0][0] - offset, line[1][0] - offset),\n    Math.min(line[0][1] - offset, line[1][1] - offset),\n    Math.max(line[0][0] + offset, line[1][0] + offset),\n    Math.max(line[0][1] + offset, line[1][1] + offset),\n  ] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n\n  if (!doBoundsIntersect(intersectorBounds, elementBounds)) {\n    return [];\n  }\n\n  // Do the actual intersection test against the element's shape\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"selection\":\n    case \"magicframe\":\n      return intersectRectanguloidWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"diamond\":\n      return intersectDiamondWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"ellipse\":\n      return intersectEllipseWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n      );\n    case \"line\":\n    case \"freedraw\":\n    case \"arrow\":\n      return intersectLinearOrFreeDrawWithLineSegment(element, line, onlyFirst);\n  }\n};\n\nconst curveIntersections = (\n  curves: Curve<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      for (const j of hits) {\n        intersections.push(pointRotateRads(j, center, angle));\n      }\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst lineIntersections = (\n  lines: LineSegment<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(pointRotateRads(intersection, center, angle));\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectLinearOrFreeDrawWithLineSegment = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  segment: LineSegment<GlobalPoint>,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // NOTE: This is the only one which return the decomposed elements\n  // rotated! This is due to taking advantage of roughjs definitions.\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  const intersections: GlobalPoint[] = [];\n\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(intersection);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      intersections.push(...hits);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectRectanguloidWithLineSegment = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  segment: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedA = pointRotateRads<GlobalPoint>(\n    segment[0],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedB = pointRotateRads<GlobalPoint>(\n    segment[1],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element, offset);\n\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectDiamondWithLineSegment = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  const [sides, corners] = deconstructDiamondElement(element, offset);\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectEllipseWithLineSegment = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n\n  return ellipseSegmentInterceptPoints(\n    ellipse(center, element.width / 2 + offset, element.height / 2 + offset),\n    lineSegment(rotatedA, rotatedB),\n  ).map((p) => pointRotateRads(p, center, element.angle));\n};\n\n/**\n * Check if the given point is considered on the given shape's border\n *\n * @param point\n * @param element\n * @param tolerance\n * @returns\n */\nconst isPointOnElementOutline = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 1,\n) => distanceToElement(element, elementsMap, point) <= tolerance;\n\n/**\n * Check if the given point is considered inside the element's border\n *\n * @param point\n * @param element\n * @returns\n */\nexport const isPointInElement = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (\n    (isLinearElement(element) || isFreeDrawElement(element)) &&\n    !isPathALoop(element.points)\n  ) {\n    // There isn't any \"inside\" for a non-looping path\n    return false;\n  }\n\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n\n  if (!isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2))) {\n    return false;\n  }\n\n  const center = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n  const otherPoint = pointFromVector(\n    vectorScale(\n      vectorNormalize(vectorFromPoint(point, center, 0.1)),\n      Math.max(element.width, element.height) * 2,\n    ),\n    center,\n  );\n  const intersector = lineSegment(point, otherPoint);\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    intersector,\n  ).filter((p, pos, arr) => arr.findIndex((q) => pointsEqual(q, p)) === pos);\n\n  return intersections.length % 2 === 1;\n};\n\nexport const isBindableElementInsideOtherBindable = (\n  innerElement: ExcalidrawBindableElement,\n  outerElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  // Get corner points of the inner element based on its type\n  const getCornerPoints = (\n    element: ExcalidrawElement,\n    offset: number,\n  ): GlobalPoint[] => {\n    const { x, y, width, height, angle } = element;\n    const center = elementCenterPoint(element, elementsMap);\n\n    if (element.type === \"diamond\") {\n      // Diamond has 4 corner points at the middle of each side\n      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n        getDiamondPoints(element);\n      const corners: GlobalPoint[] = [\n        pointFrom(x + topX, y + topY - offset), // top\n        pointFrom(x + rightX + offset, y + rightY), // right\n        pointFrom(x + bottomX, y + bottomY + offset), // bottom\n        pointFrom(x + leftX - offset, y + leftY), // left\n      ];\n      return corners.map((corner) => pointRotateRads(corner, center, angle));\n    }\n    if (element.type === \"ellipse\") {\n      // For ellipse, test points at the extremes (top, right, bottom, left)\n      const cx = x + width / 2;\n      const cy = y + height / 2;\n      const rx = width / 2;\n      const ry = height / 2;\n      const corners: GlobalPoint[] = [\n        pointFrom(cx, cy - ry - offset), // top\n        pointFrom(cx + rx + offset, cy), // right\n        pointFrom(cx, cy + ry + offset), // bottom\n        pointFrom(cx - rx - offset, cy), // left\n      ];\n      return corners.map((corner) => pointRotateRads(corner, center, angle));\n    }\n    // Rectangle and other rectangular shapes (image, text, etc.)\n    const corners: GlobalPoint[] = [\n      pointFrom(x - offset, y - offset), // top-left\n      pointFrom(x + width + offset, y - offset), // top-right\n      pointFrom(x + width + offset, y + height + offset), // bottom-right\n      pointFrom(x - offset, y + height + offset), // bottom-left\n    ];\n    return corners.map((corner) => pointRotateRads(corner, center, angle));\n  };\n\n  const offset = (-1 * Math.max(innerElement.width, innerElement.height)) / 20; // 5% offset\n  const innerCorners = getCornerPoints(innerElement, offset);\n\n  // Check if all corner points of the inner element are inside the outer element\n  return innerCorners.every((corner) =>\n    isPointInElement(corner, outerElement, elementsMap),\n  );\n};\n", "import {\n  DEFAULT_ADAPTIVE_RADIUS,\n  DEFAULT_PROPORTIONAL_RADIUS,\n  invariant,\n  LINE_CONFIRM_THRESHOLD,\n  ROUNDNESS,\n} from \"@excalidraw/common\";\n\nimport {\n  bezierEquation,\n  curve,\n  curveCatmullRomCubicApproxPoints,\n  curveOffsetPoints,\n  lineSegment,\n  lineSegmentIntersectionPoints,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  pointFromVector,\n  pointRotateRads,\n  pointTranslate,\n  rectangle,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorScale,\n  type GlobalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Curve, LineSegment, LocalPoint } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  NormalizedZoomValue,\n  Zoom,\n} from \"@excalidraw/excalidraw/types\";\n\nimport { elementCenterPoint, getDiamondPoints } from \"./bounds\";\n\nimport { generateLinearCollisionShape } from \"./shape\";\n\nimport { hitElementItself, isPointInElement } from \"./collision\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { isRectangularElement } from \"./typeChecks\";\nimport { maxBindingDistance_simple } from \"./binding\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\ntype ElementShape = [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]];\n\nconst ElementShapesCache = new WeakMap<\n  ExcalidrawElement,\n  { version: ExcalidrawElement[\"version\"]; shapes: Map<number, ElementShape> }\n>();\n\nconst getElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  offset: number,\n): ElementShape | undefined => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    return undefined;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.delete(element);\n    return undefined;\n  }\n\n  return shapes.get(offset);\n};\n\nconst setElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  shape: ElementShape,\n  offset: number,\n) => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  shapes.set(offset, shape);\n};\n\n/**\n * Returns the **rotated** components of freedraw, line or arrow elements.\n *\n * @param element The linear element to deconstruct\n * @returns The rotated in components.\n */\nexport function deconstructLinearOrFreeDrawElement(\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, 0);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const ops = generateLinearCollisionShape(element) as {\n    op: string;\n    data: number[];\n  }[];\n  const lines = [];\n  const curves = [];\n\n  for (let idx = 0; idx < ops.length; idx += 1) {\n    const op = ops[idx];\n    const prevPoint =\n      ops[idx - 1] && pointFromArray<LocalPoint>(ops[idx - 1].data.slice(-2));\n    switch (op.op) {\n      case \"move\":\n        continue;\n      case \"lineTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        lines.push(\n          lineSegment<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n          ),\n        );\n        continue;\n      case \"bcurveTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        curves.push(\n          curve<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[2],\n              element.y + op.data[3],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[4],\n              element.y + op.data[5],\n            ),\n          ),\n        );\n        continue;\n      default: {\n        console.error(\"Unknown op type\", op.op);\n      }\n    }\n  }\n\n  const shape = [lines, curves] as ElementShape;\n  setElementShapesCacheEntry(element, shape, 0);\n\n  return shape;\n}\n\n/**\n * Get the building components of a rectanguloid element in the form of\n * line segments and curves **unrotated**.\n *\n * @param element Target rectanguloid element\n * @param offset Optional offset to expand the rectanguloid shape\n * @returns Tuple of **unrotated** line segments (0) and curves (1)\n */\nexport function deconstructRectanguloidElement(\n  element: ExcalidrawRectanguloidElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  let radius = getCornerRadius(\n    Math.min(element.width, element.height),\n    element,\n  );\n\n  if (radius === 0) {\n    radius = 0.01;\n  }\n\n  const r = rectangle(\n    pointFrom(element.x, element.y),\n    pointFrom(element.x + element.width, element.y + element.height),\n  );\n\n  const top = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[0][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[0][1]),\n  );\n  const right = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[1][0], r[0][1] + radius),\n    pointFrom<GlobalPoint>(r[1][0], r[1][1] - radius),\n  );\n  const bottom = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[1][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[1][1]),\n  );\n  const left = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0], r[1][1] - radius),\n    pointFrom<GlobalPoint>(r[0][0], r[0][1] + radius),\n  );\n\n  const baseCorners = [\n    curve(\n      left[1],\n      pointFrom<GlobalPoint>(\n        left[1][0] + (2 / 3) * (r[0][0] - left[1][0]),\n        left[1][1] + (2 / 3) * (r[0][1] - left[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        top[0][0] + (2 / 3) * (r[0][0] - top[0][0]),\n        top[0][1] + (2 / 3) * (r[0][1] - top[0][1]),\n      ),\n      top[0],\n    ), // TOP LEFT\n    curve(\n      top[1],\n      pointFrom<GlobalPoint>(\n        top[1][0] + (2 / 3) * (r[1][0] - top[1][0]),\n        top[1][1] + (2 / 3) * (r[0][1] - top[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        right[0][0] + (2 / 3) * (r[1][0] - right[0][0]),\n        right[0][1] + (2 / 3) * (r[0][1] - right[0][1]),\n      ),\n      right[0],\n    ), // TOP RIGHT\n    curve(\n      right[1],\n      pointFrom<GlobalPoint>(\n        right[1][0] + (2 / 3) * (r[1][0] - right[1][0]),\n        right[1][1] + (2 / 3) * (r[1][1] - right[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        bottom[1][0] + (2 / 3) * (r[1][0] - bottom[1][0]),\n        bottom[1][1] + (2 / 3) * (r[1][1] - bottom[1][1]),\n      ),\n      bottom[1],\n    ), // BOTTOM RIGHT\n    curve(\n      bottom[0],\n      pointFrom<GlobalPoint>(\n        bottom[0][0] + (2 / 3) * (r[0][0] - bottom[0][0]),\n        bottom[0][1] + (2 / 3) * (r[1][1] - bottom[0][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        left[0][0] + (2 / 3) * (r[0][0] - left[0][0]),\n        left[0][1] + (2 / 3) * (r[1][1] - left[0][1]),\n      ),\n      left[0],\n    ), // BOTTOM LEFT\n  ];\n\n  const corners =\n    offset > 0\n      ? baseCorners.map(\n          (corner) =>\n            curveCatmullRomCubicApproxPoints(\n              curveOffsetPoints(corner, offset),\n            )!,\n        )\n      : [\n          [baseCorners[0]],\n          [baseCorners[1]],\n          [baseCorners[2]],\n          [baseCorners[3]],\n        ];\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\nexport function getDiamondBaseCorners(\n  element: ExcalidrawDiamondElement,\n  offset: number = 0,\n): Curve<GlobalPoint>[] {\n  const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n    getDiamondPoints(element);\n  const verticalRadius = element.roundness\n    ? getCornerRadius(Math.abs(topX - leftX), element)\n    : (topX - leftX) * 0.01;\n  const horizontalRadius = element.roundness\n    ? getCornerRadius(Math.abs(rightY - topY), element)\n    : (rightY - topY) * 0.01;\n\n  const [top, right, bottom, left]: GlobalPoint[] = [\n    pointFrom(element.x + topX, element.y + topY),\n    pointFrom(element.x + rightX, element.y + rightY),\n    pointFrom(element.x + bottomX, element.y + bottomY),\n    pointFrom(element.x + leftX, element.y + leftY),\n  ];\n\n  return [\n    curve(\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] - horizontalRadius,\n      ),\n      right,\n      right,\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] + horizontalRadius,\n      ),\n    ), // RIGHT\n    curve(\n      pointFrom<GlobalPoint>(\n        bottom[0] + verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n      bottom,\n      bottom,\n      pointFrom<GlobalPoint>(\n        bottom[0] - verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n    ), // BOTTOM\n    curve(\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] + horizontalRadius,\n      ),\n      left,\n      left,\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] - horizontalRadius,\n      ),\n    ), // LEFT\n    curve(\n      pointFrom<GlobalPoint>(\n        top[0] - verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n      top,\n      top,\n      pointFrom<GlobalPoint>(\n        top[0] + verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n    ), // TOP\n  ];\n}\n\n/**\n * Get the **unrotated** building components of a diamond element\n * in the form of line segments and curves as a tuple, in this order.\n *\n * @param element The element to deconstruct\n * @param offset An optional offset\n * @returns Tuple of line **unrotated** segments (0) and curves (1)\n */\nexport function deconstructDiamondElement(\n  element: ExcalidrawDiamondElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const baseCorners = getDiamondBaseCorners(element, offset);\n\n  const corners = baseCorners.map(\n    (corner) =>\n      curveCatmullRomCubicApproxPoints(curveOffsetPoints(corner, offset))!,\n  );\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = pointDistance(first, last);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\nexport const getCornerRadius = (x: number, element: ExcalidrawElement) => {\n  if (\n    element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS ||\n    element.roundness?.type === ROUNDNESS.LEGACY\n  ) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n\n  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {\n    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;\n\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n\n    return fixedRadiusSize;\n  }\n\n  return 0;\n};\n\nconst getDiagonalsForBindableElement = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  // for rectangles, shrink the diagonals a bit because there's something\n  // going on with the focus points around the corners. Ask Mark for details.\n  const OFFSET_PX = element.type === \"rectangle\" ? 15 : 0;\n  const shrinkSegment = (seg: LineSegment<GlobalPoint>) => {\n    const v = vectorNormalize(vectorFromPoint(seg[1], seg[0]));\n    const offset = vectorScale(v, OFFSET_PX);\n    return lineSegment<GlobalPoint>(\n      pointTranslate(seg[0], offset),\n      pointTranslate(seg[1], vectorScale(offset, -1)),\n    );\n  };\n\n  const center = elementCenterPoint(element, elementsMap);\n  const diagonalOne = shrinkSegment(\n    isRectangularElement(element)\n      ? lineSegment<GlobalPoint>(\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x, element.y),\n            center,\n            element.angle,\n          ),\n          pointRotateRads(\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height,\n            ),\n            center,\n            element.angle,\n          ),\n        )\n      : lineSegment<GlobalPoint>(\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n            center,\n            element.angle,\n          ),\n          pointRotateRads(\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height,\n            ),\n            center,\n            element.angle,\n          ),\n        ),\n  );\n  const diagonalTwo = shrinkSegment(\n    isRectangularElement(element)\n      ? lineSegment<GlobalPoint>(\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + element.width, element.y),\n            center,\n            element.angle,\n          ),\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x, element.y + element.height),\n            center,\n            element.angle,\n          ),\n        )\n      : lineSegment<GlobalPoint>(\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n            center,\n            element.angle,\n          ),\n          pointRotateRads(\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height / 2,\n            ),\n            center,\n            element.angle,\n          ),\n        ),\n  );\n\n  return [diagonalOne, diagonalTwo];\n};\n\nexport const getSnapOutlineMidPoint = (\n  point: GlobalPoint,\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  zoom: AppState[\"zoom\"],\n) => {\n  const center = elementCenterPoint(element, elementsMap);\n  const sideMidpoints =\n    element.type === \"diamond\"\n      ? getDiamondBaseCorners(element).map((curve) => {\n          const point = bezierEquation(curve, 0.5);\n          const rotatedPoint = pointRotateRads(point, center, element.angle);\n\n          return pointFrom<GlobalPoint>(rotatedPoint[0], rotatedPoint[1]);\n        })\n      : [\n          // RIGHT midpoint\n          pointRotateRads(\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height / 2,\n            ),\n            center,\n            element.angle,\n          ),\n          // BOTTOM midpoint\n          pointRotateRads(\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height,\n            ),\n            center,\n            element.angle,\n          ),\n          // LEFT midpoint\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n            center,\n            element.angle,\n          ),\n          // TOP midpoint\n          pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n            center,\n            element.angle,\n          ),\n        ];\n  const candidate = sideMidpoints.find(\n    (midpoint) =>\n      pointDistance(point, midpoint) <=\n        maxBindingDistance_simple(zoom) + element.strokeWidth / 2 &&\n      !hitElementItself({\n        point,\n        element,\n        threshold: 0,\n        elementsMap,\n        overrideShouldTestInside: true,\n      }),\n  );\n\n  return candidate;\n};\n\nexport const projectFixedPointOntoDiagonal = (\n  arrow: ExcalidrawArrowElement,\n  point: GlobalPoint,\n  element: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n  zoom: AppState[\"zoom\"],\n): GlobalPoint | null => {\n  invariant(arrow.points.length >= 2, \"Arrow must have at least two points\");\n  if (arrow.width < 3 && arrow.height < 3) {\n    return null;\n  }\n\n  const sideMidPoint = getSnapOutlineMidPoint(\n    point,\n    element,\n    elementsMap,\n    zoom,\n  );\n  if (sideMidPoint) {\n    return sideMidPoint;\n  }\n\n  // Do the projection onto the diagonals (or center lines\n  // for non-rectangular shapes)\n  const [diagonalOne, diagonalTwo] = getDiagonalsForBindableElement(\n    element,\n    elementsMap,\n  );\n\n  const a = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    arrow,\n    startOrEnd === \"start\" ? 1 : arrow.points.length - 2,\n    elementsMap,\n  );\n  const b = pointFromVector<GlobalPoint>(\n    vectorScale(\n      vectorFromPoint(point, a),\n      2 * pointDistance(a, point) +\n        Math.max(\n          pointDistance(diagonalOne[0], diagonalOne[1]),\n          pointDistance(diagonalTwo[0], diagonalTwo[1]),\n        ),\n    ),\n    a,\n  );\n  const intersector = lineSegment<GlobalPoint>(b, a);\n  const p1 = lineSegmentIntersectionPoints(diagonalOne, intersector);\n  const p2 = lineSegmentIntersectionPoints(diagonalTwo, intersector);\n  const d1 = p1 && pointDistance(a, p1);\n  const d2 = p2 && pointDistance(a, p2);\n\n  let projection = null;\n  if (d1 != null && d2 != null) {\n    projection = d1 < d2 ? p1 : p2;\n  } else {\n    projection = p1 || p2 || null;\n  }\n\n  if (projection && isPointInElement(projection, element, elementsMap)) {\n    return projection;\n  }\n\n  return null;\n};\n", "import { ROUNDNESS, assertNever } from \"@excalidraw/common\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { ElementOrToolType } from \"@excalidraw/excalidraw/types\";\n\nimport type { MarkNonNullable } from \"@excalidraw/common/utility-types\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawFreeDrawElement,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n  RoundnessType,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawElementType,\n  ExcalidrawIframeElement,\n  ExcalidrawIframeLikeElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawLineElement,\n  ExcalidrawFlowchartNodeElement,\n  ExcalidrawLinearElementSubType,\n} from \"./types\";\n\nexport const isInitializedImageElement = (\n  element: ExcalidrawElement | null,\n): element is InitializedExcalidrawImageElement => {\n  return !!element && element.type === \"image\" && !!element.fileId;\n};\n\nexport const isImageElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawImageElement => {\n  return !!element && element.type === \"image\";\n};\n\nexport const isEmbeddableElement = (\n  element: ExcalidrawElement | null | undefined,\n): element is ExcalidrawEmbeddableElement => {\n  return !!element && element.type === \"embeddable\";\n};\n\nexport const isIframeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeElement => {\n  return !!element && element.type === \"iframe\";\n};\n\nexport const isIframeLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeLikeElement => {\n  return (\n    !!element && (element.type === \"iframe\" || element.type === \"embeddable\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameElement => {\n  return element != null && element.type === \"frame\";\n};\n\nexport const isMagicFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawMagicFrameElement => {\n  return element != null && element.type === \"magicframe\";\n};\n\nexport const isFrameLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameLikeElement => {\n  return (\n    element != null &&\n    (element.type === \"frame\" || element.type === \"magicframe\")\n  );\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElementType,\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLineElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLineElement => {\n  return element != null && element.type === \"line\";\n};\n\nexport const isArrowElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawArrowElement => {\n  return element != null && element.type === \"arrow\";\n};\n\nexport const isElbowArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawElbowArrowElement => {\n  return isArrowElement(element) && element.elbowed;\n};\n\n/**\n * sharp or curved arrow, but not elbow\n */\nexport const isSimpleArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed;\n};\n\nexport const isSharpArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed && !element.roundness;\n};\n\nexport const isCurvedArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return (\n    isArrowElement(element) && !element.elbowed && element.roundness !== null\n  );\n};\n\nexport const isLinearElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawArrowElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    isBindingElementType(element.type)\n  );\n};\n\nexport const isBindingElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null | undefined,\n  includeLocked = true,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nexport const isRectanguloidElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\n// TODO: Remove this when proper distance calculation is introduced\n// @see binding.ts:distanceToBindableElement()\nexport const isRectangularElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"text\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      element.type === \"freedraw\")\n  );\n};\n\nexport const isTextBindableContainer = (\n  element: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawTextContainer => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      isArrowElement(element))\n  );\n};\n\nexport const isExcalidrawElement = (\n  element: any,\n): element is ExcalidrawElement => {\n  const type: ExcalidrawElementType | undefined = element?.type;\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case \"text\":\n    case \"diamond\":\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"ellipse\":\n    case \"arrow\":\n    case \"freedraw\":\n    case \"line\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"image\":\n    case \"selection\": {\n      return true;\n    }\n    default: {\n      assertNever(type, null);\n      return false;\n    }\n  }\n};\n\nexport const isFlowchartNodeElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawFlowchartNodeElement => {\n  return (\n    element.type === \"rectangle\" ||\n    element.type === \"ellipse\" ||\n    element.type === \"diamond\"\n  );\n};\n\nexport const hasBoundTextElement = (\n  element: ExcalidrawElement | null,\n): element is MarkNonNullable<ExcalidrawBindableElement, \"boundElements\"> => {\n  return (\n    isTextBindableContainer(element) &&\n    !!element.boundElements?.some(({ type }) => type === \"text\")\n  );\n};\n\nexport const isBoundToContainer = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElementWithContainer => {\n  return (\n    element !== null &&\n    \"containerId\" in element &&\n    element.containerId !== null &&\n    isTextElement(element)\n  );\n};\n\nexport const isArrowBoundToElement = (element: ExcalidrawArrowElement) => {\n  return !!element.startBinding || !!element.endBinding;\n};\n\nexport const isUsingAdaptiveRadius = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"embeddable\" ||\n  type === \"iframe\" ||\n  type === \"image\";\n\nexport const isUsingProportionalRadius = (type: string) =>\n  type === \"line\" || type === \"arrow\" || type === \"diamond\";\n\nexport const canApplyRoundnessTypeToElement = (\n  roundnessType: RoundnessType,\n  element: ExcalidrawElement,\n) => {\n  if (\n    (roundnessType === ROUNDNESS.ADAPTIVE_RADIUS ||\n      // if legacy roundness, it can be applied to elements that currently\n      // use adaptive radius\n      roundnessType === ROUNDNESS.LEGACY) &&\n    isUsingAdaptiveRadius(element.type)\n  ) {\n    return true;\n  }\n  if (\n    roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS &&\n    isUsingProportionalRadius(element.type)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getDefaultRoundnessTypeForElement = (\n  element: ExcalidrawElement,\n) => {\n  if (isUsingProportionalRadius(element.type)) {\n    return {\n      type: ROUNDNESS.PROPORTIONAL_RADIUS,\n    };\n  }\n\n  if (isUsingAdaptiveRadius(element.type)) {\n    return {\n      type: ROUNDNESS.ADAPTIVE_RADIUS,\n    };\n  }\n\n  return null;\n};\n\nexport const getLinearElementSubType = (\n  element: ExcalidrawLinearElement,\n): ExcalidrawLinearElementSubType => {\n  if (isSharpArrow(element)) {\n    return \"sharpArrow\";\n  }\n  if (isCurvedArrow(element)) {\n    return \"curvedArrow\";\n  }\n  if (isElbowArrow(element)) {\n    return \"elbowArrow\";\n  }\n  return \"line\";\n};\n\n/**\n * Checks if current element points meet all the conditions for polygon=true\n * (this isn't a element type check, for that use isLineElement).\n *\n * If you want to check if points *can* be turned into a polygon, use\n *  canBecomePolygon(points).\n */\nexport const isValidPolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return points.length > 3 && pointsEqual(points[0], points[points.length - 1]);\n};\n\nexport const canBecomePolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return (\n    points.length > 3 ||\n    // 3-point polygons can't have all points in a single line\n    (points.length === 3 && !pointsEqual(points[0], points[points.length - 1]))\n  );\n};\n", "import {\n  ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO,\n  ARROW_LABEL_WIDTH_FRACTION,\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  STICKY_NOTE_PADDING,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  getFontString,\n  isProdEnv,\n  invariant,\n} from \"@excalidraw/common\";\n\nimport { pointFrom, pointRotateRads, type Radians } from \"@excalidraw/math\";\n\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport type { ExtractSetType } from \"@excalidraw/common/utility-types\";\n\nimport {\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"./containerCache\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { measureText } from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\nimport {\n  isBoundToContainer,\n  isArrowElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { MaybeTransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawElementType,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nexport const redrawTextBoundingBox = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawElement | null,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  let maxWidth = undefined;\n\n  if (!isProdEnv()) {\n    invariant(\n      !container || !isArrowElement(container) || textElement.angle === 0,\n      \"text element angle must be 0 if bound to arrow container\",\n    );\n  }\n\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    angle: (container\n      ? isArrowElement(container)\n        ? 0\n        : container.angle\n      : textElement.angle) as Radians,\n  };\n\n  boundTextUpdates.text = textElement.text;\n\n  if (container || !textElement.autoResize) {\n    maxWidth = container\n      ? getBoundTextMaxWidth(container, textElement)\n      : textElement.width;\n    boundTextUpdates.text = wrapText(\n      textElement.originalText,\n      getFontString(textElement),\n      maxWidth,\n    );\n  }\n\n  const metrics = measureText(\n    boundTextUpdates.text,\n    getFontString(textElement),\n    textElement.lineHeight,\n  );\n\n  // Note: only update width for unwrapped text and bound texts (which always have autoResize set to true)\n  if (textElement.autoResize) {\n    boundTextUpdates.width = metrics.width;\n  }\n  boundTextUpdates.height = metrics.height;\n\n  if (container) {\n    const maxContainerHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n    const maxContainerWidth = getBoundTextMaxWidth(container, textElement);\n\n    if (!isArrowElement(container) && metrics.height > maxContainerHeight) {\n      const nextHeight = computeContainerDimensionForBoundText(\n        metrics.height,\n        container.type,\n      );\n      scene.mutateElement(container, { height: nextHeight });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n\n    if (metrics.width > maxContainerWidth) {\n      const nextWidth = computeContainerDimensionForBoundText(\n        metrics.width,\n        container.type,\n      );\n      scene.mutateElement(container, { width: nextWidth });\n    }\n\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates,\n    } as ExcalidrawTextElementWithContainer;\n\n    const { x, y } = computeBoundTextPosition(\n      container,\n      updatedTextElement,\n      elementsMap,\n    );\n\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n\n  scene.mutateElement(textElement, boundTextUpdates);\n};\n\nexport const handleBindTextResize = (\n  container: NonDeletedExcalidrawElement,\n  scene: Scene,\n  transformHandleType: MaybeTransformHandleType,\n  shouldMaintainAspectRatio = false,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  const textElement = getBoundTextElement(container, elementsMap);\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const maxWidth = getBoundTextMaxWidth(container, textElement);\n    const maxHeight = getBoundTextMaxHeight(container, textElement);\n    let containerHeight = container.height;\n    if (\n      shouldMaintainAspectRatio ||\n      (transformHandleType !== \"n\" && transformHandleType !== \"s\")\n    ) {\n      if (text) {\n        text = wrapText(\n          textElement.originalText,\n          getFontString(textElement),\n          maxWidth,\n        );\n      }\n      const metrics = measureText(\n        text,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(\n        nextHeight,\n        container.type,\n      );\n\n      const diff = containerHeight - container.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY =\n        !isArrowElement(container) &&\n        (transformHandleType === \"ne\" ||\n          transformHandleType === \"nw\" ||\n          transformHandleType === \"n\")\n          ? container.y - diff\n          : container.y;\n      scene.mutateElement(container, {\n        height: containerHeight,\n        y: updatedY,\n      });\n    }\n\n    scene.mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n    });\n\n    if (!isArrowElement(container)) {\n      scene.mutateElement(\n        textElement,\n        computeBoundTextPosition(container, textElement, elementsMap),\n      );\n    }\n  }\n};\n\nexport const computeBoundTextPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);\n\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y =\n      containerCoords.y +\n      (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x =\n      containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  const angle = (container.angle ?? 0) as Radians;\n\n  if (angle !== 0) {\n    const contentCenter = pointFrom(\n      containerCoords.x + maxContainerWidth / 2,\n      containerCoords.y + maxContainerHeight / 2,\n    );\n    const textCenter = pointFrom(\n      x + boundTextElement.width / 2,\n      y + boundTextElement.height / 2,\n    );\n\n    const [rx, ry] = pointRotateRads(textCenter, contentCenter, angle);\n\n    return {\n      x: rx - boundTextElement.width / 2,\n      y: ry - boundTextElement.height / 2,\n    };\n  }\n\n  return { x, y };\n};\n\nexport const getBoundTextElementId = (container: ExcalidrawElement | null) => {\n  return container?.boundElements?.length\n    ? container?.boundElements?.find((ele) => ele.type === \"text\")?.id || null\n    : null;\n};\n\nexport const getBoundTextElement = (\n  element: ExcalidrawElement | null,\n  elementsMap: ElementsMap,\n) => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  if (boundTextElementId) {\n    return (elementsMap.get(boundTextElementId) ||\n      null) as ExcalidrawTextElementWithContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerElement = (\n  element: ExcalidrawTextElement | null,\n  elementsMap: ElementsMap,\n): ExcalidrawTextContainer | null => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    return (elementsMap.get(element.containerId) ||\n      null) as ExcalidrawTextContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerCenter = (\n  container: ExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2,\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(\n    container,\n    elementsMap,\n  );\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n      container,\n      container.points[index],\n      elementsMap,\n    );\n    return { x: midPoint[0], y: midPoint[1] };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(\n    container,\n    elementsMap,\n    appState,\n  )[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n      container,\n      index + 1,\n    );\n  }\n  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };\n};\n\nconst isStickyNoteContainer = (el: ExcalidrawElement) =>\n  el.type === \"rectangle\" && (el as { customData?: { isStickyNote?: boolean } }).customData?.isStickyNote === true;\n\nexport const getContainerCoords = (container: NonDeletedExcalidrawElement) => {\n  if (container.type === \"rectangle\") {\n    const padding = isStickyNoteContainer(container) ? STICKY_NOTE_PADDING : BOUND_TEXT_PADDING;\n    return { x: container.x + padding, y: container.y + padding };\n  }\n\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += (container.width / 2) * (1 - Math.sqrt(2) / 2);\n    offsetY += (container.height / 2) * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY,\n  };\n};\n\nexport const getTextElementAngle = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawTextContainer | null,\n) => {\n  if (isArrowElement(container)) {\n    return 0;\n  }\n  if (!container) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\n\nexport const getBoundTextElementPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n};\n\nexport const shouldAllowVerticalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\n\nexport const suppportsHorizontalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n\n    return isTextElement(element);\n  });\n};\n\nconst VALID_CONTAINER_TYPES = new Set([\n  \"rectangle\",\n  \"ellipse\",\n  \"diamond\",\n  \"arrow\",\n]);\n\nexport const isValidTextContainer = (element: {\n  type: ExcalidrawElementType;\n}) => VALID_CONTAINER_TYPES.has(element.type);\n\nexport const computeContainerDimensionForBoundText = (\n  dimension: number,\n  containerType: ExtractSetType<typeof VALID_CONTAINER_TYPES>,\n) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n\n  if (containerType === \"ellipse\") {\n    return Math.round(((dimension + padding) / Math.sqrt(2)) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\n\nexport const getBoundTextMaxWidth = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElement | null,\n) => {\n  const { width } = container;\n  if (isArrowElement(container)) {\n    const minWidth =\n      (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) *\n      ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;\n    return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);\n  }\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((width / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  const padding = isStickyNoteContainer(container) ? STICKY_NOTE_PADDING : BOUND_TEXT_PADDING;\n  return width - padding * 2;\n};\n\nexport const getBoundTextMaxHeight = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  const { height } = container;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((height / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  const padding = isStickyNoteContainer(container) ? STICKY_NOTE_PADDING : BOUND_TEXT_PADDING;\n  return height - padding * 2;\n};\n\n/** retrieves text from text elements and concatenates to a single string */\nexport const getTextFromElements = (\n  elements: readonly ExcalidrawElement[],\n  separator = \"\\n\\n\",\n) => {\n  const text = elements\n    .reduce((acc: string[], element) => {\n      if (isTextElement(element)) {\n        acc.push(element.text);\n      }\n      return acc;\n    }, [])\n    .join(separator);\n  return text;\n};\n", "import type { ExcalidrawTextContainer } from \"./types\";\n\nexport const originalContainerCache: {\n  [id: ExcalidrawTextContainer[\"id\"]]:\n    | {\n        height: ExcalidrawTextContainer[\"height\"];\n      }\n    | undefined;\n} = {};\n\nexport const updateOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n  height: ExcalidrawTextContainer[\"height\"],\n) => {\n  const data =\n    originalContainerCache[id] || (originalContainerCache[id] = { height });\n  data.height = height;\n  return data;\n};\n\nexport const resetOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  if (originalContainerCache[id]) {\n    delete originalContainerCache[id];\n  }\n};\n\nexport const getOriginalContainerHeightFromCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  return originalContainerCache[id]?.height ?? null;\n};\n", "import {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  getFontString,\n  isTestEnv,\n  normalizeEOL,\n} from \"@excalidraw/common\";\n\nimport type { FontString, ExcalidrawTextElement } from \"./types\";\n\nexport const measureText = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const _text = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(_text, fontSize, lineHeight);\n  const width = getTextWidth(_text, font);\n  return { width, height };\n};\n\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return (\n      measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width +\n      BOUND_TEXT_PADDING * 2\n    );\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\n\nexport const getMinTextElementWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return measureText(\"\", font, lineHeight).width + BOUND_TEXT_PADDING * 2;\n};\n\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(\n    DUMMY_TEXT,\n    getFontString({\n      fontSize: DEFAULT_FONT_SIZE,\n      fontFamily: DEFAULT_FONT_FAMILY,\n    }),\n  );\n  return width > 0;\n};\n\nexport const normalizeText = (text: string) => {\n  return (\n    normalizeEOL(text)\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n  );\n};\n\nconst splitIntoLines = (text: string) => {\n  return normalizeText(text).split(\"\\n\");\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = (textElement: ExcalidrawTextElement) => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return (textElement.height /\n    lineCount /\n    textElement.fontSize) as ExcalidrawTextElement[\"lineHeight\"];\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\n\nlet textMetricsProvider: TextMetricsProvider | undefined;\n\n/**\n * Set a custom text metrics provider.\n *\n * Useful for overriding the width calculation algorithm where canvas API is not available / desired.\n */\nexport const setCustomTextMetricsProvider = (provider: TextMetricsProvider) => {\n  textMetricsProvider = provider;\n};\n\nexport interface TextMetricsProvider {\n  getLineWidth(text: string, fontString: FontString): number;\n}\n\nclass CanvasTextMetricsProvider implements TextMetricsProvider {\n  private canvas: HTMLCanvasElement;\n\n  constructor() {\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  /**\n   * We need to use the advance width as that's the closest thing to the browser wrapping algo, hence using it for:\n   * - text wrapping\n   * - wysiwyg editor (+padding)\n   *\n   * > The advance width is the distance between the glyph's initial pen position and the next glyph's initial pen position.\n   */\n  public getLineWidth(text: string, fontString: FontString): number {\n    const context = this.canvas.getContext(\"2d\")!;\n    context.font = fontString;\n    const metrics = context.measureText(text);\n    const advanceWidth = metrics.width;\n\n    // since in test env the canvas measureText algo\n    // doesn't measure text and instead just returns number of\n    // characters hence we assume that each letteris 10px\n    if (isTestEnv()) {\n      return advanceWidth * 10;\n    }\n\n    return advanceWidth;\n  }\n}\n\nexport const getLineWidth = (text: string, font: FontString) => {\n  if (!textMetricsProvider) {\n    textMetricsProvider = new CanvasTextMetricsProvider();\n  }\n\n  return textMetricsProvider.getLineWidth(text, font);\n};\n\nexport const getTextWidth = (text: string, font: FontString) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach((line) => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n\n  return width;\n};\n\nexport const getTextHeight = (\n  text: string,\n  fontSize: number,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\n\nexport const charWidth = (() => {\n  const cachedCharWidth: { [key: FontString]: Array<number> } = {};\n\n  const calculate = (char: string, font: FontString) => {\n    const unicode = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][unicode]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][unicode] = width;\n    }\n\n    return cachedCharWidth[font][unicode];\n  };\n\n  const getCache = (font: FontString) => {\n    return cachedCharWidth[font];\n  };\n\n  const clearCache = (font: FontString) => {\n    cachedCharWidth[font] = [];\n  };\n\n  return {\n    calculate,\n    getCache,\n    clearCache,\n  };\n})();\n\nexport const getMinCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n\n  return Math.min(...cacheWithOutEmpty);\n};\n\nexport const getMaxCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\n", "import { isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport { charWidth, getLineWidth } from \"./textMeasurements\";\n\nimport type { FontString } from \"./types\";\n\nlet cachedCjkRegex: RegExp | undefined;\nlet cachedLineBreakRegex: RegExp | undefined;\nlet cachedEmojiRegex: RegExp | undefined;\n\n/**\n * Test if a given text contains any CJK characters (including symbols, punctuation, etc,).\n */\nexport const containsCJK = (text: string) => {\n  if (!cachedCjkRegex) {\n    cachedCjkRegex = Regex.class(...Object.values(CJK));\n  }\n\n  return cachedCjkRegex.test(text);\n};\n\nconst getLineBreakRegex = () => {\n  if (!cachedLineBreakRegex) {\n    try {\n      cachedLineBreakRegex = getLineBreakRegexAdvanced();\n    } catch {\n      cachedLineBreakRegex = getLineBreakRegexSimple();\n    }\n  }\n\n  return cachedLineBreakRegex;\n};\n\nconst getEmojiRegex = () => {\n  if (!cachedEmojiRegex) {\n    cachedEmojiRegex = getEmojiRegexUnicode();\n  }\n\n  return cachedEmojiRegex;\n};\n\n/**\n * Common symbols used across different languages.\n */\nconst COMMON = {\n  /**\n   * Natural breaking points for any grammars.\n   *\n   * Hello world\n   *      \u2191 BREAK ALWAYS \" \" \u2192 [\"Hello\", \" \", \"world\"]\n   * Hello-world\n   *       \u2191 BREAK AFTER \"-\" \u2192 [\"Hello-\", \"world\"]\n   */\n  WHITESPACE: /\\s/u,\n  HYPHEN: /-/u,\n  /**\n   * Generally do not break, unless closed symbol is followed by an opening symbol.\n   *\n   * Also, western punctation is often used in modern Korean and expects to be treated\n   * similarly to the CJK opening and closing symbols.\n   *\n   * Hello(\uD55C\uAE00)\u2192 [\"Hello\", \"(\uD55C\", \"\uAE00)\"]\n   *      \u2191 BREAK BEFORE \"(\"\n   *          \u2191 BREAK AFTER \")\"\n   */\n  OPENING: /<\\(\\[\\{/u,\n  CLOSING: />\\)\\]\\}.,:;!\\?\u2026\\//u,\n};\n\n/**\n * Characters and symbols used in Chinese, Japanese and Korean.\n */\nconst CJK = {\n  /**\n   * Every CJK breaks before and after, unless it's paired with an opening or closing symbol.\n   *\n   * Does not include every possible char used in CJK texts, such as currency, parentheses or punctuation.\n   */\n  CHAR: /\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}\uFF40\uFF07\uFF3E\u3003\u3030\u3006\uFF03\uFF06\uFF0A\uFF0B\uFF0D\u30FC\uFF0F\uFF3C\uFF1D\uFF5C\uFFE4\u3012\uFFE2\uFFE3/u,\n  /**\n   * Opening and closing CJK punctuation breaks before and after all such characters (in case of many),\n   * and creates pairs with neighboring characters.\n   *\n   * Hello \u305F\u3002\u2192 [\"Hello\", \"\u305F\u3002\"]\n   *        \u2191 DON'T BREAK \"\u305F\u3002\"\n   * * Hello\u300C\u305F\u300D World \u2192 [\"Hello\", \"\u300C\u305F\u300D\", \"World\"]\n   *       \u2191 DON'T BREAK \"\u300C\u305F\"\n   *        \u2191 DON'T BREAK \"\u305F\"\n   *      \u2191 BREAK BEFORE \"\u300C\"\n   *         \u2191 BREAK AFTER \"\u300D\"\n   */\n  // eslint-disable-next-line prettier/prettier\n  OPENING:/\uFF08\uFF3B\uFF5B\u3008\u300A\uFF5F\uFF62\u300C\u300E\u3010\u3016\u3014\u3018\u301A\uFF1C\u301D/u,\n  CLOSING: /\uFF09\uFF3D\uFF5D\u3009\u300B\uFF60\uFF63\u300D\u300F\u3011\u3017\u3015\u3019\u301B\uFF1E\u3002\uFF0E\uFF0C\u3001\u301F\u2025\uFF1F\uFF01\uFF1A\uFF1B\u30FB\u301C\u301E/u,\n  /**\n   * Currency symbols break before, not after\n   *\n   * Price\uFFE5100 \u2192 [\"Price\", \"\uFFE5100\"]\n   *      \u2191 BREAK BEFORE \"\uFFE5\"\n   */\n  CURRENCY: /\uFFE5\uFFE6\uFFE1\uFFE0\uFF04/u,\n};\n\nconst EMOJI = {\n  FLAG: /\\p{RI}\\p{RI}/u,\n  JOINER:\n    /(?:\\p{Emoji_Modifier}|\\uFE0F\\u20E3?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?/u,\n  ZWJ: /\\u200D/u,\n  ANY: /[\\p{Emoji}]/u,\n  MOST: /[\\p{Extended_Pictographic}\\p{Emoji_Presentation}]/u,\n};\n\n/**\n * Simple fallback for browsers (mainly Safari < 16.4) that don't support \"Lookbehind assertion\".\n *\n * Browser support as of 10/2024:\n * - 91% Lookbehind assertion https://caniuse.com/mdn-javascript_regular_expressions_lookbehind_assertion\n * - 94% Unicode character class escape https://caniuse.com/mdn-javascript_regular_expressions_unicode_character_class_escape\n *\n * Does not include advanced CJK breaking rules, but covers most of the core cases, especially for latin.\n */\nconst getLineBreakRegexSimple = () =>\n  Regex.or(\n    getEmojiRegex(),\n    Break.On(COMMON.HYPHEN, COMMON.WHITESPACE, CJK.CHAR),\n  );\n\n/**\n * Specifies the line breaking rules based for alphabetic-based languages,\n * Chinese, Japanese, Korean and Emojis.\n *\n * \"Hello-world\" \u2192 [\"Hello-\", \"world\"]\n * \"Hello \u300C\u4E16\u754C\u3002\u300D\uD83C\uDF0E\uD83D\uDDFA\" \u2192 [\"Hello\", \" \", \"\u300C\u4E16\", \"\u754C\u3002\u300D\", \"\uD83C\uDF0E\", \"\uD83D\uDDFA\"]\n */\nconst getLineBreakRegexAdvanced = () =>\n  Regex.or(\n    // Unicode-defined regex for (multi-codepoint) Emojis\n    getEmojiRegex(),\n    // Rules for whitespace and hyphen\n    Break.Before(COMMON.WHITESPACE).Build(),\n    Break.After(COMMON.WHITESPACE, COMMON.HYPHEN).Build(),\n    // Rules for CJK (chars, symbols, currency)\n    Break.Before(CJK.CHAR, CJK.CURRENCY)\n      .NotPrecededBy(COMMON.OPENING, CJK.OPENING)\n      .Build(),\n    Break.After(CJK.CHAR)\n      .NotFollowedBy(COMMON.HYPHEN, COMMON.CLOSING, CJK.CLOSING)\n      .Build(),\n    // Rules for opening and closing punctuation\n    Break.BeforeMany(CJK.OPENING).NotPrecededBy(COMMON.OPENING).Build(),\n    Break.AfterMany(CJK.CLOSING).NotFollowedBy(COMMON.CLOSING).Build(),\n    Break.AfterMany(COMMON.CLOSING).FollowedBy(COMMON.OPENING).Build(),\n  );\n\n/**\n * Matches various emoji types.\n *\n * 1. basic emojis (\uD83D\uDE00, \uD83C\uDF0D)\n * 2. flags (\uD83C\uDDE8\uD83C\uDDFF)\n * 3. multi-codepoint emojis:\n *    - skin tones (\uD83D\uDC4D\uD83C\uDFFD)\n *    - variation selectors (\u2602\uFE0F)\n *    - keycaps (1\uFE0F\u20E3)\n *    - tag sequences (\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67\uDB40\uDC7F)\n *    - emoji sequences (\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66, \uD83D\uDC69\u200D\uD83D\uDE80, \uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08)\n *\n * Unicode points:\n * - \\uFE0F: presentation selector\n * - \\u20E3: enclosing keycap\n * - \\u200D: zero width joiner\n * - \\u{E0020}-\\u{E007E}: tags\n * - \\u{E007F}: cancel tag\n *\n * @see https://unicode.org/reports/tr51/#EBNF_and_Regex, with changes:\n * - replaced \\p{Emoji} with [\\p{Extended_Pictographic}\\p{Emoji_Presentation}], see more in `should tokenize emojis mixed with mixed text` test\n * - replaced \\p{Emod} with \\p{Emoji_Modifier} as some engines do not understand the abbreviation (i.e. https://devina.io/redos-checker)\n */\nconst getEmojiRegexUnicode = () =>\n  Regex.group(\n    Regex.or(\n      EMOJI.FLAG,\n      Regex.and(\n        EMOJI.MOST,\n        EMOJI.JOINER,\n        Regex.build(\n          `(?:${EMOJI.ZWJ.source}(?:${EMOJI.FLAG.source}|${EMOJI.ANY.source}${EMOJI.JOINER.source}))*`,\n        ),\n      ),\n    ),\n  );\n\n/**\n * Regex utilities for unicode character classes.\n */\nconst Regex = {\n  /**\n   * Builds a regex from a string.\n   */\n  build: (regex: string): RegExp => new RegExp(regex, \"u\"),\n  /**\n   * Joins regexes into a single string.\n   */\n  join: (...regexes: RegExp[]): string => regexes.map((x) => x.source).join(\"\"),\n  /**\n   * Joins regexes into a single regex as with \"and\" operator.\n   */\n  and: (...regexes: RegExp[]): RegExp => Regex.build(Regex.join(...regexes)),\n  /**\n   * Joins regexes into a single regex with \"or\" operator.\n   */\n  or: (...regexes: RegExp[]): RegExp =>\n    Regex.build(regexes.map((x) => x.source).join(\"|\")),\n  /**\n   * Puts regexes into a matching group.\n   */\n  group: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`(${Regex.join(...regexes)})`),\n  /**\n   * Puts regexes into a character class.\n   */\n  class: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`[${Regex.join(...regexes)}]`),\n};\n\n/**\n * Human-readable lookahead and lookbehind utilities for defining line break\n * opportunities between pairs of character classes.\n */\nconst Break = {\n  /**\n   * Break on the given class of characters.\n   */\n  On: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    return Regex.build(`([${joined}])`);\n  },\n  /**\n   * Break before the given class of characters.\n   */\n  Before: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after the given class of characters.\n   */\n  After: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Break before one or multiple characters of the same class.\n   */\n  BeforeMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after one or multiple character from the same class.\n   */\n  AfterMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Do not break before the given class of characters.\n   */\n  NotBefore: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotFollowedBy\"\n    >;\n  },\n  /**\n   * Do not break after the given class of characters.\n   */\n  NotAfter: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotPrecededBy\"\n    >;\n  },\n  Chain: (rootBuilder: () => RegExp) => ({\n    /**\n     * Build the root regex.\n     */\n    Build: rootBuilder,\n    /**\n     * Specify additional class of characters that should precede the root regex.\n     */\n    PreceededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const preceeded = Break.After(...regexes).Build();\n      const builder = () => Regex.and(preceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"PreceededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should follow the root regex.\n     */\n    FollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const followed = Break.Before(...regexes).Build();\n      const builder = () => Regex.and(root, followed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"FollowedBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not precede the root regex.\n     */\n    NotPrecededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notPreceeded = Break.NotAfter(...regexes).Build();\n      const builder = () => Regex.and(notPreceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotPrecededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not follow the root regex.\n     */\n    NotFollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notFollowed = Break.NotBefore(...regexes).Build();\n      const builder = () => Regex.and(root, notFollowed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotFollowedBy\"\n      >;\n    },\n  }),\n};\n\n/**\n * Breaks the line into the tokens based on the found line break opporutnities.\n */\nexport const parseTokens = (line: string) => {\n  const breakLineRegex = getLineBreakRegex();\n\n  // normalizing to single-codepoint composed chars due to canonical equivalence\n  // of multi-codepoint versions for chars like \u010D, \u3067 (~ so that we don't break a line in between c and \u02C7)\n  // filtering due to multi-codepoint chars like \uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66, \uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB0\n  return line.normalize(\"NFC\").split(breakLineRegex).filter(Boolean);\n};\n\n/**\n * Wraps the original text into the lines based on the given width.\n */\nexport const wrapText = (\n  text: string,\n  font: FontString,\n  maxWidth: number,\n): string => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split(\"\\n\");\n\n  for (const originalLine of originalLines) {\n    const currentLineWidth = getLineWidth(originalLine, font);\n\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      continue;\n    }\n\n    const wrappedLine = wrapLine(originalLine, font, maxWidth);\n    lines.push(...wrappedLine);\n  }\n\n  return lines.join(\"\\n\");\n};\n\n/**\n * Wraps the original line into the lines based on the given width.\n */\nconst wrapLine = (\n  line: string,\n  font: FontString,\n  maxWidth: number,\n): string[] => {\n  const lines: Array<string> = [];\n  const tokens = parseTokens(line);\n  const tokenIterator = tokens[Symbol.iterator]();\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  let iterator = tokenIterator.next();\n\n  while (!iterator.done) {\n    const token = iterator.value;\n    const testLine = currentLine + token;\n\n    // cache single codepoint whitespace, CJK or emoji width calc. as kerning should not apply here\n    const testLineWidth = isSingleCharacter(token)\n      ? currentLineWidth + charWidth.calculate(token, font)\n      : getLineWidth(testLine, font);\n\n    // build up the current line, skipping length check for possibly trailing whitespaces\n    if (/\\s/.test(token) || testLineWidth <= maxWidth) {\n      currentLine = testLine;\n      currentLineWidth = testLineWidth;\n      iterator = tokenIterator.next();\n      continue;\n    }\n\n    // current line is empty => just the token (word) is longer than `maxWidth` and needs to be wrapped\n    if (!currentLine) {\n      const wrappedWord = wrapWord(token, font, maxWidth);\n      const trailingLine = wrappedWord[wrappedWord.length - 1] ?? \"\";\n      const precedingLines = wrappedWord.slice(0, -1);\n\n      lines.push(...precedingLines);\n\n      // trailing line of the wrapped word might still be joined with next token/s\n      currentLine = trailingLine;\n      currentLineWidth = getLineWidth(trailingLine, font);\n      iterator = tokenIterator.next();\n    } else {\n      // push & reset, but don't iterate on the next token, as we didn't use it yet!\n      lines.push(currentLine.trimEnd());\n\n      // purposefully not iterating and not setting `currentLine` to `token`, so that we could use a simple !currentLine check above\n      currentLine = \"\";\n      currentLineWidth = 0;\n    }\n  }\n\n  // iterator done, push the trailing line if exists\n  if (currentLine) {\n    const trailingLine = trimLine(currentLine, font, maxWidth);\n    lines.push(trailingLine);\n  }\n\n  return lines;\n};\n\n/**\n * Wraps the word into the lines based on the given width.\n */\nconst wrapWord = (\n  word: string,\n  font: FontString,\n  maxWidth: number,\n): Array<string> => {\n  // multi-codepoint emojis are already broken apart and shouldn't be broken further\n  if (getEmojiRegex().test(word)) {\n    return [word];\n  }\n\n  satisfiesWordInvariant(word);\n\n  const lines: Array<string> = [];\n  const chars = Array.from(word);\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  for (const char of chars) {\n    const _charWidth = charWidth.calculate(char, font);\n    const testLineWidth = currentLineWidth + _charWidth;\n\n    if (testLineWidth <= maxWidth) {\n      currentLine = currentLine + char;\n      currentLineWidth = testLineWidth;\n      continue;\n    }\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    currentLine = char;\n    currentLineWidth = _charWidth;\n  }\n\n  if (currentLine) {\n    lines.push(currentLine);\n  }\n\n  return lines;\n};\n\n/**\n * Similarly to browsers, does not trim all trailing whitespaces, but only those exceeding the `maxWidth`.\n */\nconst trimLine = (line: string, font: FontString, maxWidth: number) => {\n  const shouldTrimWhitespaces = getLineWidth(line, font) > maxWidth;\n\n  if (!shouldTrimWhitespaces) {\n    return line;\n  }\n\n  // defensively default to `trimeEnd` in case the regex does not match\n  let [, trimmedLine, whitespaces] = line.match(/^(.+?)(\\s+)$/) ?? [\n    line,\n    line.trimEnd(),\n    \"\",\n  ];\n\n  let trimmedLineWidth = getLineWidth(trimmedLine, font);\n\n  for (const whitespace of Array.from(whitespaces)) {\n    const _charWidth = charWidth.calculate(whitespace, font);\n    const testLineWidth = trimmedLineWidth + _charWidth;\n\n    if (testLineWidth > maxWidth) {\n      break;\n    }\n\n    trimmedLine = trimmedLine + whitespace;\n    trimmedLineWidth = testLineWidth;\n  }\n\n  return trimmedLine;\n};\n\n/**\n * Check if the given string is a single character.\n *\n * Handles multi-byte chars (\u00E9, \u4E2D) and purposefully does not handle multi-codepoint char (\uD83D\uDC68\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66, \uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDDB0).\n */\nconst isSingleCharacter = (maybeSingleCharacter: string) => {\n  return (\n    maybeSingleCharacter.codePointAt(0) !== undefined &&\n    maybeSingleCharacter.codePointAt(1) === undefined\n  );\n};\n\n/**\n * Invariant for the word wrapping algorithm.\n */\nconst satisfiesWordInvariant = (word: string) => {\n  if (isTestEnv() || isDevEnv()) {\n    if (/\\s/.test(word)) {\n      throw new Error(\"Word should not contain any whitespaces!\");\n    }\n  }\n};\n", "import {\n  curvePointDistance,\n  distanceToLineSegment,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { ellipse, ellipseDistanceFromPoint } from \"@excalidraw/math/ellipse\";\n\nimport type { GlobalPoint, Radians } from \"@excalidraw/math\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { elementCenterPoint } from \"./bounds\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\nexport const distanceToElement = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  switch (element.type) {\n    case \"selection\":\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"magicframe\":\n      return distanceToRectanguloidElement(element, elementsMap, p);\n    case \"diamond\":\n      return distanceToDiamondElement(element, elementsMap, p);\n    case \"ellipse\":\n      return distanceToEllipseElement(element, elementsMap, p);\n    case \"line\":\n    case \"arrow\":\n    case \"freedraw\":\n      return distanceToLinearOrFreeDraElement(element, p);\n  }\n};\n\n/**\n * Returns the distance of a point and the provided rectangular-shaped element,\n * accounting for roundness and rotation\n *\n * @param element The rectanguloid element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the rectanguloid element\n */\nconst distanceToRectanguloidElement = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n) => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...corners\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided diamond element, accounting\n * for roundness and rotation\n *\n * @param element The diamond element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the diamond\n */\nconst distanceToDiamondElement = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  const [sides, curves] = deconstructDiamondElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...curves\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided ellipse element, accounting\n * for roundness and rotation\n *\n * @param element The ellipse element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the ellipse\n */\nconst distanceToEllipseElement = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n  return ellipseDistanceFromPoint(\n    // Instead of rotating the ellipse, rotate the point to the inverse angle\n    pointRotateRads(p, center, -element.angle as Radians),\n    ellipse(center, element.width / 2, element.height / 2),\n  );\n};\n\nconst distanceToLinearOrFreeDraElement = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  p: GlobalPoint,\n) => {\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  return Math.min(\n    ...lines.map((s) => distanceToLineSegment(p, s)),\n    ...curves.map((a) => curvePointDistance(a, p)),\n  );\n};\n", "import {\n  invariant,\n  isDevEnv,\n  isTestEnv,\n  type Bounds,\n} from \"@excalidraw/common\";\n\nimport {\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointScaleFromOrigin,\n  pointsEqual,\n  triangleIncludesPoint,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport type {\n  LocalPoint,\n  GlobalPoint,\n  Triangle,\n  Vector,\n} from \"@excalidraw/math\";\n\nimport { getCenterForBounds } from \"./bounds\";\n\nimport type { ExcalidrawBindableElement } from \"./types\";\n\nexport const HEADING_RIGHT = [1, 0] as Heading;\nexport const HEADING_DOWN = [0, 1] as Heading;\nexport const HEADING_LEFT = [-1, 0] as Heading;\nexport const HEADING_UP = [0, -1] as Heading;\nexport type Heading = [1, 0] | [0, 1] | [-1, 0] | [0, -1];\n\nexport const vectorToHeading = (vec: Vector): Heading => {\n  const [x, y] = vec;\n  const absX = Math.abs(x);\n  const absY = Math.abs(y);\n  if (x > absY) {\n    return HEADING_RIGHT;\n  } else if (x <= -absY) {\n    return HEADING_LEFT;\n  } else if (y > absX) {\n    return HEADING_DOWN;\n  }\n  return HEADING_UP;\n};\n\nexport const headingForPoint = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => vectorToHeading(vectorFromPoint<P>(p, o));\n\nexport const headingForPointIsHorizontal = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => headingIsHorizontal(headingForPoint<P>(p, o));\n\nexport const compareHeading = (a: Heading, b: Heading) =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const headingIsHorizontal = (a: Heading) =>\n  compareHeading(a, HEADING_RIGHT) || compareHeading(a, HEADING_LEFT);\n\nexport const headingIsVertical = (a: Heading) => !headingIsHorizontal(a);\n\nconst headingForPointFromDiamondElement = (\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  point: Readonly<GlobalPoint>,\n): Heading => {\n  const midPoint = getCenterForBounds(aabb);\n\n  if (isDevEnv() || isTestEnv()) {\n    invariant(\n      element.width > 0 && element.height > 0,\n      \"Diamond element has no width or height\",\n    );\n    invariant(\n      !pointsEqual(midPoint, point),\n      \"The point is too close to the element mid point to determine heading\",\n    );\n  }\n\n  const SHRINK = 0.95; // Rounded elements tolerance\n  const top = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const right = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height / 2,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const bottom = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width / 2,\n            element.y + element.height,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const left = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n\n  // Corners\n  if (\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, right)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, left)) > 0\n  ) {\n    return headingForPoint(top, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, right),\n      vectorFromPoint(right, bottom),\n    ) <= 0 &&\n    vectorCross(vectorFromPoint(point, right), vectorFromPoint(right, top)) > 0\n  ) {\n    return headingForPoint(right, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, left),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, right),\n    ) > 0\n  ) {\n    return headingForPoint(bottom, midPoint);\n  } else if (\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, top)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, bottom)) > 0\n  ) {\n    return headingForPoint(left, midPoint);\n  }\n\n  // Sides\n  if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(top, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? top : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(left, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : left;\n    return headingForPoint(p, midPoint);\n  }\n\n  const p = element.width > element.height ? top : left;\n  return headingForPoint(p, midPoint);\n};\n\n// Gets the heading for the point by creating a bounding box around the rotated\n// close fitting bounding box, then creating 4 search cones around the center of\n// the external bbox.\nexport const headingForPointFromElement = <Point extends GlobalPoint>(\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  p: Readonly<Point>,\n): Heading => {\n  const SEARCH_CONE_MULTIPLIER = 2;\n\n  const midPoint = getCenterForBounds(aabb);\n\n  if (element.type === \"diamond\") {\n    return headingForPointFromDiamondElement(element, aabb, p);\n  }\n\n  const topLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const topRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n\n  return triangleIncludesPoint<Point>(\n    [topLeft, topRight, midPoint] as Triangle<Point>,\n    p,\n  )\n    ? HEADING_UP\n    : triangleIncludesPoint<Point>(\n        [topRight, bottomRight, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_RIGHT\n    : triangleIncludesPoint<Point>(\n        [bottomRight, bottomLeft, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_DOWN\n    : HEADING_LEFT;\n};\n\nexport const flipHeading = (h: Heading): Heading =>\n  [\n    h[0] === 0 ? 0 : h[0] > 0 ? -1 : 1,\n    h[1] === 0 ? 0 : h[1] > 0 ? -1 : 1,\n  ] as Heading;\n", "import {\n  getSizeFromPoints,\n  randomInteger,\n  getUpdatedTimestamp,\n} from \"@excalidraw/common\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\n\nimport { isElbowArrow } from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"./types\";\n\nexport type ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"updated\"\n>;\n\n/**\n * This function tracks updates of text elements for the purposes for collaboration.\n * The version is used to compare updates when more than one user is working in\n * the same drawing.\n *\n * WARNING: this won't trigger the component to update, so if you need to trigger component update,\n * use `scene.mutateElement` or `ExcalidrawImperativeAPI.mutateElement` instead.\n */\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  elementsMap: ElementsMap,\n  updates: ElementUpdate<TElement>,\n  options?: {\n    isDragging?: boolean;\n  },\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points, fixedSegments, fileId } = updates as any;\n\n  if (\n    isElbowArrow(element) &&\n    (Object.keys(updates).length === 0 || // normalization case\n      typeof points !== \"undefined\" || // repositioning\n      typeof fixedSegments !== \"undefined\") // segment fixing\n  ) {\n    updates = {\n      ...updates,\n      angle: 0 as Radians,\n      ...updateElbowArrowPoints(\n        {\n          ...element,\n          x: updates.x || element.x,\n          y: updates.y || element.y,\n        },\n        elementsMap as NonDeletedSceneElementsMap,\n        updates as ElementUpdate<ExcalidrawElbowArrowElement>,\n        options,\n      ),\n    };\n  } else if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        // (except for specific keys we handle below)\n        (typeof value !== \"object\" ||\n          value === null ||\n          key === \"groupIds\" ||\n          key === \"scale\")\n      ) {\n        continue;\n      }\n\n      if (key === \"scale\") {\n        const prevScale = (element as any)[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint = prevPoints[index];\n            const nextPoint = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof fileId != \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    ShapeCache.delete(element);\n  }\n\n  element.version = updates.version ?? element.version + 1;\n  element.versionNonce = updates.versionNonce ?? randomInteger();\n  element.updated = getUpdatedTimestamp();\n\n  return element;\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n  /** pass `true` to always regenerate */\n  force = false,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        (typeof value !== \"object\" || value === null)\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange && !force) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: updates.version ?? element.version + 1,\n    versionNonce: updates.versionNonce ?? randomInteger(),\n    updated: getUpdatedTimestamp(),\n  };\n};\n\n/**\n * Mutates element, bumping `version`, `versionNonce`, and `updated`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = <T extends Mutable<ExcalidrawElement>>(\n  element: T,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  return element;\n};\n", "import {\n  clamp,\n  pointDistance,\n  pointFrom,\n  pointScaleFromOrigin,\n  pointsEqual,\n  pointTranslate,\n  vector,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport {\n  type Bounds,\n  BinaryHeap,\n  invariant,\n  isAnyTrue,\n  getSizeFromPoints,\n  isDevEnv,\n  arrayToMap,\n} from \"@excalidraw/common\";\n\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport {\n  bindPointToSnapToElementOutline,\n  getHeadingForElbowArrowSnap,\n  getGlobalFixedPointForBindableElement,\n  getBindingGap,\n  maxBindingDistance_simple,\n  BASE_BINDING_GAP_ELBOW,\n} from \"./binding\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  compareHeading,\n  flipHeading,\n  HEADING_DOWN,\n  HEADING_LEFT,\n  HEADING_RIGHT,\n  HEADING_UP,\n  headingForPointIsHorizontal,\n  headingIsHorizontal,\n  vectorToHeading,\n  headingForPoint,\n} from \"./heading\";\nimport { type ElementUpdate } from \"./mutateElement\";\nimport { isBindableElement } from \"./typeChecks\";\nimport {\n  type ExcalidrawElbowArrowElement,\n  type NonDeletedSceneElementsMap,\n} from \"./types\";\nimport { aabbForElement, pointInsideBounds } from \"./bounds\";\nimport { getHoveredElementForBinding } from \"./collision\";\n\nimport type { Heading } from \"./heading\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ExcalidrawBindableElement,\n  FixedPointBinding,\n  FixedSegment,\n  NonDeletedExcalidrawElement,\n  Ordered,\n} from \"./types\";\n\ntype GridAddress = [number, number] & { _brand: \"gridaddress\" };\n\ntype Node = {\n  f: number;\n  g: number;\n  h: number;\n  closed: boolean;\n  visited: boolean;\n  parent: Node | null;\n  pos: GlobalPoint;\n  addr: GridAddress;\n};\n\ntype Grid = {\n  row: number;\n  col: number;\n  data: (Node | null)[];\n};\n\ntype ElbowArrowState = {\n  x: number;\n  y: number;\n  startBinding: FixedPointBinding | null;\n  endBinding: FixedPointBinding | null;\n  startArrowhead: Arrowhead | null;\n  endArrowhead: Arrowhead | null;\n};\n\ntype ElbowArrowData = {\n  dynamicAABBs: Bounds[];\n  startDonglePosition: GlobalPoint | null;\n  startGlobalPoint: GlobalPoint;\n  startHeading: Heading;\n  endDonglePosition: GlobalPoint | null;\n  endGlobalPoint: GlobalPoint;\n  endHeading: Heading;\n  commonBounds: Bounds;\n  hoveredStartElement: ExcalidrawBindableElement | null;\n  hoveredEndElement: ExcalidrawBindableElement | null;\n};\n\nconst DEDUP_TRESHOLD = 1;\nexport const BASE_PADDING = 40;\n\nconst handleSegmentRenormalization = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const nextFixedSegments: FixedSegment[] | null = arrow.fixedSegments\n    ? arrow.fixedSegments.slice()\n    : null;\n\n  if (nextFixedSegments) {\n    const _nextPoints: GlobalPoint[] = [];\n\n    arrow.points\n      .map((p) => pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]))\n      .forEach((p, i, points) => {\n        if (i < 2) {\n          return _nextPoints.push(p);\n        }\n\n        const currentSegmentIsHorizontal = headingForPoint(p, points[i - 1]);\n        const prevSegmentIsHorizontal = headingForPoint(\n          points[i - 1],\n          points[i - 2],\n        );\n\n        if (\n          // Check if previous two points are on the same line\n          compareHeading(currentSegmentIsHorizontal, prevSegmentIsHorizontal)\n        ) {\n          const prevSegmentIdx =\n            nextFixedSegments?.findIndex(\n              (segment) => segment.index === i - 1,\n            ) ?? -1;\n          const segmentIdx =\n            nextFixedSegments?.findIndex((segment) => segment.index === i) ??\n            -1;\n\n          // If the current segment is a fixed segment, update its start point\n          if (segmentIdx !== -1) {\n            nextFixedSegments[segmentIdx].start = pointFrom<LocalPoint>(\n              points[i - 2][0] - arrow.x,\n              points[i - 2][1] - arrow.y,\n            );\n          }\n\n          // Remove the fixed segment status from the previous segment if it is\n          // a fixed segment, because we are going to unify that segment with\n          // the current one\n          if (prevSegmentIdx !== -1) {\n            nextFixedSegments.splice(prevSegmentIdx, 1);\n          }\n\n          // Remove the duplicate point\n          _nextPoints.splice(-1, 1);\n\n          // Update fixed point indices\n          nextFixedSegments.forEach((segment) => {\n            if (segment.index > i - 1) {\n              segment.index -= 1;\n            }\n          });\n        }\n\n        return _nextPoints.push(p);\n      });\n\n    const nextPoints: GlobalPoint[] = [];\n\n    _nextPoints.forEach((p, i, points) => {\n      if (i < 3) {\n        return nextPoints.push(p);\n      }\n\n      if (\n        // Remove segments that are too short\n        pointDistance(points[i - 2], points[i - 1]) < DEDUP_TRESHOLD\n      ) {\n        const prevPrevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 2) ??\n          -1;\n        const prevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 1) ??\n          -1;\n\n        // Remove the previous fixed segment if it exists (i.e. the segment\n        // which will be removed due to being parallel or too short)\n        if (prevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevSegmentIdx, 1);\n        }\n\n        // Remove the fixed segment status from the segment 2 steps back\n        // if it is a fixed segment, because we are going to unify that\n        // segment with the current one\n        if (prevPrevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevPrevSegmentIdx, 1);\n        }\n\n        nextPoints.splice(-2, 2);\n\n        // Since we have to remove two segments, update any fixed segment\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i - 2) {\n            segment.index -= 2;\n          }\n        });\n\n        // Remove aligned segment points\n        const isHorizontal = headingForPointIsHorizontal(p, points[i - 1]);\n\n        return nextPoints.push(\n          pointFrom<GlobalPoint>(\n            !isHorizontal ? points[i - 2][0] : p[0],\n            isHorizontal ? points[i - 2][1] : p[1],\n          ),\n        );\n      }\n\n      nextPoints.push(p);\n    });\n\n    const filteredNextFixedSegments = nextFixedSegments.filter(\n      (segment) =>\n        segment.index !== 1 && segment.index !== nextPoints.length - 1,\n    );\n    if (filteredNextFixedSegments.length === 0) {\n      return normalizeArrowElementUpdate(\n        getElbowArrowCornerPoints(\n          removeElbowArrowShortSegments(\n            routeElbowArrow(\n              arrow,\n              getElbowArrowData(\n                arrow,\n                elementsMap,\n                nextPoints.map((p) =>\n                  pointFrom<LocalPoint>(p[0] - arrow.x, p[1] - arrow.y),\n                ),\n              ),\n            ) ?? [],\n          ),\n        ),\n        filteredNextFixedSegments,\n        null,\n        null,\n      );\n    }\n\n    isDevEnv() &&\n      invariant(\n        validateElbowPoints(nextPoints),\n        \"Invalid elbow points with fixed segments\",\n      );\n\n    return normalizeArrowElementUpdate(\n      nextPoints,\n      filteredNextFixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  return {\n    x: arrow.x,\n    y: arrow.y,\n    points: arrow.points,\n    fixedSegments: arrow.fixedSegments,\n    startIsSpecial: arrow.startIsSpecial,\n    endIsSpecial: arrow.endIsSpecial,\n  };\n};\n\nconst handleSegmentRelease = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const newFixedSegmentIndices = fixedSegments.map((segment) => segment.index);\n  const oldFixedSegmentIndices =\n    arrow.fixedSegments?.map((segment) => segment.index) ?? [];\n  const deletedSegmentIdx = oldFixedSegmentIndices.findIndex(\n    (idx) => !newFixedSegmentIndices.includes(idx),\n  );\n\n  if (deletedSegmentIdx === -1 || !arrow.fixedSegments?.[deletedSegmentIdx]) {\n    return {\n      points: arrow.points,\n    };\n  }\n\n  const deletedIdx = arrow.fixedSegments[deletedSegmentIdx].index;\n\n  // Find prev and next fixed segments\n  const prevSegment = arrow.fixedSegments[deletedSegmentIdx - 1];\n  const nextSegment = arrow.fixedSegments[deletedSegmentIdx + 1];\n\n  // We need to render a sub-arrow path to restore deleted segments\n  const x = arrow.x + (prevSegment ? prevSegment.end[0] : 0);\n  const y = arrow.y + (prevSegment ? prevSegment.end[1] : 0);\n  const startBinding = prevSegment ? null : arrow.startBinding;\n  const endBinding = nextSegment ? null : arrow.endBinding;\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x,\n      y,\n      startBinding,\n      endBinding,\n      startArrowhead: null,\n      endArrowhead: null,\n      points: arrow.points,\n    },\n    elementsMap,\n    [\n      pointFrom<LocalPoint>(0, 0),\n      pointFrom<LocalPoint>(\n        arrow.x +\n          (nextSegment?.start[0] ?? arrow.points[arrow.points.length - 1][0]) -\n          x,\n        arrow.y +\n          (nextSegment?.start[1] ?? arrow.points[arrow.points.length - 1][1]) -\n          y,\n      ),\n    ],\n    { isDragging: false },\n  );\n\n  const { points: restoredPoints } = normalizeArrowElementUpdate(\n    getElbowArrowCornerPoints(\n      removeElbowArrowShortSegments(\n        routeElbowArrow(arrow, {\n          startHeading,\n          endHeading,\n          startGlobalPoint,\n          endGlobalPoint,\n          hoveredStartElement,\n          hoveredEndElement,\n          ...rest,\n        }) ?? [],\n      ),\n    ),\n    fixedSegments,\n    null,\n    null,\n  );\n\n  if (!restoredPoints || restoredPoints.length < 2) {\n    throw new Error(\n      \"Property 'points' is required in the update returned by normalizeArrowElementUpdate()\",\n    );\n  }\n\n  const nextPoints: GlobalPoint[] = [];\n\n  // First part of the arrow are the old points\n  if (prevSegment) {\n    for (let i = 0; i < prevSegment.index; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  restoredPoints.forEach((p) => {\n    nextPoints.push(\n      pointFrom<GlobalPoint>(\n        arrow.x + (prevSegment ? prevSegment.end[0] : 0) + p[0],\n        arrow.y + (prevSegment ? prevSegment.end[1] : 0) + p[1],\n      ),\n    );\n  });\n\n  // Last part of the arrow are the old points too\n  if (nextSegment) {\n    for (let i = nextSegment.index; i < arrow.points.length; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  // Update nextFixedSegments\n  const originalSegmentCountDiff =\n    (nextSegment?.index ?? arrow.points.length) - (prevSegment?.index ?? 0) - 1;\n\n  const nextFixedSegments = fixedSegments.map((segment) => {\n    if (segment.index > deletedIdx) {\n      return {\n        ...segment,\n        index:\n          segment.index -\n          originalSegmentCountDiff +\n          (restoredPoints.length - 1),\n      };\n    }\n\n    return segment;\n  });\n\n  const simplifiedPoints = nextPoints.flatMap((p, i) => {\n    const prev = nextPoints[i - 1];\n    const next = nextPoints[i + 1];\n\n    if (prev && next) {\n      const prevHeading = headingForPoint(p, prev);\n      const nextHeading = headingForPoint(next, p);\n\n      if (compareHeading(prevHeading, nextHeading)) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index -= 1;\n          }\n        });\n\n        return [];\n      } else if (compareHeading(prevHeading, flipHeading(nextHeading))) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index += 1;\n          }\n        });\n\n        return [p, p];\n      }\n    }\n\n    return [p];\n  });\n\n  return normalizeArrowElementUpdate(\n    simplifiedPoints,\n    nextFixedSegments,\n    false,\n    false,\n  );\n};\n\n/**\n *\n */\nconst handleSegmentMove = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  const activelyModifiedSegmentIdx = fixedSegments\n    .map((segment, i) => {\n      if (\n        arrow.fixedSegments == null ||\n        arrow.fixedSegments[i] === undefined ||\n        arrow.fixedSegments[i].index !== segment.index\n      ) {\n        return i;\n      }\n\n      return (segment.start[0] !== arrow.fixedSegments![i].start[0] &&\n        segment.end[0] !== arrow.fixedSegments![i].end[0]) !==\n        (segment.start[1] !== arrow.fixedSegments![i].start[1] &&\n          segment.end[1] !== arrow.fixedSegments![i].end[1])\n        ? i\n        : null;\n    })\n    .filter((idx) => idx !== null)\n    .shift();\n\n  if (activelyModifiedSegmentIdx == null) {\n    return { points: arrow.points };\n  }\n\n  const firstSegmentIdx =\n    arrow.fixedSegments?.findIndex((segment) => segment.index === 1) ?? -1;\n  const lastSegmentIdx =\n    arrow.fixedSegments?.findIndex(\n      (segment) => segment.index === arrow.points.length - 1,\n    ) ?? -1;\n\n  // Handle special case for first segment move\n  const segmentLength = pointDistance(\n    fixedSegments[activelyModifiedSegmentIdx].start,\n    fixedSegments[activelyModifiedSegmentIdx].end,\n  );\n  const segmentIsTooShort = segmentLength < BASE_PADDING + 5;\n  if (\n    firstSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index === 1 &&\n    hoveredStartElement\n  ) {\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const startIsPositive = startIsHorizontal\n      ? compareHeading(startHeading, HEADING_RIGHT)\n      : compareHeading(startHeading, HEADING_DOWN);\n    const padding = startIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].start = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].start[0] +\n        (startIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].start[1] +\n        (!startIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Handle special case for last segment move\n  if (\n    lastSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index ===\n      arrow.points.length - 1 &&\n    hoveredEndElement\n  ) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const endIsPositive = endIsHorizontal\n      ? compareHeading(endHeading, HEADING_RIGHT)\n      : compareHeading(endHeading, HEADING_DOWN);\n    const padding = endIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].end = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].end[0] +\n        (endIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].end[1] +\n        (!endIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Translate all fixed segments to global coordinates\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + segment.start[0],\n      arrow.y + segment.start[1],\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + segment.end[0],\n      arrow.y + segment.end[1],\n    ),\n  }));\n\n  // For start, clone old arrow points\n  const newPoints: GlobalPoint[] = arrow.points.map((p, i) =>\n    pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n  );\n\n  const startIdx = nextFixedSegments[activelyModifiedSegmentIdx].index - 1;\n  const endIdx = nextFixedSegments[activelyModifiedSegmentIdx].index;\n  const start = nextFixedSegments[activelyModifiedSegmentIdx].start;\n  const end = nextFixedSegments[activelyModifiedSegmentIdx].end;\n  const prevSegmentIsHorizontal =\n    newPoints[startIdx - 1] &&\n    !pointsEqual(newPoints[startIdx], newPoints[startIdx - 1])\n      ? headingForPointIsHorizontal(\n          newPoints[startIdx - 1],\n          newPoints[startIdx],\n        )\n      : undefined;\n  const nextSegmentIsHorizontal =\n    newPoints[endIdx + 1] &&\n    !pointsEqual(newPoints[endIdx], newPoints[endIdx + 1])\n      ? headingForPointIsHorizontal(newPoints[endIdx + 1], newPoints[endIdx])\n      : undefined;\n\n  // Override the segment points with the actively moved fixed segment\n  if (prevSegmentIsHorizontal !== undefined) {\n    const dir = prevSegmentIsHorizontal ? 1 : 0;\n    newPoints[startIdx - 1][dir] = start[dir];\n  }\n  newPoints[startIdx] = start;\n  newPoints[endIdx] = end;\n  if (nextSegmentIsHorizontal !== undefined) {\n    const dir = nextSegmentIsHorizontal ? 1 : 0;\n    newPoints[endIdx + 1][dir] = end[dir];\n  }\n\n  // Override neighboring fixedSegment start/end points, if any\n  const prevSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === startIdx,\n  );\n  if (prevSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[prevSegmentIdx].end,\n      nextFixedSegments[prevSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[prevSegmentIdx].start[dir] = start[dir];\n    nextFixedSegments[prevSegmentIdx].end = start;\n  }\n\n  const nextSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === endIdx + 1,\n  );\n  if (nextSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[nextSegmentIdx].end,\n      nextFixedSegments[nextSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[nextSegmentIdx].end[dir] = end[dir];\n    nextFixedSegments[nextSegmentIdx].start = end;\n  }\n\n  // First segment move needs an additional segment\n  if (firstSegmentIdx === -1 && startIdx === 0) {\n    const startIsHorizontal = hoveredStartElement\n      ? headingIsHorizontal(startHeading)\n      : headingForPointIsHorizontal(newPoints[1], newPoints[0]);\n    newPoints.unshift(\n      pointFrom<GlobalPoint>(\n        startIsHorizontal ? start[0] : arrow.x + arrow.points[0][0],\n        !startIsHorizontal ? start[1] : arrow.y + arrow.points[0][1],\n      ),\n    );\n\n    if (hoveredStartElement) {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        ),\n      );\n    }\n\n    for (const segment of nextFixedSegments) {\n      segment.index += hoveredStartElement ? 2 : 1;\n    }\n  }\n\n  // Last segment move needs an additional segment\n  if (lastSegmentIdx === -1 && endIdx === arrow.points.length - 1) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    newPoints.push(\n      pointFrom<GlobalPoint>(\n        endIsHorizontal\n          ? end[0]\n          : arrow.x + arrow.points[arrow.points.length - 1][0],\n        !endIsHorizontal\n          ? end[1]\n          : arrow.y + arrow.points[arrow.points.length - 1][1],\n      ),\n    );\n    if (hoveredEndElement) {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        ),\n      );\n    }\n  }\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments.map((segment) => ({\n      ...segment,\n      start: pointFrom<LocalPoint>(\n        segment.start[0] - arrow.x,\n        segment.start[1] - arrow.y,\n      ),\n      end: pointFrom<LocalPoint>(\n        segment.end[0] - arrow.x,\n        segment.end[1] - arrow.y,\n      ),\n    })),\n    false, // If you move a segment, there is no special point anymore\n    false, // If you move a segment, there is no special point anymore\n  );\n};\n\nconst handleEndpointDrag = (\n  arrow: ExcalidrawElbowArrowElement,\n  updatedPoints: readonly LocalPoint[],\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  startGlobalPoint: GlobalPoint,\n  endGlobalPoint: GlobalPoint,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  let startIsSpecial = arrow.startIsSpecial ?? null;\n  let endIsSpecial = arrow.endIsSpecial ?? null;\n  const globalUpdatedPoints = updatedPoints.map((p, i) =>\n    i === 0\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : i === updatedPoints.length - 1\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n  );\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + (segment.start[0] - updatedPoints[0][0]),\n      arrow.y + (segment.start[1] - updatedPoints[0][1]),\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + (segment.end[0] - updatedPoints[0][0]),\n      arrow.y + (segment.end[1] - updatedPoints[0][1]),\n    ),\n  }));\n  const newPoints: GlobalPoint[] = [];\n\n  // Add the inside points\n  const offset = 2 + (startIsSpecial ? 1 : 0);\n  const endOffset = 2 + (endIsSpecial ? 1 : 0);\n  while (newPoints.length + offset < globalUpdatedPoints.length - endOffset) {\n    newPoints.push(globalUpdatedPoints[newPoints.length + offset]);\n  }\n\n  // Calculate the moving second point connection and add the start point\n  {\n    const secondPoint = globalUpdatedPoints.at(startIsSpecial ? 2 : 1);\n    const thirdPoint = globalUpdatedPoints.at(startIsSpecial ? 3 : 2);\n\n    if (!secondPoint || !thirdPoint) {\n      throw new Error(\n        `Second and third points must exist when handling endpoint drag (${startIsSpecial})`,\n      );\n    }\n\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const secondIsHorizontal = headingIsHorizontal(\n      vectorToHeading(vectorFromPoint(secondPoint, thirdPoint)),\n    );\n\n    if (hoveredStartElement && startIsHorizontal === secondIsHorizontal) {\n      const positive = startIsHorizontal\n        ? compareHeading(startHeading, HEADING_RIGHT)\n        : compareHeading(startHeading, HEADING_DOWN);\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdPoint[0]\n            : startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdPoint[1]\n            : startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          startIsHorizontal\n            ? startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[0],\n          !startIsHorizontal\n            ? startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[1],\n        ),\n      );\n      if (!startIsSpecial) {\n        startIsSpecial = true;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index += 1;\n          }\n        }\n      }\n    } else {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondPoint[0] : startGlobalPoint[0],\n          secondIsHorizontal ? secondPoint[1] : startGlobalPoint[1],\n        ),\n      );\n      if (startIsSpecial) {\n        startIsSpecial = false;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index -= 1;\n          }\n        }\n      }\n    }\n    newPoints.unshift(startGlobalPoint);\n  }\n\n  // Calculate the moving second to last point connection\n  {\n    const secondToLastPoint = globalUpdatedPoints.at(\n      globalUpdatedPoints.length - (endIsSpecial ? 3 : 2),\n    );\n    const thirdToLastPoint = globalUpdatedPoints.at(\n      globalUpdatedPoints.length - (endIsSpecial ? 4 : 3),\n    );\n\n    if (!secondToLastPoint || !thirdToLastPoint) {\n      throw new Error(\n        `Second and third to last points must exist when handling endpoint drag (${endIsSpecial})`,\n      );\n    }\n\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const secondIsHorizontal = headingForPointIsHorizontal(\n      thirdToLastPoint,\n      secondToLastPoint,\n    );\n    if (hoveredEndElement && endIsHorizontal === secondIsHorizontal) {\n      const positive = endIsHorizontal\n        ? compareHeading(endHeading, HEADING_RIGHT)\n        : compareHeading(endHeading, HEADING_DOWN);\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdToLastPoint[0]\n            : endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdToLastPoint[1]\n            : endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          endIsHorizontal\n            ? endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[0],\n          !endIsHorizontal\n            ? endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[1],\n        ),\n      );\n      if (!endIsSpecial) {\n        endIsSpecial = true;\n      }\n    } else {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondToLastPoint[0] : endGlobalPoint[0],\n          secondIsHorizontal ? secondToLastPoint[1] : endGlobalPoint[1],\n        ),\n      );\n      if (endIsSpecial) {\n        endIsSpecial = false;\n      }\n    }\n  }\n\n  newPoints.push(endGlobalPoint);\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments\n      .map(({ index }) => ({\n        index,\n        start: newPoints[index - 1],\n        end: newPoints[index],\n      }))\n      .map((segment) => ({\n        ...segment,\n        start: pointFrom<LocalPoint>(\n          segment.start[0] - startGlobalPoint[0],\n          segment.start[1] - startGlobalPoint[1],\n        ),\n        end: pointFrom<LocalPoint>(\n          segment.end[0] - startGlobalPoint[0],\n          segment.end[1] - startGlobalPoint[1],\n        ),\n      })),\n    startIsSpecial,\n    endIsSpecial,\n  );\n};\n\nconst MAX_POS = 1e6;\n\n/**\n *\n */\nexport const updateElbowArrowPoints = (\n  arrow: Readonly<ExcalidrawElbowArrowElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  updates: {\n    points?: readonly LocalPoint[];\n    fixedSegments?: readonly FixedSegment[] | null;\n    startBinding?: FixedPointBinding | null;\n    endBinding?: FixedPointBinding | null;\n  },\n  options?: {\n    isDragging?: boolean;\n  },\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  if (arrow.points.length < 2) {\n    return { points: updates.points ?? arrow.points };\n  }\n\n  if (!import.meta.env.PROD) {\n    invariant(\n      !updates.points || updates.points.length >= 2,\n      \"Updated point array length must match the arrow point length, contain \" +\n        \"exactly the new start and end points or not be specified at all (i.e. \" +\n        \"you can't add new points between start and end manually to elbow arrows)\",\n    );\n\n    invariant(\n      !arrow.fixedSegments ||\n        arrow.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      !updates.fixedSegments ||\n        updates.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Updates to fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      arrow.points\n        .slice(1)\n        .map(\n          (p, i) => p[0] === arrow.points[i][0] || p[1] === arrow.points[i][1],\n        ),\n      \"Elbow arrow segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      updates.fixedSegments?.find(\n        (segment) =>\n          segment.index === 1 &&\n          pointsEqual(segment.start, (updates.points ?? arrow.points)[0]),\n      ) == null &&\n        updates.fixedSegments?.find(\n          (segment) =>\n            segment.index === (updates.points ?? arrow.points).length - 1 &&\n            pointsEqual(\n              segment.end,\n              (updates.points ?? arrow.points)[\n                (updates.points ?? arrow.points).length - 1\n              ],\n            ),\n        ) == null,\n      \"The first and last segments cannot be fixed\",\n    );\n  }\n\n  const fixedSegments = updates.fixedSegments ?? arrow.fixedSegments ?? [];\n\n  const updatedPoints: readonly LocalPoint[] = updates.points\n    ? updates.points && updates.points.length === 2\n      ? arrow.points.map((p, idx) =>\n          idx === 0\n            ? updates.points![0]\n            : idx === arrow.points.length - 1\n            ? updates.points![1]\n            : p,\n        )\n      : updates.points.slice()\n    : arrow.points.slice();\n\n  // During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  const {\n    startBinding: updatedStartBinding,\n    endBinding: updatedEndBinding,\n    ...restOfTheUpdates\n  } = updates;\n  const startBinding =\n    typeof updatedStartBinding !== \"undefined\"\n      ? updatedStartBinding\n      : arrow.startBinding;\n  const endBinding =\n    typeof updatedEndBinding !== \"undefined\"\n      ? updatedEndBinding\n      : arrow.endBinding;\n  const startElement =\n    startBinding &&\n    getBindableElementForId(startBinding.elementId, elementsMap);\n  const endElement =\n    endBinding && getBindableElementForId(endBinding.elementId, elementsMap);\n  const areUpdatedPointsValid = validateElbowPoints(updatedPoints);\n\n  if (\n    (startBinding && !startElement && areUpdatedPointsValid) ||\n    (endBinding && !endElement && areUpdatedPointsValid) ||\n    (elementsMap.size === 0 && areUpdatedPointsValid) ||\n    (Object.keys(restOfTheUpdates).length === 0 &&\n      (startElement?.id !== startBinding?.elementId ||\n        endElement?.id !== endBinding?.elementId))\n  ) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x: arrow.x,\n      y: arrow.y,\n      startBinding,\n      endBinding,\n      startArrowhead: arrow.startArrowhead,\n      endArrowhead: arrow.endArrowhead,\n      points: arrow.points,\n    },\n    elementsMap,\n    updatedPoints,\n    options,\n  );\n\n  // 0. During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  if (elementsMap.size === 0 && areUpdatedPointsValid) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  ////\n  // 1. Renormalize the arrow\n  ////\n  if (\n    !updates.points &&\n    !updates.fixedSegments &&\n    !updates.startBinding &&\n    !updates.endBinding\n  ) {\n    return handleSegmentRenormalization(arrow, elementsMap);\n  }\n\n  // Short circuit on no-op to avoid huge performance hit\n  if (\n    updates.startBinding === arrow.startBinding &&\n    updates.endBinding === arrow.endBinding &&\n    (updates.points ?? []).every((p, i) =>\n      pointsEqual(\n        p,\n        arrow.points[i] ?? pointFrom<LocalPoint>(Infinity, Infinity),\n      ),\n    ) &&\n    areUpdatedPointsValid\n  ) {\n    return {};\n  }\n\n  ////\n  // 2. Just normal elbow arrow things\n  ////\n  if (fixedSegments.length === 0) {\n    return normalizeArrowElementUpdate(\n      getElbowArrowCornerPoints(\n        removeElbowArrowShortSegments(\n          routeElbowArrow(arrow, {\n            startHeading,\n            endHeading,\n            startGlobalPoint,\n            endGlobalPoint,\n            hoveredStartElement,\n            hoveredEndElement,\n            ...rest,\n          }) ?? [],\n        ),\n      ),\n      fixedSegments,\n      null,\n      null,\n    );\n  }\n\n  ////\n  // 3. Handle releasing a fixed segment\n  if ((arrow.fixedSegments?.length ?? 0) > fixedSegments.length) {\n    return handleSegmentRelease(arrow, fixedSegments, elementsMap);\n  }\n\n  ////\n  // 4. Handle manual segment move\n  ////\n  if (!updates.points) {\n    return handleSegmentMove(\n      arrow,\n      fixedSegments,\n      startHeading,\n      endHeading,\n      hoveredStartElement,\n      hoveredEndElement,\n    );\n  }\n\n  ////\n  // 5. Handle resize\n  ////\n  if (updates.points && updates.fixedSegments) {\n    return updates;\n  }\n\n  ////\n  // 6. One or more segments are fixed and endpoints are moved\n  //\n  // The key insights are:\n  // - When segments are fixed, the arrow will keep the exact amount of segments\n  // - Fixed segments are \"replacements\" for exactly one segment in the old arrow\n  ////\n  return handleEndpointDrag(\n    arrow,\n    updatedPoints,\n    fixedSegments,\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n  );\n};\n\n/**\n * Retrieves data necessary for calculating the elbow arrow path.\n *\n * @param arrow - The arrow object containing its properties.\n * @param elementsMap - A map of elements in the scene.\n * @param nextPoints - The next set of points for the arrow.\n * @param options - Optional parameters for the calculation.\n * @param options.isDragging - Indicates if the arrow is being dragged.\n * @param options.startIsMidPoint - Indicates if the start point is a midpoint.\n * @param options.endIsMidPoint - Indicates if the end point is a midpoint.\n *\n * @returns An object containing various properties needed for elbow arrow calculations:\n * - dynamicAABBs: Dynamically generated axis-aligned bounding boxes.\n * - startDonglePosition: The position of the start dongle.\n * - startGlobalPoint: The global coordinates of the start point.\n * - startHeading: The heading direction from the start point.\n * - endDonglePosition: The position of the end dongle.\n * - endGlobalPoint: The global coordinates of the end point.\n * - endHeading: The heading direction from the end point.\n * - commonBounds: The common bounding box that encompasses both start and end points.\n * - hoveredStartElement: The element being hovered over at the start point.\n * - hoveredEndElement: The element being hovered over at the end point.\n */\nconst getElbowArrowData = (\n  arrow: {\n    x: number;\n    y: number;\n    startBinding: FixedPointBinding | null;\n    endBinding: FixedPointBinding | null;\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points: readonly LocalPoint[];\n  },\n  elementsMap: NonDeletedSceneElementsMap,\n  nextPoints: readonly LocalPoint[],\n  options?: {\n    isDragging?: boolean;\n    zoom?: AppState[\"zoom\"];\n  },\n) => {\n  const origStartGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[0], vector(arrow.x, arrow.y));\n  const origEndGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[nextPoints.length - 1], vector(arrow.x, arrow.y));\n\n  let hoveredStartElement = null;\n  let hoveredEndElement = null;\n  if (options?.isDragging) {\n    const elements = Array.from(elementsMap.values());\n    hoveredStartElement =\n      getHoveredElement(\n        origStartGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n    hoveredEndElement =\n      getHoveredElement(\n        origEndGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n  } else {\n    hoveredStartElement = arrow.startBinding\n      ? getBindableElementForId(arrow.startBinding.elementId, elementsMap) ||\n        null\n      : null;\n    hoveredEndElement = arrow.endBinding\n      ? getBindableElementForId(arrow.endBinding.elementId, elementsMap) || null\n      : null;\n  }\n\n  const startGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      angle: 0,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"start\",\n    arrow.startBinding?.fixedPoint,\n    origStartGlobalPoint,\n    hoveredStartElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const endGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      angle: 0,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"end\",\n    arrow.endBinding?.fixedPoint,\n    origEndGlobalPoint,\n    hoveredEndElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const startHeading = getBindPointHeading(\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    origStartGlobalPoint,\n    elementsMap,\n    options?.zoom,\n  );\n  const endHeading = getBindPointHeading(\n    endGlobalPoint,\n    startGlobalPoint,\n    hoveredEndElement,\n    origEndGlobalPoint,\n    elementsMap,\n    options?.zoom,\n  );\n  const startPointBounds = [\n    startGlobalPoint[0] - 2,\n    startGlobalPoint[1] - 2,\n    startGlobalPoint[0] + 2,\n    startGlobalPoint[1] + 2,\n  ] as Bounds;\n  const endPointBounds = [\n    endGlobalPoint[0] - 2,\n    endGlobalPoint[1] - 2,\n    endGlobalPoint[0] + 2,\n    endGlobalPoint[1] + 2,\n  ] as Bounds;\n  const startElementBounds = hoveredStartElement\n    ? aabbForElement(\n        hoveredStartElement,\n        elementsMap,\n        offsetFromHeading(\n          startHeading,\n          arrow.startArrowhead\n            ? getBindingGap(hoveredStartElement, { elbowed: true }) * 6\n            : getBindingGap(hoveredStartElement, { elbowed: true }) * 2,\n          1,\n        ),\n      )\n    : startPointBounds;\n  const endElementBounds = hoveredEndElement\n    ? aabbForElement(\n        hoveredEndElement,\n        elementsMap,\n        offsetFromHeading(\n          endHeading,\n          arrow.endArrowhead\n            ? getBindingGap(hoveredEndElement, { elbowed: true }) * 6\n            : getBindingGap(hoveredEndElement, { elbowed: true }) * 2,\n          1,\n        ),\n      )\n    : endPointBounds;\n  const boundsOverlap =\n    pointInsideBounds(\n      startGlobalPoint,\n      hoveredEndElement\n        ? aabbForElement(\n            hoveredEndElement,\n            elementsMap,\n            offsetFromHeading(endHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : endPointBounds,\n    ) ||\n    pointInsideBounds(\n      endGlobalPoint,\n      hoveredStartElement\n        ? aabbForElement(\n            hoveredStartElement,\n            elementsMap,\n            offsetFromHeading(startHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : startPointBounds,\n    );\n  const commonBounds = commonAABB(\n    boundsOverlap\n      ? [startPointBounds, endPointBounds]\n      : [startElementBounds, endElementBounds],\n  );\n  const dynamicAABBs = generateDynamicAABBs(\n    boundsOverlap ? startPointBounds : startElementBounds,\n    boundsOverlap ? endPointBounds : endElementBounds,\n    commonBounds,\n    boundsOverlap\n      ? offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.startArrowhead\n                  ? BASE_BINDING_GAP_ELBOW * 6\n                  : BASE_BINDING_GAP_ELBOW * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap\n      ? offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.endArrowhead\n                  ? BASE_BINDING_GAP_ELBOW * 6\n                  : BASE_BINDING_GAP_ELBOW * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap,\n    hoveredStartElement && aabbForElement(hoveredStartElement, elementsMap),\n    hoveredEndElement && aabbForElement(hoveredEndElement, elementsMap),\n  );\n  const startDonglePosition = getDonglePosition(\n    dynamicAABBs[0],\n    startHeading,\n    startGlobalPoint,\n  );\n  const endDonglePosition = getDonglePosition(\n    dynamicAABBs[1],\n    endHeading,\n    endGlobalPoint,\n  );\n\n  return {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredStartElement,\n    hoveredEndElement,\n    boundsOverlap,\n    startElementBounds,\n    endElementBounds,\n  };\n};\n\n/**\n * Generate the elbow arrow segments\n *\n * @param arrow\n * @param elementsMap\n * @param nextPoints\n * @param options\n * @returns\n */\nconst routeElbowArrow = (\n  arrow: ElbowArrowState,\n  elbowArrowData: ElbowArrowData,\n): GlobalPoint[] | null => {\n  const {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredEndElement,\n  } = elbowArrowData;\n\n  // Canculate Grid positions\n  const grid = calculateGrid(\n    dynamicAABBs,\n    startDonglePosition ? startDonglePosition : startGlobalPoint,\n    startHeading,\n    endDonglePosition ? endDonglePosition : endGlobalPoint,\n    endHeading,\n    commonBounds,\n  );\n\n  const startDongle =\n    startDonglePosition && pointToGridNode(startDonglePosition, grid);\n  const endDongle =\n    endDonglePosition && pointToGridNode(endDonglePosition, grid);\n\n  // Do not allow stepping on the true end or true start points\n  const endNode = pointToGridNode(endGlobalPoint, grid);\n  if (endNode && hoveredEndElement) {\n    endNode.closed = true;\n  }\n  const startNode = pointToGridNode(startGlobalPoint, grid);\n  if (startNode && arrow.startBinding) {\n    startNode.closed = true;\n  }\n  const dongleOverlap =\n    startDongle &&\n    endDongle &&\n    (pointInsideBounds(startDongle.pos, dynamicAABBs[1]) ||\n      pointInsideBounds(endDongle.pos, dynamicAABBs[0]));\n\n  // Create path to end dongle from start dongle\n  const path = astar(\n    startDongle ? startDongle : startNode!,\n    endDongle ? endDongle : endNode!,\n    grid,\n    startHeading ? startHeading : HEADING_RIGHT,\n    endHeading ? endHeading : HEADING_RIGHT,\n    dongleOverlap ? [] : dynamicAABBs,\n  );\n\n  if (path) {\n    const points = path.map((node) => [\n      node.pos[0],\n      node.pos[1],\n    ]) as GlobalPoint[];\n    startDongle && points.unshift(startGlobalPoint);\n    endDongle && points.push(endGlobalPoint);\n\n    return points;\n  }\n\n  return null;\n};\n\nconst offsetFromHeading = (\n  heading: Heading,\n  head: number,\n  side: number,\n): [number, number, number, number] => {\n  switch (heading) {\n    case HEADING_UP:\n      return [head, side, side, side];\n    case HEADING_RIGHT:\n      return [side, head, side, side];\n    case HEADING_DOWN:\n      return [side, side, head, side];\n  }\n\n  return [side, side, side, head];\n};\n\n/**\n * Routing algorithm based on the A* path search algorithm.\n * @see https://www.geeksforgeeks.org/a-search-algorithm/\n *\n * Binary heap is used to optimize node lookup.\n * See {@link calculateGrid} for the grid calculation details.\n *\n * Additional modifications added due to aesthetic route reasons:\n * 1) Arrow segment direction change is penalized by specific linear constant (bendMultiplier)\n * 2) Arrow segments are not allowed to go \"backwards\", overlapping with the previous segment\n */\nconst astar = (\n  start: Node,\n  end: Node,\n  grid: Grid,\n  startHeading: Heading,\n  endHeading: Heading,\n  aabbs: Bounds[],\n) => {\n  const bendMultiplier = m_dist(start.pos, end.pos);\n  const open = new BinaryHeap<Node>((node) => node.f);\n\n  open.push(start);\n\n  while (open.size() > 0) {\n    // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n    const current = open.pop();\n\n    if (!current || current.closed) {\n      // Current is not passable, continue with next element\n      continue;\n    }\n\n    // End case -- result has been found, return the traced path.\n    if (current === end) {\n      return pathTo(start, current);\n    }\n\n    // Normal case -- move current from open to closed, process each of its neighbors.\n    current.closed = true;\n\n    // Find all neighbors for the current node.\n    const neighbors = getNeighbors(current.addr, grid);\n\n    for (let i = 0; i < 4; i++) {\n      const neighbor = neighbors[i];\n\n      if (!neighbor || neighbor.closed) {\n        // Not a valid node to process, skip to next neighbor.\n        continue;\n      }\n\n      // Intersect\n      const neighborHalfPoint = pointScaleFromOrigin(\n        neighbor.pos,\n        current.pos,\n        0.5,\n      );\n      if (\n        isAnyTrue(\n          ...aabbs.map((aabb) => pointInsideBounds(neighborHalfPoint, aabb)),\n        )\n      ) {\n        continue;\n      }\n\n      // The g score is the shortest distance from start to current node.\n      // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n      const neighborHeading = neighborIndexToHeading(i as 0 | 1 | 2 | 3);\n      const previousDirection = current.parent\n        ? vectorToHeading(vectorFromPoint(current.pos, current.parent.pos))\n        : startHeading;\n\n      // Do not allow going in reverse\n      const reverseHeading = flipHeading(previousDirection);\n      const neighborIsReverseRoute =\n        compareHeading(reverseHeading, neighborHeading) ||\n        (gridAddressesEqual(start.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, startHeading)) ||\n        (gridAddressesEqual(end.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, endHeading));\n      if (neighborIsReverseRoute) {\n        continue;\n      }\n\n      const directionChange = previousDirection !== neighborHeading;\n      const gScore =\n        current.g +\n        m_dist(neighbor.pos, current.pos) +\n        (directionChange ? Math.pow(bendMultiplier, 3) : 0);\n\n      const beenVisited = neighbor.visited;\n\n      if (!beenVisited || gScore < neighbor.g) {\n        const estBendCount = estimateSegmentCount(\n          neighbor,\n          end,\n          neighborHeading,\n          endHeading,\n        );\n        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n        neighbor.visited = true;\n        neighbor.parent = current;\n        neighbor.h =\n          m_dist(end.pos, neighbor.pos) +\n          estBendCount * Math.pow(bendMultiplier, 2);\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        if (!beenVisited) {\n          // Pushing to heap will put it in proper place based on the 'f' value.\n          open.push(neighbor);\n        } else {\n          // Already seen the node, but since it has been rescored we need to reorder it in the heap\n          open.rescoreElement(neighbor);\n        }\n      }\n    }\n  }\n\n  return null;\n};\n\nconst pathTo = (start: Node, node: Node) => {\n  let curr = node;\n  const path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  path.unshift(start);\n\n  return path;\n};\n\nconst m_dist = (a: GlobalPoint | LocalPoint, b: GlobalPoint | LocalPoint) =>\n  Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n\n/**\n * Create dynamically resizing, always touching\n * bounding boxes having a minimum extent represented\n * by the given static bounds.\n */\nconst generateDynamicAABBs = (\n  a: Bounds,\n  b: Bounds,\n  common: Bounds,\n  startDifference?: [number, number, number, number],\n  endDifference?: [number, number, number, number],\n  disableSideHack?: boolean,\n  startElementBounds?: Bounds | null,\n  endElementBounds?: Bounds | null,\n): Bounds[] => {\n  const startEl = startElementBounds ?? a;\n  const endEl = endElementBounds ?? b;\n  const [startUp, startRight, startDown, startLeft] = startDifference ?? [\n    0, 0, 0, 0,\n  ];\n  const [endUp, endRight, endDown, endLeft] = endDifference ?? [0, 0, 0, 0];\n\n  const first = [\n    a[0] > b[2]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.min((startEl[0] + endEl[2]) / 2, a[0] - startLeft)\n        : (startEl[0] + endEl[2]) / 2\n      : a[0] > b[0]\n      ? a[0] - startLeft\n      : common[0] - startLeft,\n    a[1] > b[3]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.min((startEl[1] + endEl[3]) / 2, a[1] - startUp)\n        : (startEl[1] + endEl[3]) / 2\n      : a[1] > b[1]\n      ? a[1] - startUp\n      : common[1] - startUp,\n    a[2] < b[0]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.max((startEl[2] + endEl[0]) / 2, a[2] + startRight)\n        : (startEl[2] + endEl[0]) / 2\n      : a[2] < b[2]\n      ? a[2] + startRight\n      : common[2] + startRight,\n    a[3] < b[1]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.max((startEl[3] + endEl[1]) / 2, a[3] + startDown)\n        : (startEl[3] + endEl[1]) / 2\n      : a[3] < b[3]\n      ? a[3] + startDown\n      : common[3] + startDown,\n  ] as Bounds;\n  const second = [\n    b[0] > a[2]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.min((endEl[0] + startEl[2]) / 2, b[0] - endLeft)\n        : (endEl[0] + startEl[2]) / 2\n      : b[0] > a[0]\n      ? b[0] - endLeft\n      : common[0] - endLeft,\n    b[1] > a[3]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.min((endEl[1] + startEl[3]) / 2, b[1] - endUp)\n        : (endEl[1] + startEl[3]) / 2\n      : b[1] > a[1]\n      ? b[1] - endUp\n      : common[1] - endUp,\n    b[2] < a[0]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.max((endEl[2] + startEl[0]) / 2, b[2] + endRight)\n        : (endEl[2] + startEl[0]) / 2\n      : b[2] < a[2]\n      ? b[2] + endRight\n      : common[2] + endRight,\n    b[3] < a[1]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.max((endEl[3] + startEl[1]) / 2, b[3] + endDown)\n        : (endEl[3] + startEl[1]) / 2\n      : b[3] < a[3]\n      ? b[3] + endDown\n      : common[3] + endDown,\n  ] as Bounds;\n\n  const c = commonAABB([first, second]);\n  if (\n    !disableSideHack &&\n    first[2] - first[0] + second[2] - second[0] > c[2] - c[0] + 0.00000000001 &&\n    first[3] - first[1] + second[3] - second[1] > c[3] - c[1] + 0.00000000001\n  ) {\n    const [endCenterX, endCenterY] = [\n      (second[0] + second[2]) / 2,\n      (second[1] + second[3]) / 2,\n    ];\n    if (b[0] > a[2] && a[1] > b[3]) {\n      // BOTTOM LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], cX, first[3]],\n          [cX, second[1], second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    } else if (a[2] < b[0] && a[3] < b[1]) {\n      // TOP LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], first[2], cY],\n          [second[0], cY, second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], cX, first[3]],\n        [cX, second[1], second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[3] < b[1]) {\n      // TOP RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], first[2], cY],\n        [second[0], cY, second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[1] > b[3]) {\n      // BOTTOM RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    }\n  }\n\n  return [first, second];\n};\n\n/**\n * Calculates the grid which is used as nodes at\n * the grid line intersections by the A* algorithm.\n *\n * NOTE: This is not a uniform grid. It is built at\n * various intersections of bounding boxes.\n */\nconst calculateGrid = (\n  aabbs: Bounds[],\n  start: GlobalPoint,\n  startHeading: Heading,\n  end: GlobalPoint,\n  endHeading: Heading,\n  common: Bounds,\n): Grid => {\n  const horizontal = new Set<number>();\n  const vertical = new Set<number>();\n\n  if (startHeading === HEADING_LEFT || startHeading === HEADING_RIGHT) {\n    vertical.add(start[1]);\n  } else {\n    horizontal.add(start[0]);\n  }\n  if (endHeading === HEADING_LEFT || endHeading === HEADING_RIGHT) {\n    vertical.add(end[1]);\n  } else {\n    horizontal.add(end[0]);\n  }\n\n  aabbs.forEach((aabb) => {\n    horizontal.add(aabb[0]);\n    horizontal.add(aabb[2]);\n    vertical.add(aabb[1]);\n    vertical.add(aabb[3]);\n  });\n\n  horizontal.add(common[0]);\n  horizontal.add(common[2]);\n  vertical.add(common[1]);\n  vertical.add(common[3]);\n\n  const _vertical = Array.from(vertical).sort((a, b) => a - b);\n  const _horizontal = Array.from(horizontal).sort((a, b) => a - b);\n\n  return {\n    row: _vertical.length,\n    col: _horizontal.length,\n    data: _vertical.flatMap((y, row) =>\n      _horizontal.map(\n        (x, col): Node => ({\n          f: 0,\n          g: 0,\n          h: 0,\n          closed: false,\n          visited: false,\n          parent: null,\n          addr: [col, row] as GridAddress,\n          pos: [x, y] as GlobalPoint,\n        }),\n      ),\n    ),\n  };\n};\n\nconst getDonglePosition = (\n  bounds: Bounds,\n  heading: Heading,\n  p: GlobalPoint,\n): GlobalPoint => {\n  switch (heading) {\n    case HEADING_UP:\n      return pointFrom(p[0], bounds[1]);\n    case HEADING_RIGHT:\n      return pointFrom(bounds[2], p[1]);\n    case HEADING_DOWN:\n      return pointFrom(p[0], bounds[3]);\n  }\n  return pointFrom(bounds[0], p[1]);\n};\n\nconst estimateSegmentCount = (\n  start: Node,\n  end: Node,\n  startHeading: Heading,\n  endHeading: Heading,\n) => {\n  if (endHeading === HEADING_RIGHT) {\n    switch (startHeading) {\n      case HEADING_RIGHT: {\n        if (start.pos[0] >= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n      }\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_LEFT) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[0] <= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_UP) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[1] >= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  } else if (endHeading === HEADING_DOWN) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[1] <= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  }\n  return 0;\n};\n\n/**\n * Get neighboring points for a gived grid address\n */\nconst getNeighbors = ([col, row]: [number, number], grid: Grid) =>\n  [\n    gridNodeFromAddr([col, row - 1], grid),\n    gridNodeFromAddr([col + 1, row], grid),\n    gridNodeFromAddr([col, row + 1], grid),\n    gridNodeFromAddr([col - 1, row], grid),\n  ] as [Node | null, Node | null, Node | null, Node | null];\n\nconst gridNodeFromAddr = (\n  [col, row]: [col: number, row: number],\n  grid: Grid,\n): Node | null => {\n  if (col < 0 || col >= grid.col || row < 0 || row >= grid.row) {\n    return null;\n  }\n\n  return grid.data[row * grid.col + col] ?? null;\n};\n\n/**\n * Get node for global point on canvas (if exists)\n */\nconst pointToGridNode = (point: GlobalPoint, grid: Grid): Node | null => {\n  for (let col = 0; col < grid.col; col++) {\n    for (let row = 0; row < grid.row; row++) {\n      const candidate = gridNodeFromAddr([col, row], grid);\n      if (\n        candidate &&\n        point[0] === candidate.pos[0] &&\n        point[1] === candidate.pos[1]\n      ) {\n        return candidate;\n      }\n    }\n  }\n\n  return null;\n};\n\nconst commonAABB = (aabbs: Bounds[]): Bounds => [\n  Math.min(...aabbs.map((aabb) => aabb[0])),\n  Math.min(...aabbs.map((aabb) => aabb[1])),\n  Math.max(...aabbs.map((aabb) => aabb[2])),\n  Math.max(...aabbs.map((aabb) => aabb[3])),\n];\n\n/// #region Utils\n\nconst getBindableElementForId = (\n  id: string,\n  elementsMap: ElementsMap,\n): ExcalidrawBindableElement | null => {\n  const element = elementsMap.get(id);\n  if (element && isBindableElement(element)) {\n    return element;\n  }\n\n  return null;\n};\n\nconst normalizeArrowElementUpdate = (\n  global: GlobalPoint[],\n  nextFixedSegments: readonly FixedSegment[] | null,\n  startIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n  endIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  const offsetX = global[0][0];\n  const offsetY = global[0][1];\n  let points = global.map((p) =>\n    pointTranslate<GlobalPoint, LocalPoint>(\n      p,\n      vectorScale(vectorFromPoint(global[0]), -1),\n    ),\n  );\n\n  // NOTE (mtolmacs): This is a temporary check to see if the normalization\n  // creates an overly large arrow. This should be removed once we have an answer.\n  if (\n    offsetX < -MAX_POS ||\n    offsetX > MAX_POS ||\n    offsetY < -MAX_POS ||\n    offsetY > MAX_POS ||\n    offsetX + points[points.length - 1][0] < -MAX_POS ||\n    offsetY + points[points.length - 1][0] > MAX_POS ||\n    offsetX + points[points.length - 1][1] < -MAX_POS ||\n    offsetY + points[points.length - 1][1] > MAX_POS\n  ) {\n    console.error(\n      \"Elbow arrow normalization is outside reasonable bounds (> 1e6)\",\n      {\n        x: offsetX,\n        y: offsetY,\n        points,\n        ...getSizeFromPoints(points),\n      },\n    );\n  }\n\n  points = points.map(([x, y]) =>\n    pointFrom<LocalPoint>(clamp(x, -1e6, 1e6), clamp(y, -1e6, 1e6)),\n  );\n\n  return {\n    points,\n    x: clamp(offsetX, -1e6, 1e6),\n    y: clamp(offsetY, -1e6, 1e6),\n    fixedSegments:\n      (nextFixedSegments?.length ?? 0) > 0 ? nextFixedSegments : null,\n    ...getSizeFromPoints(points),\n    startIsSpecial,\n    endIsSpecial,\n  };\n};\n\nconst getElbowArrowCornerPoints = (points: GlobalPoint[]): GlobalPoint[] => {\n  if (points.length > 1) {\n    let previousHorizontal =\n      Math.abs(points[0][1] - points[1][1]) <\n      Math.abs(points[0][0] - points[1][0]);\n\n    return points.filter((p, idx) => {\n      // The very first and last points are always kept\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const next = points[idx + 1];\n      const nextHorizontal =\n        Math.abs(p[1] - next[1]) < Math.abs(p[0] - next[0]);\n      if (previousHorizontal === nextHorizontal) {\n        previousHorizontal = nextHorizontal;\n        return false;\n      }\n\n      previousHorizontal = nextHorizontal;\n      return true;\n    });\n  }\n\n  return points;\n};\n\nconst removeElbowArrowShortSegments = (\n  points: GlobalPoint[],\n): GlobalPoint[] => {\n  if (points.length >= 4) {\n    return points.filter((p, idx) => {\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const prev = points[idx - 1];\n      const prevDist = pointDistance(prev, p);\n      return prevDist > DEDUP_TRESHOLD;\n    });\n  }\n\n  return points;\n};\n\nconst neighborIndexToHeading = (idx: number): Heading => {\n  switch (idx) {\n    case 0:\n      return HEADING_UP;\n    case 1:\n      return HEADING_RIGHT;\n    case 2:\n      return HEADING_DOWN;\n  }\n  return HEADING_LEFT;\n};\n\nconst getGlobalPoint = (\n  arrow: ExcalidrawElbowArrowElement,\n  startOrEnd: \"start\" | \"end\",\n  fixedPointRatio: [number, number] | undefined | null,\n  initialPoint: GlobalPoint,\n  element?: ExcalidrawBindableElement | null,\n  elementsMap?: ElementsMap,\n  isDragging?: boolean,\n): GlobalPoint => {\n  if (isDragging) {\n    if (element && elementsMap) {\n      return bindPointToSnapToElementOutline(\n        arrow,\n        element,\n        startOrEnd,\n        elementsMap,\n      );\n    }\n\n    return initialPoint;\n  }\n\n  if (element) {\n    return getGlobalFixedPointForBindableElement(\n      fixedPointRatio || [0, 0],\n      element,\n      elementsMap ?? arrayToMap([element]),\n    );\n  }\n\n  return initialPoint;\n};\n\nconst getBindPointHeading = (\n  p: GlobalPoint,\n  otherPoint: GlobalPoint,\n  hoveredElement: ExcalidrawBindableElement | null | undefined,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n): Heading =>\n  getHeadingForElbowArrowSnap(\n    p,\n    otherPoint,\n    hoveredElement,\n    hoveredElement &&\n      aabbForElement(\n        hoveredElement,\n        elementsMap,\n        Array(4).fill(distanceToElement(hoveredElement, elementsMap, p)) as [\n          number,\n          number,\n          number,\n          number,\n        ],\n      ),\n    origPoint,\n    elementsMap,\n    zoom,\n  );\n\nconst getHoveredElement = (\n  origPoint: GlobalPoint,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  zoom?: AppState[\"zoom\"],\n) => {\n  return getHoveredElementForBinding(\n    origPoint,\n    elements,\n    elementsMap,\n    maxBindingDistance_simple(zoom),\n  );\n};\n\nconst gridAddressesEqual = (a: GridAddress, b: GridAddress): boolean =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const validateElbowPoints = <P extends GlobalPoint | LocalPoint>(\n  points: readonly P[],\n  tolerance: number = DEDUP_TRESHOLD,\n) =>\n  points\n    .slice(1)\n    .map(\n      (p, i) =>\n        Math.abs(p[0] - points[i][0]) < tolerance ||\n        Math.abs(p[1] - points[i][1]) < tolerance,\n    )\n    .every(Boolean);\n", "import { arrayToMap } from \"@excalidraw/common\";\nimport { isPointWithinBounds, pointFrom } from \"@excalidraw/math\";\nimport { doLineSegmentsIntersect } from \"@excalidraw/utils/bbox\";\nimport { elementsOverlappingBBox } from \"@excalidraw/utils/withinBounds\";\n\nimport type {\n  AppClassProperties,\n  AppState,\n  StaticCanvasAppState,\n} from \"@excalidraw/excalidraw/types\";\n\nimport type { ReadonlySetLike } from \"@excalidraw/common/utility-types\";\n\nimport { getElementsWithinSelection, getSelectedElements } from \"./selection\";\nimport { getElementsInGroup, selectGroupsFromGivenElements } from \"./groups\";\n\nimport {\n  getElementLineSegments,\n  getCommonBounds,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isFrameElement,\n  isFrameLikeElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { ExcalidrawElementsIncludingDeleted } from \"./Scene\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n// --------------------------- Frame State ------------------------------------\nexport const bindElementsToFramesAfterDuplication = (\n  nextElements: readonly ExcalidrawElement[],\n  origElements: readonly ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n) => {\n  const nextElementMap = arrayToMap(nextElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n\n  for (const element of origElements) {\n    if (element.frameId) {\n      // use its frameId to get the new frameId\n      const nextElementId = origIdToDuplicateId.get(element.id);\n      const nextFrameId = origIdToDuplicateId.get(element.frameId);\n      const nextElement = nextElementId && nextElementMap.get(nextElementId);\n      if (nextElement) {\n        mutateElement(nextElement, nextElementMap, {\n          frameId: nextFrameId ?? null,\n        });\n      }\n    }\n  }\n};\n\nexport function isElementIntersectingFrame(\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) {\n  const frameLineSegments = getElementLineSegments(frame, elementsMap);\n\n  const elementLineSegments = getElementLineSegments(element, elementsMap);\n\n  const intersecting = frameLineSegments.some((frameLineSegment) =>\n    elementLineSegments.some((elementLineSegment) =>\n      doLineSegmentsIntersect(frameLineSegment, elementLineSegment),\n    ),\n  );\n\n  return intersecting;\n}\n\nexport const getElementsCompletelyInFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) =>\n  omitGroupsContainingFrameLikes(\n    getElementsWithinSelection(elements, frame, elementsMap, false),\n  ).filter(\n    (element) =>\n      (!isFrameLikeElement(element) && !element.frameId) ||\n      element.frameId === frame.id,\n  );\n\nexport const isElementContainingFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return getElementsWithinSelection([frame], element, elementsMap).some(\n    (e) => e.id === frame.id,\n  );\n};\n\nexport const getElementsIntersectingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  return elements.filter((element) =>\n    isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const elementsAreInFrameBounds = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(\n    frame,\n    elementsMap,\n  );\n\n  const [elementX1, elementY1, elementX2, elementY2] =\n    getCommonBounds(elements);\n\n  return (\n    frameX1 <= elementX1 &&\n    frameY1 <= elementY1 &&\n    frameX2 >= elementX2 &&\n    frameY2 >= elementY2\n  );\n};\n\nexport const elementOverlapsWithFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return (\n    elementsAreInFrameBounds([element], frame, elementsMap) ||\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap)\n  );\n};\n\nexport const isCursorInFrame = (\n  cursorCoords: {\n    x: number;\n    y: number;\n  },\n  frame: NonDeleted<ExcalidrawFrameLikeElement>,\n  elementsMap: ElementsMap,\n) => {\n  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);\n\n  return isPointWithinBounds(\n    pointFrom(fx1, fy1),\n    pointFrom(cursorCoords.x, cursorCoords.y),\n    pointFrom(fx2, fy2),\n  );\n};\n\nexport const groupsAreAtLeastIntersectingTheFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return !!elementsInGroup.find(\n    (element) =>\n      elementsAreInFrameBounds([element], frame, elementsMap) ||\n      isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const groupsAreCompletelyOutOfFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return (\n    elementsInGroup.find(\n      (element) =>\n        elementsAreInFrameBounds([element], frame, elementsMap) ||\n        isElementIntersectingFrame(element, frame, elementsMap),\n    ) === undefined\n  );\n};\n\n// --------------------------- Frame Utils ------------------------------------\n\n/**\n * Returns a map of frameId to frame elements. Includes empty frames.\n */\nexport const groupByFrameLikes = (elements: readonly ExcalidrawElement[]) => {\n  const frameElementsMap = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elements) {\n    const frameId = isFrameLikeElement(element) ? element.id : element.frameId;\n    if (frameId && !frameElementsMap.has(frameId)) {\n      frameElementsMap.set(frameId, getFrameChildren(elements, frameId));\n    }\n  }\n\n  return frameElementsMap;\n};\n\nexport const getFrameChildren = (\n  allElements: ElementsMapOrArray,\n  frameId: string,\n) => {\n  const frameChildren: ExcalidrawElement[] = [];\n  for (const element of allElements.values()) {\n    if (element.frameId === frameId) {\n      frameChildren.push(element);\n    }\n  }\n  return frameChildren;\n};\n\nexport const getFrameLikeElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n): ExcalidrawFrameLikeElement[] => {\n  return allElements.filter((element): element is ExcalidrawFrameLikeElement =>\n    isFrameLikeElement(element),\n  );\n};\n\n/**\n * Returns ExcalidrawFrameElements and non-frame-children elements.\n *\n * Considers children as root elements if they point to a frame parent\n * non-existing in the elements set.\n *\n * Considers non-frame bound elements (container or arrow labels) as root.\n */\nexport const getRootElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n) => {\n  const frameElements = arrayToMap(getFrameLikeElements(allElements));\n  return allElements.filter(\n    (element) =>\n      frameElements.has(element.id) ||\n      !element.frameId ||\n      !frameElements.has(element.frameId),\n  );\n};\n\nexport const getElementsInResizingFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n): ExcalidrawElement[] => {\n  const prevElementsInFrame = getFrameChildren(allElements, frame.id);\n  const nextElementsInFrame = new Set<ExcalidrawElement>(prevElementsInFrame);\n\n  const elementsCompletelyInFrame = new Set([\n    ...getElementsCompletelyInFrame(allElements, frame, elementsMap),\n    ...prevElementsInFrame.filter((element) =>\n      isElementContainingFrame(element, frame, elementsMap),\n    ),\n  ]);\n\n  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(\n    (element) => !elementsCompletelyInFrame.has(element),\n  );\n\n  // for elements that are completely in the frame\n  // if they are part of some groups, then those groups are still\n  // considered to belong to the frame\n  const groupsToKeep = new Set<string>(\n    Array.from(elementsCompletelyInFrame).flatMap(\n      (element) => element.groupIds,\n    ),\n  );\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (!isElementIntersectingFrame(element, frame, elementsMap)) {\n      if (element.groupIds.length === 0) {\n        nextElementsInFrame.delete(element);\n      }\n    } else if (element.groupIds.length > 0) {\n      // group element intersects with the frame, we should keep the groups\n      // that this element is part of\n      for (const id of element.groupIds) {\n        groupsToKeep.add(id);\n      }\n    }\n  }\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (element.groupIds.length > 0) {\n      let shouldRemoveElement = true;\n\n      for (const id of element.groupIds) {\n        if (groupsToKeep.has(id)) {\n          shouldRemoveElement = false;\n        }\n      }\n\n      if (shouldRemoveElement) {\n        nextElementsInFrame.delete(element);\n      }\n    }\n  }\n\n  const individualElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length === 0);\n\n  for (const element of individualElementsCompletelyInFrame) {\n    nextElementsInFrame.add(element);\n  }\n\n  const newGroupElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length > 0);\n\n  const groupIds = selectGroupsFromGivenElements(\n    newGroupElementsCompletelyInFrame,\n    appState,\n  );\n\n  // new group elements\n  for (const [id, isSelected] of Object.entries(groupIds)) {\n    if (isSelected) {\n      const elementsInGroup = getElementsInGroup(allElements, id);\n\n      if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {\n        for (const element of elementsInGroup) {\n          nextElementsInFrame.add(element);\n        }\n      }\n    }\n  }\n\n  return [...nextElementsInFrame].filter((element) => {\n    return !(isTextElement(element) && element.containerId);\n  });\n};\n\nexport const getElementsInNewFrame = (\n  elements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return omitPartialGroups(\n    omitGroupsContainingFrameLikes(\n      elements,\n      getElementsCompletelyInFrame(elements, frame, elementsMap),\n    ),\n    frame,\n    elementsMap,\n  );\n};\n\nexport const omitPartialGroups = (\n  elements: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  allElementsMap: ElementsMap,\n) => {\n  const elementsToReturn = [];\n  const checkedGroups = new Map<string, boolean>();\n\n  for (const element of elements) {\n    let shouldOmit = false;\n    if (element.groupIds.length > 0) {\n      // if some partial group should be omitted, then all elements in that group should be omitted\n      if (element.groupIds.some((gid) => checkedGroups.get(gid))) {\n        shouldOmit = true;\n      } else {\n        const allElementsInGroup = new Set(\n          element.groupIds.flatMap((gid) =>\n            getElementsInGroup(allElementsMap, gid),\n          ),\n        );\n\n        shouldOmit = !elementsAreInFrameBounds(\n          Array.from(allElementsInGroup),\n          frame,\n          allElementsMap,\n        );\n      }\n\n      element.groupIds.forEach((gid) => {\n        checkedGroups.set(gid, shouldOmit);\n      });\n    }\n\n    if (!shouldOmit) {\n      elementsToReturn.push(element);\n    }\n  }\n\n  return elementsToReturn;\n};\n\nexport const getContainingFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (!element.frameId) {\n    return null;\n  }\n  return (elementsMap.get(element.frameId) ||\n    null) as null | ExcalidrawFrameLikeElement;\n};\n\n// --------------------------- Frame Operations -------------------------------\n\n/** */\nexport const filterElementsEligibleAsFrameChildren = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n  const elementsMap = arrayToMap(elements);\n  elements = omitGroupsContainingFrameLikes(elements);\n\n  for (const element of elements) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  const processedGroups = new Set<ExcalidrawElement[\"id\"]>();\n\n  const eligibleElements: ExcalidrawElement[] = [];\n\n  for (const element of elements) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    if (element.groupIds.length) {\n      const shallowestGroupId = element.groupIds.at(-1)!;\n      if (!processedGroups.has(shallowestGroupId)) {\n        processedGroups.add(shallowestGroupId);\n        const groupElements = getElementsInGroup(elements, shallowestGroupId);\n        if (\n          groupElements.some((el) =>\n            elementOverlapsWithFrame(el, frame, elementsMap),\n          )\n        ) {\n          for (const child of groupElements) {\n            eligibleElements.push(child);\n          }\n        }\n      }\n    } else {\n      const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);\n      if (overlaps) {\n        eligibleElements.push(element);\n      }\n    }\n  }\n\n  return eligibleElements;\n};\n\n/**\n * Retains (or repairs for target frame) the ordering invriant where children\n * elements come right before the parent frame:\n * [el, el, child, child, frame, el]\n *\n * @returns mutated allElements (same data structure)\n */\nexport const addElementsToFrame = <T extends ElementsMapOrArray>(\n  allElements: T,\n  elementsToAdd: NonDeletedExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n): T => {\n  const elementsMap = arrayToMap(allElements);\n  const currTargetFrameChildrenMap = new Map<ExcalidrawElement[\"id\"], true>();\n  for (const element of allElements.values()) {\n    if (element.frameId === frame.id) {\n      currTargetFrameChildrenMap.set(element.id, true);\n    }\n  }\n\n  const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));\n\n  const finalElementsToAdd: ExcalidrawElement[] = [];\n\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n\n  for (const element of elementsToAdd) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  // - add bound text elements if not already in the array\n  // - filter out elements that are already in the frame\n  for (const element of omitGroupsContainingFrameLikes(\n    allElements,\n    elementsToAdd,\n  )) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    // if the element is already in another frame (which is also in elementsToAdd),\n    // it means that frame and children are selected at the same time\n    // => keep original frame membership, do not add to the target frame\n    if (\n      element.frameId &&\n      appState.selectedElementIds[element.id] &&\n      appState.selectedElementIds[element.frameId]\n    ) {\n      continue;\n    }\n\n    if (!currTargetFrameChildrenMap.has(element.id)) {\n      finalElementsToAdd.push(element);\n    }\n\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (\n      boundTextElement &&\n      !suppliedElementsToAddSet.has(boundTextElement.id) &&\n      !currTargetFrameChildrenMap.has(boundTextElement.id)\n    ) {\n      finalElementsToAdd.push(boundTextElement);\n    }\n  }\n\n  for (const element of finalElementsToAdd) {\n    mutateElement(element, elementsMap, {\n      frameId: frame.id,\n    });\n  }\n\n  return allElements;\n};\n\nexport const removeElementsFromFrame = (\n  elementsToRemove: ReadonlySetLike<NonDeletedExcalidrawElement>,\n  elementsMap: ElementsMap,\n) => {\n  const _elementsToRemove = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >();\n\n  const toRemoveElementsByFrame = new Map<\n    ExcalidrawFrameLikeElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elementsToRemove) {\n    if (element.frameId) {\n      _elementsToRemove.set(element.id, element);\n\n      const arr = toRemoveElementsByFrame.get(element.frameId) || [];\n      arr.push(element);\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        _elementsToRemove.set(boundTextElement.id, boundTextElement);\n        arr.push(boundTextElement);\n      }\n\n      toRemoveElementsByFrame.set(element.frameId, arr);\n    }\n  }\n\n  for (const [, element] of _elementsToRemove) {\n    mutateElement(element, elementsMap, {\n      frameId: null,\n    });\n  }\n};\n\nexport const removeAllElementsFromFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsInFrame = getFrameChildren(allElements, frame.id);\n  removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));\n  return allElements;\n};\n\nexport const replaceAllElementsInFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  nextElementsInFrame: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  app: AppClassProperties,\n): T[] => {\n  return addElementsToFrame(\n    removeAllElementsFromFrame(allElements, frame),\n    nextElementsInFrame,\n    frame,\n    app.state,\n  ).slice();\n};\n\n/** does not mutate elements, but returns new ones */\nexport const updateFrameMembershipOfSelectedElements = <\n  T extends ElementsMapOrArray,\n>(\n  allElements: T,\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements: allElements,\n  });\n  const elementsToFilter = new Set<ExcalidrawElement>(selectedElements);\n\n  if (appState.editingGroupId) {\n    for (const element of selectedElements) {\n      if (element.groupIds.length === 0) {\n        elementsToFilter.add(element);\n      } else {\n        element.groupIds\n          .flatMap((gid) => getElementsInGroup(allElements, gid))\n          .forEach((element) => elementsToFilter.add(element));\n      }\n    }\n  }\n\n  const elementsToRemove = new Set<ExcalidrawElement>();\n\n  const elementsMap = arrayToMap(allElements);\n\n  elementsToFilter.forEach((element) => {\n    if (\n      element.frameId &&\n      !isFrameLikeElement(element) &&\n      !isElementInFrame(element, elementsMap, appState)\n    ) {\n      elementsToRemove.add(element);\n    }\n  });\n\n  if (elementsToRemove.size > 0) {\n    removeElementsFromFrame(elementsToRemove, elementsMap);\n  }\n  return allElements;\n};\n\n/**\n * filters out elements that are inside groups that contain a frame element\n * anywhere in the group tree\n */\nexport const omitGroupsContainingFrameLikes = (\n  allElements: ElementsMapOrArray,\n  /** subset of elements you want to filter. Optional perf optimization so we\n   * don't have to filter all elements unnecessarily\n   */\n  selectedElements?: readonly ExcalidrawElement[],\n) => {\n  const uniqueGroupIds = new Set<string>();\n  const elements = selectedElements || allElements;\n\n  for (const el of elements.values()) {\n    const topMostGroupId = el.groupIds[el.groupIds.length - 1];\n    if (topMostGroupId) {\n      uniqueGroupIds.add(topMostGroupId);\n    }\n  }\n\n  const rejectedGroupIds = new Set<string>();\n  for (const groupId of uniqueGroupIds) {\n    if (\n      getElementsInGroup(allElements, groupId).some((el) =>\n        isFrameLikeElement(el),\n      )\n    ) {\n      rejectedGroupIds.add(groupId);\n    }\n  }\n\n  const ret: ExcalidrawElement[] = [];\n\n  for (const element of elements.values()) {\n    if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {\n      ret.push(element);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * depending on the appState, return target frame, which is the frame the given element\n * is going to be added to or remove from\n */\nexport const getTargetFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n) => {\n  const _element = isTextElement(element)\n    ? getContainerElement(element, elementsMap) || element\n    : element;\n\n  // if the element and its containing frame are both selected, then\n  // the containing frame is the target frame\n  if (\n    _element.frameId &&\n    appState.selectedElementIds[_element.id] &&\n    appState.selectedElementIds[_element.frameId]\n  ) {\n    return getContainingFrame(_element, elementsMap);\n  }\n\n  return appState.selectedElementIds[_element.id] &&\n    appState.selectedElementsAreBeingDragged\n    ? appState.frameToHighlight\n    : getContainingFrame(_element, elementsMap);\n};\n\n// TODO: this a huge bottleneck for large scenes, optimise\n// given an element, return if the element is in some frame\nexport const isElementInFrame = (\n  element: ExcalidrawElement,\n  allElementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n  opts?: {\n    targetFrame?: ExcalidrawFrameLikeElement;\n    checkedGroups?: Map<string, boolean>;\n  },\n) => {\n  const frame =\n    opts?.targetFrame ?? getTargetFrame(element, allElementsMap, appState);\n\n  if (!frame) {\n    return false;\n  }\n\n  const _element = isTextElement(element)\n    ? getContainerElement(element, allElementsMap) || element\n    : element;\n\n  const setGroupsInFrame = (isInFrame: boolean) => {\n    if (opts?.checkedGroups) {\n      _element.groupIds.forEach((groupId) => {\n        opts.checkedGroups?.set(groupId, isInFrame);\n      });\n    }\n  };\n\n  if (\n    // if the element is not selected, or it is selected but not being dragged,\n    // frame membership won't update, so return true\n    !appState.selectedElementIds[_element.id] ||\n    !appState.selectedElementsAreBeingDragged ||\n    // if both frame and element are selected, won't update membership, so return true\n    (appState.selectedElementIds[_element.id] &&\n      appState.selectedElementIds[frame.id])\n  ) {\n    return true;\n  }\n\n  if (_element.groupIds.length === 0) {\n    return elementOverlapsWithFrame(_element, frame, allElementsMap);\n  }\n\n  for (const gid of _element.groupIds) {\n    if (opts?.checkedGroups?.has(gid)) {\n      return opts.checkedGroups.get(gid)!!;\n    }\n  }\n\n  const allElementsInGroup = new Set(\n    _element.groupIds\n      .filter((gid) => {\n        if (opts?.checkedGroups) {\n          return !opts.checkedGroups.has(gid);\n        }\n        return true;\n      })\n      .flatMap((gid) => getElementsInGroup(allElementsMap, gid)),\n  );\n\n  if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {\n    const selectedElements = new Set(\n      getSelectedElements(allElementsMap, appState),\n    );\n\n    const editingGroupOverlapsFrame = appState.frameToHighlight !== null;\n\n    if (editingGroupOverlapsFrame) {\n      return true;\n    }\n\n    selectedElements.forEach((selectedElement) => {\n      allElementsInGroup.delete(selectedElement);\n    });\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (isFrameLikeElement(elementInGroup)) {\n      setGroupsInFrame(false);\n      return false;\n    }\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {\n      setGroupsInFrame(true);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const shouldApplyFrameClip = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  appState: StaticCanvasAppState,\n  elementsMap: ElementsMap,\n  checkedGroups?: Map<string, boolean>,\n) => {\n  if (!appState.frameRendering || !appState.frameRendering.clip) {\n    return false;\n  }\n\n  // for individual elements, only clip when the element is\n  // a. overlapping with the frame, or\n  // b. containing the frame, for example when an element is used as a background\n  //    and is therefore bigger than the frame and completely contains the frame\n  const shouldClipElementItself =\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap);\n\n  if (shouldClipElementItself) {\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, true);\n    }\n\n    return true;\n  }\n\n  // if an element is outside the frame, but is part of a group that has some elements\n  // \"in\" the frame, we should clip the element\n  if (\n    !shouldClipElementItself &&\n    element.groupIds.length > 0 &&\n    !elementsAreInFrameBounds([element], frame, elementsMap)\n  ) {\n    let shouldClip = false;\n\n    // if no elements are being dragged, we can skip the geometry check\n    // because we know if the element is in the given frame or not\n    if (!appState.selectedElementsAreBeingDragged) {\n      shouldClip = element.frameId === frame.id;\n      for (const groupId of element.groupIds) {\n        checkedGroups?.set(groupId, shouldClip);\n      }\n    } else {\n      shouldClip = isElementInFrame(element, elementsMap, appState, {\n        targetFrame: frame,\n        checkedGroups,\n      });\n    }\n\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, shouldClip);\n    }\n\n    return shouldClip;\n  }\n\n  return false;\n};\n\nconst DEFAULT_FRAME_NAME = \"Frame\";\nconst DEFAULT_AI_FRAME_NAME = \"AI Frame\";\n\nexport const getDefaultFrameName = (element: ExcalidrawFrameLikeElement) => {\n  // TODO name frames \"AI\" only if specific to AI frames\n  return isFrameElement(element) ? DEFAULT_FRAME_NAME : DEFAULT_AI_FRAME_NAME;\n};\n\nexport const getFrameLikeTitle = (element: ExcalidrawFrameLikeElement) => {\n  return element.name === null ? getDefaultFrameName(element) : element.name;\n};\n\nexport const getElementsOverlappingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  return (\n    elementsOverlappingBBox({\n      elements,\n      bounds: frame,\n      type: \"overlap\",\n    })\n      // removes elements who are overlapping, but are in a different frame,\n      // and thus invisible in target frame\n      .filter((el) => !el.frameId || el.frameId === frame.id)\n  );\n};\n\nexport const frameAndChildrenSelectedTogether = (\n  selectedElements: readonly ExcalidrawElement[],\n) => {\n  const selectedElementsMap = arrayToMap(selectedElements);\n\n  return (\n    selectedElements.length > 1 &&\n    selectedElements.some(\n      (element) => element.frameId && selectedElementsMap.has(element.frameId),\n    )\n  );\n};\n", "import {\n  vectorCross,\n  vectorFromPoint,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/common\";\n\nexport type LineSegment<P extends LocalPoint | GlobalPoint> = [P, P];\n\nexport function getBBox<P extends LocalPoint | GlobalPoint>(\n  line: LineSegment<P>,\n): Bounds {\n  return [\n    Math.min(line[0][0], line[1][0]),\n    Math.min(line[0][1], line[1][1]),\n    Math.max(line[0][0], line[1][0]),\n    Math.max(line[0][1], line[1][1]),\n  ];\n}\n\nexport function doBBoxesIntersect(a: Bounds, b: Bounds) {\n  return a[0] <= b[2] && a[2] >= b[0] && a[1] <= b[3] && a[3] >= b[1];\n}\n\nconst EPSILON = 0.000001;\n\nexport function isPointOnLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  const r = vectorCross(p1, p2);\n\n  return Math.abs(r) < EPSILON;\n}\n\nexport function isPointRightOfLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  return vectorCross(p1, p2) < 0;\n}\n\nexport function isLineSegmentTouchingOrCrossingLine<\n  P extends GlobalPoint | LocalPoint,\n>(a: LineSegment<P>, b: LineSegment<P>) {\n  return (\n    isPointOnLine(a, b[0]) ||\n    isPointOnLine(a, b[1]) ||\n    (isPointRightOfLine(a, b[0])\n      ? !isPointRightOfLine(a, b[1])\n      : isPointRightOfLine(a, b[1]))\n  );\n}\n\n// https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/\nexport function doLineSegmentsIntersect<P extends GlobalPoint | LocalPoint>(\n  a: LineSegment<P>,\n  b: LineSegment<P>,\n) {\n  return (\n    doBBoxesIntersect(getBBox(a), getBBox(b)) &&\n    isLineSegmentTouchingOrCrossingLine(a, b) &&\n    isLineSegmentTouchingOrCrossingLine(b, a)\n  );\n}\n", "import { arrayToMap, type Bounds } from \"@excalidraw/common\";\nimport { getElementBounds } from \"@excalidraw/element\";\nimport {\n  isArrowElement,\n  isExcalidrawElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"@excalidraw/element\";\nimport {\n  rangeIncludesValue,\n  pointFrom,\n  pointRotateRads,\n  rangeInclusive,\n} from \"@excalidraw/math\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\nimport type { LocalPoint } from \"@excalidraw/math\";\n\ntype Element = NonDeletedExcalidrawElement;\ntype Elements = readonly NonDeletedExcalidrawElement[];\n\ntype Points = readonly LocalPoint[];\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getNonLinearElementRelativePoints = (\n  element: Exclude<\n    Element,\n    ExcalidrawLinearElement | ExcalidrawFreeDrawElement\n  >,\n): [\n  TopLeft: LocalPoint,\n  TopRight: LocalPoint,\n  BottomRight: LocalPoint,\n  BottomLeft: LocalPoint,\n] => {\n  if (element.type === \"diamond\") {\n    return [\n      pointFrom(element.width / 2, 0),\n      pointFrom(element.width, element.height / 2),\n      pointFrom(element.width / 2, element.height),\n      pointFrom(0, element.height / 2),\n    ];\n  }\n  return [\n    pointFrom(0, 0),\n    pointFrom(0 + element.width, 0),\n    pointFrom(0 + element.width, element.height),\n    pointFrom(0, element.height),\n  ];\n};\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getElementRelativePoints = (element: ExcalidrawElement): Points => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points;\n  }\n  return getNonLinearElementRelativePoints(element);\n};\n\nconst getMinMaxPoints = (points: Points) => {\n  const ret = points.reduce(\n    (limits, [x, y]) => {\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n\n      return limits;\n    },\n    {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity,\n      cx: 0,\n      cy: 0,\n    },\n  );\n\n  ret.cx = (ret.maxX + ret.minX) / 2;\n  ret.cy = (ret.maxY + ret.minY) / 2;\n\n  return ret;\n};\n\nconst getRotatedBBox = (element: Element): Bounds => {\n  const points = getElementRelativePoints(element);\n\n  const { cx, cy } = getMinMaxPoints(points);\n  const centerPoint = pointFrom<LocalPoint>(cx, cy);\n\n  const rotatedPoints = points.map((p) =>\n    pointRotateRads(p, centerPoint, element.angle),\n  );\n  const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const isElementInsideBBox = (\n  element: Element,\n  bbox: Bounds,\n  eitherDirection = false,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  const elementInsideBbox =\n    bbox[0] <= elementBBox[0] &&\n    bbox[2] >= elementBBox[2] &&\n    bbox[1] <= elementBBox[1] &&\n    bbox[3] >= elementBBox[3];\n\n  if (!eitherDirection) {\n    return elementInsideBbox;\n  }\n\n  if (elementInsideBbox) {\n    return true;\n  }\n\n  return (\n    elementBBox[0] <= bbox[0] &&\n    elementBBox[2] >= bbox[2] &&\n    elementBBox[1] <= bbox[1] &&\n    elementBBox[3] >= bbox[3]\n  );\n};\n\nexport const elementPartiallyOverlapsWithOrContainsBBox = (\n  element: Element,\n  bbox: Bounds,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  return (\n    (rangeIncludesValue(elementBBox[0], rangeInclusive(bbox[0], bbox[2])) ||\n      rangeIncludesValue(\n        bbox[0],\n        rangeInclusive(elementBBox[0], elementBBox[2]),\n      )) &&\n    (rangeIncludesValue(elementBBox[1], rangeInclusive(bbox[1], bbox[3])) ||\n      rangeIncludesValue(\n        bbox[1],\n        rangeInclusive(elementBBox[1], elementBBox[3]),\n      ))\n  );\n};\n\nexport const elementsOverlappingBBox = ({\n  elements,\n  bounds,\n  type,\n  errorMargin = 0,\n}: {\n  elements: Elements;\n  bounds: Bounds | ExcalidrawElement;\n  /** safety offset. Defaults to 0. */\n  errorMargin?: number;\n  /**\n   * - overlap: elements overlapping or inside bounds\n   * - contain: elements inside bounds or bounds inside elements\n   * - inside: elements inside bounds\n   **/\n  type: \"overlap\" | \"contain\" | \"inside\";\n}) => {\n  if (isExcalidrawElement(bounds)) {\n    bounds = getElementBounds(bounds, arrayToMap(elements));\n  }\n  const adjustedBBox: Bounds = [\n    bounds[0] - errorMargin,\n    bounds[1] - errorMargin,\n    bounds[2] + errorMargin,\n    bounds[3] + errorMargin,\n  ];\n\n  const includedElementSet = new Set<string>();\n\n  for (const element of elements) {\n    if (includedElementSet.has(element.id)) {\n      continue;\n    }\n\n    const isOverlaping =\n      type === \"overlap\"\n        ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox)\n        : type === \"inside\"\n        ? isElementInsideBBox(element, adjustedBBox)\n        : isElementInsideBBox(element, adjustedBBox, true);\n\n    if (isOverlaping) {\n      includedElementSet.add(element.id);\n\n      if (element.boundElements) {\n        for (const boundElement of element.boundElements) {\n          includedElementSet.add(boundElement.id);\n        }\n      }\n\n      if (isTextElement(element) && element.containerId) {\n        includedElementSet.add(element.containerId);\n      }\n\n      if (isArrowElement(element)) {\n        if (element.startBinding) {\n          includedElementSet.add(element.startBinding.elementId);\n        }\n\n        if (element.endBinding) {\n          includedElementSet.add(element.endBinding?.elementId);\n        }\n      }\n    }\n  }\n\n  return elements.filter((element) => includedElementSet.has(element.id));\n};\n", "import { arrayToMap, isShallowEqual } from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  InteractiveCanvasAppState,\n} from \"@excalidraw/excalidraw/types\";\n\nimport { getElementAbsoluteCoords, getElementBounds } from \"./bounds\";\nimport { isElementInViewport } from \"./sizeHelpers\";\nimport {\n  isBoundToContainer,\n  isFrameLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getContainingFrame,\n  getFrameChildren,\n} from \"./frame\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { selectGroupsForSelectedElements } from \"./groups\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = <\n  T extends ExcalidrawElement,\n>(\n  selectedElements: readonly T[],\n) => {\n  const framesInSelection = new Set<T[\"id\"]>();\n\n  selectedElements.forEach((element) => {\n    if (isFrameLikeElement(element)) {\n      framesInSelection.add(element.id);\n    }\n  });\n\n  return selectedElements.filter((element) => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  excludeElementsInFrames: boolean = true,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection, elementsMap);\n\n  let elementsInSelection = elements.filter((element) => {\n    let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n      elementsMap,\n    );\n\n    const containingFrame = getContainingFrame(element, elementsMap);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(\n        containingFrame,\n        elementsMap,\n      );\n\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n\n    return (\n      element.locked === false &&\n      element.type !== \"selection\" &&\n      !isBoundToContainer(element) &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n\n  elementsInSelection = excludeElementsInFrames\n    ? excludeElementsInFramesFromSelection(elementsInSelection)\n    : elementsInSelection;\n\n  elementsInSelection = elementsInSelection.filter((element) => {\n    const containingFrame = getContainingFrame(element, elementsMap);\n\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame, elementsMap);\n    }\n\n    return true;\n  });\n\n  return elementsInSelection;\n};\n\nexport const getVisibleAndNonSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const selectedElementsSet = new Set(\n    selectedElements.map((element) => element.id),\n  );\n  return elements.filter((element) => {\n    const isVisible = isElementInViewport(\n      element,\n      appState.width,\n      appState.height,\n      appState,\n      elementsMap,\n    );\n\n    return !selectedElementsSet.has(element.id) && isVisible;\n  });\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = (function () {\n  let lastElements: readonly NonDeletedExcalidrawElement[] | null = null;\n  let lastSelectedElementIds: AppState[\"selectedElementIds\"] | null = null;\n  let isSelected: boolean | null = null;\n\n  const ret = (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: Pick<AppState, \"selectedElementIds\">,\n  ): boolean => {\n    if (\n      isSelected != null &&\n      elements === lastElements &&\n      appState.selectedElementIds === lastSelectedElementIds\n    ) {\n      return isSelected;\n    }\n\n    isSelected = elements.some(\n      (element) => appState.selectedElementIds[element.id],\n    );\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n\n    return isSelected;\n  };\n\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n\n  return ret;\n})();\n\nexport const getSelectedElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<InteractiveCanvasAppState, \"selectedElementIds\">,\n  opts?: {\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  },\n) => {\n  const addedElements = new Set<ExcalidrawElement[\"id\"]>();\n  const selectedElements: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (appState.selectedElementIds[element.id]) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n    if (\n      opts?.includeBoundTextElement &&\n      isBoundToContainer(element) &&\n      appState.selectedElementIds[element?.containerId]\n    ) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n  }\n\n  if (opts?.includeElementsInFrames) {\n    const elementsToInclude: ExcalidrawElement[] = [];\n    selectedElements.forEach((element) => {\n      if (isFrameLikeElement(element)) {\n        getFrameChildren(elements, element.id).forEach(\n          (e) => !addedElements.has(e.id) && elementsToInclude.push(e),\n        );\n      }\n      elementsToInclude.push(element);\n    });\n\n    return elementsToInclude;\n  }\n\n  return selectedElements;\n};\n\nexport const getTargetElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<\n    AppState,\n    \"selectedElementIds\" | \"editingTextElement\" | \"newElement\"\n  >,\n) =>\n  appState.editingTextElement\n    ? [appState.editingTextElement]\n    : appState.newElement\n    ? [appState.newElement]\n    : getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      });\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (\n  nextSelectedElementIds: AppState[\"selectedElementIds\"],\n  prevState: Pick<AppState, \"selectedElementIds\">,\n) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n\n  return nextSelectedElementIds;\n};\n\nconst _getLinearElementEditor = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n) => {\n  const linears = targetElements.filter(isLinearElement);\n  if (linears.length === 1) {\n    const linear = linears[0];\n    const boundElements = linear.boundElements?.map((def) => def.id) ?? [];\n    const onlySingleLinearSelected = targetElements.every(\n      (el) => el.id === linear.id || boundElements.includes(el.id),\n    );\n\n    if (onlySingleLinearSelected) {\n      return new LinearElementEditor(linear, arrayToMap(allElements));\n    }\n  }\n\n  return null;\n};\n\nexport const getSelectionStateForElements = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    selectedLinearElement: _getLinearElementEditor(targetElements, allElements),\n    ...selectGroupsForSelectedElements(\n      {\n        editingGroupId: appState.editingGroupId,\n        selectedElementIds: excludeElementsInFramesFromSelection(\n          targetElements,\n        ).reduce((acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n          if (!isBoundToContainer(element)) {\n            acc[element.id] = true;\n          }\n          return acc;\n        }, {}),\n      },\n      allElements,\n      appState,\n      null,\n    ),\n  };\n};\n", "import type {\n  AppClassProperties,\n  AppState,\n  InteractiveCanvasAppState,\n} from \"@excalidraw/excalidraw/types\";\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { isBoundToContainer } from \"./typeChecks\";\n\nimport { makeNextSelectedElementIds, getSelectedElements } from \"./selection\";\n\nimport type {\n  GroupId,\n  ExcalidrawElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  ElementsMapOrArray,\n  ElementsMap,\n} from \"./types\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: InteractiveCanvasAppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): Pick<\n  InteractiveCanvasAppState,\n  \"selectedGroupIds\" | \"selectedElementIds\" | \"editingGroupId\"\n> => {\n  const elementsInGroup = elements.reduce(\n    (acc: Record<string, true>, element) => {\n      if (element.groupIds.includes(groupId)) {\n        acc[element.id] = true;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  if (Object.keys(elementsInGroup).length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        selectedElementIds: appState.selectedElementIds,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    editingGroupId: appState.editingGroupId,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...elementsInGroup,\n    },\n  };\n};\n\nexport const selectGroupsForSelectedElements = (function () {\n  type SelectGroupsReturnType = Pick<\n    InteractiveCanvasAppState,\n    \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n  >;\n\n  let lastSelectedElements: readonly NonDeleted<ExcalidrawElement>[] | null =\n    null;\n  let lastElements: readonly NonDeleted<ExcalidrawElement>[] | null = null;\n  let lastReturnValue: SelectGroupsReturnType | null = null;\n\n  const _selectGroups = (\n    selectedElements: readonly NonDeleted<ExcalidrawElement>[],\n    elements: readonly NonDeleted<ExcalidrawElement>[],\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    prevAppState: InteractiveCanvasAppState,\n  ): SelectGroupsReturnType => {\n    if (\n      lastReturnValue !== undefined &&\n      elements === lastElements &&\n      selectedElements === lastSelectedElements &&\n      appState.editingGroupId === lastReturnValue?.editingGroupId\n    ) {\n      return lastReturnValue;\n    }\n\n    const selectedGroupIds: Record<GroupId, boolean> = {};\n    // Gather all the groups withing selected elements\n    for (const selectedElement of selectedElements) {\n      let groupIds = selectedElement.groupIds;\n      if (appState.editingGroupId) {\n        // handle the case where a group is nested within a group\n        const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n        if (indexOfEditingGroup > -1) {\n          groupIds = groupIds.slice(0, indexOfEditingGroup);\n        }\n      }\n      if (groupIds.length > 0) {\n        const lastSelectedGroup = groupIds[groupIds.length - 1];\n        selectedGroupIds[lastSelectedGroup] = true;\n      }\n    }\n\n    // Gather all the elements within selected groups\n    const groupElementsIndex: Record<GroupId, string[]> = {};\n    const selectedElementIdsInGroups = elements.reduce(\n      (acc: Record<string, true>, element) => {\n        if (element.isDeleted) {\n          return acc;\n        }\n\n        const groupId = element.groupIds.find((id) => selectedGroupIds[id]);\n\n        if (groupId) {\n          acc[element.id] = true;\n\n          // Populate the index\n          if (!Array.isArray(groupElementsIndex[groupId])) {\n            groupElementsIndex[groupId] = [element.id];\n          } else {\n            groupElementsIndex[groupId].push(element.id);\n          }\n        }\n        return acc;\n      },\n      {},\n    );\n\n    for (const groupId of Object.keys(groupElementsIndex)) {\n      // If there is one element in the group, and the group is selected or it's being edited, it's not a group\n      if (groupElementsIndex[groupId].length < 2) {\n        if (selectedGroupIds[groupId]) {\n          selectedGroupIds[groupId] = false;\n        }\n      }\n    }\n\n    lastElements = elements;\n    lastSelectedElements = selectedElements;\n\n    lastReturnValue = {\n      editingGroupId: appState.editingGroupId,\n      selectedGroupIds,\n      selectedElementIds: makeNextSelectedElementIds(\n        {\n          ...appState.selectedElementIds,\n          ...selectedElementIdsInGroups,\n        },\n        prevAppState,\n      ),\n    };\n\n    return lastReturnValue;\n  };\n\n  /**\n   * When you select an element, you often want to actually select the whole group it's in, unless\n   * you're currently editing that group.\n   */\n  const selectGroupsForSelectedElements = (\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    elements: readonly NonDeletedExcalidrawElement[],\n    prevAppState: InteractiveCanvasAppState,\n    /**\n     * supply null in cases where you don't have access to App instance and\n     * you don't care about optimizing selectElements retrieval\n     */\n    app: AppClassProperties | null,\n  ): Mutable<\n    Pick<\n      InteractiveCanvasAppState,\n      \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n    >\n  > => {\n    const selectedElements = app\n      ? app.scene.getSelectedElements({\n          selectedElementIds: appState.selectedElementIds,\n          // supplying elements explicitly in case we're passed non-state elements\n          elements,\n        })\n      : getSelectedElements(elements, appState);\n\n    if (!selectedElements.length) {\n      return {\n        selectedGroupIds: {},\n        editingGroupId: null,\n        selectedElementIds: makeNextSelectedElementIds(\n          appState.selectedElementIds,\n          prevAppState,\n        ),\n      };\n    }\n\n    return _selectGroups(selectedElements, elements, appState, prevAppState);\n  };\n\n  selectGroupsForSelectedElements.clearCache = () => {\n    lastElements = null;\n    lastSelectedElements = null;\n    lastReturnValue = null;\n  };\n\n  return selectGroupsForSelectedElements;\n})();\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: InteractiveCanvasAppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: Pick<\n    InteractiveCanvasAppState,\n    \"editingGroupId\" | \"selectedGroupIds\"\n  >,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (\n  appState: InteractiveCanvasAppState,\n): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n// given a list of elements, return the the actual group ids that should be selected\n// or used to update the elements\nexport const selectGroupsFromGivenElements = (\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n  appState: InteractiveCanvasAppState,\n) => {\n  let nextAppState: InteractiveCanvasAppState = {\n    ...appState,\n    selectedGroupIds: {},\n  };\n\n  for (const element of elements) {\n    let groupIds = element.groupIds;\n    if (appState.editingGroupId) {\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = {\n        ...nextAppState,\n        ...selectGroup(groupId, nextAppState, elements),\n      };\n    }\n  }\n\n  return nextAppState.selectedGroupIds;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: ElementsMapOrArray,\n  groupId: string,\n) => {\n  const elementsInGroup: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (isElementInGroup(element, groupId)) {\n      elementsInGroup.push(element);\n    }\n  }\n  return elementsInGroup;\n};\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    // Include bound text if present when grouping\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nexport const getNonDeletedGroupIds = (elements: ElementsMap) => {\n  const nonDeletedGroupIds = new Set<string>();\n\n  for (const [, element] of elements) {\n    // defensive check\n    if (element.isDeleted) {\n      continue;\n    }\n\n    // defensive fallback\n    for (const groupId of element.groupIds ?? []) {\n      nonDeletedGroupIds.add(groupId);\n    }\n  }\n\n  return nonDeletedGroupIds;\n};\n\nexport const elementsAreInSameGroup = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const allGroups = elements.flatMap((element) => element.groupIds);\n  const groupCount = new Map<string, number>();\n  let maxGroup = 0;\n\n  for (const group of allGroups) {\n    groupCount.set(group, (groupCount.get(group) ?? 0) + 1);\n    if (groupCount.get(group)! > maxGroup) {\n      maxGroup = groupCount.get(group)!;\n    }\n  }\n\n  return maxGroup === elements.length;\n};\n\nexport const isInGroup = (element: NonDeletedExcalidrawElement) => {\n  return element.groupIds.length > 0;\n};\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\n// given a list of selected elements, return the element grouped by their immediate group selected state\n// in the case if only one group is selected and all elements selected are within the group, it will respect group hierarchy in accordance to their nested grouping order\nexport const getSelectedElementsByGroup = (\n  selectedElements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n  appState: Readonly<AppState>,\n): ExcalidrawElement[][] => {\n  const selectedGroupIds = getSelectedGroupIds(appState);\n  const unboundElements = selectedElements.filter(\n    (element) => !isBoundToContainer(element),\n  );\n  const groups: Map<string, ExcalidrawElement[]> = new Map();\n  const elements: Map<string, ExcalidrawElement[]> = new Map();\n\n  // helper function to add an element to the elements map\n  const addToElementsMap = (element: ExcalidrawElement) => {\n    // elements\n    const currentElementMembers = elements.get(element.id) || [];\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n\n    if (boundTextElement) {\n      currentElementMembers.push(boundTextElement);\n    }\n    elements.set(element.id, [...currentElementMembers, element]);\n  };\n\n  // helper function to add an element to the groups map\n  const addToGroupsMap = (element: ExcalidrawElement, groupId: string) => {\n    // groups\n    const currentGroupMembers = groups.get(groupId) || [];\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  };\n\n  // helper function to handle the case where a single group is selected\n  // and all elements selected are within the group, it will respect group hierarchy in accordance to\n  // their nested grouping order\n  const handleSingleSelectedGroupCase = (\n    element: ExcalidrawElement,\n    selectedGroupId: GroupId,\n  ) => {\n    const indexOfSelectedGroupId = element.groupIds.indexOf(selectedGroupId, 0);\n    const nestedGroupCount = element.groupIds.slice(\n      0,\n      indexOfSelectedGroupId,\n    ).length;\n    return nestedGroupCount > 0\n      ? addToGroupsMap(element, element.groupIds[indexOfSelectedGroupId - 1])\n      : addToElementsMap(element);\n  };\n\n  const isAllInSameGroup = selectedElements.every((element) =>\n    isSelectedViaGroup(appState, element),\n  );\n\n  unboundElements.forEach((element) => {\n    const selectedGroupId = getSelectedGroupIdForElement(\n      element,\n      appState.selectedGroupIds,\n    );\n    if (!selectedGroupId) {\n      addToElementsMap(element);\n    } else if (selectedGroupIds.length === 1 && isAllInSameGroup) {\n      handleSingleSelectedGroupCase(element, selectedGroupId);\n    } else {\n      addToGroupsMap(element, selectedGroupId);\n    }\n  });\n  return Array.from(groups.values()).concat(Array.from(elements.values()));\n};\n", "import type { ElementOrToolType } from \"@excalidraw/excalidraw/types\";\n\nexport const hasBackground = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\" ||\n  type === \"freedraw\";\n\nexport const hasStrokeColor = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\" ||\n  type === \"text\" ||\n  type === \"embeddable\";\n\nexport const hasStrokeWidth = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeRoundness = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"line\" ||\n  type === \"diamond\" ||\n  type === \"image\";\n\nexport const toolIsArrow = (type: ElementOrToolType) => type === \"arrow\";\n\nexport const canHaveArrowheads = (type: ElementOrToolType) => type === \"arrow\";\n", "import type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBoundingBox } from \"./bounds\";\nimport { getSelectedElementsByGroup } from \"./groups\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { BoundingBox } from \"./bounds\";\nimport type { ExcalidrawElement } from \"./types\";\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n  scene: Scene,\n  appState: Readonly<AppState>,\n): ExcalidrawElement[] => {\n  const groups: ExcalidrawElement[][] = getSelectedElementsByGroup(\n    selectedElements,\n    scene.getNonDeletedElementsMap(),\n    appState,\n  );\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) => {\n      // update element\n      const updatedEle = scene.mutateElement(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      });\n\n      // update bound elements\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: group,\n        indirectArrowUpdate: true,\n      });\n      return updatedEle;\n    });\n  });\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: BoundingBox,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n", "import {\n  arrayToMap,\n  arrayToObject,\n  assertNever,\n  isDevEnv,\n  isShallowEqual,\n  isTestEnv,\n  randomInteger,\n} from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n  Ordered,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport type {\n  DTO,\n  Mutable,\n  SubtypeOf,\n  ValueOf,\n} from \"@excalidraw/common/utility-types\";\n\nimport type {\n  AppState,\n  ObservedAppState,\n  ObservedElementsAppState,\n  ObservedStandaloneAppState,\n} from \"@excalidraw/excalidraw/types\";\n\nimport { getObservedAppState } from \"./store\";\n\nimport {\n  BoundElement,\n  BindableElement,\n  bindingProperties,\n  updateBoundElements,\n} from \"./binding\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement, newElementWith } from \"./mutateElement\";\nimport { getBoundTextElementId, redrawTextBoundingBox } from \"./textElement\";\nimport {\n  hasBoundTextElement,\n  isBindableElement,\n  isBoundToContainer,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { getNonDeletedGroupIds } from \"./groups\";\n\nimport { orderByFractionalIndex, syncMovedIndices } from \"./fractionalIndex\";\n\nimport { StoreSnapshot } from \"./store\";\n\nimport { Scene } from \"./Scene\";\n\nimport type { BindableProp, BindingProp } from \"./binding\";\n\nimport type { ElementUpdate } from \"./mutateElement\";\n\n/**\n * Represents the difference between two objects of the same type.\n *\n * Both `deleted` and `inserted` partials represent the same set of added, removed or updated properties, where:\n * - `deleted` is a set of all the deleted values\n * - `inserted` is a set of all the inserted (added, updated) values\n *\n * Keeping it as pure object (without transient state, side-effects, etc.), so we won't have to instantiate it on load.\n */\nexport class Delta<T> {\n  private constructor(\n    public readonly deleted: Partial<T>,\n    public readonly inserted: Partial<T>,\n  ) {}\n\n  public static create<T>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    modifier?: (\n      delta: Partial<T>,\n      partialType: \"deleted\" | \"inserted\",\n    ) => Partial<T>,\n    modifierOptions?: \"deleted\" | \"inserted\" | \"both\",\n  ) {\n    const modifiedDeleted =\n      modifier && modifierOptions !== \"inserted\"\n        ? modifier(deleted, \"deleted\")\n        : deleted;\n    const modifiedInserted =\n      modifier && modifierOptions !== \"deleted\"\n        ? modifier(inserted, \"inserted\")\n        : inserted;\n\n    return new Delta(modifiedDeleted, modifiedInserted);\n  }\n\n  /**\n   * Calculates the delta between two objects.\n   *\n   * @param prevObject - The previous state of the object.\n   * @param nextObject - The next state of the object.\n   *\n   * @returns new delta instance.\n   */\n  public static calculate<T extends { [key: string]: any }>(\n    prevObject: T,\n    nextObject: T,\n    modifier?: (partial: Partial<T>) => Partial<T>,\n    postProcess?: (\n      deleted: Partial<T>,\n      inserted: Partial<T>,\n    ) => [Partial<T>, Partial<T>],\n  ): Delta<T> {\n    if (prevObject === nextObject) {\n      return Delta.empty();\n    }\n\n    const deleted = {} as Partial<T>;\n    const inserted = {} as Partial<T>;\n\n    // O(n^3) here for elements, but it's not as bad as it looks:\n    // - we do this only on store recordings, not on every frame (not for ephemerals)\n    // - we do this only on previously detected changed elements\n    // - we do shallow compare only on the first level of properties (not going any deeper)\n    // - # of properties is reasonably small\n    for (const key of this.getDifferences(prevObject, nextObject)) {\n      deleted[key as keyof T] = prevObject[key];\n      inserted[key as keyof T] = nextObject[key];\n    }\n\n    const [processedDeleted, processedInserted] = postProcess\n      ? postProcess(deleted, inserted)\n      : [deleted, inserted];\n\n    return Delta.create(processedDeleted, processedInserted, modifier);\n  }\n\n  public static empty() {\n    return new Delta({}, {});\n  }\n\n  public static isEmpty<T>(delta: Delta<T>): boolean {\n    return (\n      !Object.keys(delta.deleted).length && !Object.keys(delta.inserted).length\n    );\n  }\n\n  /**\n   * Merges two deltas into a new one.\n   */\n  public static merge<T>(\n    delta1: Delta<T>,\n    delta2: Delta<T>,\n    delta3: Delta<T> = Delta.empty(),\n  ) {\n    return Delta.create(\n      { ...delta1.deleted, ...delta2.deleted, ...delta3.deleted },\n      { ...delta1.inserted, ...delta2.inserted, ...delta3.inserted },\n    );\n  }\n\n  /**\n   * Merges deleted and inserted object partials.\n   */\n  public static mergeObjects<T extends { [key: string]: unknown }>(\n    prev: T,\n    added: T,\n    removed: T = {} as T,\n  ) {\n    const cloned = { ...prev };\n\n    for (const key of Object.keys(removed)) {\n      delete cloned[key];\n    }\n\n    return { ...cloned, ...added };\n  }\n\n  /**\n   * Merges deleted and inserted array partials.\n   */\n  public static mergeArrays<T>(\n    prev: readonly T[] | null,\n    added: readonly T[] | null | undefined,\n    removed: readonly T[] | null | undefined,\n    predicate?: (value: T) => string,\n  ) {\n    return Object.values(\n      Delta.mergeObjects(\n        arrayToObject(prev ?? [], predicate),\n        arrayToObject(added ?? [], predicate),\n        arrayToObject(removed ?? [], predicate),\n      ),\n    );\n  }\n\n  /**\n   * Diff object partials as part of the `postProcess`.\n   */\n  public static diffObjects<T, K extends keyof T, V extends ValueOf<T[K]>>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    property: K,\n    setValue: (prevValue: V | undefined) => V,\n  ) {\n    if (!deleted[property] && !inserted[property]) {\n      return;\n    }\n\n    const isDeletedObject =\n      deleted[property] !== null && typeof deleted[property] === \"object\";\n    const isInsertedObject =\n      inserted[property] !== null && typeof inserted[property] === \"object\";\n\n    if (isDeletedObject || isInsertedObject) {\n      type RecordLike = Record<string, V | undefined>;\n\n      const deletedObject: RecordLike = deleted[property] ?? {};\n      const insertedObject: RecordLike = inserted[property] ?? {};\n\n      const deletedDifferences = Delta.getLeftDifferences(\n        deletedObject,\n        insertedObject,\n      ).reduce((acc, curr) => {\n        acc[curr] = setValue(deletedObject[curr]);\n        return acc;\n      }, {} as RecordLike);\n\n      const insertedDifferences = Delta.getRightDifferences(\n        deletedObject,\n        insertedObject,\n      ).reduce((acc, curr) => {\n        acc[curr] = setValue(insertedObject[curr]);\n        return acc;\n      }, {} as RecordLike);\n\n      if (\n        Object.keys(deletedDifferences).length ||\n        Object.keys(insertedDifferences).length\n      ) {\n        Reflect.set(deleted, property, deletedDifferences);\n        Reflect.set(inserted, property, insertedDifferences);\n      } else {\n        Reflect.deleteProperty(deleted, property);\n        Reflect.deleteProperty(inserted, property);\n      }\n    } else if (deleted[property] === inserted[property]) {\n      Reflect.deleteProperty(deleted, property);\n      Reflect.deleteProperty(inserted, property);\n    }\n  }\n\n  /**\n   * Diff array partials as part of the `postProcess`.\n   */\n  public static diffArrays<T, K extends keyof T, V extends T[K]>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    property: K,\n    groupBy: (value: V extends ArrayLike<infer T> ? T : never) => string,\n  ) {\n    if (!deleted[property] && !inserted[property]) {\n      return;\n    }\n\n    if (Array.isArray(deleted[property]) || Array.isArray(inserted[property])) {\n      const deletedArray = (\n        Array.isArray(deleted[property]) ? deleted[property] : []\n      ) as [];\n      const insertedArray = (\n        Array.isArray(inserted[property]) ? inserted[property] : []\n      ) as [];\n\n      const deletedDifferences = arrayToObject(\n        Delta.getLeftDifferences(\n          arrayToObject(deletedArray, groupBy),\n          arrayToObject(insertedArray, groupBy),\n        ),\n        (x) => x,\n      );\n      const insertedDifferences = arrayToObject(\n        Delta.getRightDifferences(\n          arrayToObject(deletedArray, groupBy),\n          arrayToObject(insertedArray, groupBy),\n        ),\n        (x) => x,\n      );\n\n      if (\n        Object.keys(deletedDifferences).length ||\n        Object.keys(insertedDifferences).length\n      ) {\n        const deletedValue = deletedArray.filter(\n          (x) => deletedDifferences[groupBy ? groupBy(x) : String(x)],\n        );\n        const insertedValue = insertedArray.filter(\n          (x) => insertedDifferences[groupBy ? groupBy(x) : String(x)],\n        );\n\n        Reflect.set(deleted, property, deletedValue);\n        Reflect.set(inserted, property, insertedValue);\n      } else {\n        Reflect.deleteProperty(deleted, property);\n        Reflect.deleteProperty(inserted, property);\n      }\n    }\n  }\n\n  /**\n   * Compares if object1 contains any different value compared to the object2.\n   */\n  public static isLeftDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = this.distinctKeysIterator(\n      \"left\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if object2 contains any different value compared to the object1.\n   */\n  public static isRightDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = this.distinctKeysIterator(\n      \"right\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if shared properties of object1 and object2 contain any different value (aka inner join).\n   */\n  public static isInnerDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = !!this.distinctKeysIterator(\n      \"inner\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if any properties of object1 and object2 contain any different value (aka full join).\n   */\n  public static isDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = !!this.distinctKeysIterator(\n      \"full\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Returns sorted object1 keys that have distinct values.\n   */\n  public static getLeftDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"left\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted object2 keys that have distinct values.\n   */\n  public static getRightDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"right\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted keys of shared object1 and object2 properties that have distinct values (aka inner join).\n   */\n  public static getInnerDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"inner\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted keys that have distinct values between object1 and object2 (aka full join).\n   */\n  public static getDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"full\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Iterator comparing values of object properties based on the passed joining strategy.\n   *\n   * @yields keys of properties with different values\n   *\n   * WARN: it's based on shallow compare performed only on the first level and doesn't go deeper than that.\n   */\n  private static *distinctKeysIterator<T extends {}>(\n    join: \"left\" | \"right\" | \"inner\" | \"full\",\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    if (object1 === object2) {\n      return;\n    }\n\n    let keys: string[] = [];\n\n    if (join === \"left\") {\n      keys = Object.keys(object1);\n    } else if (join === \"right\") {\n      keys = Object.keys(object2);\n    } else if (join === \"inner\") {\n      keys = Object.keys(object1).filter((key) => key in object2);\n    } else if (join === \"full\") {\n      keys = Array.from(\n        new Set([...Object.keys(object1), ...Object.keys(object2)]),\n      );\n    } else {\n      assertNever(\n        join,\n        `Unknown distinctKeysIterator's join param \"${join}\"`,\n        true,\n      );\n    }\n\n    for (const key of keys) {\n      const value1 = object1[key as keyof T];\n      const value2 = object2[key as keyof T];\n\n      if (value1 !== value2) {\n        if (\n          !skipShallowCompare &&\n          typeof value1 === \"object\" &&\n          typeof value2 === \"object\" &&\n          value1 !== null &&\n          value2 !== null &&\n          isShallowEqual(value1, value2)\n        ) {\n          continue;\n        }\n\n        yield key;\n      }\n    }\n  }\n}\n\n/**\n * Encapsulates a set of application-level `Delta`s.\n */\nexport interface DeltaContainer<T> {\n  /**\n   * Inverses the `Delta`s while creating a new `DeltaContainer` instance.\n   */\n  inverse(): DeltaContainer<T>;\n\n  /**\n   * Applies the `Delta`s to the previous object.\n   *\n   * @returns a tuple of the next object `T` with applied `Delta`s, and `boolean`, indicating whether the applied deltas resulted in a visible change.\n   */\n  applyTo(previous: T, ...options: unknown[]): [T, boolean];\n\n  /**\n   * Squashes the current delta with the given one.\n   */\n  squash(delta: DeltaContainer<T>): this;\n\n  /**\n   * Checks whether all `Delta`s are empty.\n   */\n  isEmpty(): boolean;\n}\n\nexport class AppStateDelta implements DeltaContainer<AppState> {\n  private constructor(public delta: Delta<ObservedAppState>) {}\n\n  public static create(delta: Delta<ObservedAppState>): AppStateDelta {\n    return new AppStateDelta(delta);\n  }\n\n  public static calculate<T extends ObservedAppState>(\n    prevAppState: T,\n    nextAppState: T,\n  ): AppStateDelta {\n    const delta = Delta.calculate(\n      prevAppState,\n      nextAppState,\n      // making the order of keys in deltas stable for hashing purposes\n      AppStateDelta.orderAppStateKeys,\n      AppStateDelta.postProcess,\n    );\n\n    return new AppStateDelta(delta);\n  }\n\n  public static restore(appStateDeltaDTO: DTO<AppStateDelta>): AppStateDelta {\n    const { delta } = appStateDeltaDTO;\n    return new AppStateDelta(delta);\n  }\n\n  public static empty() {\n    return new AppStateDelta(Delta.create({}, {}));\n  }\n\n  public inverse(): AppStateDelta {\n    const inversedDelta = Delta.create(this.delta.inserted, this.delta.deleted);\n    return new AppStateDelta(inversedDelta);\n  }\n\n  public squash(delta: AppStateDelta): this {\n    if (delta.isEmpty()) {\n      return this;\n    }\n\n    const mergedDeletedSelectedElementIds = Delta.mergeObjects(\n      this.delta.deleted.selectedElementIds ?? {},\n      delta.delta.deleted.selectedElementIds ?? {},\n    );\n\n    const mergedInsertedSelectedElementIds = Delta.mergeObjects(\n      this.delta.inserted.selectedElementIds ?? {},\n      delta.delta.inserted.selectedElementIds ?? {},\n    );\n\n    const mergedDeletedSelectedGroupIds = Delta.mergeObjects(\n      this.delta.deleted.selectedGroupIds ?? {},\n      delta.delta.deleted.selectedGroupIds ?? {},\n    );\n\n    const mergedInsertedSelectedGroupIds = Delta.mergeObjects(\n      this.delta.inserted.selectedGroupIds ?? {},\n      delta.delta.inserted.selectedGroupIds ?? {},\n    );\n\n    const mergedDeletedLockedMultiSelections = Delta.mergeObjects(\n      this.delta.deleted.lockedMultiSelections ?? {},\n      delta.delta.deleted.lockedMultiSelections ?? {},\n    );\n\n    const mergedInsertedLockedMultiSelections = Delta.mergeObjects(\n      this.delta.inserted.lockedMultiSelections ?? {},\n      delta.delta.inserted.lockedMultiSelections ?? {},\n    );\n\n    const mergedInserted: Partial<ObservedAppState> = {};\n    const mergedDeleted: Partial<ObservedAppState> = {};\n\n    if (\n      Object.keys(mergedDeletedSelectedElementIds).length ||\n      Object.keys(mergedInsertedSelectedElementIds).length\n    ) {\n      mergedDeleted.selectedElementIds = mergedDeletedSelectedElementIds;\n      mergedInserted.selectedElementIds = mergedInsertedSelectedElementIds;\n    }\n\n    if (\n      Object.keys(mergedDeletedSelectedGroupIds).length ||\n      Object.keys(mergedInsertedSelectedGroupIds).length\n    ) {\n      mergedDeleted.selectedGroupIds = mergedDeletedSelectedGroupIds;\n      mergedInserted.selectedGroupIds = mergedInsertedSelectedGroupIds;\n    }\n\n    if (\n      Object.keys(mergedDeletedLockedMultiSelections).length ||\n      Object.keys(mergedInsertedLockedMultiSelections).length\n    ) {\n      mergedDeleted.lockedMultiSelections = mergedDeletedLockedMultiSelections;\n      mergedInserted.lockedMultiSelections =\n        mergedInsertedLockedMultiSelections;\n    }\n\n    this.delta = Delta.merge(\n      this.delta,\n      delta.delta,\n      Delta.create(mergedDeleted, mergedInserted),\n    );\n\n    return this;\n  }\n\n  public applyTo(\n    appState: AppState,\n    nextElements: SceneElementsMap,\n  ): [AppState, boolean] {\n    try {\n      const {\n        selectedElementIds: deletedSelectedElementIds = {},\n        selectedGroupIds: deletedSelectedGroupIds = {},\n        lockedMultiSelections: deletedLockedMultiSelections = {},\n      } = this.delta.deleted;\n\n      const {\n        selectedElementIds: insertedSelectedElementIds = {},\n        selectedGroupIds: insertedSelectedGroupIds = {},\n        lockedMultiSelections: insertedLockedMultiSelections = {},\n        selectedLinearElement: insertedSelectedLinearElement,\n        ...directlyApplicablePartial\n      } = this.delta.inserted;\n\n      const mergedSelectedElementIds = Delta.mergeObjects(\n        appState.selectedElementIds,\n        insertedSelectedElementIds,\n        deletedSelectedElementIds,\n      );\n\n      const mergedSelectedGroupIds = Delta.mergeObjects(\n        appState.selectedGroupIds,\n        insertedSelectedGroupIds,\n        deletedSelectedGroupIds,\n      );\n\n      const mergedLockedMultiSelections = Delta.mergeObjects(\n        appState.lockedMultiSelections,\n        insertedLockedMultiSelections,\n        deletedLockedMultiSelections,\n      );\n\n      const selectedLinearElement =\n        insertedSelectedLinearElement &&\n        nextElements.has(insertedSelectedLinearElement.elementId)\n          ? new LinearElementEditor(\n              nextElements.get(\n                insertedSelectedLinearElement.elementId,\n              ) as NonDeleted<ExcalidrawLinearElement>,\n              nextElements,\n              insertedSelectedLinearElement.isEditing,\n            )\n          : null;\n\n      const nextAppState = {\n        ...appState,\n        ...directlyApplicablePartial,\n        selectedElementIds: mergedSelectedElementIds,\n        selectedGroupIds: mergedSelectedGroupIds,\n        lockedMultiSelections: mergedLockedMultiSelections,\n        selectedLinearElement:\n          typeof insertedSelectedLinearElement !== \"undefined\"\n            ? selectedLinearElement\n            : appState.selectedLinearElement,\n      };\n\n      const constainsVisibleChanges = this.filterInvisibleChanges(\n        appState,\n        nextAppState,\n        nextElements,\n      );\n\n      return [nextAppState, constainsVisibleChanges];\n    } catch (e) {\n      // shouldn't really happen, but just in case\n      console.error(`Couldn't apply appstate change`, e);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n\n      return [appState, false];\n    }\n  }\n\n  public isEmpty(): boolean {\n    return Delta.isEmpty(this.delta);\n  }\n\n  /**\n   * Mutates `nextAppState` be filtering out state related to deleted elements.\n   *\n   * @returns `true` if a visible change is found, `false` otherwise.\n   */\n  private filterInvisibleChanges(\n    prevAppState: AppState,\n    nextAppState: AppState,\n    nextElements: SceneElementsMap,\n  ): boolean {\n    // TODO: #7348 we could still get an empty undo/redo, as we assume that previous appstate does not contain references to deleted elements\n    // which is not always true - i.e. now we do cleanup appstate during history, but we do not do it during remote updates\n    const prevObservedAppState = getObservedAppState(prevAppState);\n    const nextObservedAppState = getObservedAppState(nextAppState);\n\n    const containsStandaloneDifference = Delta.isRightDifferent(\n      AppStateDelta.stripElementsProps(prevObservedAppState),\n      AppStateDelta.stripElementsProps(nextObservedAppState),\n    );\n\n    const containsElementsDifference = Delta.isRightDifferent(\n      AppStateDelta.stripStandaloneProps(prevObservedAppState),\n      AppStateDelta.stripStandaloneProps(nextObservedAppState),\n    );\n\n    if (!containsStandaloneDifference && !containsElementsDifference) {\n      // no change in appstate was detected\n      return false;\n    }\n\n    const visibleDifferenceFlag = {\n      value: containsStandaloneDifference,\n    };\n\n    if (containsElementsDifference) {\n      // filter invisible changes on each iteration\n      const changedElementsProps = Delta.getRightDifferences(\n        AppStateDelta.stripStandaloneProps(prevObservedAppState),\n        AppStateDelta.stripStandaloneProps(nextObservedAppState),\n      ) as Array<keyof ObservedElementsAppState>;\n\n      let nonDeletedGroupIds = new Set<string>();\n\n      if (\n        changedElementsProps.includes(\"editingGroupId\") ||\n        changedElementsProps.includes(\"selectedGroupIds\")\n      ) {\n        // this one iterates through all the non deleted elements, so make sure it's not done twice\n        nonDeletedGroupIds = getNonDeletedGroupIds(nextElements);\n      }\n\n      // check whether delta properties are related to the existing non-deleted elements\n      for (const key of changedElementsProps) {\n        switch (key) {\n          case \"selectedElementIds\":\n            nextAppState[key] = AppStateDelta.filterSelectedElements(\n              nextAppState[key],\n              nextElements,\n              visibleDifferenceFlag,\n            );\n\n            break;\n          case \"selectedGroupIds\":\n            nextAppState[key] = AppStateDelta.filterSelectedGroups(\n              nextAppState[key],\n              nonDeletedGroupIds,\n              visibleDifferenceFlag,\n            );\n\n            break;\n          case \"croppingElementId\": {\n            const croppingElementId = nextAppState[key];\n\n            if (!croppingElementId) {\n              // previously there was a croppingElementId (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else {\n              const element = nextElements.get(croppingElementId);\n\n              if (element && !element.isDeleted) {\n                visibleDifferenceFlag.value = true;\n              } else {\n                nextAppState[key] = null;\n              }\n            }\n\n            break;\n          }\n          case \"editingGroupId\":\n            const editingGroupId = nextAppState[key];\n\n            if (!editingGroupId) {\n              // previously there was an editingGroup (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else if (nonDeletedGroupIds.has(editingGroupId)) {\n              // previously there wasn't an editingGroup, now there is one which is visible\n              visibleDifferenceFlag.value = true;\n            } else {\n              // there was assigned an editingGroup now, but it's related to deleted element\n              nextAppState[key] = null;\n            }\n\n            break;\n          case \"selectedLinearElement\":\n            const nextLinearElement = nextAppState[key];\n\n            if (!nextLinearElement) {\n              // previously there was a linear element (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else {\n              const element = nextElements.get(nextLinearElement.elementId);\n\n              if (element && !element.isDeleted) {\n                // previously there wasn't a linear element, now there is one which is visible\n                visibleDifferenceFlag.value = true;\n              } else {\n                // there was assigned a linear element now, but it's deleted\n                nextAppState[key] = null;\n              }\n            }\n\n            break;\n          case \"lockedMultiSelections\":\n            const prevLockedUnits = prevAppState[key] || {};\n            const nextLockedUnits = nextAppState[key] || {};\n\n            // TODO: this seems wrong, we are already doing this comparison generically above,\n            // hence instead we should check whether elements are actually visible,\n            // so that once these changes are applied they actually result in a visible change to the user\n            if (!isShallowEqual(prevLockedUnits, nextLockedUnits)) {\n              visibleDifferenceFlag.value = true;\n            }\n            break;\n          case \"activeLockedId\":\n            const prevHitLockedId = prevAppState[key] || null;\n            const nextHitLockedId = nextAppState[key] || null;\n\n            // TODO: this seems wrong, we are already doing this comparison generically above,\n            // hence instead we should check whether elements are actually visible,\n            // so that once these changes are applied they actually result in a visible change to the user\n            if (prevHitLockedId !== nextHitLockedId) {\n              visibleDifferenceFlag.value = true;\n            }\n            break;\n          default:\n            assertNever(\n              key,\n              `Unknown ObservedElementsAppState's key \"${key}\"`,\n              true,\n            );\n        }\n      }\n    }\n\n    return visibleDifferenceFlag.value;\n  }\n\n  private static filterSelectedElements(\n    selectedElementIds: AppState[\"selectedElementIds\"],\n    elements: SceneElementsMap,\n    visibleDifferenceFlag: { value: boolean },\n  ) {\n    const ids = Object.keys(selectedElementIds);\n\n    if (!ids.length) {\n      // previously there were ids (assuming related to visible elements), now there are none\n      visibleDifferenceFlag.value = true;\n      return selectedElementIds;\n    }\n\n    const nextSelectedElementIds = { ...selectedElementIds };\n\n    for (const id of ids) {\n      const element = elements.get(id);\n\n      if (element && !element.isDeleted) {\n        // there is a selected element id related to a visible element\n        visibleDifferenceFlag.value = true;\n      } else {\n        delete nextSelectedElementIds[id];\n      }\n    }\n\n    return nextSelectedElementIds;\n  }\n\n  private static filterSelectedGroups(\n    selectedGroupIds: AppState[\"selectedGroupIds\"],\n    nonDeletedGroupIds: Set<string>,\n    visibleDifferenceFlag: { value: boolean },\n  ) {\n    const ids = Object.keys(selectedGroupIds);\n\n    if (!ids.length) {\n      // previously there were ids (assuming related to visible groups), now there are none\n      visibleDifferenceFlag.value = true;\n      return selectedGroupIds;\n    }\n\n    const nextSelectedGroupIds = { ...selectedGroupIds };\n\n    for (const id of Object.keys(nextSelectedGroupIds)) {\n      if (nonDeletedGroupIds.has(id)) {\n        // there is a selected group id related to a visible group\n        visibleDifferenceFlag.value = true;\n      } else {\n        delete nextSelectedGroupIds[id];\n      }\n    }\n\n    return nextSelectedGroupIds;\n  }\n\n  private static stripElementsProps(\n    delta: Partial<ObservedAppState>,\n  ): Partial<ObservedStandaloneAppState> {\n    // WARN: Do not remove the type-casts as they here to ensure proper type checks\n    const {\n      editingGroupId,\n      selectedGroupIds,\n      selectedElementIds,\n      selectedLinearElement,\n      croppingElementId,\n      lockedMultiSelections,\n      activeLockedId,\n      ...standaloneProps\n    } = delta as ObservedAppState;\n\n    return standaloneProps as SubtypeOf<\n      typeof standaloneProps,\n      ObservedStandaloneAppState\n    >;\n  }\n\n  private static stripStandaloneProps(\n    delta: Partial<ObservedAppState>,\n  ): Partial<ObservedElementsAppState> {\n    // WARN: Do not remove the type-casts as they here to ensure proper type checks\n    const { name, viewBackgroundColor, ...elementsProps } =\n      delta as ObservedAppState;\n\n    return elementsProps as SubtypeOf<\n      typeof elementsProps,\n      ObservedElementsAppState\n    >;\n  }\n\n  /**\n   * It is necessary to post process the partials in case of reference values,\n   * for which we need to calculate the real diff between `deleted` and `inserted`.\n   */\n  private static postProcess<T extends ObservedAppState>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n  ): [Partial<T>, Partial<T>] {\n    try {\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"selectedElementIds\",\n        // ts language server has a bit trouble resolving this, so we are giving it a little push\n        (_) => true as ValueOf<T[\"selectedElementIds\"]>,\n      );\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"selectedGroupIds\",\n        (prevValue) => (prevValue ?? false) as ValueOf<T[\"selectedGroupIds\"]>,\n      );\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"lockedMultiSelections\",\n        (prevValue) => (prevValue ?? {}) as ValueOf<T[\"lockedMultiSelections\"]>,\n      );\n    } catch (e) {\n      // if postprocessing fails it does not make sense to bubble up, but let's make sure we know about it\n      console.error(`Couldn't postprocess appstate change deltas.`);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [deleted, inserted];\n    }\n  }\n\n  private static orderAppStateKeys(partial: Partial<ObservedAppState>) {\n    const orderedPartial: { [key: string]: unknown } = {};\n\n    for (const key of Object.keys(partial).sort()) {\n      // relying on insertion order\n      orderedPartial[key] = partial[key as keyof ObservedAppState];\n    }\n\n    return orderedPartial as Partial<ObservedAppState>;\n  }\n}\n\ntype ElementPartial<TElement extends ExcalidrawElement = ExcalidrawElement> =\n  Omit<Partial<Ordered<TElement>>, \"id\" | \"updated\" | \"seed\">;\n\nexport type ApplyToOptions = {\n  excludedProperties?: Set<keyof ElementPartial>;\n};\n\ntype ApplyToFlags = {\n  containsVisibleDifference: boolean;\n  containsZindexDifference: boolean;\n  applyDirection: \"forward\" | \"backward\" | undefined;\n};\n\n/**\n * Elements change is a low level primitive to capture a change between two sets of elements.\n * It does so by encapsulating forward and backward `Delta`s, allowing to time-travel in both directions.\n */\nexport class ElementsDelta implements DeltaContainer<SceneElementsMap> {\n  private constructor(\n    public readonly added: Record<string, Delta<ElementPartial>>,\n    public readonly removed: Record<string, Delta<ElementPartial>>,\n    public readonly updated: Record<string, Delta<ElementPartial>>,\n  ) {}\n\n  public static create(\n    added: Record<string, Delta<ElementPartial>>,\n    removed: Record<string, Delta<ElementPartial>>,\n    updated: Record<string, Delta<ElementPartial>>,\n    options: {\n      shouldRedistribute: boolean;\n    } = {\n      shouldRedistribute: false,\n    },\n  ) {\n    let delta: ElementsDelta;\n\n    if (options.shouldRedistribute) {\n      const nextAdded: Record<string, Delta<ElementPartial>> = {};\n      const nextRemoved: Record<string, Delta<ElementPartial>> = {};\n      const nextUpdated: Record<string, Delta<ElementPartial>> = {};\n\n      const deltas = [\n        ...Object.entries(added),\n        ...Object.entries(removed),\n        ...Object.entries(updated),\n      ];\n\n      for (const [id, delta] of deltas) {\n        if (this.satisfiesAddition(delta)) {\n          nextAdded[id] = delta;\n        } else if (this.satisfiesRemoval(delta)) {\n          nextRemoved[id] = delta;\n        } else {\n          nextUpdated[id] = delta;\n        }\n      }\n\n      delta = new ElementsDelta(nextAdded, nextRemoved, nextUpdated);\n    } else {\n      delta = new ElementsDelta(added, removed, updated);\n    }\n\n    if (isTestEnv() || isDevEnv()) {\n      ElementsDelta.validate(delta, \"added\", this.satisfiesAddition);\n      ElementsDelta.validate(delta, \"removed\", this.satisfiesRemoval);\n      ElementsDelta.validate(delta, \"updated\", this.satisfiesUpdate);\n    }\n\n    return delta;\n  }\n\n  public static restore(elementsDeltaDTO: DTO<ElementsDelta>): ElementsDelta {\n    const { added, removed, updated } = elementsDeltaDTO;\n    return ElementsDelta.create(added, removed, updated);\n  }\n\n  private static satisfiesAddition = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    // dissallowing added as \"deleted\", which could cause issues when resolving conflicts\n    deleted.isDeleted === true && !inserted.isDeleted;\n\n  private static satisfiesRemoval = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    !deleted.isDeleted && inserted.isDeleted === true;\n\n  private static satisfiesUpdate = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) => !!deleted.isDeleted === !!inserted.isDeleted;\n\n  private static satisfiesCommmonInvariants = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    !!(\n      // versions are required integers\n      (\n        Number.isInteger(deleted.version) &&\n        Number.isInteger(inserted.version) &&\n        // versions should be positive, zero included\n        deleted.version! >= 0 &&\n        inserted.version! >= 0 &&\n        // versions should never be the same\n        deleted.version !== inserted.version\n      )\n    );\n\n  private static satisfiesUniqueInvariants = (\n    elementsDelta: ElementsDelta,\n    id: string,\n  ) => {\n    const { added, removed, updated } = elementsDelta;\n    // it's required that there is only one unique delta type per element\n    return [added[id], removed[id], updated[id]].filter(Boolean).length === 1;\n  };\n\n  private static validate(\n    elementsDelta: ElementsDelta,\n    type: \"added\" | \"removed\" | \"updated\",\n    satifiesSpecialInvariants: (delta: Delta<ElementPartial>) => boolean,\n  ) {\n    for (const [id, delta] of Object.entries(elementsDelta[type])) {\n      if (\n        !this.satisfiesCommmonInvariants(delta) ||\n        !this.satisfiesUniqueInvariants(elementsDelta, id) ||\n        !satifiesSpecialInvariants(delta)\n      ) {\n        console.error(\n          `Broken invariant for \"${type}\" delta, element \"${id}\", delta:`,\n          delta,\n        );\n        throw new Error(`ElementsDelta invariant broken for element \"${id}\".`);\n      }\n    }\n  }\n\n  /**\n   * Calculates the `Delta`s between the previous and next set of elements.\n   *\n   * @param prevElements - Map representing the previous state of elements.\n   * @param nextElements - Map representing the next state of elements.\n   *\n   * @returns `ElementsDelta` instance representing the `Delta` changes between the two sets of elements.\n   */\n  public static calculate<T extends OrderedExcalidrawElement>(\n    prevElements: Map<string, T>,\n    nextElements: Map<string, T>,\n  ): ElementsDelta {\n    if (prevElements === nextElements) {\n      return ElementsDelta.empty();\n    }\n\n    const added: Record<string, Delta<ElementPartial>> = {};\n    const removed: Record<string, Delta<ElementPartial>> = {};\n    const updated: Record<string, Delta<ElementPartial>> = {};\n\n    // this might be needed only in same edge cases, like during collab, when `isDeleted` elements get removed or when we (un)intentionally remove the elements\n    for (const prevElement of prevElements.values()) {\n      const nextElement = nextElements.get(prevElement.id);\n\n      if (!nextElement) {\n        const deleted = { ...prevElement } as ElementPartial;\n\n        const inserted = {\n          isDeleted: true,\n          version: prevElement.version + 1,\n          versionNonce: randomInteger(),\n        } as ElementPartial;\n\n        const delta = Delta.create(\n          deleted,\n          inserted,\n          ElementsDelta.stripIrrelevantProps,\n        );\n\n        if (!prevElement.isDeleted) {\n          removed[prevElement.id] = delta;\n        } else {\n          updated[prevElement.id] = delta;\n        }\n      }\n    }\n\n    for (const nextElement of nextElements.values()) {\n      const prevElement = prevElements.get(nextElement.id);\n\n      if (!prevElement) {\n        const deleted = {\n          isDeleted: true,\n          version: nextElement.version - 1,\n          versionNonce: randomInteger(),\n        } as ElementPartial;\n\n        const inserted = {\n          ...nextElement,\n        } as ElementPartial;\n\n        const delta = Delta.create(\n          deleted,\n          inserted,\n          ElementsDelta.stripIrrelevantProps,\n        );\n\n        // ignore updates which would \"delete\" already deleted element\n        if (!nextElement.isDeleted) {\n          added[nextElement.id] = delta;\n        } else {\n          updated[nextElement.id] = delta;\n        }\n\n        continue;\n      }\n\n      if (prevElement.versionNonce !== nextElement.versionNonce) {\n        const delta = Delta.calculate<ElementPartial>(\n          prevElement,\n          nextElement,\n          ElementsDelta.stripIrrelevantProps,\n          ElementsDelta.postProcess,\n        );\n\n        if (\n          // making sure we don't get here some non-boolean values (i.e. undefined, null, etc.)\n          typeof prevElement.isDeleted === \"boolean\" &&\n          typeof nextElement.isDeleted === \"boolean\" &&\n          prevElement.isDeleted !== nextElement.isDeleted\n        ) {\n          // notice that other props could have been updated as well\n          if (prevElement.isDeleted && !nextElement.isDeleted) {\n            added[nextElement.id] = delta;\n          } else {\n            removed[nextElement.id] = delta;\n          }\n\n          continue;\n        }\n\n        updated[nextElement.id] = delta;\n      }\n    }\n\n    return ElementsDelta.create(added, removed, updated);\n  }\n\n  public static empty() {\n    return ElementsDelta.create({}, {}, {});\n  }\n\n  public inverse(): ElementsDelta {\n    const inverseInternal = (deltas: Record<string, Delta<ElementPartial>>) => {\n      const inversedDeltas: Record<string, Delta<ElementPartial>> = {};\n\n      for (const [id, { inserted, deleted }] of Object.entries(deltas)) {\n        inversedDeltas[id] = Delta.create({ ...inserted }, { ...deleted });\n      }\n\n      return inversedDeltas;\n    };\n\n    const added = inverseInternal(this.added);\n    const removed = inverseInternal(this.removed);\n    const updated = inverseInternal(this.updated);\n\n    // notice we inverse removed with added not to break the invariants\n    return ElementsDelta.create(removed, added, updated);\n  }\n\n  public isEmpty(): boolean {\n    return (\n      Object.keys(this.added).length === 0 &&\n      Object.keys(this.removed).length === 0 &&\n      Object.keys(this.updated).length === 0\n    );\n  }\n\n  /**\n   * Update delta/s based on the existing elements.\n   *\n   * @param nextElements current elements\n   * @param modifierOptions defines which of the delta (`deleted` or `inserted`) will be updated\n   * @returns new instance with modified delta/s\n   */\n  public applyLatestChanges(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    modifierOptions?: \"deleted\" | \"inserted\",\n  ): ElementsDelta {\n    const modifier =\n      (\n        prevElement: OrderedExcalidrawElement | undefined,\n        nextElement: OrderedExcalidrawElement | undefined,\n      ) =>\n      (partial: ElementPartial, partialType: \"deleted\" | \"inserted\") => {\n        let element: OrderedExcalidrawElement | undefined;\n\n        switch (partialType) {\n          case \"deleted\":\n            element = prevElement;\n            break;\n          case \"inserted\":\n            element = nextElement;\n            break;\n        }\n\n        // the element wasn't found -> don't update the partial\n        if (!element) {\n          console.error(\n            `Element not found when trying to apply latest changes`,\n          );\n          return partial;\n        }\n\n        const latestPartial: { [key: string]: unknown } = {};\n\n        for (const key of Object.keys(partial) as Array<keyof typeof partial>) {\n          // do not update following props:\n          // - `boundElements`, as it is a reference value which is postprocessed to contain only deleted/inserted keys\n          switch (key) {\n            case \"boundElements\":\n              latestPartial[key] = partial[key];\n              break;\n            default:\n              latestPartial[key] = element[key];\n          }\n        }\n\n        return latestPartial;\n      };\n\n    const applyLatestChangesInternal = (\n      deltas: Record<string, Delta<ElementPartial>>,\n    ) => {\n      const modifiedDeltas: Record<string, Delta<ElementPartial>> = {};\n\n      for (const [id, delta] of Object.entries(deltas)) {\n        const prevElement = prevElements.get(id);\n        const nextElement = nextElements.get(id);\n\n        let latestDelta: Delta<ElementPartial> | null = null;\n\n        if (prevElement || nextElement) {\n          latestDelta = Delta.create(\n            delta.deleted,\n            delta.inserted,\n            modifier(prevElement, nextElement),\n            modifierOptions,\n          );\n        } else {\n          latestDelta = delta;\n        }\n\n        // it might happen that after applying latest changes the delta itself does not contain any changes\n        if (Delta.isInnerDifferent(latestDelta.deleted, latestDelta.inserted)) {\n          modifiedDeltas[id] = latestDelta;\n        }\n      }\n\n      return modifiedDeltas;\n    };\n\n    const added = applyLatestChangesInternal(this.added);\n    const removed = applyLatestChangesInternal(this.removed);\n    const updated = applyLatestChangesInternal(this.updated);\n\n    return ElementsDelta.create(added, removed, updated, {\n      shouldRedistribute: true, // redistribute the deltas as `isDeleted` could have been updated\n    });\n  }\n\n  public applyTo(\n    elements: SceneElementsMap,\n    snapshot: StoreSnapshot[\"elements\"] = StoreSnapshot.empty().elements,\n    options?: ApplyToOptions,\n  ): [SceneElementsMap, boolean] {\n    let nextElements = new Map(elements) as SceneElementsMap;\n    let changedElements: Map<string, OrderedExcalidrawElement>;\n\n    const flags: ApplyToFlags = {\n      containsVisibleDifference: false,\n      containsZindexDifference: false,\n      applyDirection: undefined,\n    };\n\n    // mimic a transaction by applying deltas into `nextElements` (always new instance, no mutation)\n    try {\n      const applyDeltas = ElementsDelta.createApplier(\n        elements,\n        nextElements,\n        snapshot,\n        flags,\n        options,\n      );\n\n      const addedElements = applyDeltas(this.added);\n      const removedElements = applyDeltas(this.removed);\n      const updatedElements = applyDeltas(this.updated);\n\n      const affectedElements = this.resolveConflicts(\n        elements,\n        nextElements,\n        flags.applyDirection,\n      );\n\n      // TODO: #7348 validate elements semantically and syntactically the changed elements, in case they would result data integrity issues\n      changedElements = new Map([\n        ...addedElements,\n        ...removedElements,\n        ...updatedElements,\n        ...affectedElements,\n      ]);\n    } catch (e) {\n      console.error(`Couldn't apply elements delta`, e);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n\n      // should not really happen, but just in case we cannot apply deltas, let's return the previous elements with visible change set to `true`\n      // even though there is obviously no visible change, returning `false` could be dangerous, as i.e.:\n      // in the worst case, it could lead into iterating through the whole stack with no possibility to redo\n      // instead, the worst case when returning `true` is an empty undo / redo\n      return [elements, true];\n    }\n\n    try {\n      // the following reorder performs mutations, but only on new instances of changed elements,\n      // unless something goes really bad and it fallbacks to fixing all invalid indices\n      nextElements = ElementsDelta.reorderElements(\n        nextElements,\n        changedElements,\n        flags,\n      );\n\n      ElementsDelta.redrawElements(nextElements, changedElements);\n    } catch (e) {\n      console.error(\n        `Couldn't mutate elements after applying elements change`,\n        e,\n      );\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [nextElements, flags.containsVisibleDifference];\n    }\n  }\n\n  public squash(delta: ElementsDelta): this {\n    if (delta.isEmpty()) {\n      return this;\n    }\n\n    const { added, removed, updated } = delta;\n\n    const mergeBoundElements = (\n      prevDelta: Delta<ElementPartial>,\n      nextDelta: Delta<ElementPartial>,\n    ) => {\n      const mergedDeletedBoundElements =\n        Delta.mergeArrays(\n          prevDelta.deleted.boundElements ?? [],\n          nextDelta.deleted.boundElements ?? [],\n          undefined,\n          (x) => x.id,\n        ) ?? [];\n\n      const mergedInsertedBoundElements =\n        Delta.mergeArrays(\n          prevDelta.inserted.boundElements ?? [],\n          nextDelta.inserted.boundElements ?? [],\n          undefined,\n          (x) => x.id,\n        ) ?? [];\n\n      if (\n        !mergedDeletedBoundElements.length &&\n        !mergedInsertedBoundElements.length\n      ) {\n        return;\n      }\n\n      return Delta.create(\n        {\n          boundElements: mergedDeletedBoundElements,\n        },\n        {\n          boundElements: mergedInsertedBoundElements,\n        },\n      );\n    };\n\n    for (const [id, nextDelta] of Object.entries(added)) {\n      const prevDelta = this.added[id] ?? this.removed[id] ?? this.updated[id];\n\n      if (!prevDelta) {\n        this.added[id] = nextDelta;\n      } else {\n        const mergedDelta = mergeBoundElements(prevDelta, nextDelta);\n        delete this.removed[id];\n        delete this.updated[id];\n\n        this.added[id] = Delta.merge(prevDelta, nextDelta, mergedDelta);\n      }\n    }\n\n    for (const [id, nextDelta] of Object.entries(removed)) {\n      const prevDelta = this.added[id] ?? this.removed[id] ?? this.updated[id];\n\n      if (!prevDelta) {\n        this.removed[id] = nextDelta;\n      } else {\n        const mergedDelta = mergeBoundElements(prevDelta, nextDelta);\n        delete this.added[id];\n        delete this.updated[id];\n\n        this.removed[id] = Delta.merge(prevDelta, nextDelta, mergedDelta);\n      }\n    }\n\n    for (const [id, nextDelta] of Object.entries(updated)) {\n      const prevDelta = this.added[id] ?? this.removed[id] ?? this.updated[id];\n\n      if (!prevDelta) {\n        this.updated[id] = nextDelta;\n      } else {\n        const mergedDelta = mergeBoundElements(prevDelta, nextDelta);\n        const updatedDelta = Delta.merge(prevDelta, nextDelta, mergedDelta);\n\n        if (prevDelta === this.added[id]) {\n          this.added[id] = updatedDelta;\n        } else if (prevDelta === this.removed[id]) {\n          this.removed[id] = updatedDelta;\n        } else {\n          this.updated[id] = updatedDelta;\n        }\n      }\n    }\n\n    if (isTestEnv() || isDevEnv()) {\n      ElementsDelta.validate(this, \"added\", ElementsDelta.satisfiesAddition);\n      ElementsDelta.validate(this, \"removed\", ElementsDelta.satisfiesRemoval);\n      ElementsDelta.validate(this, \"updated\", ElementsDelta.satisfiesUpdate);\n    }\n\n    return this;\n  }\n\n  private static createApplier =\n    (\n      prevElements: SceneElementsMap,\n      nextElements: SceneElementsMap,\n      snapshot: StoreSnapshot[\"elements\"],\n      flags: ApplyToFlags,\n      options?: ApplyToOptions,\n    ) =>\n    (deltas: Record<string, Delta<ElementPartial>>) => {\n      const getElement = ElementsDelta.createGetter(\n        nextElements,\n        snapshot,\n        flags,\n      );\n\n      return Object.entries(deltas).reduce((acc, [id, delta]) => {\n        const element = getElement(id, delta.inserted);\n\n        if (element) {\n          const nextElement = ElementsDelta.applyDelta(\n            element,\n            delta,\n            flags,\n            options,\n          );\n\n          nextElements.set(nextElement.id, nextElement);\n          acc.set(nextElement.id, nextElement);\n\n          if (!flags.applyDirection) {\n            const prevElement = prevElements.get(id);\n\n            if (prevElement) {\n              flags.applyDirection =\n                prevElement.version > nextElement.version\n                  ? \"backward\"\n                  : \"forward\";\n            }\n          }\n        }\n\n        return acc;\n      }, new Map<string, OrderedExcalidrawElement>());\n    };\n\n  private static createGetter =\n    (\n      elements: SceneElementsMap,\n      snapshot: StoreSnapshot[\"elements\"],\n      flags: ApplyToFlags,\n    ) =>\n    (id: string, partial: ElementPartial) => {\n      let element = elements.get(id);\n\n      if (!element) {\n        // always fallback to the local snapshot, in cases when we cannot find the element in the elements array\n        element = snapshot.get(id);\n\n        if (element) {\n          // as the element was brought from the snapshot, it automatically results in a possible zindex difference\n          flags.containsZindexDifference = true;\n\n          // as the element was force deleted, we need to check if adding it back results in a visible change\n          if (!partial.isDeleted || (partial.isDeleted && !element.isDeleted)) {\n            flags.containsVisibleDifference = true;\n          }\n        } else {\n          // not in elements, not in snapshot? element might have been added remotely!\n          element = newElementWith(\n            { id, version: 1 } as OrderedExcalidrawElement,\n            {\n              ...partial,\n            },\n          );\n        }\n      }\n\n      return element;\n    };\n\n  private static applyDelta(\n    element: OrderedExcalidrawElement,\n    delta: Delta<ElementPartial>,\n    flags: ApplyToFlags,\n    options?: ApplyToOptions,\n  ) {\n    const directlyApplicablePartial: Mutable<ElementPartial> = {};\n\n    // some properties are not directly applicable, such as:\n    // - boundElements which contains only diff)\n    // - version & versionNonce, if we don't want to return to previous versions\n    for (const key of Object.keys(delta.inserted) as Array<\n      keyof typeof delta.inserted\n    >) {\n      if (key === \"boundElements\") {\n        continue;\n      }\n\n      if (options?.excludedProperties?.has(key)) {\n        continue;\n      }\n\n      const value = delta.inserted[key];\n      Reflect.set(directlyApplicablePartial, key, value);\n    }\n\n    if (\n      delta.deleted.boundElements?.length ||\n      delta.inserted.boundElements?.length\n    ) {\n      const mergedBoundElements = Delta.mergeArrays(\n        element.boundElements,\n        delta.inserted.boundElements,\n        delta.deleted.boundElements,\n        (x) => x.id,\n      );\n\n      Object.assign(directlyApplicablePartial, {\n        boundElements: mergedBoundElements,\n      });\n    }\n\n    if (!flags.containsVisibleDifference) {\n      // strip away fractional index, as even if it would be different, it doesn't have to result in visible change\n      const { index, ...rest } = directlyApplicablePartial;\n      const containsVisibleDifference = ElementsDelta.checkForVisibleDifference(\n        element,\n        rest,\n      );\n\n      flags.containsVisibleDifference = containsVisibleDifference;\n    }\n\n    if (!flags.containsZindexDifference) {\n      flags.containsZindexDifference =\n        delta.deleted.index !== delta.inserted.index;\n    }\n\n    return newElementWith(element, directlyApplicablePartial, true);\n  }\n\n  /**\n   * Check for visible changes regardless of whether they were removed, added or updated.\n   */\n  private static checkForVisibleDifference(\n    element: OrderedExcalidrawElement,\n    partial: ElementPartial,\n  ) {\n    if (element.isDeleted && partial.isDeleted !== false) {\n      // when it's deleted and partial is not false, it cannot end up with a visible change\n      return false;\n    }\n\n    if (element.isDeleted && partial.isDeleted === false) {\n      // when we add an element, it results in a visible change\n      return true;\n    }\n\n    if (element.isDeleted === false && partial.isDeleted) {\n      // when we remove an element, it results in a visible change\n      return true;\n    }\n\n    // check for any difference on a visible element\n    return Delta.isRightDifferent(element, partial);\n  }\n\n  /**\n   * Resolves conflicts for all previously added, removed and updated elements.\n   * Updates the previous deltas with all the changes after conflict resolution.\n   *\n   * // TODO: revisit since some bound arrows seem to be often redrawn incorrectly\n   *\n   * @returns all elements affected by the conflict resolution\n   */\n  private resolveConflicts(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    applyDirection: \"forward\" | \"backward\" = \"forward\",\n  ) {\n    const nextAffectedElements = new Map<string, OrderedExcalidrawElement>();\n    const updater = (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => {\n      const nextElement = nextElements.get(element.id); // only ever modify next element!\n      if (!nextElement) {\n        return;\n      }\n\n      const prevElement = prevElements.get(element.id);\n      const nextVersion =\n        applyDirection === \"forward\"\n          ? nextElement.version + 1\n          : nextElement.version - 1;\n\n      const elementUpdates = updates as ElementUpdate<OrderedExcalidrawElement>;\n\n      let affectedElement: OrderedExcalidrawElement;\n\n      if (prevElement === nextElement) {\n        // create the new element instance in case we didn't modify the element yet\n        // so that we won't end up in an incosistent state in case we would fail in the middle of mutations\n        affectedElement = newElementWith(\n          nextElement,\n          {\n            ...elementUpdates,\n            version: nextVersion,\n          },\n          true,\n        );\n      } else {\n        affectedElement = mutateElement(nextElement, nextElements, {\n          ...elementUpdates,\n          // don't modify the version further, if it's already different\n          version:\n            prevElement?.version !== nextElement.version\n              ? nextElement.version\n              : nextVersion,\n        });\n      }\n\n      nextAffectedElements.set(affectedElement.id, affectedElement);\n      nextElements.set(affectedElement.id, affectedElement);\n    };\n\n    // removed delta is affecting the bindings always, as all the affected elements of the removed elements need to be unbound\n    for (const id of Object.keys(this.removed)) {\n      ElementsDelta.unbindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // added delta is affecting the bindings always, all the affected elements of the added elements need to be rebound\n    for (const id of Object.keys(this.added)) {\n      ElementsDelta.rebindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // updated delta is affecting the binding only in case it contains changed binding or bindable property\n    for (const [id] of Array.from(Object.entries(this.updated)).filter(\n      ([_, delta]) =>\n        Object.keys({ ...delta.deleted, ...delta.inserted }).find((prop) =>\n          bindingProperties.has(prop as BindingProp | BindableProp),\n        ),\n    )) {\n      const updatedElement = nextElements.get(id);\n      if (!updatedElement || updatedElement.isDeleted) {\n        // skip fixing bindings for updates on deleted elements\n        continue;\n      }\n\n      ElementsDelta.rebindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // filter only previous elements, which were now affected\n    const prevAffectedElements = new Map(\n      Array.from(prevElements).filter(([id]) => nextAffectedElements.has(id)),\n    );\n\n    // calculate complete deltas for affected elements, and squash them back to the current deltas\n    this.squash(\n      // technically we could do better here if perf. would become an issue\n      ElementsDelta.calculate(prevAffectedElements, nextAffectedElements),\n    );\n\n    return nextAffectedElements;\n  }\n\n  /**\n   * Non deleted affected elements of removed elements (before and after applying delta),\n   * should be unbound ~ bindings should not point from non deleted into the deleted element/s.\n   */\n  private static unbindAffected(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    id: string,\n    updater: (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    // the instance could have been updated, so make sure we are passing the latest element to each function below\n    const prevElement = () => prevElements.get(id); // element before removal\n    const nextElement = () => nextElements.get(id); // element after removal\n\n    BoundElement.unbindAffected(nextElements, prevElement(), updater);\n    BoundElement.unbindAffected(nextElements, nextElement(), updater);\n\n    BindableElement.unbindAffected(nextElements, prevElement(), updater);\n    BindableElement.unbindAffected(nextElements, nextElement(), updater);\n  }\n\n  /**\n   * Non deleted affected elements of added or updated element/s (before and after applying delta),\n   * should be rebound (if possible) with the current element ~ bindings should be bidirectional.\n   */\n  private static rebindAffected(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    id: string,\n    updater: (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    // the instance could have been updated, so make sure we are passing the latest element to each function below\n    const prevElement = () => prevElements.get(id); // element before addition / update\n    const nextElement = () => nextElements.get(id); // element after addition / update\n\n    BoundElement.unbindAffected(nextElements, prevElement(), updater);\n    BoundElement.rebindAffected(nextElements, nextElement(), updater);\n\n    BindableElement.unbindAffected(\n      nextElements,\n      prevElement(),\n      (element, updates) => {\n        // we cannot rebind arrows with bindable element so we don't unbind them at all during rebind (we still need to unbind them on removal)\n        // TODO: #7348 add startBinding / endBinding to the `BoundElement` context so that we could rebind arrows and remove this condition\n        if (isTextElement(element)) {\n          updater(element, updates);\n        }\n      },\n    );\n    BindableElement.rebindAffected(nextElements, nextElement(), updater);\n  }\n\n  public static redrawElements(\n    nextElements: SceneElementsMap,\n    changedElements: Map<string, OrderedExcalidrawElement>,\n  ) {\n    try {\n      // we don't have an up-to-date scene, as we can be just in the middle of applying history entry\n      // we also don't have a scene on the server\n      // so we are creating a temp scene just to query and mutate elements\n      const tempScene = new Scene(nextElements, { skipValidation: true });\n\n      ElementsDelta.redrawTextBoundingBoxes(tempScene, changedElements);\n\n      // needs ordered nextElements to avoid z-index binding issues\n      ElementsDelta.redrawBoundArrows(tempScene, changedElements);\n    } catch (e) {\n      console.error(`Couldn't redraw elements`, e);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return nextElements;\n    }\n  }\n\n  private static redrawTextBoundingBoxes(\n    scene: Scene,\n    changed: Map<string, OrderedExcalidrawElement>,\n  ) {\n    const elements = scene.getNonDeletedElementsMap();\n    const boxesToRedraw = new Map<\n      string,\n      { container: OrderedExcalidrawElement; boundText: ExcalidrawTextElement }\n    >();\n\n    for (const element of changed.values()) {\n      if (isBoundToContainer(element)) {\n        const { containerId } = element as ExcalidrawTextElement;\n        const container = containerId ? elements.get(containerId) : undefined;\n\n        if (container) {\n          boxesToRedraw.set(container.id, {\n            container,\n            boundText: element as ExcalidrawTextElement,\n          });\n        }\n      }\n\n      if (hasBoundTextElement(element)) {\n        const boundTextElementId = getBoundTextElementId(element);\n        const boundText = boundTextElementId\n          ? elements.get(boundTextElementId)\n          : undefined;\n\n        if (boundText) {\n          boxesToRedraw.set(element.id, {\n            container: element,\n            boundText: boundText as ExcalidrawTextElement,\n          });\n        }\n      }\n    }\n\n    for (const { container, boundText } of boxesToRedraw.values()) {\n      if (container.isDeleted || boundText.isDeleted) {\n        // skip redraw if one of them is deleted, as it would not result in a meaningful redraw\n        continue;\n      }\n\n      redrawTextBoundingBox(boundText, container, scene);\n    }\n  }\n\n  private static redrawBoundArrows(\n    scene: Scene,\n    changed: Map<string, OrderedExcalidrawElement>,\n  ) {\n    for (const element of changed.values()) {\n      if (!element.isDeleted && isBindableElement(element)) {\n        // TODO: with precise bindings this is quite expensive, so consider optimisation so it's only triggered when the arrow does not intersect (imprecise) element bounds\n        updateBoundElements(element, scene, {\n          changedElements: changed,\n        });\n      }\n    }\n  }\n\n  private static reorderElements(\n    elements: SceneElementsMap,\n    changed: Map<string, OrderedExcalidrawElement>,\n    flags: {\n      containsVisibleDifference: boolean;\n      containsZindexDifference: boolean;\n    },\n  ) {\n    if (!flags.containsZindexDifference) {\n      return elements;\n    }\n\n    const unordered = Array.from(elements.values());\n    const ordered = orderByFractionalIndex([...unordered]);\n    const moved = Delta.getRightDifferences(unordered, ordered, true).reduce(\n      (acc, arrayIndex) => {\n        const candidate = unordered[Number(arrayIndex)];\n        if (candidate && changed.has(candidate.id)) {\n          acc.set(candidate.id, candidate);\n        }\n\n        return acc;\n      },\n      new Map(),\n    );\n\n    if (!flags.containsVisibleDifference && moved.size) {\n      // we found a difference in order!\n      flags.containsVisibleDifference = true;\n    }\n\n    // synchronize all elements that were actually moved\n    // could fallback to synchronizing all invalid indices\n    return arrayToMap(syncMovedIndices(ordered, moved)) as typeof elements;\n  }\n\n  /**\n   * It is necessary to post process the partials in case of reference values,\n   * for which we need to calculate the real diff between `deleted` and `inserted`.\n   */\n  private static postProcess(\n    deleted: ElementPartial,\n    inserted: ElementPartial,\n  ): [ElementPartial, ElementPartial] {\n    try {\n      Delta.diffArrays(deleted, inserted, \"boundElements\", (x) => x.id);\n\n      // don't diff the points as:\n      // - we can't ensure the multiplayer order consistency without fractional index on each point\n      // - we prefer to not merge the points, as it might just lead to unexpected / incosistent results\n      const deletedPoints =\n        (\n          deleted as ElementPartial<\n            ExcalidrawFreeDrawElement | ExcalidrawLinearElement\n          >\n        ).points ?? [];\n\n      const insertedPoints =\n        (\n          inserted as ElementPartial<\n            ExcalidrawFreeDrawElement | ExcalidrawLinearElement\n          >\n        ).points ?? [];\n\n      if (!Delta.isDifferent(deletedPoints, insertedPoints)) {\n        // delete the points from delta if there is no difference, otherwise leave them as they were captured due to consistency\n        Reflect.deleteProperty(deleted, \"points\");\n        Reflect.deleteProperty(inserted, \"points\");\n      }\n    } catch (e) {\n      // if postprocessing fails, it does not make sense to bubble up, but let's make sure we know about it\n      console.error(`Couldn't postprocess elements delta.`);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [deleted, inserted];\n    }\n  }\n\n  private static stripIrrelevantProps(\n    partial: Partial<OrderedExcalidrawElement>,\n  ): ElementPartial {\n    const { id, updated, ...strippedPartial } = partial;\n\n    return strippedPartial;\n  }\n}\n", "import {\n  assertNever,\n  COLOR_PALETTE,\n  isDevEnv,\n  isTestEnv,\n  randomId,\n  Emitter,\n  toIterable,\n} from \"@excalidraw/common\";\n\nimport type App from \"@excalidraw/excalidraw/components/App\";\n\nimport type { DTO, ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport type { AppState, ObservedAppState } from \"@excalidraw/excalidraw/types\";\n\nimport { deepCopyElement } from \"./duplicate\";\nimport { newElementWith } from \"./mutateElement\";\n\nimport { ElementsDelta, AppStateDelta, Delta } from \"./delta\";\n\nimport {\n  syncInvalidIndicesImmutable,\n  hashElementsVersion,\n  hashString,\n  isInitializedImageElement,\n  isImageElement,\n} from \"./index\";\n\nimport type { ApplyToOptions } from \"./delta\";\n\nimport type {\n  ExcalidrawElement,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"./types\";\n\nexport const CaptureUpdateAction = {\n  /**\n   * Immediately undoable.\n   *\n   * Use for updates which should be captured.\n   * Should be used for most of the local updates, except ephemerals such as dragging or resizing.\n   *\n   * These updates will _immediately_ make it to the local undo / redo stacks.\n   */\n  IMMEDIATELY: \"IMMEDIATELY\",\n  /**\n   * Never undoable.\n   *\n   * Use for updates which should never be recorded, such as remote updates\n   * or scene initialization.\n   *\n   * These updates will _never_ make it to the local undo / redo stacks.\n   */\n  NEVER: \"NEVER\",\n  /**\n   * Eventually undoable.\n   *\n   * Use for updates which should not be captured immediately - likely\n   * exceptions which are part of some async multi-step process. Otherwise, all\n   * such updates would end up being captured with the next\n   * `CaptureUpdateAction.IMMEDIATELY` - triggered either by the next `updateScene`\n   * or internally by the editor.\n   *\n   * These updates will _eventually_ make it to the local undo / redo stacks.\n   */\n  EVENTUALLY: \"EVENTUALLY\",\n} as const;\n\nexport type CaptureUpdateActionType = ValueOf<typeof CaptureUpdateAction>;\n\ntype MicroActionsQueue = (() => void)[];\n\n/**\n * Store which captures the observed changes and emits them as `StoreIncrement` events.\n */\nexport class Store {\n  // for internal use by history\n  public readonly onDurableIncrementEmitter = new Emitter<[DurableIncrement]>();\n  // for public use as part of onIncrement API\n  public readonly onStoreIncrementEmitter = new Emitter<\n    [DurableIncrement | EphemeralIncrement]\n  >();\n\n  private scheduledMacroActions: Set<CaptureUpdateActionType> = new Set();\n  private scheduledMicroActions: MicroActionsQueue = [];\n\n  private _snapshot = StoreSnapshot.empty();\n\n  public get snapshot() {\n    return this._snapshot;\n  }\n\n  public set snapshot(snapshot: StoreSnapshot) {\n    this._snapshot = snapshot;\n  }\n\n  constructor(private readonly app: App) {}\n\n  public scheduleAction(action: CaptureUpdateActionType) {\n    this.scheduledMacroActions.add(action);\n    this.satisfiesScheduledActionsInvariant();\n  }\n\n  /**\n   * Use to schedule a delta calculation, which will consquentially be emitted as `DurableStoreIncrement` and pushed in the undo stack.\n   */\n  // TODO: Suspicious that this is called so many places. Seems error-prone.\n  public scheduleCapture() {\n    this.scheduleAction(CaptureUpdateAction.IMMEDIATELY);\n  }\n\n  /**\n   * Schedule special \"micro\" actions, to-be executed before the next commit, before it executes a scheduled \"macro\" action.\n   */\n  public scheduleMicroAction(\n    params:\n      | {\n          action: CaptureUpdateActionType;\n          elements: readonly ExcalidrawElement[] | undefined;\n          appState: AppState | ObservedAppState | undefined;\n        }\n      | {\n          action: typeof CaptureUpdateAction.IMMEDIATELY;\n          change: StoreChange;\n          delta: StoreDelta;\n        }\n      | {\n          action:\n            | typeof CaptureUpdateAction.NEVER\n            | typeof CaptureUpdateAction.EVENTUALLY;\n          change: StoreChange;\n        },\n  ) {\n    const { action } = params;\n\n    let change: StoreChange;\n\n    if (\"change\" in params) {\n      change = params.change;\n    } else {\n      // immediately create an immutable change of the scheduled updates,\n      // compared to the current state, so that they won't mutate later on during batching\n      // also, we have to compare against the current state,\n      // as comparing against the snapshot might include yet uncomitted changes (i.e. async freedraw / text / image, etc.)\n      const currentSnapshot = StoreSnapshot.create(\n        this.app.scene.getElementsMapIncludingDeleted(),\n        this.app.state,\n      );\n\n      const scheduledSnapshot = currentSnapshot.maybeClone(\n        action,\n        // let's sync invalid indices first, so that we could detect this change\n        // also have the synced elements immutable, so that we don't mutate elements,\n        // that are already in the scene, otherwise we wouldn't see any change\n        params.elements\n          ? syncInvalidIndicesImmutable(params.elements)\n          : undefined,\n        params.appState,\n      );\n\n      change = StoreChange.create(currentSnapshot, scheduledSnapshot);\n    }\n\n    const delta = \"delta\" in params ? params.delta : undefined;\n\n    this.scheduledMicroActions.push(() =>\n      this.processAction({\n        action,\n        change,\n        delta,\n      }),\n    );\n  }\n\n  /**\n   * Performs the incoming `CaptureUpdateAction` and emits the corresponding `StoreIncrement`.\n   * Emits `DurableStoreIncrement` when action is \"capture\", emits `EphemeralStoreIncrement` otherwise.\n   *\n   * @emits StoreIncrement\n   */\n  public commit(\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ): void {\n    // execute all scheduled micro actions first\n    // similar to microTasks, there can be many\n    this.flushMicroActions();\n\n    try {\n      // execute a single scheduled \"macro\" function\n      // similar to macro tasks, there can be only one within a single commit (loop)\n      const action = this.getScheduledMacroAction();\n      this.processAction({ action, elements, appState });\n    } finally {\n      this.satisfiesScheduledActionsInvariant();\n      // defensively reset all scheduled \"macro\" actions, possibly cleans up other runtime garbage\n      this.scheduledMacroActions = new Set();\n    }\n  }\n\n  /**\n   * Clears the store instance.\n   */\n  public clear(): void {\n    this.snapshot = StoreSnapshot.empty();\n    this.scheduledMacroActions = new Set();\n  }\n\n  /**\n   * Performs delta & change calculation and emits a durable increment.\n   *\n   * @emits StoreIncrement.\n   */\n  private emitDurableIncrement(\n    snapshot: StoreSnapshot,\n    change: StoreChange | undefined = undefined,\n    delta: StoreDelta | undefined = undefined,\n  ) {\n    const prevSnapshot = this.snapshot;\n\n    let storeChange: StoreChange;\n    let storeDelta: StoreDelta;\n\n    if (change) {\n      storeChange = change;\n    } else {\n      storeChange = StoreChange.create(prevSnapshot, snapshot);\n    }\n\n    if (delta) {\n      // we might have the delta already (i.e. when applying history entry), thus we don't need to calculate it again\n      // using the same instance, since in history we have a check against `HistoryEntry`, so that we don't re-record the same delta again\n      storeDelta = delta;\n    } else {\n      storeDelta = StoreDelta.calculate(prevSnapshot, snapshot);\n    }\n\n    if (!storeDelta.isEmpty()) {\n      const increment = new DurableIncrement(storeChange, storeDelta);\n\n      this.onDurableIncrementEmitter.trigger(increment);\n      this.onStoreIncrementEmitter.trigger(increment);\n    }\n  }\n\n  /**\n   * Performs change calculation and emits an ephemeral increment.\n   *\n   * @emits EphemeralStoreIncrement\n   */\n  private emitEphemeralIncrement(\n    snapshot: StoreSnapshot,\n    change: StoreChange | undefined = undefined,\n  ) {\n    let storeChange: StoreChange;\n\n    if (change) {\n      storeChange = change;\n    } else {\n      const prevSnapshot = this.snapshot;\n      storeChange = StoreChange.create(prevSnapshot, snapshot);\n    }\n\n    const increment = new EphemeralIncrement(storeChange);\n\n    // Notify listeners with the increment\n    this.onStoreIncrementEmitter.trigger(increment);\n  }\n\n  private applyChangeToSnapshot(change: StoreChange) {\n    const prevSnapshot = this.snapshot;\n    const nextSnapshot = this.snapshot.applyChange(change);\n\n    if (prevSnapshot === nextSnapshot) {\n      return null;\n    }\n\n    return nextSnapshot;\n  }\n\n  /**\n   * Clones the snapshot if there are changes detected.\n   */\n  private maybeCloneSnapshot(\n    action: CaptureUpdateActionType,\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ) {\n    if (!elements && !appState) {\n      return null;\n    }\n\n    const prevSnapshot = this.snapshot;\n    const nextSnapshot = this.snapshot.maybeClone(action, elements, appState);\n\n    if (prevSnapshot === nextSnapshot) {\n      return null;\n    }\n\n    return nextSnapshot;\n  }\n\n  private flushMicroActions() {\n    for (const microAction of this.scheduledMicroActions) {\n      try {\n        microAction();\n      } catch (error) {\n        console.error(`Failed to execute scheduled micro action`, error);\n      }\n    }\n\n    this.scheduledMicroActions = [];\n  }\n\n  private processAction(\n    params:\n      | {\n          action: CaptureUpdateActionType;\n          elements: SceneElementsMap | undefined;\n          appState: AppState | ObservedAppState | undefined;\n        }\n      | {\n          action: CaptureUpdateActionType;\n          change: StoreChange;\n          delta: StoreDelta | undefined;\n        },\n  ) {\n    const { action } = params;\n\n    // perf. optimisation, since \"EVENTUALLY\" does not update the snapshot,\n    // so if nobody is listening for increments, we don't need to even clone the snapshot\n    // as it's only needed for `StoreChange` computation inside `EphemeralIncrement`\n    if (\n      action === CaptureUpdateAction.EVENTUALLY &&\n      !this.onStoreIncrementEmitter.subscribers.length\n    ) {\n      return;\n    }\n\n    let nextSnapshot: StoreSnapshot | null;\n\n    if (\"change\" in params) {\n      nextSnapshot = this.applyChangeToSnapshot(params.change);\n    } else {\n      nextSnapshot = this.maybeCloneSnapshot(\n        action,\n        params.elements,\n        params.appState,\n      );\n    }\n\n    if (!nextSnapshot) {\n      // don't continue if there is not change detected\n      return;\n    }\n\n    const change = \"change\" in params ? params.change : undefined;\n    const delta = \"delta\" in params ? params.delta : undefined;\n\n    try {\n      switch (action) {\n        // only immediately emits a durable increment\n        case CaptureUpdateAction.IMMEDIATELY:\n          this.emitDurableIncrement(nextSnapshot, change, delta);\n          break;\n        // both never and eventually emit an ephemeral increment\n        case CaptureUpdateAction.NEVER:\n        case CaptureUpdateAction.EVENTUALLY:\n          this.emitEphemeralIncrement(nextSnapshot, change);\n          break;\n        default:\n          assertNever(action, `Unknown store action`);\n      }\n    } finally {\n      // update the snapshot no-matter what, as it would mess up with the next action\n      switch (action) {\n        // both immediately and never update the snapshot, unlike eventually\n        case CaptureUpdateAction.IMMEDIATELY:\n        case CaptureUpdateAction.NEVER:\n          this.snapshot = nextSnapshot;\n          break;\n      }\n    }\n  }\n\n  /**\n   * Returns the scheduled macro action.\n   */\n  private getScheduledMacroAction() {\n    let scheduledAction: CaptureUpdateActionType;\n\n    if (this.scheduledMacroActions.has(CaptureUpdateAction.IMMEDIATELY)) {\n      // Capture has a precedence over update, since it also performs snapshot update\n      scheduledAction = CaptureUpdateAction.IMMEDIATELY;\n    } else if (this.scheduledMacroActions.has(CaptureUpdateAction.NEVER)) {\n      // Update has a precedence over none, since it also emits an (ephemeral) increment\n      scheduledAction = CaptureUpdateAction.NEVER;\n    } else {\n      // Default is to emit ephemeral increment and don't update the snapshot\n      scheduledAction = CaptureUpdateAction.EVENTUALLY;\n    }\n\n    return scheduledAction;\n  }\n\n  /**\n   * Ensures that the scheduled actions invariant is satisfied.\n   */\n  private satisfiesScheduledActionsInvariant() {\n    if (\n      !(\n        this.scheduledMacroActions.size >= 0 &&\n        this.scheduledMacroActions.size <=\n          Object.keys(CaptureUpdateAction).length\n      )\n    ) {\n      const message = `There can be at most three store actions scheduled at the same time, but there are \"${this.scheduledMacroActions.size}\".`;\n      console.error(message, this.scheduledMacroActions.values());\n\n      if (isTestEnv() || isDevEnv()) {\n        throw new Error(message);\n      }\n    }\n  }\n}\n\n/**\n * Repsents a change to the store containing changed elements and appState.\n */\nexport class StoreChange {\n  // so figuring out what has changed should ideally be just quick reference checks\n  // TODO: we might need to have binary files here as well, in order to be drop-in replacement for `onChange`\n  private constructor(\n    public readonly elements: Record<string, OrderedExcalidrawElement>,\n    public readonly appState: Partial<ObservedAppState>,\n  ) {}\n\n  public static create(\n    prevSnapshot: StoreSnapshot,\n    nextSnapshot: StoreSnapshot,\n  ) {\n    const changedElements = nextSnapshot.getChangedElements(prevSnapshot);\n    const changedAppState = nextSnapshot.getChangedAppState(prevSnapshot);\n\n    return new StoreChange(changedElements, changedAppState);\n  }\n}\n\n/**\n * Encpasulates any change to the store (durable or ephemeral).\n */\nexport abstract class StoreIncrement {\n  protected constructor(\n    public readonly type: \"durable\" | \"ephemeral\",\n    public readonly change: StoreChange,\n  ) {}\n\n  public static isDurable(\n    increment: StoreIncrement,\n  ): increment is DurableIncrement {\n    return increment.type === \"durable\";\n  }\n\n  public static isEphemeral(\n    increment: StoreIncrement,\n  ): increment is EphemeralIncrement {\n    return increment.type === \"ephemeral\";\n  }\n}\n\n/**\n * Represents a durable change to the store.\n */\nexport class DurableIncrement extends StoreIncrement {\n  constructor(\n    public readonly change: StoreChange,\n    public readonly delta: StoreDelta,\n  ) {\n    super(\"durable\", change);\n  }\n}\n\n/**\n * Represents an ephemeral change to the store.\n */\nexport class EphemeralIncrement extends StoreIncrement {\n  constructor(public readonly change: StoreChange) {\n    super(\"ephemeral\", change);\n  }\n}\n\n/**\n * Represents a captured delta by the Store.\n */\nexport class StoreDelta {\n  protected constructor(\n    public readonly id: string,\n    public readonly elements: ElementsDelta,\n    public readonly appState: AppStateDelta,\n  ) {}\n\n  /**\n   * Create a new instance of `StoreDelta`.\n   */\n  public static create(\n    elements: ElementsDelta,\n    appState: AppStateDelta,\n    opts: {\n      id: string;\n    } = {\n      id: randomId(),\n    },\n  ) {\n    return new this(opts.id, elements, appState);\n  }\n\n  /**\n   * Calculate the delta between the previous and next snapshot.\n   */\n  public static calculate(\n    prevSnapshot: StoreSnapshot,\n    nextSnapshot: StoreSnapshot,\n  ) {\n    const elementsDelta = nextSnapshot.metadata.didElementsChange\n      ? ElementsDelta.calculate(prevSnapshot.elements, nextSnapshot.elements)\n      : ElementsDelta.empty();\n\n    const appStateDelta = nextSnapshot.metadata.didAppStateChange\n      ? AppStateDelta.calculate(prevSnapshot.appState, nextSnapshot.appState)\n      : AppStateDelta.empty();\n\n    return this.create(elementsDelta, appStateDelta);\n  }\n\n  /**\n   * Restore a store delta instance from a DTO.\n   */\n  public static restore(storeDeltaDTO: DTO<StoreDelta>) {\n    const { id, elements, appState } = storeDeltaDTO;\n    return new this(\n      id,\n      ElementsDelta.restore(elements),\n      AppStateDelta.restore(appState),\n    );\n  }\n\n  /**\n   * Parse and load the delta from the remote payload.\n   */\n  public static load({\n    id,\n    elements: { added, removed, updated },\n    appState: { delta: appStateDelta },\n  }: DTO<StoreDelta>) {\n    const elements = ElementsDelta.create(added, removed, updated);\n    const appState = AppStateDelta.create(appStateDelta);\n\n    return new this(id, elements, appState);\n  }\n\n  /**\n   * Squash the passed deltas into the aggregated delta instance.\n   */\n  public static squash(...deltas: StoreDelta[]) {\n    const aggregatedDelta = StoreDelta.empty();\n\n    for (const delta of deltas) {\n      aggregatedDelta.elements.squash(delta.elements);\n      aggregatedDelta.appState.squash(delta.appState);\n    }\n\n    return aggregatedDelta;\n  }\n\n  /**\n   * Inverse store delta, creates new instance of `StoreDelta`.\n   */\n  public static inverse(delta: StoreDelta) {\n    return this.create(delta.elements.inverse(), delta.appState.inverse());\n  }\n\n  /**\n   * Apply the delta to the passed elements and appState, does not modify the snapshot.\n   */\n  public static applyTo(\n    delta: StoreDelta,\n    elements: SceneElementsMap,\n    appState: AppState,\n    options?: ApplyToOptions,\n  ): [SceneElementsMap, AppState, boolean] {\n    const [nextElements, elementsContainVisibleChange] = delta.elements.applyTo(\n      elements,\n      StoreSnapshot.empty().elements,\n      options,\n    );\n\n    const [nextAppState, appStateContainsVisibleChange] =\n      delta.appState.applyTo(appState, nextElements);\n\n    const appliedVisibleChanges =\n      elementsContainVisibleChange || appStateContainsVisibleChange;\n\n    return [nextElements, nextAppState, appliedVisibleChanges];\n  }\n\n  /**\n   * Apply latest (remote) changes to the delta, creates new instance of `StoreDelta`.\n   */\n  public static applyLatestChanges(\n    delta: StoreDelta,\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    modifierOptions?: \"deleted\" | \"inserted\",\n  ): StoreDelta {\n    return this.create(\n      delta.elements.applyLatestChanges(\n        prevElements,\n        nextElements,\n        modifierOptions,\n      ),\n      delta.appState,\n      {\n        id: delta.id,\n      },\n    );\n  }\n\n  public static empty() {\n    return StoreDelta.create(ElementsDelta.empty(), AppStateDelta.empty());\n  }\n\n  public isEmpty() {\n    return this.elements.isEmpty() && this.appState.isEmpty();\n  }\n}\n\n/**\n * Represents a snapshot of the captured or updated changes in the store,\n * used for producing deltas and emitting `DurableStoreIncrement`s.\n */\nexport class StoreSnapshot {\n  private _lastChangedElementsHash: number = 0;\n  private _lastChangedAppStateHash: number = 0;\n\n  private constructor(\n    public readonly elements: SceneElementsMap,\n    public readonly appState: ObservedAppState,\n    public readonly metadata: {\n      didElementsChange: boolean;\n      didAppStateChange: boolean;\n      isEmpty?: boolean;\n    } = {\n      didElementsChange: false,\n      didAppStateChange: false,\n      isEmpty: false,\n    },\n  ) {}\n\n  public static create(\n    elements: SceneElementsMap,\n    appState: AppState | ObservedAppState,\n    metadata: {\n      didElementsChange: boolean;\n      didAppStateChange: boolean;\n    } = {\n      didElementsChange: false,\n      didAppStateChange: false,\n    },\n  ) {\n    return new StoreSnapshot(\n      elements,\n      isObservedAppState(appState) ? appState : getObservedAppState(appState),\n      metadata,\n    );\n  }\n\n  public static empty() {\n    return new StoreSnapshot(\n      new Map() as SceneElementsMap,\n      getDefaultObservedAppState(),\n      {\n        didElementsChange: false,\n        didAppStateChange: false,\n        isEmpty: true,\n      },\n    );\n  }\n\n  public getChangedElements(prevSnapshot: StoreSnapshot) {\n    const changedElements: Record<string, OrderedExcalidrawElement> = {};\n\n    for (const prevElement of toIterable(prevSnapshot.elements)) {\n      const nextElement = this.elements.get(prevElement.id);\n\n      if (!nextElement) {\n        changedElements[prevElement.id] = newElementWith(prevElement, {\n          isDeleted: true,\n        });\n      }\n    }\n\n    for (const nextElement of toIterable(this.elements)) {\n      // Due to the structural clone inside `maybeClone`, we can perform just these reference checks\n      if (prevSnapshot.elements.get(nextElement.id) !== nextElement) {\n        changedElements[nextElement.id] = nextElement;\n      }\n    }\n\n    return changedElements;\n  }\n\n  public getChangedAppState(\n    prevSnapshot: StoreSnapshot,\n  ): Partial<ObservedAppState> {\n    return Delta.getRightDifferences(\n      prevSnapshot.appState,\n      this.appState,\n    ).reduce(\n      (acc, key) =>\n        Object.assign(acc, {\n          [key]: this.appState[key as keyof ObservedAppState],\n        }),\n      {} as Partial<ObservedAppState>,\n    );\n  }\n\n  public isEmpty() {\n    return this.metadata.isEmpty;\n  }\n\n  /**\n   * Apply the change and return a new snapshot instance.\n   */\n  public applyChange(change: StoreChange): StoreSnapshot {\n    const nextElements = new Map(this.elements) as SceneElementsMap;\n\n    for (const [id, changedElement] of Object.entries(change.elements)) {\n      nextElements.set(id, changedElement);\n    }\n\n    const nextAppState = getObservedAppState({\n      ...this.appState,\n      ...change.appState,\n    });\n\n    return StoreSnapshot.create(nextElements, nextAppState, {\n      // by default we assume that change is different from what we have in the snapshot\n      // so that we trigger the delta calculation and if it isn't different, delta will be empty\n      didElementsChange: Object.keys(change.elements).length > 0,\n      didAppStateChange: Object.keys(change.appState).length > 0,\n    });\n  }\n\n  /**\n   * Efficiently clone the existing snapshot, only if we detected changes.\n   *\n   * @returns same instance if there are no changes detected, new instance otherwise.\n   */\n  public maybeClone(\n    action: CaptureUpdateActionType,\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ) {\n    const options = {\n      shouldCompareHashes: false,\n    };\n\n    if (action === CaptureUpdateAction.EVENTUALLY) {\n      // actions that do not update the snapshot immediately, must be additionally checked for changes against the latest hash\n      // as we are always comparing against the latest snapshot, so they would emit elements or appState as changed on every component update\n      // instead of just the first time the elements or appState actually changed\n      options.shouldCompareHashes = true;\n    }\n\n    const nextElementsSnapshot = this.maybeCreateElementsSnapshot(\n      elements,\n      options,\n    );\n    const nextAppStateSnapshot = this.maybeCreateAppStateSnapshot(\n      appState,\n      options,\n    );\n\n    let didElementsChange = false;\n    let didAppStateChange = false;\n\n    if (this.elements !== nextElementsSnapshot) {\n      didElementsChange = true;\n    }\n\n    if (this.appState !== nextAppStateSnapshot) {\n      didAppStateChange = true;\n    }\n\n    if (!didElementsChange && !didAppStateChange) {\n      return this;\n    }\n\n    const snapshot = new StoreSnapshot(\n      nextElementsSnapshot,\n      nextAppStateSnapshot,\n      {\n        didElementsChange,\n        didAppStateChange,\n      },\n    );\n\n    return snapshot;\n  }\n\n  private maybeCreateAppStateSnapshot(\n    appState: AppState | ObservedAppState | undefined,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): ObservedAppState {\n    if (!appState) {\n      return this.appState;\n    }\n\n    // Not watching over everything from the app state, just the relevant props\n    const nextAppStateSnapshot = !isObservedAppState(appState)\n      ? getObservedAppState(appState)\n      : appState;\n\n    const didAppStateChange = this.detectChangedAppState(\n      nextAppStateSnapshot,\n      options,\n    );\n\n    if (!didAppStateChange) {\n      return this.appState;\n    }\n\n    return nextAppStateSnapshot;\n  }\n\n  private maybeCreateElementsSnapshot(\n    elements: SceneElementsMap | undefined,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): SceneElementsMap {\n    if (!elements) {\n      return this.elements;\n    }\n\n    const changedElements = this.detectChangedElements(elements, options);\n\n    if (!changedElements?.size) {\n      return this.elements;\n    }\n\n    const elementsSnapshot = this.createElementsSnapshot(changedElements);\n    return elementsSnapshot;\n  }\n\n  private detectChangedAppState(\n    nextObservedAppState: ObservedAppState,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): boolean | undefined {\n    if (this.appState === nextObservedAppState) {\n      return;\n    }\n\n    const didAppStateChange = Delta.isRightDifferent(\n      this.appState,\n      nextObservedAppState,\n    );\n\n    if (!didAppStateChange) {\n      return;\n    }\n\n    const changedAppStateHash = hashString(\n      JSON.stringify(nextObservedAppState),\n    );\n\n    if (\n      options.shouldCompareHashes &&\n      this._lastChangedAppStateHash === changedAppStateHash\n    ) {\n      return;\n    }\n\n    this._lastChangedAppStateHash = changedAppStateHash;\n\n    return didAppStateChange;\n  }\n\n  /**\n   * Detect if there are any changed elements.\n   */\n  private detectChangedElements(\n    nextElements: SceneElementsMap,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): SceneElementsMap | undefined {\n    if (this.elements === nextElements) {\n      return;\n    }\n\n    const changedElements: SceneElementsMap = new Map() as SceneElementsMap;\n\n    for (const prevElement of toIterable(this.elements)) {\n      const nextElement = nextElements.get(prevElement.id);\n\n      if (!nextElement) {\n        // element was deleted\n        changedElements.set(\n          prevElement.id,\n          newElementWith(prevElement, { isDeleted: true }),\n        );\n      }\n    }\n\n    for (const nextElement of toIterable(nextElements)) {\n      const prevElement = this.elements.get(nextElement.id);\n\n      if (\n        !prevElement || // element was added\n        prevElement.version < nextElement.version // element was updated\n      ) {\n        if (\n          isImageElement(nextElement) &&\n          !isInitializedImageElement(nextElement)\n        ) {\n          // ignore any updates on uninitialized image elements\n          continue;\n        }\n\n        changedElements.set(nextElement.id, nextElement);\n      }\n    }\n\n    if (!changedElements.size) {\n      return;\n    }\n\n    const changedElementsHash = hashElementsVersion(changedElements);\n\n    if (\n      options.shouldCompareHashes &&\n      this._lastChangedElementsHash === changedElementsHash\n    ) {\n      return;\n    }\n\n    this._lastChangedElementsHash = changedElementsHash;\n\n    return changedElements;\n  }\n\n  /**\n   * Perform structural clone, deep cloning only elements that changed.\n   */\n  private createElementsSnapshot(changedElements: SceneElementsMap) {\n    const clonedElements = new Map() as SceneElementsMap;\n\n    for (const prevElement of toIterable(this.elements)) {\n      // Clone previous elements, never delete, in case nextElements would be just a subset of previous elements\n      // i.e. during collab, persist or whenenever isDeleted elements get cleared\n      clonedElements.set(prevElement.id, prevElement);\n    }\n\n    for (const changedElement of toIterable(changedElements)) {\n      // TODO: consider just creating new instance, once we can ensure that all reference properties on every element are immutable\n      // TODO: consider creating a lazy deep clone, having a one-time-usage proxy over the snapshotted element and deep cloning only if it gets mutated\n      clonedElements.set(changedElement.id, deepCopyElement(changedElement));\n    }\n\n    return clonedElements;\n  }\n}\n\n// hidden non-enumerable property for runtime checks\nconst hiddenObservedAppStateProp = \"__observedAppState\";\n\nconst getDefaultObservedAppState = (): ObservedAppState => {\n  return {\n    name: null,\n    editingGroupId: null,\n    viewBackgroundColor: COLOR_PALETTE.white,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    selectedLinearElement: null,\n    croppingElementId: null,\n    activeLockedId: null,\n    lockedMultiSelections: {},\n  };\n};\n\nexport const getObservedAppState = (\n  appState: AppState | ObservedAppState,\n): ObservedAppState => {\n  const observedAppState = {\n    name: appState.name,\n    editingGroupId: appState.editingGroupId,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    croppingElementId: appState.croppingElementId,\n    activeLockedId: appState.activeLockedId,\n    lockedMultiSelections: appState.lockedMultiSelections,\n    selectedLinearElement: appState.selectedLinearElement\n      ? {\n          elementId: appState.selectedLinearElement.elementId,\n          isEditing: !!appState.selectedLinearElement.isEditing,\n        }\n      : null,\n  };\n\n  Reflect.defineProperty(observedAppState, hiddenObservedAppStateProp, {\n    value: true,\n    enumerable: false,\n  });\n\n  return observedAppState;\n};\n\nconst isObservedAppState = (\n  appState: AppState | ObservedAppState,\n): appState is ObservedAppState =>\n  !!Reflect.get(appState, hiddenObservedAppStateProp);\n", "import {\n  ORIG_ID,\n  randomId,\n  randomInteger,\n  arrayToMap,\n  castArray,\n  findLastIndex,\n  getUpdatedTimestamp,\n  isTestEnv,\n} from \"@excalidraw/common\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport {\n  getElementsInGroup,\n  getNewGroupIdsForDuplication,\n  getSelectedGroupForElement,\n} from \"./groups\";\n\nimport {\n  bindElementsToFramesAfterDuplication,\n  getFrameChildren,\n} from \"./frame\";\n\nimport { normalizeElementOrder } from \"./sortElements\";\n\nimport { bumpVersion } from \"./mutateElement\";\n\nimport {\n  hasBoundTextElement,\n  isBoundToContainer,\n  isFrameLikeElement,\n} from \"./typeChecks\";\n\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\n\nimport { fixDuplicatedBindingsAfterDuplication } from \"./binding\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  GroupId,\n  NonDeletedSceneElementsMap,\n} from \"./types\";\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n */\nexport const duplicateElement = <TElement extends ExcalidrawElement>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  randomizeSeed?: boolean,\n): Readonly<TElement> => {\n  const copy = deepCopyElement(element);\n\n  if (isTestEnv()) {\n    __test__defineOrigId(copy, element.id);\n  }\n\n  copy.id = randomId();\n  copy.updated = getUpdatedTimestamp();\n  if (randomizeSeed) {\n    copy.seed = randomInteger();\n    bumpVersion(copy);\n  }\n\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  return copy;\n};\n\nexport const duplicateElements = (\n  opts: {\n    elements: readonly ExcalidrawElement[];\n    randomizeSeed?: boolean;\n    overrides?: (data: {\n      duplicateElement: ExcalidrawElement;\n      origElement: ExcalidrawElement;\n      origIdToDuplicateId: Map<\n        ExcalidrawElement[\"id\"],\n        ExcalidrawElement[\"id\"]\n      >;\n    }) => Partial<ExcalidrawElement>;\n  } & (\n    | {\n        /**\n         * Duplicates all elements in array.\n         *\n         * Use this when programmaticaly duplicating elements, without direct\n         * user interaction.\n         */\n        type: \"everything\";\n      }\n    | {\n        /**\n         * Duplicates specified elements and inserts them back into the array\n         * in specified order.\n         *\n         * Use this when duplicating Scene elements, during user interaction\n         * such as alt-drag or on duplicate action.\n         */\n        type: \"in-place\";\n        idsOfElementsToDuplicate: Map<\n          ExcalidrawElement[\"id\"],\n          ExcalidrawElement\n        >;\n        appState: {\n          editingGroupId: AppState[\"editingGroupId\"];\n          selectedGroupIds: AppState[\"selectedGroupIds\"];\n        };\n      }\n  ),\n) => {\n  let { elements } = opts;\n\n  const appState =\n    \"appState\" in opts\n      ? opts.appState\n      : ({\n          editingGroupId: null,\n          selectedGroupIds: {},\n        } as const);\n\n  // Ids of elements that have already been processed so we don't push them\n  // into the array twice if we end up backtracking when retrieving\n  // discontiguous group of elements (can happen due to a bug, or in edge\n  // cases such as a group containing deleted elements which were not selected).\n  //\n  // This is not enough to prevent duplicates, so we do a second loop afterwards\n  // to remove them.\n  //\n  // For convenience we mark even the newly created ones even though we don't\n  // loop over them.\n  const processedIds = new Map<ExcalidrawElement[\"id\"], true>();\n  const groupIdMap = new Map();\n  const duplicatedElements: ExcalidrawElement[] = [];\n  const origElements: ExcalidrawElement[] = [];\n  const origIdToDuplicateId = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[\"id\"]\n  >();\n  const duplicateIdToOrigElement = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >();\n  const duplicateElementsMap = new Map<string, ExcalidrawElement>();\n  const elementsMap = arrayToMap(elements) as ElementsMap;\n  const _idsOfElementsToDuplicate =\n    opts.type === \"in-place\"\n      ? opts.idsOfElementsToDuplicate\n      : new Map(elements.map((el) => [el.id, el]));\n\n  // For sanity\n  if (opts.type === \"in-place\") {\n    for (const groupId of Object.keys(opts.appState.selectedGroupIds)) {\n      elements\n        .filter((el) => el.groupIds?.includes(groupId))\n        .forEach((el) => _idsOfElementsToDuplicate.set(el.id, el));\n    }\n  }\n\n  elements = normalizeElementOrder(elements);\n\n  const elementsWithDuplicates: ExcalidrawElement[] = elements.slice();\n\n  // helper functions\n  // -------------------------------------------------------------------------\n\n  // Used for the heavy lifing of copying a single element, a group of elements\n  // an element with bound text etc.\n  const copyElements = <T extends ExcalidrawElement | ExcalidrawElement[]>(\n    element: T,\n  ): T extends ExcalidrawElement[]\n    ? ExcalidrawElement[]\n    : ExcalidrawElement | null => {\n    const elements = castArray(element);\n\n    const _newElements = elements.reduce(\n      (acc: ExcalidrawElement[], element) => {\n        if (processedIds.has(element.id)) {\n          return acc;\n        }\n\n        processedIds.set(element.id, true);\n\n        const newElement = duplicateElement(\n          appState.editingGroupId,\n          groupIdMap,\n          element,\n          opts.randomizeSeed,\n        );\n\n        processedIds.set(newElement.id, true);\n\n        duplicateElementsMap.set(newElement.id, newElement);\n        origIdToDuplicateId.set(element.id, newElement.id);\n        duplicateIdToOrigElement.set(newElement.id, element);\n\n        origElements.push(element);\n        duplicatedElements.push(newElement);\n\n        acc.push(newElement);\n        return acc;\n      },\n      [],\n    );\n\n    return (\n      Array.isArray(element) ? _newElements : _newElements[0] || null\n    ) as T extends ExcalidrawElement[]\n      ? ExcalidrawElement[]\n      : ExcalidrawElement | null;\n  };\n\n  // Helper to position cloned elements in the Z-order the product needs it\n  const insertBeforeOrAfterIndex = (\n    index: number,\n    elements: ExcalidrawElement | null | ExcalidrawElement[],\n  ) => {\n    if (!elements) {\n      return;\n    }\n\n    if (index > elementsWithDuplicates.length - 1) {\n      elementsWithDuplicates.push(...castArray(elements));\n      return;\n    }\n\n    elementsWithDuplicates.splice(index + 1, 0, ...castArray(elements));\n  };\n\n  const frameIdsToDuplicate = new Set(\n    elements\n      .filter(\n        (el) => _idsOfElementsToDuplicate.has(el.id) && isFrameLikeElement(el),\n      )\n      .map((el) => el.id),\n  );\n\n  for (const element of elements) {\n    if (processedIds.has(element.id)) {\n      continue;\n    }\n\n    if (!_idsOfElementsToDuplicate.has(element.id)) {\n      continue;\n    }\n\n    // groups\n    // -------------------------------------------------------------------------\n\n    const groupId = getSelectedGroupForElement(appState, element);\n    if (groupId) {\n      const groupElements = getElementsInGroup(elements, groupId).flatMap(\n        (element) =>\n          isFrameLikeElement(element)\n            ? [...getFrameChildren(elements, element.id), element]\n            : [element],\n      );\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.groupIds?.includes(groupId);\n      });\n\n      insertBeforeOrAfterIndex(targetIndex, copyElements(groupElements));\n      continue;\n    }\n\n    // frame duplication\n    // -------------------------------------------------------------------------\n\n    if (element.frameId && frameIdsToDuplicate.has(element.frameId)) {\n      continue;\n    }\n\n    if (isFrameLikeElement(element)) {\n      const frameId = element.id;\n\n      const frameChildren = getFrameChildren(elements, frameId);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.frameId === frameId || el.id === frameId;\n      });\n\n      insertBeforeOrAfterIndex(\n        targetIndex,\n        copyElements([...frameChildren, element]),\n      );\n      continue;\n    }\n\n    // text container\n    // -------------------------------------------------------------------------\n\n    if (hasBoundTextElement(element)) {\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return (\n          el.id === element.id ||\n          (\"containerId\" in el && el.containerId === element.id)\n        );\n      });\n\n      if (boundTextElement) {\n        insertBeforeOrAfterIndex(\n          targetIndex,\n          copyElements([element, boundTextElement]),\n        );\n      } else {\n        insertBeforeOrAfterIndex(targetIndex, copyElements(element));\n      }\n\n      continue;\n    }\n\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.id === element.id || el.id === container?.id;\n      });\n\n      if (container) {\n        insertBeforeOrAfterIndex(\n          targetIndex,\n          copyElements([container, element]),\n        );\n      } else {\n        insertBeforeOrAfterIndex(targetIndex, copyElements(element));\n      }\n\n      continue;\n    }\n\n    // default duplication (regular elements)\n    // -------------------------------------------------------------------------\n\n    insertBeforeOrAfterIndex(\n      findLastIndex(elementsWithDuplicates, (el) => el.id === element.id),\n      copyElements(element),\n    );\n  }\n\n  // ---------------------------------------------------------------------------\n\n  fixDuplicatedBindingsAfterDuplication(\n    duplicatedElements,\n    origIdToDuplicateId,\n    duplicateElementsMap as NonDeletedSceneElementsMap,\n  );\n\n  bindElementsToFramesAfterDuplication(\n    elementsWithDuplicates,\n    origElements,\n    origIdToDuplicateId,\n  );\n\n  if (opts.overrides) {\n    for (const duplicateElement of duplicatedElements) {\n      const origElement = duplicateIdToOrigElement.get(duplicateElement.id);\n      if (origElement) {\n        Object.assign(\n          duplicateElement,\n          opts.overrides({\n            duplicateElement,\n            origElement,\n            origIdToDuplicateId,\n          }),\n        );\n      }\n    }\n  }\n\n  return {\n    duplicatedElements,\n    duplicateElementsMap,\n    elementsWithDuplicates,\n    origIdToDuplicateId,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement.\n//\n// Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n// Typed arrays and other non-null objects.\n//\n// Adapted from https://github.com/lukeed/klona\n//\n// The reason for `deepCopyElement()` wrapper is type safety (only allow\n// passing ExcalidrawElement as the top-level argument).\nconst _deepCopyElement = (val: any, depth: number = 0) => {\n  // only clone non-primitives\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  const objectType = Object.prototype.toString.call(val);\n\n  if (objectType === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy non-serializable objects like these caches. They'll be\n        // populated when the element is rendered.\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = _deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = _deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  // we're not cloning non-array & non-plain-object objects because we\n  // don't support them on excalidraw elements yet. If we do, we need to make\n  // sure we start cloning them, so let's warn about it.\n  if (import.meta.env.DEV) {\n    if (\n      objectType !== \"[object Object]\" &&\n      objectType !== \"[object Array]\" &&\n      objectType.startsWith(\"[object \")\n    ) {\n      console.warn(\n        `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`,\n      );\n    }\n  }\n\n  return val;\n};\n\n/**\n * Clones ExcalidrawElement data structure. Does not regenerate id, nonce, or\n * any value. The purpose is to to break object references for immutability\n * reasons, whenever we want to keep the original element, but ensure it's not\n * mutated.\n *\n * Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n * Typed arrays and other non-null objects.\n */\nexport const deepCopyElement = <T extends ExcalidrawElement>(\n  val: T,\n): Mutable<T> => {\n  return _deepCopyElement(val);\n};\n\nconst __test__defineOrigId = (clonedObj: object, origId: string) => {\n  Object.defineProperty(clonedObj, ORIG_ID, {\n    value: origId,\n    writable: false,\n    enumerable: false,\n  });\n};\n", "import { arrayToMapWithIndex } from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\nconst normalizeGroupElementOrder = (elements: readonly ExcalidrawElement[]) => {\n  const origElements: ExcalidrawElement[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  const orderInnerGroups = (\n    elements: readonly ExcalidrawElement[],\n  ): ExcalidrawElement[] => {\n    const firstGroupSig = elements[0]?.groupIds?.join(\"\");\n    const aGroup: ExcalidrawElement[] = [elements[0]];\n    const bGroup: ExcalidrawElement[] = [];\n    for (const element of elements.slice(1)) {\n      if (element.groupIds?.join(\"\") === firstGroupSig) {\n        aGroup.push(element);\n      } else {\n        bGroup.push(element);\n      }\n    }\n    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;\n  };\n\n  const groupHandledElements = new Map<string, true>();\n\n  origElements.forEach((element, idx) => {\n    if (groupHandledElements.has(element.id)) {\n      return;\n    }\n    if (element.groupIds?.length) {\n      const topGroup = element.groupIds[element.groupIds.length - 1];\n      const groupElements = origElements.slice(idx).filter((element) => {\n        const ret = element?.groupIds?.some((id) => id === topGroup);\n        if (ret) {\n          groupHandledElements.set(element!.id, true);\n        }\n        return ret;\n      });\n\n      for (const elem of orderInnerGroups(groupElements)) {\n        sortedElements.add(elem);\n      }\n    } else {\n      sortedElements.add(element);\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\n/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */\nconst normalizeBoundElementsOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const elementsMap = arrayToMapWithIndex(elements);\n\n  const origElements: (ExcalidrawElement | null)[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  origElements.forEach((element, idx) => {\n    if (!element) {\n      return;\n    }\n    if (element.boundElements?.length) {\n      sortedElements.add(element);\n      origElements[idx] = null;\n      element.boundElements.forEach((boundElement) => {\n        const child = elementsMap.get(boundElement.id);\n        if (child && boundElement.type === \"text\") {\n          sortedElements.add(child[0]);\n          origElements[child[1]] = null;\n        }\n      });\n    } else if (element.type === \"text\" && element.containerId) {\n      const parent = elementsMap.get(element.containerId);\n      if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {\n        sortedElements.add(element);\n        origElements[idx] = null;\n\n        // if element has a container and container lists it, skip this element\n        // as it'll be taken care of by the container\n      }\n    } else {\n      sortedElements.add(element);\n      origElements[idx] = null;\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\n      \"normalizeBoundElementsOrder: lost some elements... bailing!\",\n    );\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\nexport const normalizeElementOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  return normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));\n};\n", "import { generateNKeysBetween } from \"fractional-indexing\";\n\nimport { arrayToMap } from \"@excalidraw/common\";\n\nimport { mutateElement, newElementWith } from \"./mutateElement\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { hasBoundTextElement } from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  FractionalIndex,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"./types\";\n\nexport class InvalidFractionalIndexError extends Error {\n  public code = \"ELEMENT_HAS_INVALID_INDEX\" as const;\n}\n\n/**\n * Envisioned relation between array order and fractional indices:\n *\n * 1) Array (or array-like ordered data structure) should be used as a cache of elements order, hiding the internal fractional indices implementation.\n * - it's undesirable to perform reorder for each related operation, therefore it's necessary to cache the order defined by fractional indices into an ordered data structure\n * - it's easy enough to define the order of the elements from the outside (boundaries), without worrying about the underlying structure of fractional indices (especially for the host apps)\n * - it's necessary to always keep the array support for backwards compatibility (restore) - old scenes, old libraries, supporting multiple excalidraw versions etc.\n * - it's necessary to always keep the fractional indices in sync with the array order\n * - elements with invalid indices should be detected and synced, without altering the already valid indices\n *\n * 2) Fractional indices should be used to reorder the elements, whenever the cached order is expected to be invalidated.\n * - as the fractional indices are encoded as part of the elements, it opens up possibilities for incremental-like APIs\n * - re-order based on fractional indices should be part of (multiplayer) operations such as reconciliation & undo/redo\n * - technically all the z-index actions could perform also re-order based on fractional indices,but in current state it would not bring much benefits,\n *   as it's faster & more efficient to perform re-order based on array manipulation and later synchronisation of moved indices with the array order\n */\n\n/**\n * Ensure that all elements have valid fractional indices.\n *\n * @throws `InvalidFractionalIndexError` if invalid index is detected.\n */\nexport const validateFractionalIndices = (\n  elements: readonly ExcalidrawElement[],\n  {\n    shouldThrow = false,\n    includeBoundTextValidation = false,\n    ignoreLogs,\n    reconciliationContext,\n  }: {\n    shouldThrow: boolean;\n    includeBoundTextValidation: boolean;\n    ignoreLogs?: true;\n    reconciliationContext?: {\n      localElements: ReadonlyArray<ExcalidrawElement>;\n      remoteElements: ReadonlyArray<ExcalidrawElement>;\n    };\n  },\n) => {\n  const errorMessages = [];\n  const stringifyElement = (element: ExcalidrawElement | void) =>\n    `${element?.index}:${element?.id}:${element?.type}:${element?.isDeleted}:${element?.version}:${element?.versionNonce}`;\n\n  const indices = elements.map((x) => x.index);\n  for (const [i, index] of indices.entries()) {\n    const predecessorIndex = indices[i - 1];\n    const successorIndex = indices[i + 1];\n\n    if (!isValidFractionalIndex(index, predecessorIndex, successorIndex)) {\n      errorMessages.push(\n        `Fractional indices invariant has been compromised: \"${stringifyElement(\n          elements[i - 1],\n        )}\", \"${stringifyElement(elements[i])}\", \"${stringifyElement(\n          elements[i + 1],\n        )}\"`,\n      );\n    }\n\n    // disabled by default, as we don't fix it\n    if (includeBoundTextValidation && hasBoundTextElement(elements[i])) {\n      const container = elements[i];\n      const text = getBoundTextElement(container, arrayToMap(elements));\n\n      if (text && text.index! <= container.index!) {\n        errorMessages.push(\n          `Fractional indices invariant for bound elements has been compromised: \"${stringifyElement(\n            text,\n          )}\", \"${stringifyElement(container)}\"`,\n        );\n      }\n    }\n  }\n\n  if (errorMessages.length) {\n    const error = new InvalidFractionalIndexError();\n    const additionalContext = [];\n\n    if (reconciliationContext) {\n      additionalContext.push(\"Additional reconciliation context:\");\n      additionalContext.push(\n        reconciliationContext.localElements.map((x) => stringifyElement(x)),\n      );\n      additionalContext.push(\n        reconciliationContext.remoteElements.map((x) => stringifyElement(x)),\n      );\n    }\n\n    if (!ignoreLogs) {\n      // report just once and with the stacktrace\n      console.error(\n        errorMessages.join(\"\\n\\n\"),\n        error.stack,\n        elements.map((x) => stringifyElement(x)),\n        ...additionalContext,\n      );\n    }\n\n    if (shouldThrow) {\n      // if enabled, gather all the errors first, throw once\n      throw error;\n    }\n  }\n};\n\n/**\n * Order the elements based on the fractional indices.\n * - when fractional indices are identical, break the tie based on the element id\n * - when there is no fractional index in one of the elements, respect the order of the array\n */\nexport const orderByFractionalIndex = (\n  elements: OrderedExcalidrawElement[],\n) => {\n  return elements.sort((a, b) => {\n    // in case the indices are not the defined at runtime\n    if (isOrderedElement(a) && isOrderedElement(b)) {\n      if (a.index < b.index) {\n        return -1;\n      } else if (a.index > b.index) {\n        return 1;\n      }\n\n      // break ties based on the element id\n      return a.id < b.id ? -1 : 1;\n    }\n\n    // defensively keep the array order\n    return 1;\n  });\n};\n\n/**\n * Synchronizes invalid fractional indices of moved elements with the array order by mutating passed elements.\n * If the synchronization fails or the result is invalid, it fallbacks to `syncInvalidIndices`.\n */\nexport const syncMovedIndices = (\n  elements: readonly ExcalidrawElement[],\n  movedElements: ElementsMap,\n): OrderedExcalidrawElement[] => {\n  try {\n    const elementsMap = arrayToMap(elements);\n    const indicesGroups = getMovedIndicesGroups(elements, movedElements);\n\n    // try generatating indices, throws on invalid movedElements\n    const elementsUpdates = generateIndices(elements, indicesGroups);\n    const elementsCandidates = elements.map((x) => {\n      const elementUpdates = elementsUpdates.get(x);\n\n      if (elementUpdates) {\n        return { ...x, index: elementUpdates.index };\n      }\n\n      return x;\n    });\n\n    // ensure next indices are valid before mutation, throws on invalid ones\n    validateFractionalIndices(\n      elementsCandidates,\n      // we don't autofix invalid bound text indices, hence don't include it in the validation\n      {\n        includeBoundTextValidation: false,\n        shouldThrow: true,\n        ignoreLogs: true,\n      },\n    );\n\n    // split mutation so we don't end up in an incosistent state\n    for (const [element, { index }] of elementsUpdates) {\n      mutateElement(element, elementsMap, { index });\n    }\n  } catch (e) {\n    // fallback to default sync\n    syncInvalidIndices(elements);\n  }\n\n  return elements as OrderedExcalidrawElement[];\n};\n\n/**\n * Synchronizes all invalid fractional indices within the array order by mutating elements in the passed array.\n *\n * WARN: in edge cases it could modify the elements which were not moved, as it's impossible to guess the actually moved elements from the elements array itself.\n */\nexport const syncInvalidIndices = (\n  elements: readonly ExcalidrawElement[],\n): OrderedExcalidrawElement[] => {\n  const elementsMap = arrayToMap(elements);\n  const indicesGroups = getInvalidIndicesGroups(elements);\n  const elementsUpdates = generateIndices(elements, indicesGroups);\n\n  for (const [element, { index }] of elementsUpdates) {\n    mutateElement(element, elementsMap, { index });\n  }\n\n  return elements as OrderedExcalidrawElement[];\n};\n\n/**\n * Synchronizes all invalid fractional indices within the array order by creating new instances of elements with corrected indices.\n *\n * WARN: in edge cases it could modify the elements which were not moved, as it's impossible to guess the actually moved elements from the elements array itself.\n */\nexport const syncInvalidIndicesImmutable = (\n  elements: readonly ExcalidrawElement[],\n): SceneElementsMap | undefined => {\n  const syncedElements = arrayToMap(elements);\n  const indicesGroups = getInvalidIndicesGroups(elements);\n  const elementsUpdates = generateIndices(elements, indicesGroups);\n\n  for (const [element, { index }] of elementsUpdates) {\n    syncedElements.set(element.id, newElementWith(element, { index }));\n  }\n\n  return syncedElements as SceneElementsMap;\n};\n\n/**\n * Get contiguous groups of indices of passed moved elements.\n *\n * NOTE: First and last elements within the groups are indices of lower and upper bounds.\n */\nconst getMovedIndicesGroups = (\n  elements: readonly ExcalidrawElement[],\n  movedElements: ElementsMap,\n) => {\n  const indicesGroups: number[][] = [];\n\n  let i = 0;\n\n  while (i < elements.length) {\n    if (movedElements.has(elements[i].id)) {\n      const indicesGroup = [i - 1, i]; // push the lower bound index as the first item\n\n      while (++i < elements.length) {\n        if (!movedElements.has(elements[i].id)) {\n          break;\n        }\n\n        indicesGroup.push(i);\n      }\n\n      indicesGroup.push(i); // push the upper bound index as the last item\n      indicesGroups.push(indicesGroup);\n    } else {\n      i++;\n    }\n  }\n\n  return indicesGroups;\n};\n\n/**\n * Gets contiguous groups of all invalid indices automatically detected inside the elements array.\n *\n * WARN: First and last items within the groups do NOT have to be contiguous, those are the found lower and upper bounds!\n */\nconst getInvalidIndicesGroups = (elements: readonly ExcalidrawElement[]) => {\n  const indicesGroups: number[][] = [];\n\n  // once we find lowerBound / upperBound, it cannot be lower than that, so we cache it for better perf.\n  let lowerBound: ExcalidrawElement[\"index\"] | undefined = undefined;\n  let upperBound: ExcalidrawElement[\"index\"] | undefined = undefined;\n  let lowerBoundIndex: number = -1;\n  let upperBoundIndex: number = 0;\n\n  /** @returns maybe valid lowerBound */\n  const getLowerBound = (\n    index: number,\n  ): [ExcalidrawElement[\"index\"] | undefined, number] => {\n    const lowerBound = elements[lowerBoundIndex]\n      ? elements[lowerBoundIndex].index\n      : undefined;\n\n    // we are already iterating left to right, therefore there is no need for additional looping\n    const candidate = elements[index - 1]?.index;\n\n    if (\n      (!lowerBound && candidate) || // first lowerBound\n      (lowerBound && candidate && candidate > lowerBound) // next lowerBound\n    ) {\n      // WARN: candidate's index could be higher or same as the current element's index\n      return [candidate, index - 1];\n    }\n\n    // cache hit! take the last lower bound\n    return [lowerBound, lowerBoundIndex];\n  };\n\n  /** @returns always valid upperBound */\n  const getUpperBound = (\n    index: number,\n  ): [ExcalidrawElement[\"index\"] | undefined, number] => {\n    const upperBound = elements[upperBoundIndex]\n      ? elements[upperBoundIndex].index\n      : undefined;\n\n    // cache hit! don't let it find the upper bound again\n    if (upperBound && index < upperBoundIndex) {\n      return [upperBound, upperBoundIndex];\n    }\n\n    // set the current upperBoundIndex as the starting point\n    let i = upperBoundIndex;\n    while (++i < elements.length) {\n      const candidate = elements[i]?.index;\n\n      if (\n        (!upperBound && candidate) || // first upperBound\n        (upperBound && candidate && candidate > upperBound) // next upperBound\n      ) {\n        return [candidate, i];\n      }\n    }\n\n    // we reached the end, sky is the limit\n    return [undefined, i];\n  };\n\n  let i = 0;\n\n  while (i < elements.length) {\n    const current = elements[i].index;\n    [lowerBound, lowerBoundIndex] = getLowerBound(i);\n    [upperBound, upperBoundIndex] = getUpperBound(i);\n\n    if (!isValidFractionalIndex(current, lowerBound, upperBound)) {\n      // push the lower bound index as the first item\n      const indicesGroup = [lowerBoundIndex, i];\n\n      while (++i < elements.length) {\n        const current = elements[i].index;\n        const [nextLowerBound, nextLowerBoundIndex] = getLowerBound(i);\n        const [nextUpperBound, nextUpperBoundIndex] = getUpperBound(i);\n\n        if (isValidFractionalIndex(current, nextLowerBound, nextUpperBound)) {\n          break;\n        }\n\n        // assign bounds only for the moved elements\n        [lowerBound, lowerBoundIndex] = [nextLowerBound, nextLowerBoundIndex];\n        [upperBound, upperBoundIndex] = [nextUpperBound, nextUpperBoundIndex];\n\n        indicesGroup.push(i);\n      }\n\n      // push the upper bound index as the last item\n      indicesGroup.push(upperBoundIndex);\n      indicesGroups.push(indicesGroup);\n    } else {\n      i++;\n    }\n  }\n\n  return indicesGroups;\n};\n\nconst isValidFractionalIndex = (\n  index: ExcalidrawElement[\"index\"] | undefined,\n  predecessor: ExcalidrawElement[\"index\"] | undefined,\n  successor: ExcalidrawElement[\"index\"] | undefined,\n) => {\n  if (!index) {\n    return false;\n  }\n\n  if (predecessor && successor) {\n    return predecessor < index && index < successor;\n  }\n\n  if (!predecessor && successor) {\n    // first element\n    return index < successor;\n  }\n\n  if (predecessor && !successor) {\n    // last element\n    return predecessor < index;\n  }\n\n  // only element in the array\n  return !!index;\n};\n\nconst generateIndices = (\n  elements: readonly ExcalidrawElement[],\n  indicesGroups: number[][],\n) => {\n  const elementsUpdates = new Map<\n    ExcalidrawElement,\n    { index: FractionalIndex }\n  >();\n\n  for (const indices of indicesGroups) {\n    const lowerBoundIndex = indices.shift()!;\n    const upperBoundIndex = indices.pop()!;\n\n    const fractionalIndices = generateNKeysBetween(\n      elements[lowerBoundIndex]?.index,\n      elements[upperBoundIndex]?.index,\n      indices.length,\n    ) as FractionalIndex[];\n\n    for (let i = 0; i < indices.length; i++) {\n      const element = elements[indices[i]];\n\n      elementsUpdates.set(element, {\n        index: fractionalIndices[i],\n      });\n    }\n  }\n\n  return elementsUpdates;\n};\n\nconst isOrderedElement = (\n  element: ExcalidrawElement,\n): element is OrderedExcalidrawElement => {\n  // for now it's sufficient whether the index is there\n  // meaning, the element was already ordered in the past\n  // meaning, it is not a newly inserted element, not an unrestored element, etc.\n  // it does not have to mean that the index itself is valid\n  if (element.index) {\n    return true;\n  }\n\n  return false;\n};\n", "// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS =\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error(\"invalid integer part of order key: \" + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= \"a\" && head <= \"z\") {\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\n  } else if (head >= \"A\" && head <= \"Z\") {\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error(\"invalid order key head: \" + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === \"A\" + digits[0].repeat(26)) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === \"Z\") {\n      return \"a\" + digits[0];\n    }\n    if (head === \"z\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > \"a\") {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === \"a\") {\n      return \"Z\" + digits.slice(-1);\n    }\n    if (head === \"A\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < \"Z\") {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return \"a\" + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === \"A\" + digits[0].repeat(26)) {\n      return ib + midpoint(\"\", fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error(\"cannot decrement any more\");\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error(\"cannot increment any more\");\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n", "import throttle from \"lodash.throttle\";\n\nimport {\n  randomInteger,\n  arrayToMap,\n  toBrandedType,\n  isDevEnv,\n  isTestEnv,\n  toArray,\n} from \"@excalidraw/common\";\nimport { isNonDeletedElement } from \"@excalidraw/element\";\nimport { isFrameLikeElement } from \"@excalidraw/element\";\nimport { getElementsInGroup } from \"@excalidraw/element\";\n\nimport {\n  syncInvalidIndices,\n  syncMovedIndices,\n  validateFractionalIndices,\n} from \"@excalidraw/element\";\n\nimport { getSelectedElements } from \"@excalidraw/element\";\n\nimport { mutateElement, type ElementUpdate } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFrameLikeElement,\n  ElementsMapOrArray,\n  SceneElementsMap,\n  NonDeletedSceneElementsMap,\n  OrderedExcalidrawElement,\n  Ordered,\n} from \"@excalidraw/element/types\";\n\nimport type {\n  Assert,\n  Mutable,\n  SameType,\n} from \"@excalidraw/common/utility-types\";\n\nimport type { AppState } from \"../../excalidraw/types\";\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\ntype SelectionHash = string & { __brand: \"selectionHash\" };\n\nconst getNonDeletedElements = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n) => {\n  const elementsMap = new Map() as NonDeletedSceneElementsMap;\n  const elements: T[] = [];\n  for (const element of allElements) {\n    if (!element.isDeleted) {\n      elements.push(element as NonDeleted<T>);\n      elementsMap.set(\n        element.id,\n        element as Ordered<NonDeletedExcalidrawElement>,\n      );\n    }\n  }\n  return { elementsMap, elements };\n};\n\nconst validateIndicesThrottled = throttle(\n  (elements: readonly ExcalidrawElement[]) => {\n    if (isDevEnv() || isTestEnv() || window?.DEBUG_FRACTIONAL_INDICES) {\n      validateFractionalIndices(elements, {\n        // throw only in dev & test, to remain functional on `DEBUG_FRACTIONAL_INDICES`\n        shouldThrow: isDevEnv() || isTestEnv(),\n        includeBoundTextValidation: true,\n      });\n    }\n  },\n  1000 * 60,\n  { leading: true, trailing: false },\n);\n\nconst hashSelectionOpts = (\n  opts: Parameters<InstanceType<typeof Scene>[\"getSelectedElements\"]>[0],\n) => {\n  const keys = [\"includeBoundTextElement\", \"includeElementsInFrames\"] as const;\n\n  type HashableKeys = Omit<typeof opts, \"selectedElementIds\" | \"elements\">;\n\n  // just to ensure we're hashing all expected keys\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type _ = Assert<\n    SameType<\n      Required<HashableKeys>,\n      Pick<Required<HashableKeys>, typeof keys[number]>\n    >\n  >;\n\n  let hash = \"\";\n  for (const key of keys) {\n    hash += `${key}:${opts[key] ? \"1\" : \"0\"}`;\n  }\n  return hash as SelectionHash;\n};\n\n// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nexport type ExcalidrawElementsIncludingDeleted = readonly ExcalidrawElement[];\n\nexport class Scene {\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly Ordered<NonDeletedExcalidrawElement>[] =\n    [];\n  private nonDeletedElementsMap = toBrandedType<NonDeletedSceneElementsMap>(\n    new Map(),\n  );\n  // ideally all elements within the scene should be wrapped around with `Ordered` type, but right now there is no real benefit doing so\n  private elements: readonly OrderedExcalidrawElement[] = [];\n  private nonDeletedFramesLikes: readonly NonDeleted<ExcalidrawFrameLikeElement>[] =\n    [];\n  private frames: readonly ExcalidrawFrameLikeElement[] = [];\n  private elementsMap = toBrandedType<SceneElementsMap>(new Map());\n  private selectedElementsCache: {\n    selectedElementIds: AppState[\"selectedElementIds\"] | null;\n    elements: readonly NonDeletedExcalidrawElement[] | null;\n    cache: Map<SelectionHash, NonDeletedExcalidrawElement[]>;\n  } = {\n    selectedElementIds: null,\n    elements: null,\n    cache: new Map(),\n  };\n  /**\n   * Random integer regenerated each scene update.\n   *\n   * Does not relate to elements versions, it's only a renderer\n   * cache-invalidation nonce at the moment.\n   */\n  private sceneNonce: number | undefined;\n\n  getSceneNonce() {\n    return this.sceneNonce;\n  }\n\n  getNonDeletedElementsMap() {\n    return this.nonDeletedElementsMap;\n  }\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getElementsMapIncludingDeleted() {\n    return this.elementsMap;\n  }\n\n  getNonDeletedElements() {\n    return this.nonDeletedElements;\n  }\n\n  getFramesIncludingDeleted() {\n    return this.frames;\n  }\n\n  constructor(\n    elements: ElementsMapOrArray | null = null,\n    options?: {\n      skipValidation?: true;\n    },\n  ) {\n    if (elements) {\n      this.replaceAllElements(elements, options);\n    }\n  }\n\n  getSelectedElements(opts: {\n    // NOTE can be ommitted by making Scene constructor require App instance\n    selectedElementIds: AppState[\"selectedElementIds\"];\n    /**\n     * for specific cases where you need to use elements not from current\n     * scene state. This in effect will likely result in cache-miss, and\n     * the cache won't be updated in this case.\n     */\n    elements?: ElementsMapOrArray;\n    // selection-related options\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  }): NonDeleted<ExcalidrawElement>[] {\n    const hash = hashSelectionOpts(opts);\n\n    const elements = opts?.elements || this.nonDeletedElements;\n    if (\n      this.selectedElementsCache.elements === elements &&\n      this.selectedElementsCache.selectedElementIds === opts.selectedElementIds\n    ) {\n      const cached = this.selectedElementsCache.cache.get(hash);\n      if (cached) {\n        return cached;\n      }\n    } else if (opts?.elements == null) {\n      // if we're operating on latest scene elements and the cache is not\n      //  storing the latest elements, clear the cache\n      this.selectedElementsCache.cache.clear();\n    }\n\n    const selectedElements = getSelectedElements(\n      elements,\n      { selectedElementIds: opts.selectedElementIds },\n      opts,\n    );\n\n    // cache only if we're not using custom elements\n    if (opts?.elements == null) {\n      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;\n      this.selectedElementsCache.elements = this.nonDeletedElements;\n      this.selectedElementsCache.cache.set(hash, selectedElements);\n    }\n\n    return selectedElements;\n  }\n\n  getNonDeletedFramesLikes(): readonly NonDeleted<ExcalidrawFrameLikeElement>[] {\n    return this.nonDeletedFramesLikes;\n  }\n\n  getElement<T extends ExcalidrawElement>(id: T[\"id\"]): T | null {\n    return (this.elementsMap.get(id) as T | undefined) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */\n  mapElements(\n    iteratee: (element: ExcalidrawElement) => ExcalidrawElement,\n  ): boolean {\n    let didChange = false;\n    const newElements = this.elements.map((element) => {\n      const nextElement = iteratee(element);\n      if (nextElement !== element) {\n        didChange = true;\n      }\n      return nextElement;\n    });\n    if (didChange) {\n      this.replaceAllElements(newElements);\n    }\n    return didChange;\n  }\n\n  replaceAllElements(\n    nextElements: ElementsMapOrArray,\n    options?: {\n      skipValidation?: true;\n    },\n  ) {\n    // we do trust the insertion order on the map, though maybe we shouldn't and should prefer order defined by fractional indices\n    const _nextElements = toArray(nextElements);\n    const nextFrameLikes: ExcalidrawFrameLikeElement[] = [];\n\n    if (!options?.skipValidation) {\n      validateIndicesThrottled(_nextElements);\n    }\n\n    this.elements = syncInvalidIndices(_nextElements);\n    this.elementsMap.clear();\n    this.elements.forEach((element) => {\n      if (isFrameLikeElement(element)) {\n        nextFrameLikes.push(element);\n      }\n      this.elementsMap.set(element.id, element);\n    });\n    const nonDeletedElements = getNonDeletedElements(this.elements);\n    this.nonDeletedElements = nonDeletedElements.elements;\n    this.nonDeletedElementsMap = nonDeletedElements.elementsMap;\n\n    this.frames = nextFrameLikes;\n    this.nonDeletedFramesLikes = getNonDeletedElements(this.frames).elements;\n\n    this.triggerUpdate();\n  }\n\n  triggerUpdate() {\n    this.sceneNonce = randomInteger();\n\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  onUpdate(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    this.elements = [];\n    this.nonDeletedElements = [];\n    this.nonDeletedFramesLikes = [];\n    this.frames = [];\n    this.elementsMap.clear();\n    this.selectedElementsCache.selectedElementIds = null;\n    this.selectedElementsCache.elements = null;\n    this.selectedElementsCache.cache.clear();\n\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n\n  insertElementAtIndex(element: ExcalidrawElement, index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      element,\n      ...this.elements.slice(index),\n    ];\n\n    syncMovedIndices(nextElements, arrayToMap([element]));\n\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElementsAtIndex(elements: ExcalidrawElement[], index: number) {\n    if (!elements.length) {\n      return;\n    }\n\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      ...elements,\n      ...this.elements.slice(index),\n    ];\n\n    syncMovedIndices(nextElements, arrayToMap(elements));\n\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElement = (element: ExcalidrawElement) => {\n    const index = element.frameId\n      ? this.getElementIndex(element.frameId)\n      : this.elements.length;\n\n    this.insertElementAtIndex(element, index);\n  };\n\n  insertElements = (elements: ExcalidrawElement[]) => {\n    if (!elements.length) {\n      return;\n    }\n\n    const index = elements[0]?.frameId\n      ? this.getElementIndex(elements[0].frameId)\n      : this.elements.length;\n\n    this.insertElementsAtIndex(elements, index);\n  };\n\n  getElementIndex(elementId: string) {\n    return this.elements.findIndex((element) => element.id === elementId);\n  }\n\n  getContainerElement = (\n    element:\n      | (ExcalidrawElement & {\n          containerId: ExcalidrawElement[\"id\"] | null;\n        })\n      | null,\n  ) => {\n    if (!element) {\n      return null;\n    }\n    if (element.containerId) {\n      return this.getElement(element.containerId) || null;\n    }\n    return null;\n  };\n\n  getElementsFromId = (id: string): ExcalidrawElement[] => {\n    const elementsMap = this.getNonDeletedElementsMap();\n    // first check if the id is an element\n    const el = elementsMap.get(id);\n    if (el) {\n      return [el];\n    }\n\n    // then, check if the id is a group\n    return getElementsInGroup(elementsMap, id);\n  };\n\n  // Mutate an element with passed updates and trigger the component to update. Make sure you\n  // are calling it either from a React event handler or within unstable_batchedUpdates().\n  mutateElement<TElement extends Mutable<ExcalidrawElement>>(\n    element: TElement,\n    updates: ElementUpdate<TElement>,\n    options: {\n      informMutation: boolean;\n      isDragging: boolean;\n    } = {\n      informMutation: true,\n      isDragging: false,\n    },\n  ) {\n    const elementsMap = this.getNonDeletedElementsMap();\n\n    const { version: prevVersion } = element;\n    const { version: nextVersion } = mutateElement(\n      element,\n      elementsMap,\n      updates,\n      options,\n    );\n\n    if (\n      // skip if the element is not in the scene (i.e. selection)\n      this.elementsMap.has(element.id) &&\n      // skip if the element's version hasn't changed, as mutateElement returned the same element\n      prevVersion !== nextVersion &&\n      options.informMutation\n    ) {\n      this.triggerUpdate();\n    }\n\n    return element;\n  }\n}\n", "import type { AppState } from \"@excalidraw/excalidraw/types\";\n\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBoundingBox } from \"./bounds\";\n\nimport { getSelectedElementsByGroup } from \"./groups\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"./types\";\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n  distribution: Distribution,\n  appState: Readonly<AppState>,\n  scene: Scene,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getSelectedElementsByGroup(\n    selectedElements,\n    elementsMap,\n    appState,\n  )\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) => {\n        const updatedElement = scene.mutateElement(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        });\n        updateBoundElements(element, scene, {\n          simultaneouslyUpdated: group,\n        });\n        return updatedElement;\n      });\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) => {\n      const updatedElement = scene.mutateElement(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      });\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: group,\n      });\n      return updatedElement;\n    });\n  });\n};\n", "import {\n  type Bounds,\n  TEXT_AUTOWRAP_THRESHOLD,\n  getGridPoint,\n  getFontString,\n  DRAGGING_THRESHOLD,\n} from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  NormalizedZoomValue,\n  NullableGridSize,\n  PointerDownState,\n} from \"@excalidraw/excalidraw/types\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { unbindBindingElement, updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { getMinTextElementWidth } from \"./textMeasurements\";\nimport {\n  isArrowElement,\n  isElbowArrow,\n  isFrameLikeElement,\n  isImageElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  _selectedElements: NonDeletedExcalidrawElement[],\n  offset: { x: number; y: number },\n  scene: Scene,\n  snapOffset: {\n    x: number;\n    y: number;\n  },\n  gridSize: NullableGridSize,\n) => {\n  if (\n    _selectedElements.length === 1 &&\n    isElbowArrow(_selectedElements[0]) &&\n    (_selectedElements[0].startBinding || _selectedElements[0].endBinding)\n  ) {\n    return;\n  }\n\n  const selectedElements = _selectedElements.filter((element) => {\n    if (isElbowArrow(element) && element.startBinding && element.endBinding) {\n      const startElement = _selectedElements.find(\n        (el) => el.id === element.startBinding?.elementId,\n      );\n      const endElement = _selectedElements.find(\n        (el) => el.id === element.endBinding?.elementId,\n      );\n\n      return startElement && endElement;\n    }\n\n    return true;\n  });\n\n  // we do not want a frame and its elements to be selected at the same time\n  // but when it happens (due to some bug), we want to avoid updating element\n  // in the frame twice, hence the use of set\n  const elementsToUpdate = new Set<NonDeletedExcalidrawElement>(\n    selectedElements,\n  );\n  const frames = selectedElements\n    .filter((e) => isFrameLikeElement(e))\n    .map((f) => f.id);\n\n  if (frames.length > 0) {\n    for (const element of scene.getNonDeletedElements()) {\n      if (element.frameId !== null && frames.includes(element.frameId)) {\n        elementsToUpdate.add(element);\n      }\n    }\n  }\n\n  const origElements: ExcalidrawElement[] = [];\n\n  for (const element of elementsToUpdate) {\n    const origElement = pointerDownState.originalElements.get(element.id);\n    // if original element is not set (e.g. when you duplicate during a drag\n    // operation), exit to avoid undefined behavior\n    if (!origElement) {\n      return;\n    }\n    origElements.push(origElement);\n  }\n\n  const adjustedOffset = calculateOffset(\n    getCommonBounds(origElements),\n    offset,\n    snapOffset,\n    gridSize,\n  );\n\n  const elementsToUpdateIds = new Set(\n    Array.from(elementsToUpdate, (el) => el.id),\n  );\n\n  elementsToUpdate.forEach((element) => {\n    const isArrow = !isArrowElement(element);\n    const isStartBoundElementSelected =\n      isArrow ||\n      (element.startBinding\n        ? elementsToUpdateIds.has(element.startBinding.elementId)\n        : false);\n    const isEndBoundElementSelected =\n      isArrow ||\n      (element.endBinding\n        ? elementsToUpdateIds.has(element.endBinding.elementId)\n        : false);\n\n    if (!isArrowElement(element)) {\n      updateElementCoords(pointerDownState, element, scene, adjustedOffset);\n\n      // skip arrow labels since we calculate its position during render\n      const textElement = getBoundTextElement(\n        element,\n        scene.getNonDeletedElementsMap(),\n      );\n      if (textElement) {\n        updateElementCoords(\n          pointerDownState,\n          textElement,\n          scene,\n          adjustedOffset,\n        );\n      }\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: Array.from(elementsToUpdate),\n      });\n    } else if (\n      // NOTE: Add a little initial drag to the arrow dragging when the arrow\n      // is the single element being dragged to avoid accidentally unbinding\n      // the arrow when the user just wants to select it.\n\n      elementsToUpdate.size > 1 ||\n      Math.max(Math.abs(adjustedOffset.x), Math.abs(adjustedOffset.y)) >\n        DRAGGING_THRESHOLD ||\n      (!element.startBinding && !element.endBinding)\n    ) {\n      updateElementCoords(pointerDownState, element, scene, adjustedOffset);\n\n      const shouldUnbindStart =\n        element.startBinding && !isStartBoundElementSelected;\n      const shouldUnbindEnd = element.endBinding && !isEndBoundElementSelected;\n      if (shouldUnbindStart || shouldUnbindEnd) {\n        // NOTE: Moving the bound arrow should unbind it, otherwise we would\n        // have weird situations, like 0 lenght arrow when the user moves\n        // the arrow outside a filled shape suddenly forcing the arrow start\n        // and end point to jump \"outside\" the shape.\n        if (shouldUnbindStart) {\n          unbindBindingElement(element, \"start\", scene);\n        }\n        if (shouldUnbindEnd) {\n          unbindBindingElement(element, \"end\", scene);\n        }\n      }\n    }\n  });\n};\n\nconst calculateOffset = (\n  commonBounds: Bounds,\n  dragOffset: { x: number; y: number },\n  snapOffset: { x: number; y: number },\n  gridSize: NullableGridSize,\n): { x: number; y: number } => {\n  const [x, y] = commonBounds;\n  let nextX = x + dragOffset.x + snapOffset.x;\n  let nextY = y + dragOffset.y + snapOffset.y;\n\n  if (snapOffset.x === 0 || snapOffset.y === 0) {\n    const [nextGridX, nextGridY] = getGridPoint(\n      x + dragOffset.x,\n      y + dragOffset.y,\n      gridSize,\n    );\n\n    if (snapOffset.x === 0) {\n      nextX = nextGridX;\n    }\n\n    if (snapOffset.y === 0) {\n      nextY = nextGridY;\n    }\n  }\n  return {\n    x: nextX - x,\n    y: nextY - y,\n  };\n};\n\nconst updateElementCoords = (\n  pointerDownState: PointerDownState,\n  element: NonDeletedExcalidrawElement,\n  scene: Scene,\n  dragOffset: { x: number; y: number },\n) => {\n  const originalElement =\n    pointerDownState.originalElements.get(element.id) ?? element;\n\n  const nextX = originalElement.x + dragOffset.x;\n  const nextY = originalElement.y + dragOffset.y;\n\n  scene.mutateElement(element, {\n    x: nextX,\n    y: nextY,\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = ({\n  newElement,\n  elementType,\n  originX,\n  originY,\n  x,\n  y,\n  width,\n  height,\n  shouldMaintainAspectRatio,\n  shouldResizeFromCenter,\n  zoom,\n  scene,\n  widthAspectRatio = null,\n  originOffset = null,\n  informMutation = true,\n}: {\n  newElement: NonDeletedExcalidrawElement;\n  elementType: AppState[\"activeTool\"][\"type\"];\n  originX: number;\n  originY: number;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  shouldMaintainAspectRatio: boolean;\n  shouldResizeFromCenter: boolean;\n  zoom: NormalizedZoomValue;\n  scene: Scene;\n  /** whether to keep given aspect ratio when `isResizeWithSidesSameLength` is\n      true */\n  widthAspectRatio?: number | null;\n  originOffset?: {\n    x: number;\n    y: number;\n  } | null;\n  informMutation?: boolean;\n}) => {\n  if (shouldMaintainAspectRatio && newElement.type !== \"selection\") {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      // Depending on where the cursor is at (x, y) relative to where the starting point is\n      // (originX, originY), we use ONLY width or height to control size increase.\n      // This allows the cursor to always \"stick\" to one of the sides of the bounding box.\n      if (Math.abs(y - originY) > Math.abs(x - originX)) {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          height,\n          x < originX ? -width : width,\n        ));\n      } else {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          width,\n          y < originY ? -height : height,\n        ));\n      }\n\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  let textAutoResize = null;\n\n  if (isTextElement(newElement)) {\n    height = newElement.height;\n    const minWidth = getMinTextElementWidth(\n      getFontString({\n        fontSize: newElement.fontSize,\n        fontFamily: newElement.fontFamily,\n      }),\n      newElement.lineHeight,\n    );\n    width = Math.max(width, minWidth);\n\n    if (Math.abs(x - originX) > TEXT_AUTOWRAP_THRESHOLD / zoom) {\n      textAutoResize = {\n        autoResize: false,\n      };\n    }\n\n    newY = originY;\n    if (shouldResizeFromCenter) {\n      newX = originX - width / 2;\n    }\n  }\n\n  if (width !== 0 && height !== 0) {\n    let imageInitialDimension = null;\n    if (isImageElement(newElement)) {\n      imageInitialDimension = {\n        initialWidth: width,\n        initialHeight: height,\n      };\n    }\n\n    scene.mutateElement(\n      newElement,\n      {\n        x: newX + (originOffset?.x ?? 0),\n        y: newY + (originOffset?.y ?? 0),\n        width,\n        height,\n        ...textAutoResize,\n        ...imageInitialDimension,\n      },\n      { informMutation, isDragging: false },\n    );\n  }\n};\n", "/**\n * Create and link between shapes.\n */\n\nimport { ELEMENT_LINK_KEY, normalizeLink } from \"@excalidraw/common\";\n\nimport type { AppProps, AppState } from \"@excalidraw/excalidraw/types\";\n\nimport { elementsAreInSameGroup } from \"./groups\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\nexport const defaultGetElementLinkFromSelection: Exclude<\n  AppProps[\"generateLinkForSelection\"],\n  undefined\n> = (id, type) => {\n  const url = window.location.href;\n\n  try {\n    const link = new URL(url);\n    link.searchParams.set(ELEMENT_LINK_KEY, id);\n\n    return normalizeLink(link.toString());\n  } catch (error) {\n    console.error(error);\n  }\n\n  return normalizeLink(url);\n};\n\nexport const getLinkIdAndTypeFromSelection = (\n  selectedElements: ExcalidrawElement[],\n  appState: AppState,\n): {\n  id: string;\n  type: \"element\" | \"group\";\n} | null => {\n  if (\n    selectedElements.length > 0 &&\n    canCreateLinkFromElements(selectedElements)\n  ) {\n    if (selectedElements.length === 1) {\n      return {\n        id: selectedElements[0].id,\n        type: \"element\",\n      };\n    }\n\n    if (selectedElements.length > 1) {\n      const selectedGroupId = Object.keys(appState.selectedGroupIds)[0];\n\n      if (selectedGroupId) {\n        return {\n          id: selectedGroupId,\n          type: \"group\",\n        };\n      }\n      return {\n        id: selectedElements[0].groupIds[0],\n        type: \"group\",\n      };\n    }\n  }\n\n  return null;\n};\n\nexport const canCreateLinkFromElements = (\n  selectedElements: ExcalidrawElement[],\n) => {\n  if (selectedElements.length === 1) {\n    return true;\n  }\n\n  if (selectedElements.length > 1 && elementsAreInSameGroup(selectedElements)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const isElementLink = (url: string) => {\n  try {\n    const _url = new URL(url);\n    return (\n      _url.searchParams.has(ELEMENT_LINK_KEY) &&\n      _url.host === window.location.host\n    );\n  } catch (error) {\n    return false;\n  }\n};\n\nexport const parseElementLinkFromURL = (url: string) => {\n  try {\n    const { searchParams } = new URL(url);\n    if (searchParams.has(ELEMENT_LINK_KEY)) {\n      const id = searchParams.get(ELEMENT_LINK_KEY);\n      return id;\n    }\n  } catch {}\n\n  return null;\n};\n", "import {\n  FONT_FAMILY,\n  VERTICAL_ALIGN,\n  escapeDoubleQuotes,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport type { ExcalidrawProps } from \"@excalidraw/excalidraw/types\";\nimport type { MarkRequired } from \"@excalidraw/common/utility-types\";\n\nimport { newTextElement } from \"./newElement\";\nimport { wrapText } from \"./textWrapping\";\nimport { isIframeElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawIframeLikeElement,\n  IframeData,\n} from \"./types\";\n\ntype IframeDataWithSandbox = MarkRequired<IframeData, \"sandbox\">;\n\nconst embeddedLinkCache = new Map<string, IframeDataWithSandbox>();\n\nconst RE_YOUTUBE =\n  /^(?:http(?:s)?:\\/\\/)?(?:www\\.)?youtu(?:be\\.com|\\.be)\\/(embed\\/|watch\\?v=|shorts\\/|playlist\\?list=|embed\\/videoseries\\?list=)?([a-zA-Z0-9_-]+)/;\n\nconst RE_VIMEO =\n  /^(?:http(?:s)?:\\/\\/)?(?:(?:w){3}\\.)?(?:player\\.)?vimeo\\.com\\/(?:video\\/)?([^?\\s]+)(?:\\?.*)?$/;\nconst RE_FIGMA = /^https:\\/\\/(?:www\\.)?figma\\.com/;\n\nconst RE_GH_GIST = /^https:\\/\\/gist\\.github\\.com\\/([\\w_-]+)\\/([\\w_-]+)/;\nconst RE_GH_GIST_EMBED =\n  /^<script[\\s\\S]*?\\ssrc=[\"'](https:\\/\\/gist\\.github\\.com\\/.*?)\\.js[\"']/i;\n\nconst RE_MSFORMS = /^(?:https?:\\/\\/)?forms\\.microsoft\\.com\\//;\n\n// not anchored to start to allow <blockquote> twitter embeds\nconst RE_TWITTER =\n  /(?:https?:\\/\\/)?(?:(?:w){3}\\.)?(?:twitter|x)\\.com\\/[^/]+\\/status\\/(\\d+)/;\nconst RE_TWITTER_EMBED =\n  /^<blockquote[\\s\\S]*?\\shref=[\"'](https?:\\/\\/(?:twitter|x)\\.com\\/[^\"']*)/i;\n\nconst RE_VALTOWN =\n  /^https:\\/\\/(?:www\\.)?val\\.town\\/(v|embed)\\/[a-zA-Z_$][0-9a-zA-Z_$]+\\.[a-zA-Z_$][0-9a-zA-Z_$]+/;\n\nconst RE_GENERIC_EMBED =\n  /^<(?:iframe|blockquote)[\\s\\S]*?\\s(?:src|href)=[\"']([^\"']*)[\"'][\\s\\S]*?>$/i;\n\nconst RE_GIPHY =\n  /giphy.com\\/(?:clips|embed|gifs)\\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/;\n\nconst RE_REDDIT =\n  /^(?:http(?:s)?:\\/\\/)?(?:www\\.)?reddit\\.com\\/r\\/([a-zA-Z0-9_]+)\\/comments\\/([a-zA-Z0-9_]+)\\/([a-zA-Z0-9_]+)\\/?(?:\\?[^#\\s]*)?(?:#[^\\s]*)?$/;\n\nconst RE_REDDIT_EMBED =\n  /^<blockquote[\\s\\S]*?\\shref=[\"'](https?:\\/\\/(?:www\\.)?reddit\\.com\\/[^\"']*)/i;\n\nconst parseYouTubeTimestamp = (url: string): number => {\n  let timeParam: string | null | undefined;\n\n  try {\n    const urlObj = new URL(url.startsWith(\"http\") ? url : `https://${url}`);\n    timeParam =\n      urlObj.searchParams.get(\"t\") || urlObj.searchParams.get(\"start\");\n  } catch (error) {\n    const timeMatch = url.match(/[?&#](?:t|start)=([^&#\\s]+)/);\n    timeParam = timeMatch?.[1];\n  }\n\n  if (!timeParam) {\n    return 0;\n  }\n\n  if (/^\\d+$/.test(timeParam)) {\n    return parseInt(timeParam, 10);\n  }\n\n  const timeMatch = timeParam.match(/^(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+)s)?$/);\n  if (!timeMatch) {\n    return 0;\n  }\n\n  const [, hours = \"0\", minutes = \"0\", seconds = \"0\"] = timeMatch;\n  return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds);\n};\n\nconst ALLOWED_DOMAINS = new Set([\n  \"youtube.com\",\n  \"youtu.be\",\n  \"vimeo.com\",\n  \"player.vimeo.com\",\n  \"figma.com\",\n  \"link.excalidraw.com\",\n  \"gist.github.com\",\n  \"twitter.com\",\n  \"x.com\",\n  \"*.simplepdf.eu\",\n  \"stackblitz.com\",\n  \"val.town\",\n  \"giphy.com\",\n  \"reddit.com\",\n  \"forms.microsoft.com\",\n]);\n\nconst ALLOW_SAME_ORIGIN = new Set([\n  \"youtube.com\",\n  \"youtu.be\",\n  \"vimeo.com\",\n  \"player.vimeo.com\",\n  \"figma.com\",\n  \"twitter.com\",\n  \"x.com\",\n  \"*.simplepdf.eu\",\n  \"stackblitz.com\",\n  \"reddit.com\",\n  \"forms.microsoft.com\",\n]);\n\nexport const createSrcDoc = (body: string) => {\n  return `<html><body>${body}</body></html>`;\n};\n\nexport const getEmbedLink = (\n  link: string | null | undefined,\n): IframeDataWithSandbox | null => {\n  if (!link) {\n    return null;\n  }\n\n  if (embeddedLinkCache.has(link)) {\n    return embeddedLinkCache.get(link)!;\n  }\n\n  const originalLink = link;\n\n  const allowSameOrigin = ALLOW_SAME_ORIGIN.has(\n    matchHostname(link, ALLOW_SAME_ORIGIN) || \"\",\n  );\n\n  let type: \"video\" | \"generic\" = \"generic\";\n  let aspectRatio = { w: 560, h: 840 };\n  const ytLink = link.match(RE_YOUTUBE);\n  if (ytLink?.[2]) {\n    const startTime = parseYouTubeTimestamp(originalLink);\n    const time = startTime > 0 ? `&start=${startTime}` : ``;\n    const isPortrait = link.includes(\"shorts\");\n    type = \"video\";\n    switch (ytLink[1]) {\n      case \"embed/\":\n      case \"watch?v=\":\n      case \"shorts/\":\n        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;\n        break;\n      case \"playlist?list=\":\n      case \"embed/videoseries?list=\":\n        link = `https://www.youtube.com/embed/videoseries?list=${ytLink[2]}&enablejsapi=1${time}`;\n        break;\n      default:\n        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;\n        break;\n    }\n    aspectRatio = isPortrait ? { w: 315, h: 560 } : { w: 560, h: 315 };\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const vimeoLink = link.match(RE_VIMEO);\n  if (vimeoLink?.[1]) {\n    const target = vimeoLink?.[1];\n    const error = !/^\\d+$/.test(target)\n      ? new URIError(\"Invalid embed link format\")\n      : undefined;\n    type = \"video\";\n    link = `https://player.vimeo.com/video/${target}?api=1`;\n    aspectRatio = { w: 560, h: 315 };\n    //warning deliberately ommited so it is displayed only once per link\n    //same link next time will be served from cache\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      error,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const figmaLink = link.match(RE_FIGMA);\n  if (figmaLink) {\n    type = \"generic\";\n    link = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(\n      link,\n    )}`;\n    aspectRatio = { w: 550, h: 550 };\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const valLink = link.match(RE_VALTOWN);\n  if (valLink) {\n    link =\n      valLink[1] === \"embed\" ? valLink[0] : valLink[0].replace(\"/v\", \"/embed\");\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  if (RE_MSFORMS.test(link) && !link.includes(\"embed=true\")) {\n    link += link.includes(\"?\") ? \"&embed=true\" : \"?embed=true\";\n  }\n\n  if (RE_TWITTER.test(link)) {\n    const postId = link.match(RE_TWITTER)![1];\n    // the embed srcdoc still supports twitter.com domain only.\n    // Note that we don't attempt to parse the username as it can consist of\n    // non-latin1 characters, and the username in the url can be set to anything\n    // without affecting the embed.\n    const safeURL = escapeDoubleQuotes(\n      `https://twitter.com/x/status/${postId}`,\n    );\n\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: (theme: string) =>\n        createSrcDoc(\n          `<blockquote class=\"twitter-tweet\" data-dnt=\"true\" data-theme=\"${theme}\"><a href=\"${safeURL}\"></a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>`,\n        ),\n      intrinsicSize: { w: 480, h: 480 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(originalLink, ret);\n    return ret;\n  }\n\n  if (RE_REDDIT.test(link)) {\n    const [, page, postId, title] = link.match(RE_REDDIT)!;\n    const safeURL = escapeDoubleQuotes(\n      `https://reddit.com/r/${page}/comments/${postId}/${title}`,\n    );\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: (theme: string) =>\n        createSrcDoc(\n          `<blockquote class=\"reddit-embed-bq\" data-embed-theme=\"${theme}\"><a href=\"${safeURL}\"></a><br></blockquote><script async=\"\" src=\"https://embed.reddit.com/widgets.js\" charset=\"UTF-8\"></script>`,\n        ),\n      intrinsicSize: { w: 480, h: 480 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(originalLink, ret);\n    return ret;\n  }\n\n  if (RE_GH_GIST.test(link)) {\n    const [, user, gistId] = link.match(RE_GH_GIST)!;\n    const safeURL = escapeDoubleQuotes(\n      `https://gist.github.com/${user}/${gistId}`,\n    );\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: () =>\n        createSrcDoc(`\n          <script src=\"${safeURL}.js\"></script>\n          <style type=\"text/css\">\n            * { margin: 0px; }\n            table, .gist { height: 100%; }\n            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }\n          </style>\n        `),\n      intrinsicSize: { w: 550, h: 720 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(link, ret);\n    return ret;\n  }\n\n  embeddedLinkCache.set(link, {\n    link,\n    intrinsicSize: aspectRatio,\n    type,\n    sandbox: { allowSameOrigin },\n  });\n  return {\n    link,\n    intrinsicSize: aspectRatio,\n    type,\n    sandbox: { allowSameOrigin },\n  };\n};\n\nexport const createPlaceholderEmbeddableLabel = (\n  element: ExcalidrawIframeLikeElement,\n): ExcalidrawElement => {\n  let text: string;\n  if (isIframeElement(element)) {\n    text = \"IFrame element\";\n  } else {\n    text =\n      !element.link || element?.link === \"\" ? \"Empty Web-Embed\" : element.link;\n  }\n\n  const fontSize = Math.max(\n    Math.min(element.width / 2, element.width / text.length),\n    element.width / 30,\n  );\n  const fontFamily = FONT_FAMILY.Helvetica;\n\n  const fontString = getFontString({\n    fontSize,\n    fontFamily,\n  });\n\n  return newTextElement({\n    x: element.x + element.width / 2,\n    y: element.y + element.height / 2,\n    strokeColor:\n      element.strokeColor !== \"transparent\" ? element.strokeColor : \"black\",\n    backgroundColor: \"transparent\",\n    fontFamily,\n    fontSize,\n    text: wrapText(text, fontString, element.width - 20),\n    textAlign: \"center\",\n    verticalAlign: VERTICAL_ALIGN.MIDDLE,\n    angle: element.angle ?? 0,\n  });\n};\n\nconst matchHostname = (\n  url: string,\n  /** using a Set assumes it already contains normalized bare domains */\n  allowedHostnames: Set<string> | string,\n): string | null => {\n  try {\n    const { hostname } = new URL(url);\n\n    const bareDomain = hostname.replace(/^www\\./, \"\");\n\n    if (allowedHostnames instanceof Set) {\n      if (ALLOWED_DOMAINS.has(bareDomain)) {\n        return bareDomain;\n      }\n\n      const bareDomainWithFirstSubdomainWildcarded = bareDomain.replace(\n        /^([^.]+)/,\n        \"*\",\n      );\n      if (ALLOWED_DOMAINS.has(bareDomainWithFirstSubdomainWildcarded)) {\n        return bareDomainWithFirstSubdomainWildcarded;\n      }\n      return null;\n    }\n\n    const bareAllowedHostname = allowedHostnames.replace(/^www\\./, \"\");\n    if (bareDomain === bareAllowedHostname) {\n      return bareAllowedHostname;\n    }\n  } catch (error) {\n    // ignore\n  }\n  return null;\n};\n\nexport const maybeParseEmbedSrc = (str: string): string => {\n  const twitterMatch = str.match(RE_TWITTER_EMBED);\n  if (twitterMatch && twitterMatch.length === 2) {\n    return twitterMatch[1];\n  }\n\n  const redditMatch = str.match(RE_REDDIT_EMBED);\n  if (redditMatch && redditMatch.length === 2) {\n    return redditMatch[1];\n  }\n\n  const gistMatch = str.match(RE_GH_GIST_EMBED);\n  if (gistMatch && gistMatch.length === 2) {\n    return gistMatch[1];\n  }\n\n  if (RE_GIPHY.test(str)) {\n    return `https://giphy.com/embed/${RE_GIPHY.exec(str)![1]}`;\n  }\n\n  const match = str.match(RE_GENERIC_EMBED);\n  if (match && match.length === 2) {\n    return match[1];\n  }\n\n  return str;\n};\n\nexport const embeddableURLValidator = (\n  url: string | null | undefined,\n  validateEmbeddable: ExcalidrawProps[\"validateEmbeddable\"],\n): boolean => {\n  if (!url) {\n    return false;\n  }\n  if (validateEmbeddable != null) {\n    if (typeof validateEmbeddable === \"function\") {\n      const ret = validateEmbeddable(url);\n      // if return value is undefined, leave validation to default\n      if (typeof ret === \"boolean\") {\n        return ret;\n      }\n    } else if (typeof validateEmbeddable === \"boolean\") {\n      return validateEmbeddable;\n    } else if (validateEmbeddable instanceof RegExp) {\n      return validateEmbeddable.test(url);\n    } else if (Array.isArray(validateEmbeddable)) {\n      for (const domain of validateEmbeddable) {\n        if (domain instanceof RegExp) {\n          if (url.match(domain)) {\n            return true;\n          }\n        } else if (matchHostname(url, domain)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  return !!matchHostname(url, ALLOWED_DOMAINS);\n};\n", "import {\n  DEFAULT_ELEMENT_PROPS,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  VERTICAL_ALIGN,\n  randomInteger,\n  randomId,\n  getFontString,\n  getUpdatedTimestamp,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { MarkOptional, Merge } from \"@excalidraw/common/utility-types\";\n\nimport {\n  getElementAbsoluteCoords,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getBoundTextMaxWidth } from \"./textElement\";\nimport { normalizeText, measureText } from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\n\nimport { isLineElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  FontFamilyValues,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawIframeElement,\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawLineElement,\n} from \"./types\";\n\nexport type ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\" | \"updated\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"frameId\"\n  | \"index\"\n  | \"boundElements\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n  | \"link\"\n  | \"strokeStyle\"\n  | \"fillStyle\"\n  | \"strokeColor\"\n  | \"backgroundColor\"\n  | \"roughness\"\n  | \"strokeWidth\"\n  | \"roundness\"\n  | \"locked\"\n  | \"opacity\"\n  | \"customData\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,\n    backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,\n    fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,\n    strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,\n    strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,\n    roughness = DEFAULT_ELEMENT_PROPS.roughness,\n    opacity = DEFAULT_ELEMENT_PROPS.opacity,\n    width = 0,\n    height = 0,\n    angle = 0 as Radians,\n    groupIds = [],\n    frameId = null,\n    index = null,\n    roundness = null,\n    boundElements = null,\n    link = null,\n    locked = DEFAULT_ELEMENT_PROPS.locked,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => {\n  // NOTE (mtolmacs): This is a temporary check to detect extremely large\n  // element position or sizing\n  if (\n    x < -1e6 ||\n    x > 1e6 ||\n    y < -1e6 ||\n    y > 1e6 ||\n    width < -1e6 ||\n    width > 1e6 ||\n    height < -1e6 ||\n    height > 1e6\n  ) {\n    console.error(\"New element size or position is too large\", {\n      x,\n      y,\n      width,\n      height,\n      // @ts-ignore\n      points: rest.points,\n    });\n  }\n\n  // assign type to guard against excess properties\n  const element: Merge<ExcalidrawGenericElement, { type: T[\"type\"] }> = {\n    id: rest.id || randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    groupIds,\n    frameId,\n    index,\n    roundness,\n    seed: rest.seed ?? randomInteger(),\n    version: rest.version || 1,\n    versionNonce: rest.versionNonce ?? 0,\n    isDeleted: false as false,\n    boundElements,\n    updated: getUpdatedTimestamp(),\n    link,\n    locked,\n    customData: rest.customData,\n  };\n  return element;\n};\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\nexport const newEmbeddableElement = (\n  opts: {\n    type: \"embeddable\";\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawEmbeddableElement> => {\n  return _newElementBase<ExcalidrawEmbeddableElement>(\"embeddable\", opts);\n};\n\nexport const newIframeElement = (\n  opts: {\n    type: \"iframe\";\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawIframeElement> => {\n  return {\n    ..._newElementBase<ExcalidrawIframeElement>(\"iframe\", opts),\n  };\n};\n\nexport const newFrameElement = (\n  opts: {\n    name?: string;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFrameElement> => {\n  const frameElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawFrameElement>(\"frame\", opts),\n      type: \"frame\",\n      name: opts?.name || null,\n    },\n    {},\n  );\n\n  return frameElement;\n};\n\nexport const newMagicFrameElement = (\n  opts: {\n    name?: string;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawMagicFrameElement> => {\n  const frameElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawMagicFrameElement>(\"magicframe\", opts),\n      type: \"magicframe\",\n      name: opts?.name || null,\n    },\n    {},\n  );\n\n  return frameElement;\n};\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    originalText?: string;\n    fontSize?: number;\n    fontFamily?: FontFamilyValues;\n    textAlign?: TextAlign;\n    verticalAlign?: VerticalAlign;\n    containerId?: ExcalidrawTextContainer[\"id\"] | null;\n    lineHeight?: ExcalidrawTextElement[\"lineHeight\"];\n    autoResize?: ExcalidrawTextElement[\"autoResize\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;\n  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;\n  const lineHeight = opts.lineHeight || getLineHeight(fontFamily);\n  const text = normalizeText(opts.text);\n  const metrics = measureText(\n    text,\n    getFontString({ fontFamily, fontSize }),\n    lineHeight,\n  );\n  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;\n  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;\n  const offsets = getTextElementPositionOffsets(\n    { textAlign, verticalAlign },\n    metrics,\n  );\n\n  const textElementProps: ExcalidrawTextElement = {\n    ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n    text,\n    fontSize,\n    fontFamily,\n    textAlign,\n    verticalAlign,\n    x: opts.x - offsets.x,\n    y: opts.y - offsets.y,\n    width: metrics.width,\n    height: metrics.height,\n    containerId: opts.containerId || null,\n    originalText: opts.originalText ?? text,\n    autoResize: opts.autoResize ?? true,\n    lineHeight,\n  };\n\n  const textElement: ExcalidrawTextElement = newElementWith(\n    textElementProps,\n    {},\n  );\n\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  elementsMap: ElementsMap,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} => {\n  let { width: nextWidth, height: nextHeight } = measureText(\n    nextText,\n    getFontString(element),\n    element.lineHeight,\n  );\n\n  // wrapped text\n  if (!element.autoResize) {\n    nextWidth = element.width;\n  }\n\n  const { textAlign, verticalAlign } = element;\n  let x: number;\n  let y: number;\n  if (\n    textAlign === \"center\" &&\n    verticalAlign === VERTICAL_ALIGN.MIDDLE &&\n    !element.containerId &&\n    element.autoResize\n  ) {\n    const prevMetrics = measureText(\n      element.text,\n      getFontString(element),\n      element.lineHeight,\n    );\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n      false,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n  };\n};\n\nconst adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const refreshTextDimensions = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawTextContainer | null,\n  elementsMap: ElementsMap,\n  text = textElement.text,\n) => {\n  if (textElement.isDeleted) {\n    return;\n  }\n  if (container || !textElement.autoResize) {\n    text = wrapText(\n      text,\n      getFontString(textElement),\n      container\n        ? getBoundTextMaxWidth(container, textElement)\n        : textElement.width,\n    );\n  }\n  const dimensions = getAdjustedDimensions(textElement, elementsMap, text);\n  return { text, ...dimensions };\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n    pressures?: ExcalidrawFreeDrawElement[\"pressures\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: opts.pressures || [],\n    simulatePressure: opts.simulatePressure,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    points?: ExcalidrawLinearElement[\"points\"];\n    polygon?: ExcalidrawLineElement[\"polygon\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  const element = {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: null,\n    endArrowhead: null,\n  };\n\n  if (isLineElement(element)) {\n    const lineElement: NonDeleted<ExcalidrawLineElement> = {\n      ...element,\n      polygon: opts.polygon ?? false,\n    };\n\n    return lineElement;\n  }\n\n  return element;\n};\n\nexport const newArrowElement = <T extends boolean>(\n  opts: {\n    type: ExcalidrawArrowElement[\"type\"];\n    startArrowhead?: Arrowhead | null;\n    endArrowhead?: Arrowhead | null;\n    points?: ExcalidrawArrowElement[\"points\"];\n    elbowed?: T;\n    fixedSegments?: ExcalidrawElbowArrowElement[\"fixedSegments\"] | null;\n  } & ElementConstructorOpts,\n): T extends true\n  ? NonDeleted<ExcalidrawElbowArrowElement>\n  : NonDeleted<ExcalidrawArrowElement> => {\n  if (opts.elbowed) {\n    return {\n      ..._newElementBase<ExcalidrawElbowArrowElement>(opts.type, opts),\n      points: opts.points || [],\n      startBinding: null,\n      endBinding: null,\n      startArrowhead: opts.startArrowhead || null,\n      endArrowhead: opts.endArrowhead || null,\n      elbowed: true,\n      fixedSegments: opts.fixedSegments || [],\n      startIsSpecial: false,\n      endIsSpecial: false,\n    } as NonDeleted<ExcalidrawElbowArrowElement>;\n  }\n\n  return {\n    ..._newElementBase<ExcalidrawArrowElement>(opts.type, opts),\n    points: opts.points || [],\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead || null,\n    endArrowhead: opts.endArrowhead || null,\n    elbowed: false,\n  } as T extends true\n    ? NonDeleted<ExcalidrawElbowArrowElement>\n    : NonDeleted<ExcalidrawArrowElement>;\n};\n\nexport const newImageElement = (\n  opts: {\n    type: ExcalidrawImageElement[\"type\"];\n    status?: ExcalidrawImageElement[\"status\"];\n    fileId?: ExcalidrawImageElement[\"fileId\"];\n    scale?: ExcalidrawImageElement[\"scale\"];\n    crop?: ExcalidrawImageElement[\"crop\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawImageElement> => {\n  return {\n    ..._newElementBase<ExcalidrawImageElement>(\"image\", opts),\n    // in the future we'll support changing stroke color for some SVG elements,\n    // and `transparent` will likely mean \"use original colors of the image\"\n    strokeColor: \"transparent\",\n    status: opts.status ?? \"pending\",\n    fileId: opts.fileId ?? null,\n    scale: opts.scale ?? [1, 1],\n    crop: opts.crop ?? null,\n  };\n};\n", "import { KEYS, invariant, toBrandedType } from \"@excalidraw/common\";\n\nimport { type GlobalPoint, pointFrom, type LocalPoint } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  PendingExcalidrawElements,\n} from \"@excalidraw/excalidraw/types\";\n\nimport { bindBindingElement } from \"./binding\";\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\nimport {\n  HEADING_DOWN,\n  HEADING_LEFT,\n  HEADING_RIGHT,\n  HEADING_UP,\n  compareHeading,\n  headingForPointFromElement,\n  type Heading,\n} from \"./heading\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement } from \"./mutateElement\";\nimport { newArrowElement, newElement } from \"./newElement\";\nimport { aabbForElement } from \"./bounds\";\nimport { elementsAreInFrameBounds, elementOverlapsWithFrame } from \"./frame\";\nimport {\n  isBindableElement,\n  isElbowArrow,\n  isFrameElement,\n  isFlowchartNodeElement,\n} from \"./typeChecks\";\nimport {\n  type ElementsMap,\n  type ExcalidrawBindableElement,\n  type ExcalidrawElement,\n  type ExcalidrawFlowchartNodeElement,\n  type NonDeletedSceneElementsMap,\n  type Ordered,\n  type OrderedExcalidrawElement,\n} from \"./types\";\n\nimport type { Scene } from \"./Scene\";\n\ntype LinkDirection = \"up\" | \"right\" | \"down\" | \"left\";\n\nconst VERTICAL_OFFSET = 100;\nconst HORIZONTAL_OFFSET = 100;\n\nexport const getLinkDirectionFromKey = (key: string): LinkDirection => {\n  switch (key) {\n    case KEYS.ARROW_UP:\n      return \"up\";\n    case KEYS.ARROW_DOWN:\n      return \"down\";\n    case KEYS.ARROW_RIGHT:\n      return \"right\";\n    case KEYS.ARROW_LEFT:\n      return \"left\";\n    default:\n      return \"right\";\n  }\n};\n\nconst getNodeRelatives = (\n  type: \"predecessors\" | \"successors\",\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  const items = [...elementsMap.values()].reduce(\n    (acc: { relative: ExcalidrawBindableElement; heading: Heading }[], el) => {\n      let oppositeBinding;\n      if (\n        isElbowArrow(el) &&\n        // we want check existence of the opposite binding, in the direction\n        // we're interested in\n        (oppositeBinding =\n          el[type === \"predecessors\" ? \"startBinding\" : \"endBinding\"]) &&\n        // similarly, we need to filter only arrows bound to target node\n        el[type === \"predecessors\" ? \"endBinding\" : \"startBinding\"]\n          ?.elementId === node.id\n      ) {\n        const relative = elementsMap.get(oppositeBinding.elementId);\n\n        if (!relative) {\n          return acc;\n        }\n\n        invariant(\n          isBindableElement(relative),\n          \"not an ExcalidrawBindableElement\",\n        );\n\n        const edgePoint = (\n          type === \"predecessors\" ? el.points[el.points.length - 1] : [0, 0]\n        ) as Readonly<LocalPoint>;\n\n        const heading = headingForPointFromElement(\n          node,\n          aabbForElement(node, elementsMap),\n          [edgePoint[0] + el.x, edgePoint[1] + el.y] as Readonly<GlobalPoint>,\n        );\n\n        acc.push({\n          relative,\n          heading,\n        });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  switch (direction) {\n    case \"up\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_UP))\n        .map((item) => item.relative);\n    case \"down\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_DOWN))\n        .map((item) => item.relative);\n    case \"right\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_RIGHT))\n        .map((item) => item.relative);\n    case \"left\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_LEFT))\n        .map((item) => item.relative);\n  }\n};\n\nconst getSuccessors = (\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  return getNodeRelatives(\"successors\", node, elementsMap, direction);\n};\n\nexport const getPredecessors = (\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  return getNodeRelatives(\"predecessors\", node, elementsMap, direction);\n};\n\nconst getOffsets = (\n  element: ExcalidrawFlowchartNodeElement,\n  linkedNodes: ExcalidrawElement[],\n  direction: LinkDirection,\n) => {\n  const _HORIZONTAL_OFFSET = HORIZONTAL_OFFSET + element.width;\n\n  // check if vertical space or horizontal space is available first\n  if (direction === \"up\" || direction === \"down\") {\n    const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n    // check vertical space\n    const minX = element.x;\n    const maxX = element.x + element.width;\n\n    // vertical space is available\n    if (\n      linkedNodes.every(\n        (linkedNode) =>\n          linkedNode.x + linkedNode.width < minX || linkedNode.x > maxX,\n      )\n    ) {\n      return {\n        x: 0,\n        y: _VERTICAL_OFFSET * (direction === \"up\" ? -1 : 1),\n      };\n    }\n  } else if (direction === \"right\" || direction === \"left\") {\n    const minY = element.y;\n    const maxY = element.y + element.height;\n\n    if (\n      linkedNodes.every(\n        (linkedNode) =>\n          linkedNode.y + linkedNode.height < minY || linkedNode.y > maxY,\n      )\n    ) {\n      return {\n        x:\n          (HORIZONTAL_OFFSET + element.width) * (direction === \"left\" ? -1 : 1),\n        y: 0,\n      };\n    }\n  }\n\n  if (direction === \"up\" || direction === \"down\") {\n    const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n    const y = linkedNodes.length === 0 ? _VERTICAL_OFFSET : _VERTICAL_OFFSET;\n    const x =\n      linkedNodes.length === 0\n        ? 0\n        : (linkedNodes.length + 1) % 2 === 0\n        ? ((linkedNodes.length + 1) / 2) * _HORIZONTAL_OFFSET\n        : (linkedNodes.length / 2) * _HORIZONTAL_OFFSET * -1;\n\n    if (direction === \"up\") {\n      return {\n        x,\n        y: y * -1,\n      };\n    }\n\n    return {\n      x,\n      y,\n    };\n  }\n\n  const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n  const x =\n    (linkedNodes.length === 0 ? HORIZONTAL_OFFSET : HORIZONTAL_OFFSET) +\n    element.width;\n  const y =\n    linkedNodes.length === 0\n      ? 0\n      : (linkedNodes.length + 1) % 2 === 0\n      ? ((linkedNodes.length + 1) / 2) * _VERTICAL_OFFSET\n      : (linkedNodes.length / 2) * _VERTICAL_OFFSET * -1;\n\n  if (direction === \"left\") {\n    return {\n      x: x * -1,\n      y,\n    };\n  }\n  return {\n    x,\n    y,\n  };\n};\n\nconst addNewNode = (\n  element: ExcalidrawFlowchartNodeElement,\n  appState: AppState,\n  direction: LinkDirection,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const successors = getSuccessors(element, elementsMap, direction);\n  const predeccessors = getPredecessors(element, elementsMap, direction);\n\n  const offsets = getOffsets(\n    element,\n    [...successors, ...predeccessors],\n    direction,\n  );\n\n  const nextNode = newElement({\n    type: element.type,\n    x: element.x + offsets.x,\n    y: element.y + offsets.y,\n    // TODO: extract this to a util\n    width: element.width,\n    height: element.height,\n    roundness: element.roundness,\n    roughness: element.roughness,\n    backgroundColor: element.backgroundColor,\n    strokeColor: element.strokeColor,\n    strokeWidth: element.strokeWidth,\n    opacity: element.opacity,\n    fillStyle: element.fillStyle,\n    strokeStyle: element.strokeStyle,\n  });\n\n  invariant(\n    isFlowchartNodeElement(nextNode),\n    \"not an ExcalidrawFlowchartNodeElement\",\n  );\n\n  const bindingArrow = createBindingArrow(\n    element,\n    nextNode,\n    direction,\n    appState,\n    scene,\n  );\n\n  return {\n    nextNode,\n    bindingArrow,\n  };\n};\n\nexport const addNewNodes = (\n  startNode: ExcalidrawFlowchartNodeElement,\n  appState: AppState,\n  direction: LinkDirection,\n  scene: Scene,\n  numberOfNodes: number,\n) => {\n  // always start from 0 and distribute evenly\n  const newNodes: ExcalidrawElement[] = [];\n\n  for (let i = 0; i < numberOfNodes; i++) {\n    let nextX: number;\n    let nextY: number;\n    if (direction === \"left\" || direction === \"right\") {\n      const totalHeight =\n        VERTICAL_OFFSET * (numberOfNodes - 1) +\n        numberOfNodes * startNode.height;\n\n      const startY = startNode.y + startNode.height / 2 - totalHeight / 2;\n\n      let offsetX = HORIZONTAL_OFFSET + startNode.width;\n      if (direction === \"left\") {\n        offsetX *= -1;\n      }\n      nextX = startNode.x + offsetX;\n      const offsetY = (VERTICAL_OFFSET + startNode.height) * i;\n      nextY = startY + offsetY;\n    } else {\n      const totalWidth =\n        HORIZONTAL_OFFSET * (numberOfNodes - 1) +\n        numberOfNodes * startNode.width;\n      const startX = startNode.x + startNode.width / 2 - totalWidth / 2;\n      let offsetY = VERTICAL_OFFSET + startNode.height;\n\n      if (direction === \"up\") {\n        offsetY *= -1;\n      }\n      nextY = startNode.y + offsetY;\n      const offsetX = (HORIZONTAL_OFFSET + startNode.width) * i;\n      nextX = startX + offsetX;\n    }\n\n    const nextNode = newElement({\n      type: startNode.type,\n      x: nextX,\n      y: nextY,\n      // TODO: extract this to a util\n      width: startNode.width,\n      height: startNode.height,\n      roundness: startNode.roundness,\n      roughness: startNode.roughness,\n      backgroundColor: startNode.backgroundColor,\n      strokeColor: startNode.strokeColor,\n      strokeWidth: startNode.strokeWidth,\n      opacity: startNode.opacity,\n      fillStyle: startNode.fillStyle,\n      strokeStyle: startNode.strokeStyle,\n    });\n\n    invariant(\n      isFlowchartNodeElement(nextNode),\n      \"not an ExcalidrawFlowchartNodeElement\",\n    );\n\n    const bindingArrow = createBindingArrow(\n      startNode,\n      nextNode,\n      direction,\n      appState,\n      scene,\n    );\n\n    newNodes.push(nextNode);\n    newNodes.push(bindingArrow);\n  }\n\n  return newNodes;\n};\n\nconst createBindingArrow = (\n  startBindingElement: ExcalidrawFlowchartNodeElement,\n  endBindingElement: ExcalidrawFlowchartNodeElement,\n  direction: LinkDirection,\n  appState: AppState,\n  scene: Scene,\n) => {\n  let startX: number;\n  let startY: number;\n\n  const PADDING = 6;\n\n  switch (direction) {\n    case \"up\": {\n      startX = startBindingElement.x + startBindingElement.width / 2;\n      startY = startBindingElement.y - PADDING;\n      break;\n    }\n    case \"down\": {\n      startX = startBindingElement.x + startBindingElement.width / 2;\n      startY = startBindingElement.y + startBindingElement.height + PADDING;\n      break;\n    }\n    case \"right\": {\n      startX = startBindingElement.x + startBindingElement.width + PADDING;\n      startY = startBindingElement.y + startBindingElement.height / 2;\n      break;\n    }\n    case \"left\": {\n      startX = startBindingElement.x - PADDING;\n      startY = startBindingElement.y + startBindingElement.height / 2;\n      break;\n    }\n  }\n\n  let endX: number;\n  let endY: number;\n\n  switch (direction) {\n    case \"up\": {\n      endX = endBindingElement.x + endBindingElement.width / 2 - startX;\n      endY = endBindingElement.y + endBindingElement.height - startY + PADDING;\n      break;\n    }\n    case \"down\": {\n      endX = endBindingElement.x + endBindingElement.width / 2 - startX;\n      endY = endBindingElement.y - startY - PADDING;\n      break;\n    }\n    case \"right\": {\n      endX = endBindingElement.x - startX - PADDING;\n      endY = endBindingElement.y - startY + endBindingElement.height / 2;\n      break;\n    }\n    case \"left\": {\n      endX = endBindingElement.x + endBindingElement.width - startX + PADDING;\n      endY = endBindingElement.y - startY + endBindingElement.height / 2;\n      break;\n    }\n  }\n\n  const bindingArrow = newArrowElement({\n    type: \"arrow\",\n    x: startX,\n    y: startY,\n    startArrowhead: null,\n    endArrowhead: appState.currentItemEndArrowhead,\n    strokeColor: startBindingElement.strokeColor,\n    strokeStyle: startBindingElement.strokeStyle,\n    strokeWidth: startBindingElement.strokeWidth,\n    opacity: startBindingElement.opacity,\n    roughness: startBindingElement.roughness,\n    points: [pointFrom(0, 0), pointFrom(endX, endY)],\n    elbowed: true,\n  });\n\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  bindBindingElement(\n    bindingArrow,\n    startBindingElement,\n    \"orbit\",\n    \"start\",\n    scene,\n  );\n  bindBindingElement(bindingArrow, endBindingElement, \"orbit\", \"end\", scene);\n\n  const changedElements = new Map<string, OrderedExcalidrawElement>();\n  changedElements.set(\n    startBindingElement.id,\n    startBindingElement as OrderedExcalidrawElement,\n  );\n  changedElements.set(\n    endBindingElement.id,\n    endBindingElement as OrderedExcalidrawElement,\n  );\n  changedElements.set(\n    bindingArrow.id,\n    bindingArrow as OrderedExcalidrawElement,\n  );\n\n  LinearElementEditor.movePoints(\n    bindingArrow,\n    scene,\n    new Map([\n      [\n        1,\n        {\n          point: bindingArrow.points[1],\n        },\n      ],\n    ]),\n  );\n\n  const update = updateElbowArrowPoints(\n    bindingArrow,\n    toBrandedType<NonDeletedSceneElementsMap>(\n      new Map([\n        ...elementsMap.entries(),\n        [startBindingElement.id, startBindingElement],\n        [endBindingElement.id, endBindingElement],\n        [bindingArrow.id, bindingArrow],\n      ] as [string, Ordered<ExcalidrawElement>][]),\n    ),\n    { points: bindingArrow.points },\n  );\n\n  return {\n    ...bindingArrow,\n    ...update,\n  };\n};\n\nexport class FlowChartNavigator {\n  isExploring: boolean = false;\n  // nodes that are ONE link away (successor and predecessor both included)\n  private sameLevelNodes: ExcalidrawElement[] = [];\n  private sameLevelIndex: number = 0;\n  // set it to the opposite of the defalut creation direction\n  private direction: LinkDirection | null = null;\n  // for speedier navigation\n  private visitedNodes: Set<ExcalidrawElement[\"id\"]> = new Set();\n\n  clear() {\n    this.isExploring = false;\n    this.sameLevelNodes = [];\n    this.sameLevelIndex = 0;\n    this.direction = null;\n    this.visitedNodes.clear();\n  }\n\n  exploreByDirection(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n    direction: LinkDirection,\n  ): ExcalidrawElement[\"id\"] | null {\n    if (!isBindableElement(element)) {\n      return null;\n    }\n\n    // clear if going at a different direction\n    if (direction !== this.direction) {\n      this.clear();\n    }\n\n    // add the current node to the visited\n    if (!this.visitedNodes.has(element.id)) {\n      this.visitedNodes.add(element.id);\n    }\n\n    /**\n     * CASE:\n     * - already started exploring, AND\n     * - there are multiple nodes at the same level, AND\n     * - still going at the same direction, AND\n     *\n     * RESULT:\n     * - loop through nodes at the same level\n     *\n     * WHY:\n     * - provides user the capability to loop through nodes at the same level\n     */\n    if (\n      this.isExploring &&\n      direction === this.direction &&\n      this.sameLevelNodes.length > 1\n    ) {\n      this.sameLevelIndex =\n        (this.sameLevelIndex + 1) % this.sameLevelNodes.length;\n\n      return this.sameLevelNodes[this.sameLevelIndex].id;\n    }\n\n    const nodes = [\n      ...getSuccessors(element, elementsMap, direction),\n      ...getPredecessors(element, elementsMap, direction),\n    ];\n\n    /**\n     * CASE:\n     * - just started exploring at the given direction\n     *\n     * RESULT:\n     * - go to the first node in the given direction\n     */\n    if (nodes.length > 0) {\n      this.sameLevelIndex = 0;\n      this.isExploring = true;\n      this.sameLevelNodes = nodes;\n      this.direction = direction;\n      this.visitedNodes.add(nodes[0].id);\n\n      return nodes[0].id;\n    }\n\n    /**\n     * CASE:\n     * - (just started exploring or still going at the same direction) OR\n     * - there're no nodes at the given direction\n     *\n     * RESULT:\n     * - go to some other unvisited linked node\n     *\n     * WHY:\n     * - provide a speedier navigation from a given node to some predecessor\n     *   without the user having to change arrow key\n     */\n    if (direction === this.direction || !this.isExploring) {\n      if (!this.isExploring) {\n        // just started and no other nodes at the given direction\n        // so the current node is technically the first visited node\n        // (this is needed so that we don't get stuck between looping through )\n        this.visitedNodes.add(element.id);\n      }\n\n      const otherDirections: LinkDirection[] = [\n        \"up\",\n        \"right\",\n        \"down\",\n        \"left\",\n      ].filter((dir): dir is LinkDirection => dir !== direction);\n\n      const otherLinkedNodes = otherDirections\n        .map((dir) => [\n          ...getSuccessors(element, elementsMap, dir),\n          ...getPredecessors(element, elementsMap, dir),\n        ])\n        .flat()\n        .filter((linkedNode) => !this.visitedNodes.has(linkedNode.id));\n\n      for (const linkedNode of otherLinkedNodes) {\n        if (!this.visitedNodes.has(linkedNode.id)) {\n          this.visitedNodes.add(linkedNode.id);\n          this.isExploring = true;\n          this.direction = direction;\n          return linkedNode.id;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\nexport class FlowChartCreator {\n  isCreatingChart: boolean = false;\n  private numberOfNodes: number = 0;\n  private direction: LinkDirection | null = \"right\";\n  pendingNodes: PendingExcalidrawElements | null = null;\n\n  createNodes(\n    startNode: ExcalidrawFlowchartNodeElement,\n    appState: AppState,\n    direction: LinkDirection,\n    scene: Scene,\n  ) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    if (direction !== this.direction) {\n      const { nextNode, bindingArrow } = addNewNode(\n        startNode,\n        appState,\n        direction,\n        scene,\n      );\n\n      this.numberOfNodes = 1;\n      this.isCreatingChart = true;\n      this.direction = direction;\n      this.pendingNodes = [nextNode, bindingArrow];\n    } else {\n      this.numberOfNodes += 1;\n      const newNodes = addNewNodes(\n        startNode,\n        appState,\n        direction,\n        scene,\n        this.numberOfNodes,\n      );\n\n      this.isCreatingChart = true;\n      this.direction = direction;\n      this.pendingNodes = newNodes;\n    }\n\n    // add pending nodes to the same frame as the start node\n    // if every pending node is at least intersecting with the frame\n    if (startNode.frameId) {\n      const frame = elementsMap.get(startNode.frameId);\n\n      invariant(\n        frame && isFrameElement(frame),\n        \"not an ExcalidrawFrameElement\",\n      );\n\n      if (\n        frame &&\n        this.pendingNodes.every(\n          (node) =>\n            elementsAreInFrameBounds([node], frame, elementsMap) ||\n            elementOverlapsWithFrame(node, frame, elementsMap),\n        )\n      ) {\n        this.pendingNodes = this.pendingNodes.map((node) =>\n          mutateElement(node, elementsMap, {\n            frameId: startNode.frameId,\n          }),\n        );\n      }\n    }\n  }\n\n  clear() {\n    this.isCreatingChart = false;\n    this.pendingNodes = null;\n    this.direction = null;\n    this.numberOfNodes = 0;\n  }\n}\n\nexport const isNodeInFlowchart = (\n  element: ExcalidrawFlowchartNodeElement,\n  elementsMap: ElementsMap,\n) => {\n  for (const [, el] of elementsMap) {\n    if (\n      el.type === \"arrow\" &&\n      (el.startBinding?.elementId === element.id ||\n        el.endBinding?.elementId === element.id)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n", "import { pointDistance, pointFrom, type GlobalPoint } from \"@excalidraw/math\";\nimport { invariant } from \"@excalidraw/common\";\n\nimport type { AppState, NullableGridSize } from \"@excalidraw/excalidraw/types\";\n\nimport {\n  bindBindingElement,\n  calculateFixedPointForNonElbowArrowBinding,\n  FOCUS_POINT_SIZE,\n  getBindingGap,\n  getGlobalFixedPointForBindableElement,\n  isBindingEnabled,\n  maxBindingDistance_simple,\n  unbindBindingElement,\n  updateBoundPoint,\n} from \"../binding\";\nimport {\n  isBindableElement,\n  isBindingElement,\n  isElbowArrow,\n} from \"../typeChecks\";\nimport { LinearElementEditor } from \"../linearElementEditor\";\nimport { getHoveredElementForFocusPoint, hitElementItself } from \"../collision\";\nimport { moveArrowAboveBindable } from \"../zindex\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  NonDeletedSceneElementsMap,\n  PointsPositionUpdates,\n} from \"../types\";\n\nimport type { Scene } from \"../Scene\";\n\nexport const isFocusPointVisible = (\n  focusPoint: GlobalPoint,\n  arrow: ExcalidrawArrowElement,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  appState: {\n    isBindingEnabled: AppState[\"isBindingEnabled\"];\n    zoom: AppState[\"zoom\"];\n  },\n  ignoreOverlap = false,\n): boolean => {\n  // No focus point management for elbow arrows, because elbow arrows\n  // always have their focus point at the arrow point itself\n  if (\n    isElbowArrow(arrow) ||\n    !isBindingEnabled(appState) ||\n    arrow.points.length !== 2\n  ) {\n    return false;\n  }\n\n  // When connecting two shapes (2-point arrow with both ends bound), only the\n  // point handles are shown so we don't draw focus indicators and avoid\n  // the overlapping \"infinity\" double circle at each end.\n  if (arrow.startBinding && arrow.endBinding) {\n    return false;\n  }\n\n  // Avoid showing the focus point indicator if the focus point is essentially\n  // on top of the arrow point it belongs to itself, if not ignoring specifically\n  if (!ignoreOverlap) {\n    const associatedPointIdx =\n      arrow.startBinding?.elementId === bindableElement.id\n        ? 0\n        : arrow.points.length - 1;\n    const associatedArrowPoint =\n      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n        arrow,\n        associatedPointIdx,\n        elementsMap,\n      );\n\n    if (\n      pointDistance(focusPoint, associatedArrowPoint) <\n      (FOCUS_POINT_SIZE * 1.5) / appState.zoom.value\n    ) {\n      return false;\n    }\n  }\n\n  // Check if the focus point is within the element's shape bounds\n  return hitElementItself({\n    element: bindableElement,\n    elementsMap,\n    point: focusPoint,\n    threshold: getBindingGap(bindableElement, arrow),\n    overrideShouldTestInside: true,\n  });\n};\n\n// Updates the arrow endpoints in \"orbit\" configuration\nconst focusPointUpdate = (\n  arrow: ExcalidrawArrowElement,\n  bindableElement: ExcalidrawBindableElement | null,\n  isStartBinding: boolean,\n  elementsMap: NonDeletedSceneElementsMap,\n  scene: Scene,\n  appState: AppState,\n  switchToInsideBinding: boolean,\n) => {\n  const pointUpdates = new Map();\n\n  const bindingField = isStartBinding ? \"startBinding\" : \"endBinding\";\n  const adjacentBindingField = isStartBinding ? \"endBinding\" : \"startBinding\";\n  let currentBinding = arrow[bindingField];\n  let adjacentBinding = arrow[adjacentBindingField];\n\n  // Update the dragged focus point related end\n  if (currentBinding && bindableElement) {\n    // Update the targeted bindings\n    const boundToSameElement =\n      bindableElement &&\n      adjacentBinding &&\n      currentBinding.elementId === adjacentBinding.elementId;\n    if (switchToInsideBinding || boundToSameElement) {\n      currentBinding = {\n        ...currentBinding,\n        mode: \"inside\",\n      };\n    } else {\n      currentBinding = {\n        ...currentBinding,\n        mode: \"orbit\",\n      };\n    }\n\n    const pointIndex = isStartBinding ? 0 : arrow.points.length - 1;\n    const newPoint = updateBoundPoint(\n      arrow,\n      bindingField as \"startBinding\" | \"endBinding\",\n      currentBinding,\n      bindableElement,\n      elementsMap,\n    );\n\n    if (newPoint) {\n      pointUpdates.set(pointIndex, { point: newPoint });\n    }\n  }\n\n  // Also update the adjacent end if it has a binding\n  if (adjacentBinding && adjacentBinding.mode === \"orbit\") {\n    const adjacentBindableElement = elementsMap.get(\n      adjacentBinding.elementId,\n    ) as ExcalidrawBindableElement;\n\n    if (\n      adjacentBindableElement &&\n      isBindableElement(adjacentBindableElement) &&\n      isBindingEnabled(appState)\n    ) {\n      // Same shape bound on both ends\n      const boundToSameElementAfterUpdate =\n        bindableElement && adjacentBinding.elementId === bindableElement.id;\n      if (switchToInsideBinding || boundToSameElementAfterUpdate) {\n        adjacentBinding = {\n          ...adjacentBinding,\n          mode: \"inside\",\n        };\n      } else {\n        adjacentBinding = {\n          ...adjacentBinding,\n          mode: \"orbit\",\n        };\n      }\n\n      const adjacentPointIndex = isStartBinding ? arrow.points.length - 1 : 0;\n      const adjacentNewPoint = updateBoundPoint(\n        arrow,\n        adjacentBindingField,\n        adjacentBinding,\n        adjacentBindableElement,\n        elementsMap,\n      );\n\n      if (adjacentNewPoint) {\n        pointUpdates.set(adjacentPointIndex, {\n          point: adjacentNewPoint,\n        });\n      }\n    }\n  }\n\n  if (pointUpdates.size > 0) {\n    LinearElementEditor.movePoints(arrow, scene, pointUpdates, {\n      [bindingField]: currentBinding,\n      [adjacentBindingField]: adjacentBinding,\n    });\n  }\n};\n\nexport const handleFocusPointDrag = (\n  linearElementEditor: LinearElementEditor,\n  elementsMap: NonDeletedSceneElementsMap,\n  pointerCoords: { x: number; y: number },\n  scene: Scene,\n  appState: AppState,\n  gridSize: NullableGridSize,\n  switchToInsideBinding: boolean,\n) => {\n  const arrow = LinearElementEditor.getElement(\n    linearElementEditor.elementId,\n    elementsMap,\n  ) as any;\n\n  // Sanity checks\n  if (\n    !arrow ||\n    !isBindingElement(arrow) ||\n    isElbowArrow(arrow) ||\n    !linearElementEditor.hoveredFocusPointBinding ||\n    !linearElementEditor.draggedFocusPointBinding\n  ) {\n    return;\n  }\n\n  const isStartBinding =\n    linearElementEditor.draggedFocusPointBinding === \"start\";\n  const binding = isStartBinding ? arrow.startBinding : arrow.endBinding;\n  const { x: offsetX, y: offsetY } = linearElementEditor.pointerOffset;\n  const point = pointFrom<GlobalPoint>(\n    pointerCoords.x - offsetX,\n    pointerCoords.y - offsetY,\n  );\n  const bindingField = isStartBinding ? \"startBinding\" : \"endBinding\";\n  const hit = getHoveredElementForFocusPoint(\n    point,\n    arrow,\n    scene.getNonDeletedElements(),\n    elementsMap,\n    maxBindingDistance_simple(appState.zoom),\n  );\n\n  // Hovering a bindable element\n  if (hit && isBindingEnabled(appState)) {\n    // Break existing binding if bound to another shape or if binding is disabled\n    if (arrow[bindingField] && hit.id !== binding?.elementId) {\n      unbindBindingElement(\n        arrow,\n        linearElementEditor.draggedFocusPointBinding,\n        scene,\n      );\n    }\n\n    // Handle binding mode switch\n    const newMode =\n      switchToInsideBinding && arrow[bindingField]?.mode === \"orbit\"\n        ? \"inside\"\n        : !switchToInsideBinding && arrow[bindingField]?.mode === \"inside\"\n        ? \"orbit\"\n        : null;\n\n    // If no existing binding, create it\n    if (!arrow[bindingField] || newMode) {\n      // Create a new binding if none exists\n      bindBindingElement(\n        arrow,\n        hit,\n        newMode || \"orbit\",\n        linearElementEditor.draggedFocusPointBinding,\n        scene,\n        point,\n      );\n    }\n\n    // Update the binding's fixed point\n    scene.mutateElement(arrow, {\n      [bindingField]: {\n        ...arrow[bindingField],\n        elementId: hit.id,\n        mode: newMode || arrow[bindingField]?.mode || \"orbit\",\n        ...calculateFixedPointForNonElbowArrowBinding(\n          arrow,\n          hit,\n          linearElementEditor.draggedFocusPointBinding,\n          elementsMap,\n          point,\n        ),\n      },\n    });\n  } else {\n    // Not hovering any bindable element, move the arrow endpoint\n    const pointUpdates: PointsPositionUpdates = new Map();\n    const pointIndex = isStartBinding ? 0 : arrow.points.length - 1;\n    pointUpdates.set(pointIndex, {\n      point: LinearElementEditor.createPointAt(\n        arrow,\n        elementsMap,\n        point[0],\n        point[1],\n        gridSize,\n      ),\n    });\n    LinearElementEditor.movePoints(arrow, scene, pointUpdates);\n    if (arrow[bindingField]) {\n      unbindBindingElement(arrow, isStartBinding ? \"start\" : \"end\", scene);\n    }\n  }\n\n  // Update the arrow endpoints\n  focusPointUpdate(\n    arrow,\n    hit,\n    isStartBinding,\n    elementsMap,\n    scene,\n    appState,\n    switchToInsideBinding,\n  );\n\n  if (hit && isBindingEnabled(appState)) {\n    moveArrowAboveBindable(\n      point,\n      arrow,\n      scene.getElementsIncludingDeleted(),\n      elementsMap,\n      scene,\n      hit,\n    );\n  }\n};\n\nexport const handleFocusPointPointerDown = (\n  arrow: ExcalidrawArrowElement,\n  pointerDownState: { origin: { x: number; y: number } },\n  elementsMap: NonDeletedSceneElementsMap,\n  appState: AppState,\n): {\n  hitFocusPoint: \"start\" | \"end\" | null;\n  pointerOffset: { x: number; y: number };\n} => {\n  const pointerPos = pointFrom(\n    pointerDownState.origin.x,\n    pointerDownState.origin.y,\n  );\n  const hitThreshold = (FOCUS_POINT_SIZE * 1.5) / appState.zoom.value;\n\n  // Check start binding focus point\n  if (arrow.startBinding?.elementId) {\n    const bindableElement = elementsMap.get(arrow.startBinding.elementId);\n    if (\n      bindableElement &&\n      isBindableElement(bindableElement) &&\n      !bindableElement.isDeleted\n    ) {\n      const focusPoint = getGlobalFixedPointForBindableElement(\n        arrow.startBinding.fixedPoint,\n        bindableElement,\n        elementsMap,\n      );\n      if (\n        isFocusPointVisible(\n          focusPoint,\n          arrow,\n          bindableElement,\n          elementsMap,\n          appState,\n        ) &&\n        pointDistance(pointerPos, focusPoint) <= hitThreshold\n      ) {\n        return {\n          hitFocusPoint: \"start\",\n          pointerOffset: {\n            x: pointerPos[0] - focusPoint[0],\n            y: pointerPos[1] - focusPoint[1],\n          },\n        };\n      }\n    }\n  }\n\n  // Check end binding focus point (only if start not already hit)\n  if (arrow.endBinding?.elementId) {\n    const bindableElement = elementsMap.get(arrow.endBinding.elementId);\n    if (\n      bindableElement &&\n      isBindableElement(bindableElement) &&\n      !bindableElement.isDeleted\n    ) {\n      const focusPoint = getGlobalFixedPointForBindableElement(\n        arrow.endBinding.fixedPoint,\n        bindableElement,\n        elementsMap,\n      );\n      if (\n        isFocusPointVisible(\n          focusPoint,\n          arrow,\n          bindableElement,\n          elementsMap,\n          appState,\n        ) &&\n        pointDistance(pointerPos, focusPoint) <= hitThreshold\n      ) {\n        return {\n          hitFocusPoint: \"end\",\n          pointerOffset: {\n            x: pointerPos[0] - focusPoint[0],\n            y: pointerPos[1] - focusPoint[1],\n          },\n        };\n      }\n    }\n  }\n\n  return {\n    hitFocusPoint: null,\n    pointerOffset: { x: 0, y: 0 },\n  };\n};\n\nexport const handleFocusPointPointerUp = (\n  linearElementEditor: LinearElementEditor,\n  scene: Scene,\n) => {\n  invariant(\n    linearElementEditor.draggedFocusPointBinding,\n    \"Must have a dragged focus point at pointer release\",\n  );\n\n  const arrow = LinearElementEditor.getElement<ExcalidrawArrowElement>(\n    linearElementEditor.elementId,\n    scene.getNonDeletedElementsMap(),\n  );\n  invariant(arrow, \"Arrow must be in the scene\");\n\n  // Clean up\n  const bindingKey =\n    linearElementEditor.draggedFocusPointBinding === \"start\"\n      ? \"startBinding\"\n      : \"endBinding\";\n  const otherBindingKey =\n    linearElementEditor.draggedFocusPointBinding === \"start\"\n      ? \"endBinding\"\n      : \"startBinding\";\n  const boundElementId = arrow[bindingKey]?.elementId;\n  const otherBoundElementId = arrow[otherBindingKey]?.elementId;\n  const oldBoundElement =\n    boundElementId &&\n    scene\n      .getNonDeletedElements()\n      .find(\n        (element) =>\n          element.id !== boundElementId &&\n          element.id !== otherBoundElementId &&\n          isBindableElement(element) &&\n          element.boundElements?.find(({ id }) => id === arrow.id),\n      );\n  if (oldBoundElement) {\n    scene.mutateElement(oldBoundElement, {\n      boundElements: oldBoundElement.boundElements?.filter(\n        ({ id }) => id !== arrow.id,\n      ),\n    });\n  }\n\n  // Record the new bound element\n  const boundElement =\n    boundElementId && scene.getNonDeletedElementsMap().get(boundElementId);\n  if (boundElement) {\n    scene.mutateElement(boundElement, {\n      boundElements: [\n        ...(boundElement.boundElements || [])?.filter(\n          ({ id }) => id !== arrow.id,\n        ),\n        {\n          id: arrow.id,\n          type: \"arrow\",\n        },\n      ],\n    });\n  }\n};\n\nexport const handleFocusPointHover = (\n  arrow: ExcalidrawArrowElement,\n  scenePointerX: number,\n  scenePointerY: number,\n  scene: Scene,\n  appState: AppState,\n): \"start\" | \"end\" | null => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const pointerPos = pointFrom(scenePointerX, scenePointerY);\n  const hitThreshold = (FOCUS_POINT_SIZE * 1.5) / appState.zoom.value;\n\n  // Check start binding focus point\n  if (arrow.startBinding?.elementId) {\n    const bindableElement = elementsMap.get(arrow.startBinding.elementId);\n    if (\n      bindableElement &&\n      isBindableElement(bindableElement) &&\n      !bindableElement.isDeleted\n    ) {\n      const focusPoint = getGlobalFixedPointForBindableElement(\n        arrow.startBinding.fixedPoint,\n        bindableElement,\n        elementsMap,\n      );\n      if (\n        isFocusPointVisible(\n          focusPoint,\n          arrow,\n          bindableElement,\n          elementsMap,\n          appState,\n        ) &&\n        pointDistance(pointerPos, focusPoint) <= hitThreshold\n      ) {\n        return \"start\";\n      }\n    }\n  }\n\n  // Check end binding focus point (only if start not already hovered)\n  if (arrow.endBinding?.elementId) {\n    const bindableElement = elementsMap.get(arrow.endBinding.elementId);\n    if (\n      bindableElement &&\n      isBindableElement(bindableElement) &&\n      !bindableElement.isDeleted\n    ) {\n      const focusPoint = getGlobalFixedPointForBindableElement(\n        arrow.endBinding.fixedPoint,\n        bindableElement,\n        elementsMap,\n      );\n      if (\n        isFocusPointVisible(\n          focusPoint,\n          arrow,\n          bindableElement,\n          elementsMap,\n          appState,\n        ) &&\n        pointDistance(pointerPos, focusPoint) <= hitThreshold\n      ) {\n        return \"end\";\n      }\n    }\n  }\n\n  return null;\n};\n", "import { arrayToMap, findIndex, findLastIndex } from \"@excalidraw/common\";\n\nimport type { AppState } from \"@excalidraw/excalidraw/types\";\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport { isFrameLikeElement, isTextElement } from \"./typeChecks\";\nimport { getElementsInGroup } from \"./groups\";\nimport { syncMovedIndices } from \"./fractionalIndex\";\nimport { getSelectedElements } from \"./selection\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport { getHoveredElementForBinding } from \"./collision\";\n\nimport type { Scene } from \"./Scene\";\nimport type {\n  ExcalidrawArrowElement,\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeletedExcalidrawElement,\n  NonDeletedSceneElementsMap,\n  Ordered,\n  OrderedExcalidrawElement,\n} from \"./types\";\n\nconst isOfTargetFrame = (element: ExcalidrawElement, frameId: string) => {\n  return element.frameId === frameId || element.id === frameId;\n};\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  const selectedElementIds = arrayToMap(\n    elementsToBeMoved\n      ? elementsToBeMoved\n      : getSelectedElements(elements, appState, {\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        }),\n  );\n  while (++index < elements.length) {\n    const element = elements[index];\n    if (selectedElementIds.get(element.id)) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (element.isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */\nconst getTargetIndexAccountingForBinding = (\n  nextElement: ExcalidrawElement,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n  scene: Scene,\n) => {\n  if (\"containerId\" in nextElement && nextElement.containerId) {\n    // TODO: why not to get the container from the nextElements?\n    const containerElement = scene.getElement(nextElement.containerId);\n    if (containerElement) {\n      return direction === \"left\"\n        ? Math.min(\n            elements.indexOf(containerElement),\n            elements.indexOf(nextElement),\n          )\n        : Math.max(\n            elements.indexOf(containerElement),\n            elements.indexOf(nextElement),\n          );\n    }\n  } else {\n    const boundElementId = nextElement.boundElements?.find(\n      (binding) => binding.type !== \"arrow\",\n    )?.id;\n    if (boundElementId) {\n      const boundTextElement = scene.getElement(boundElementId);\n      if (boundTextElement) {\n        return direction === \"left\"\n          ? Math.min(\n              elements.indexOf(boundTextElement),\n              elements.indexOf(nextElement),\n            )\n          : Math.max(\n              elements.indexOf(boundTextElement),\n              elements.indexOf(nextElement),\n            );\n      }\n    }\n  }\n};\n\nconst getContiguousFrameRangeElements = (\n  allElements: readonly ExcalidrawElement[],\n  frameId: ExcalidrawFrameLikeElement[\"id\"],\n) => {\n  let rangeStart = -1;\n  let rangeEnd = -1;\n  allElements.forEach((element, index) => {\n    if (isOfTargetFrame(element, frameId)) {\n      if (rangeStart === -1) {\n        rangeStart = index;\n      }\n      rangeEnd = index;\n    }\n  });\n  if (rangeStart === -1) {\n    return [];\n  }\n  return allElements.slice(rangeStart, rangeEnd + 1);\n};\n\n/**\n * Moves the arrow element above any bindable elements it intersects with or\n * hovers over.\n */\nexport const moveArrowAboveBindable = (\n  point: GlobalPoint,\n  arrow: ExcalidrawArrowElement,\n  elements: readonly Ordered<NonDeletedExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  scene: Scene,\n  hit?: NonDeletedExcalidrawElement,\n): readonly OrderedExcalidrawElement[] => {\n  const hoveredElement = hit\n    ? hit\n    : getHoveredElementForBinding(point, elements, elementsMap);\n\n  if (!hoveredElement) {\n    return elements;\n  }\n\n  const boundTextElement = getBoundTextElement(hoveredElement, elementsMap);\n  const containerElement = isTextElement(hoveredElement)\n    ? getContainerElement(hoveredElement, elementsMap)\n    : null;\n\n  const bindableIds = [\n    hoveredElement.id,\n    boundTextElement?.id,\n    containerElement?.id,\n  ].filter((id): id is NonDeletedExcalidrawElement[\"id\"] => !!id);\n  const bindableIdx = elements.findIndex((el) => bindableIds.includes(el.id));\n  const arrowIdx = elements.findIndex((el) => el.id === arrow.id);\n\n  if (arrowIdx !== -1 && bindableIdx !== -1 && arrowIdx < bindableIdx) {\n    const updatedElements = Array.from(elements);\n    const arrow = updatedElements.splice(arrowIdx, 1)[0];\n    updatedElements.splice(bindableIdx, 0, arrow);\n\n    scene.replaceAllElements(updatedElements);\n  }\n\n  return elements;\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n  /**\n   * Frame id if moving frame children.\n   * If whole frame (including all children) is being moved, supply `null`.\n   */\n  containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n  scene: Scene,\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    if (containingFrame) {\n      return element.frameId === containingFrame;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(\n          elements,\n          (el) => indexFilter(el),\n          Math.max(0, boundaryIndex - 1),\n        )\n      : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group \u2192 return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return (\n        getTargetIndexAccountingForBinding(\n          nextElement,\n          elements,\n          direction,\n          scene,\n        ) ?? candidateIndex\n      );\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group \u2192 prevent\n      return -1;\n    }\n  }\n\n  if (\n    !containingFrame &&\n    (nextElement.frameId || isFrameLikeElement(nextElement))\n  ) {\n    const frameElements = getContiguousFrameRangeElements(\n      elements,\n      nextElement.frameId || nextElement.id,\n    );\n    return direction === \"left\"\n      ? elements.indexOf(frameElements[0])\n      : elements.indexOf(frameElements[frameElements.length - 1]);\n  }\n\n  if (!nextElement.groupIds.length) {\n    return (\n      getTargetIndexAccountingForBinding(\n        nextElement,\n        elements,\n        direction,\n        scene,\n      ) ?? candidateIndex\n    );\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc.set(element.id, element);\n    return acc;\n  }, new Map<string, ExcalidrawElement>());\n};\n\nconst shiftElementsByOne = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  scene: Scene,\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  const selectedFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>(\n    indicesToMove\n      .filter((idx) => isFrameLikeElement(elements[idx]))\n      .map((idx) => elements[idx].id),\n  );\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const containingFrame = indices.some((idx) => {\n      const el = elements[idx];\n      return el.frameId && selectedFrames.has(el.frameId);\n    })\n      ? null\n      : elements[boundaryIndex]?.frameId;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n      containingFrame,\n      scene,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  syncMovedIndices(elements, targetElementsMap);\n\n  return elements;\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (containingFrame) {\n      leadingIndex = findIndex(elements, (el) =>\n        isOfTargetFrame(el, containingFrame),\n      );\n    } else if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (containingFrame) {\n      trailingIndex = findLastIndex(elements, (el) =>\n        isOfTargetFrame(el, containingFrame),\n      );\n    } else if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  if (leadingIndex === -1) {\n    leadingIndex = 0;\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Array.from(targetElementsMap.values());\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n  const nextElements =\n    direction === \"left\"\n      ? [\n          ...leadingElements,\n          ...targetElements,\n          ...displacedElements,\n          ...trailingElements,\n        ]\n      : [\n          ...leadingElements,\n          ...displacedElements,\n          ...targetElements,\n          ...trailingElements,\n        ];\n\n  syncMovedIndices(nextElements, targetElementsMap);\n\n  return nextElements;\n};\n\nfunction shiftElementsAccountingForFrames(\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  shiftFunction: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    direction: \"left\" | \"right\",\n    containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n    elementsToBeMoved?: readonly ExcalidrawElement[],\n  ) => ExcalidrawElement[] | readonly ExcalidrawElement[],\n) {\n  const elementsToMove = arrayToMap(\n    getSelectedElements(allElements, appState, {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    }),\n  );\n\n  const frameAwareContiguousElementsToMove: {\n    regularElements: ExcalidrawElement[];\n    frameChildren: Map<ExcalidrawFrameLikeElement[\"id\"], ExcalidrawElement[]>;\n  } = { regularElements: [], frameChildren: new Map() };\n\n  const fullySelectedFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n\n  for (const element of allElements) {\n    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {\n      fullySelectedFrames.add(element.id);\n    }\n  }\n\n  for (const element of allElements) {\n    if (elementsToMove.has(element.id)) {\n      if (\n        isFrameLikeElement(element) ||\n        (element.frameId && fullySelectedFrames.has(element.frameId))\n      ) {\n        frameAwareContiguousElementsToMove.regularElements.push(element);\n      } else if (!element.frameId) {\n        frameAwareContiguousElementsToMove.regularElements.push(element);\n      } else {\n        const frameChildren =\n          frameAwareContiguousElementsToMove.frameChildren.get(\n            element.frameId,\n          ) || [];\n        frameChildren.push(element);\n        frameAwareContiguousElementsToMove.frameChildren.set(\n          element.frameId,\n          frameChildren,\n        );\n      }\n    }\n  }\n\n  let nextElements = allElements;\n\n  const frameChildrenSets = Array.from(\n    frameAwareContiguousElementsToMove.frameChildren.entries(),\n  );\n\n  for (const [frameId, children] of frameChildrenSets) {\n    nextElements = shiftFunction(\n      allElements,\n      appState,\n      direction,\n      frameId,\n      children,\n    );\n  }\n\n  return shiftFunction(\n    nextElements,\n    appState,\n    direction,\n    null,\n    frameAwareContiguousElementsToMove.regularElements,\n  );\n}\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  scene: Scene,\n) => {\n  return shiftElementsByOne(allElements, appState, \"left\", scene);\n};\n\nexport const moveOneRight = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  scene: Scene,\n) => {\n  return shiftElementsByOne(allElements, appState, \"right\", scene);\n};\n\nexport const moveAllLeft = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsAccountingForFrames(\n    allElements,\n    appState,\n    \"left\",\n    shiftElementsToEnd,\n  );\n};\n\nexport const moveAllRight = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsAccountingForFrames(\n    allElements,\n    appState,\n    \"right\",\n    shiftElementsToEnd,\n  );\n};\n", "// -----------------------------------------------------------------------------\n// ExcalidrawImageElement & related helpers\n// -----------------------------------------------------------------------------\n\nimport { MIME_TYPES, SVG_NS } from \"@excalidraw/common\";\n\nimport type {\n  AppClassProperties,\n  DataURL,\n  BinaryFiles,\n} from \"@excalidraw/excalidraw/types\";\n\nimport { isInitializedImageElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"./types\";\n\nexport const loadHTMLImageElement = (dataURL: DataURL) => {\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = (error) => {\n      reject(error);\n    };\n    image.src = dataURL;\n  });\n};\n\n/** NOTE: updates cache even if already populated with given image. Thus,\n * you should filter out the images upstream if you want to optimize this. */\nexport const updateImageCache = async ({\n  fileIds,\n  files,\n  imageCache,\n}: {\n  fileIds: FileId[];\n  files: BinaryFiles;\n  imageCache: AppClassProperties[\"imageCache\"];\n}) => {\n  const updatedFiles = new Map<FileId, true>();\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    fileIds.reduce((promises, fileId) => {\n      const fileData = files[fileId as string];\n      if (fileData && !updatedFiles.has(fileId)) {\n        updatedFiles.set(fileId, true);\n        return promises.concat(\n          (async () => {\n            try {\n              if (fileData.mimeType === MIME_TYPES.binary) {\n                throw new Error(\"Only images can be added to ImageCache\");\n              }\n\n              const imagePromise = loadHTMLImageElement(fileData.dataURL);\n              const data = {\n                image: imagePromise,\n                mimeType: fileData.mimeType,\n              } as const;\n              // store the promise immediately to indicate there's an in-progress\n              // initialization\n              imageCache.set(fileId, data);\n\n              const image = await imagePromise;\n\n              imageCache.set(fileId, { ...data, image });\n            } catch (error: any) {\n              erroredFiles.set(fileId, true);\n            }\n          })(),\n        );\n      }\n      return promises;\n    }, [] as Promise<any>[]),\n  );\n\n  return {\n    imageCache,\n    /** includes errored files because they cache was updated nonetheless */\n    updatedFiles,\n    /** files that failed when creating HTMLImageElement */\n    erroredFiles,\n  };\n};\n\nexport const getInitializedImageElements = (\n  elements: readonly ExcalidrawElement[],\n) =>\n  elements.filter((element) =>\n    isInitializedImageElement(element),\n  ) as InitializedExcalidrawImageElement[];\n\nexport const isHTMLSVGElement = (node: Node | null): node is SVGElement => {\n  // lower-casing due to XML/HTML convention differences\n  // https://johnresig.com/blog/nodename-case-sensitivity\n  return node?.nodeName.toLowerCase() === \"svg\";\n};\n\nexport const normalizeSVG = (SVGString: string) => {\n  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);\n  const svg = doc.querySelector(\"svg\");\n  const errorNode = doc.querySelector(\"parsererror\");\n  if (errorNode || !isHTMLSVGElement(svg)) {\n    throw new Error(\"Invalid SVG\");\n  } else {\n    if (!svg.hasAttribute(\"xmlns\")) {\n      svg.setAttribute(\"xmlns\", SVG_NS);\n    }\n\n    let width = svg.getAttribute(\"width\");\n    let height = svg.getAttribute(\"height\");\n\n    // Do not use % or auto values for width/height\n    // to avoid scaling issues when rendering at different sizes/zoom levels\n    if (width?.includes(\"%\") || width === \"auto\") {\n      width = null;\n    }\n    if (height?.includes(\"%\") || height === \"auto\") {\n      height = null;\n    }\n\n    const viewBox = svg.getAttribute(\"viewBox\");\n\n    if (!width || !height) {\n      width = width || \"50\";\n      height = height || \"50\";\n\n      if (viewBox) {\n        const match = viewBox.match(\n          /\\d+ +\\d+ +(\\d+(?:\\.\\d+)?) +(\\d+(?:\\.\\d+)?)/,\n        );\n        if (match) {\n          [, width, height] = match;\n        }\n      }\n\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n\n    // Make sure viewBox is set\n    if (!viewBox) {\n      svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    }\n\n    return svg.outerHTML;\n  }\n};\n", "import { getCommonBounds } from \"./bounds\";\nimport { type ElementUpdate, newElementWith } from \"./mutateElement\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\n// TODO rewrite (mostly vibe-coded)\nexport const positionElementsOnGrid = <TElement extends ExcalidrawElement>(\n  elements: TElement[] | TElement[][],\n  centerX: number,\n  centerY: number,\n  padding = 50,\n): TElement[] => {\n  // Ensure there are elements to position\n  if (!elements || elements.length === 0) {\n    return [];\n  }\n\n  const res: TElement[] = [];\n  // Normalize input to work with atomic units (groups of elements)\n  // If elements is a flat array, treat each element as its own atomic unit\n  const atomicUnits: TElement[][] = Array.isArray(elements[0])\n    ? (elements as TElement[][])\n    : (elements as TElement[]).map((element) => [element]);\n\n  // Determine the number of columns for atomic units\n  // A common approach for a \"grid-like\" layout without specific column constraints\n  // is to aim for a roughly square arrangement.\n  const numUnits = atomicUnits.length;\n  const numColumns = Math.max(1, Math.ceil(Math.sqrt(numUnits)));\n\n  // Group atomic units into rows based on the calculated number of columns\n  const rows: TElement[][][] = [];\n  for (let i = 0; i < numUnits; i += numColumns) {\n    rows.push(atomicUnits.slice(i, i + numColumns));\n  }\n\n  // Calculate properties for each row (total width, max height)\n  // and the total actual height of all row content.\n  let totalGridActualHeight = 0; // Sum of max heights of rows, without inter-row padding\n  const rowProperties = rows.map((rowUnits) => {\n    let rowWidth = 0;\n    let maxUnitHeightInRow = 0;\n\n    const unitBounds = rowUnits.map((unit) => {\n      const [minX, minY, maxX, maxY] = getCommonBounds(unit);\n      return {\n        elements: unit,\n        bounds: [minX, minY, maxX, maxY] as const,\n        width: maxX - minX,\n        height: maxY - minY,\n      };\n    });\n\n    unitBounds.forEach((unitBound, index) => {\n      rowWidth += unitBound.width;\n      // Add padding between units in the same row, but not after the last one\n      if (index < unitBounds.length - 1) {\n        rowWidth += padding;\n      }\n      if (unitBound.height > maxUnitHeightInRow) {\n        maxUnitHeightInRow = unitBound.height;\n      }\n    });\n\n    totalGridActualHeight += maxUnitHeightInRow;\n    return {\n      unitBounds,\n      width: rowWidth,\n      maxHeight: maxUnitHeightInRow,\n    };\n  });\n\n  // Calculate the total height of the grid including padding between rows\n  const totalGridHeightWithPadding =\n    totalGridActualHeight + Math.max(0, rows.length - 1) * padding;\n\n  // Calculate the starting Y position to center the entire grid vertically around centerY\n  let currentY = centerY - totalGridHeightWithPadding / 2;\n\n  // Position atomic units row by row\n  rowProperties.forEach((rowProp) => {\n    const { unitBounds, width: rowWidth, maxHeight: rowMaxHeight } = rowProp;\n\n    // Calculate the starting X for the current row to center it horizontally around centerX\n    let currentX = centerX - rowWidth / 2;\n\n    unitBounds.forEach((unitBound) => {\n      // Calculate the offset needed to position this atomic unit\n      const [originalMinX, originalMinY] = unitBound.bounds;\n      const offsetX = currentX - originalMinX;\n      const offsetY = currentY - originalMinY;\n\n      // Apply the offset to all elements in this atomic unit\n      unitBound.elements.forEach((element) => {\n        res.push(\n          newElementWith(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY,\n          } as ElementUpdate<TElement>),\n        );\n      });\n\n      // Move X for the next unit in the row\n      currentX += unitBound.width + padding;\n    });\n\n    // Move Y to the starting position for the next row\n    // This accounts for the tallest unit in the current row and the inter-row padding\n    currentY += rowMaxHeight + padding;\n  });\n  return res;\n};\n", "import {\n  pointCenter,\n  normalizeRadians,\n  pointFrom,\n  pointRotateRads,\n  type Radians,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport {\n  MIN_FONT_SIZE,\n  SHIFT_LOCKING_ANGLE,\n  rescalePoints,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport type { PointerDownState } from \"@excalidraw/excalidraw/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport {\n  getArrowLocalFixedPoints,\n  unbindBindingElement,\n  updateBoundElements,\n} from \"./binding\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n  getCommonBoundingBox,\n  getElementBounds,\n} from \"./bounds\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport {\n  getBoundTextElement,\n  getBoundTextElementId,\n  getContainerElement,\n  handleBindTextResize,\n  getBoundTextMaxWidth,\n  computeBoundTextPosition,\n} from \"./textElement\";\nimport {\n  getMinTextElementWidth,\n  measureText,\n  getApproxMinLineWidth,\n  getApproxMinLineHeight,\n} from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\nimport {\n  isArrowElement,\n  isBindingElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isFrameLikeElement,\n  isFreeDrawElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { isInGroup } from \"./groups\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { BoundingBox } from \"./bounds\";\nimport type {\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport type {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawImageElement,\n  ElementsMap,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawArrowElement,\n} from \"./types\";\nimport type { ElementUpdate } from \"./mutateElement\";\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  originalElements: PointerDownState[\"originalElements\"],\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  scene: Scene,\n  shouldRotateWithDiscreteAngle: boolean,\n  shouldResizeFromCenter: boolean,\n  shouldMaintainAspectRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n): boolean => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      if (!isElbowArrow(element)) {\n        rotateSingleElement(\n          element,\n          scene,\n          pointerX,\n          pointerY,\n          shouldRotateWithDiscreteAngle,\n        );\n        updateBoundElements(element, scene);\n      }\n    } else if (transformHandleType) {\n      const elementId = selectedElements[0].id;\n      const latestElement = elementsMap.get(elementId);\n      const origElement = originalElements.get(elementId);\n\n      if (latestElement && origElement) {\n        const { nextWidth, nextHeight } =\n          getNextSingleWidthAndHeightFromPointer(\n            latestElement,\n            origElement,\n            transformHandleType,\n            pointerX,\n            pointerY,\n            {\n              shouldMaintainAspectRatio,\n              shouldResizeFromCenter,\n            },\n          );\n\n        resizeSingleElement(\n          nextWidth,\n          nextHeight,\n          latestElement,\n          origElement,\n          originalElements,\n          scene,\n          transformHandleType,\n          {\n            shouldMaintainAspectRatio,\n            shouldResizeFromCenter,\n          },\n        );\n      }\n    }\n    if (isTextElement(element)) {\n      updateBoundElements(element, scene);\n    }\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        originalElements,\n        selectedElements,\n        scene,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (transformHandleType) {\n      const { nextWidth, nextHeight, flipByX, flipByY, originalBoundingBox } =\n        getNextMultipleWidthAndHeightFromPointer(\n          selectedElements,\n          originalElements,\n          elementsMap,\n          transformHandleType,\n          pointerX,\n          pointerY,\n          {\n            shouldMaintainAspectRatio,\n            shouldResizeFromCenter,\n          },\n        );\n\n      resizeMultipleElements(\n        selectedElements,\n        elementsMap,\n        transformHandleType,\n        scene,\n        originalElements,\n        {\n          shouldResizeFromCenter,\n          shouldMaintainAspectRatio,\n          flipByX,\n          flipByY,\n          nextWidth,\n          nextHeight,\n          originalBoundingBox,\n        },\n      );\n\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  scene: Scene,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(\n    element,\n    scene.getNonDeletedElementsMap(),\n  );\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle: Radians;\n  if (isFrameLikeElement(element)) {\n    angle = 0 as Radians;\n  } else {\n    angle = ((5 * Math.PI) / 2 +\n      Math.atan2(pointerY - cy, pointerX - cx)) as Radians;\n    if (shouldRotateWithDiscreteAngle) {\n      angle = (angle + SHIFT_LOCKING_ANGLE / 2) as Radians;\n      angle = (angle - (angle % SHIFT_LOCKING_ANGLE)) as Radians;\n    }\n    angle = normalizeRadians(angle as Radians);\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  let update: ElementUpdate<NonDeletedExcalidrawElement> = {\n    angle,\n  };\n\n  if (isBindingElement(element)) {\n    update = {\n      ...update,\n    } as ElementUpdate<ExcalidrawArrowElement>;\n\n    if (element.startBinding) {\n      unbindBindingElement(element, \"start\", scene);\n    }\n    if (element.endBinding) {\n      unbindBindingElement(element, \"end\", scene);\n    }\n  }\n\n  scene.mutateElement(element, update);\n\n  if (boundTextElementId) {\n    const textElement =\n      scene.getElement<ExcalidrawTextElementWithContainer>(boundTextElementId);\n\n    if (textElement && !isArrowElement(element)) {\n      const { x, y } = computeBoundTextPosition(\n        element,\n        textElement,\n        scene.getNonDeletedElementsMap(),\n      );\n      scene.mutateElement(textElement, {\n        angle,\n        x,\n        y,\n      });\n    }\n  }\n};\n\nexport const rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n  normalizePoints: boolean,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points, normalizePoints),\n          normalizePoints,\n        ),\n      }\n    : {};\n\nexport const measureFontSizeFromWidth = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  elementsMap: ElementsMap,\n  nextWidth: number,\n): { size: number } | null => {\n  // We only use width to scale font on resize\n  let width = element.width;\n\n  const hasContainer = isBoundToContainer(element);\n  if (hasContainer) {\n    const container = getContainerElement(element, elementsMap);\n    if (container) {\n      width = getBoundTextMaxWidth(container, element);\n    }\n  }\n  const nextFontSize = element.fontSize * (nextWidth / width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n\n  return {\n    size: nextFontSize,\n  };\n};\n\nexport const resizeSingleTextElement = (\n  origElement: NonDeleted<ExcalidrawTextElement>,\n  element: NonDeleted<ExcalidrawTextElement>,\n  scene: Scene,\n  transformHandleType: TransformHandleDirection,\n  shouldResizeFromCenter: boolean,\n  nextWidth: number,\n  nextHeight: number,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  const metricsWidth = element.width * (nextHeight / element.height);\n\n  const metrics = measureFontSizeFromWidth(element, elementsMap, metricsWidth);\n  if (metrics === null) {\n    return;\n  }\n\n  if (transformHandleType.includes(\"n\") || transformHandleType.includes(\"s\")) {\n    const previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n    const newOrigin = getResizedOrigin(\n      previousOrigin,\n      origElement.width,\n      origElement.height,\n      metricsWidth,\n      nextHeight,\n      origElement.angle,\n      transformHandleType,\n      false,\n      shouldResizeFromCenter,\n    );\n\n    scene.mutateElement(element, {\n      fontSize: metrics.size,\n      width: metricsWidth,\n      height: nextHeight,\n      x: newOrigin.x,\n      y: newOrigin.y,\n    });\n    return;\n  }\n\n  if (transformHandleType === \"e\" || transformHandleType === \"w\") {\n    const minWidth = getMinTextElementWidth(\n      getFontString({\n        fontSize: element.fontSize,\n        fontFamily: element.fontFamily,\n      }),\n      element.lineHeight,\n    );\n\n    const newWidth = Math.max(minWidth, nextWidth);\n\n    const text = wrapText(\n      element.originalText,\n      getFontString(element),\n      Math.abs(newWidth),\n    );\n    const metrics = measureText(\n      text,\n      getFontString(element),\n      element.lineHeight,\n    );\n\n    const newHeight = metrics.height;\n\n    const previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n    const newOrigin = getResizedOrigin(\n      previousOrigin,\n      origElement.width,\n      origElement.height,\n      newWidth,\n      newHeight,\n      element.angle,\n      transformHandleType,\n      false,\n      shouldResizeFromCenter,\n    );\n\n    const resizedElement: Partial<ExcalidrawTextElement> = {\n      width: Math.abs(newWidth),\n      height: Math.abs(metrics.height),\n      x: newOrigin.x,\n      y: newOrigin.y,\n      text,\n      autoResize: false,\n    };\n\n    scene.mutateElement(element, resizedElement);\n  }\n};\n\nconst rotateMultipleElements = (\n  originalElements: PointerDownState[\"originalElements\"],\n  elements: readonly NonDeletedExcalidrawElement[],\n  scene: Scene,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n\n  const rotatedElementsMap = new Map<\n    ExcalidrawElement[\"id\"],\n    NonDeletedExcalidrawElement\n  >(elements.map((element) => [element.id, element]));\n\n  for (const element of elements) {\n    if (!isFrameLikeElement(element)) {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      const origAngle =\n        originalElements.get(element.id)?.angle ?? element.angle;\n      const [rotatedCX, rotatedCY] = pointRotateRads(\n        pointFrom(cx, cy),\n        pointFrom(centerX, centerY),\n        (centerAngle + origAngle - element.angle) as Radians,\n      );\n\n      const updates = isElbowArrow(element)\n        ? {\n            // Needed to re-route the arrow\n            points: getArrowLocalFixedPoints(element, elementsMap),\n          }\n        : {\n            x: element.x + (rotatedCX - cx),\n            y: element.y + (rotatedCY - cy),\n            angle: normalizeRadians((centerAngle + origAngle) as Radians),\n          };\n\n      scene.mutateElement(element, updates);\n\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: elements,\n      });\n\n      if (isBindingElement(element)) {\n        if (element.startBinding) {\n          if (!rotatedElementsMap.has(element.startBinding.elementId)) {\n            unbindBindingElement(element, \"start\", scene);\n          }\n        }\n        if (element.endBinding) {\n          if (!rotatedElementsMap.has(element.endBinding.elementId)) {\n            unbindBindingElement(element, \"end\", scene);\n          }\n        }\n      }\n\n      const boundText = getBoundTextElement(element, elementsMap);\n      if (boundText && !isArrowElement(element)) {\n        const { x, y } = computeBoundTextPosition(\n          element,\n          boundText,\n          elementsMap,\n        );\n\n        scene.mutateElement(boundText, {\n          x,\n          y,\n          angle: normalizeRadians((centerAngle + origAngle) as Radians),\n        });\n      }\n    }\n  }\n\n  scene.triggerUpdate();\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0], elementsMap)\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = (\n    selectedElements.length === 1 ? selectedElements[0].angle : 0\n  ) as Radians;\n  [x, y] = pointRotateRads(\n    pointFrom(x, y),\n    pointFrom(cx, cy),\n    -angle as Radians,\n  );\n  switch (transformHandleType) {\n    case \"n\":\n      return pointRotateRads(\n        pointFrom(x - (x1 + x2) / 2, y - y1),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"s\":\n      return pointRotateRads(\n        pointFrom(x - (x1 + x2) / 2, y - y2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"w\":\n      return pointRotateRads(\n        pointFrom(x - x1, y - (y1 + y2) / 2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"e\":\n      return pointRotateRads(\n        pointFrom(x - x2, y - (y1 + y2) / 2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"nw\":\n      return pointRotateRads(pointFrom(x - x1, y - y1), pointFrom(0, 0), angle);\n    case \"ne\":\n      return pointRotateRads(pointFrom(x - x2, y - y1), pointFrom(0, 0), angle);\n    case \"sw\":\n      return pointRotateRads(pointFrom(x - x1, y - y2), pointFrom(0, 0), angle);\n    case \"se\":\n      return pointRotateRads(pointFrom(x - x2, y - y2), pointFrom(0, 0), angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n\ntype ResizeAnchor =\n  | \"top-left\"\n  | \"top-right\"\n  | \"bottom-left\"\n  | \"bottom-right\"\n  | \"west-side\"\n  | \"north-side\"\n  | \"east-side\"\n  | \"south-side\"\n  | \"center\";\n\nconst getResizeAnchor = (\n  handleDirection: TransformHandleDirection,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n): ResizeAnchor => {\n  if (shouldResizeFromCenter) {\n    return \"center\";\n  }\n\n  if (shouldMaintainAspectRatio) {\n    switch (handleDirection) {\n      case \"n\":\n        return \"south-side\";\n      case \"e\": {\n        return \"west-side\";\n      }\n      case \"s\":\n        return \"north-side\";\n      case \"w\":\n        return \"east-side\";\n      case \"ne\":\n        return \"bottom-left\";\n      case \"nw\":\n        return \"bottom-right\";\n      case \"se\":\n        return \"top-left\";\n      case \"sw\":\n        return \"top-right\";\n    }\n  }\n\n  if ([\"e\", \"se\", \"s\"].includes(handleDirection)) {\n    return \"top-left\";\n  } else if ([\"n\", \"nw\", \"w\"].includes(handleDirection)) {\n    return \"bottom-right\";\n  } else if (handleDirection === \"ne\") {\n    return \"bottom-left\";\n  }\n  return \"top-right\";\n};\n\nconst getResizedOrigin = (\n  prevOrigin: GlobalPoint,\n  prevWidth: number,\n  prevHeight: number,\n  newWidth: number,\n  newHeight: number,\n  angle: number,\n  handleDirection: TransformHandleDirection,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n): { x: number; y: number } => {\n  const anchor = getResizeAnchor(\n    handleDirection,\n    shouldMaintainAspectRatio,\n    shouldResizeFromCenter,\n  );\n\n  const [x, y] = prevOrigin;\n\n  switch (anchor) {\n    case \"top-left\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((newWidth - prevWidth) / 2) * Math.cos(angle) +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          (prevHeight - newHeight) / 2 +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle) +\n          ((newHeight - prevHeight) / 2) * Math.cos(angle),\n      };\n    case \"top-right\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1) +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          (prevHeight - newHeight) / 2 +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle) +\n          ((newHeight - prevHeight) / 2) * Math.cos(angle),\n      };\n\n    case \"bottom-left\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (1 - Math.cos(angle)) +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1) +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle),\n      };\n    case \"bottom-right\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1) +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1) +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle),\n      };\n    case \"center\":\n      return {\n        x: x - (newWidth - prevWidth) / 2,\n        y: y - (newHeight - prevHeight) / 2,\n      };\n    case \"east-side\":\n      return {\n        x: x + ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1),\n        y:\n          y +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle) +\n          (prevHeight - newHeight) / 2,\n      };\n    case \"west-side\":\n      return {\n        x: x + ((prevWidth - newWidth) / 2) * (1 - Math.cos(angle)),\n        y:\n          y +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle) +\n          (prevHeight - newHeight) / 2,\n      };\n    case \"north-side\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y: y + ((newHeight - prevHeight) / 2) * (Math.cos(angle) - 1),\n      };\n    case \"south-side\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y: y + ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1),\n      };\n  }\n};\n\nexport const resizeSingleElement = (\n  nextWidth: number,\n  nextHeight: number,\n  latestElement: ExcalidrawElement,\n  origElement: ExcalidrawElement,\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n  handleDirection: TransformHandleDirection,\n  {\n    shouldInformMutation = true,\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n    shouldInformMutation?: boolean;\n  } = {},\n) => {\n  if (isTextElement(latestElement) && isTextElement(origElement)) {\n    return resizeSingleTextElement(\n      origElement,\n      latestElement,\n      scene,\n      handleDirection,\n      shouldResizeFromCenter,\n      nextWidth,\n      nextHeight,\n    );\n  }\n\n  let boundTextFont: { fontSize?: number } = {};\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundTextElement = getBoundTextElement(latestElement, elementsMap);\n\n  if (boundTextElement) {\n    const stateOfBoundTextElementAtResize = originalElementsMap.get(\n      boundTextElement.id,\n    ) as typeof boundTextElement | undefined;\n    if (stateOfBoundTextElementAtResize) {\n      boundTextFont = {\n        fontSize: stateOfBoundTextElementAtResize.fontSize,\n      };\n    }\n    if (shouldMaintainAspectRatio) {\n      const updatedElement = {\n        ...latestElement,\n        width: nextWidth,\n        height: nextHeight,\n      };\n\n      const nextFont = measureFontSizeFromWidth(\n        boundTextElement,\n        elementsMap,\n        getBoundTextMaxWidth(updatedElement, boundTextElement),\n      );\n      if (nextFont === null) {\n        return;\n      }\n      boundTextFont = {\n        fontSize: nextFont.size,\n      };\n    } else {\n      const minWidth = getApproxMinLineWidth(\n        getFontString(boundTextElement),\n        boundTextElement.lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(\n        boundTextElement.fontSize,\n        boundTextElement.lineHeight,\n      );\n      nextWidth = Math.max(nextWidth, minWidth);\n      nextHeight = Math.max(nextHeight, minHeight);\n    }\n  }\n\n  const rescaledPoints = rescalePointsInElement(\n    origElement,\n    nextWidth,\n    nextHeight,\n    true,\n  );\n\n  let previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n  if (isLinearElement(origElement)) {\n    const [x1, y1] = getElementBounds(origElement, originalElementsMap);\n    previousOrigin = pointFrom<GlobalPoint>(x1, y1);\n  }\n\n  const newOrigin: {\n    x: number;\n    y: number;\n  } = getResizedOrigin(\n    previousOrigin,\n    origElement.width,\n    origElement.height,\n    nextWidth,\n    nextHeight,\n    origElement.angle,\n    handleDirection,\n    shouldMaintainAspectRatio!!,\n    shouldResizeFromCenter!!,\n  );\n\n  if (isLinearElement(origElement) && rescaledPoints.points) {\n    const offsetX = origElement.x - previousOrigin[0];\n    const offsetY = origElement.y - previousOrigin[1];\n\n    newOrigin.x += offsetX;\n    newOrigin.y += offsetY;\n\n    const scaledX = rescaledPoints.points[0][0];\n    const scaledY = rescaledPoints.points[0][1];\n\n    newOrigin.x += scaledX;\n    newOrigin.y += scaledY;\n\n    rescaledPoints.points = rescaledPoints.points.map((p) =>\n      pointFrom<LocalPoint>(p[0] - scaledX, p[1] - scaledY),\n    );\n  }\n\n  // flipping\n  if (nextWidth < 0) {\n    newOrigin.x = newOrigin.x + nextWidth;\n  }\n  if (nextHeight < 0) {\n    newOrigin.y = newOrigin.y + nextHeight;\n  }\n\n  if (\"scale\" in latestElement && \"scale\" in origElement) {\n    scene.mutateElement(latestElement, {\n      scale: [\n        // defaulting because scaleX/Y can be 0/-0\n        (Math.sign(nextWidth) || origElement.scale[0]) * origElement.scale[0],\n        (Math.sign(nextHeight) || origElement.scale[1]) * origElement.scale[1],\n      ],\n    });\n  }\n\n  if (\n    isArrowElement(latestElement) &&\n    boundTextElement &&\n    shouldMaintainAspectRatio\n  ) {\n    const fontSize =\n      (nextWidth / latestElement.width) * boundTextElement.fontSize;\n    if (fontSize < MIN_FONT_SIZE) {\n      return;\n    }\n    boundTextFont.fontSize = fontSize;\n  }\n\n  if (\n    nextWidth !== 0 &&\n    nextHeight !== 0 &&\n    Number.isFinite(newOrigin.x) &&\n    Number.isFinite(newOrigin.y)\n  ) {\n    let updates: ElementUpdate<ExcalidrawElement> = {\n      ...newOrigin,\n      width: Math.abs(nextWidth),\n      height: Math.abs(nextHeight),\n      ...rescaledPoints,\n    };\n\n    if (isBindingElement(latestElement)) {\n      if (latestElement.startBinding) {\n        updates = {\n          ...updates,\n        } as ElementUpdate<ExcalidrawArrowElement>;\n\n        if (latestElement.startBinding) {\n          unbindBindingElement(latestElement, \"start\", scene);\n        }\n      }\n\n      if (latestElement.endBinding) {\n        updates = {\n          ...updates,\n          endBinding: null,\n        } as ElementUpdate<ExcalidrawArrowElement>;\n      }\n    }\n\n    scene.mutateElement(latestElement, updates, {\n      informMutation: shouldInformMutation,\n      isDragging: false,\n    });\n\n    if (boundTextElement && boundTextFont != null) {\n      scene.mutateElement(boundTextElement, {\n        fontSize: boundTextFont.fontSize,\n      });\n    }\n    handleBindTextResize(\n      latestElement,\n      scene,\n      handleDirection,\n      shouldMaintainAspectRatio,\n    );\n\n    updateBoundElements(latestElement, scene);\n  }\n};\n\nconst getNextSingleWidthAndHeightFromPointer = (\n  latestElement: ExcalidrawElement,\n  origElement: ExcalidrawElement,\n  handleDirection: TransformHandleDirection,\n  pointerX: number,\n  pointerY: number,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n  } = {},\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    origElement,\n    origElement.width,\n    origElement.height,\n    true,\n  );\n  const startTopLeft = pointFrom(x1, y1);\n  const startBottomRight = pointFrom(x2, y2);\n  const startCenter = pointCenter(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = pointRotateRads(\n    pointFrom(pointerX, pointerY),\n    startCenter,\n    -origElement.angle as Radians,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    latestElement,\n    latestElement.width,\n    latestElement.height,\n    true,\n  );\n\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (handleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (handleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (handleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (handleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let nextWidth = latestElement.width * scaleX;\n  let nextHeight = latestElement.height * scaleY;\n\n  if (shouldResizeFromCenter) {\n    nextWidth = 2 * nextWidth - origElement.width;\n    nextHeight = 2 * nextHeight - origElement.height;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(nextWidth) / origElement.width;\n    const heightRatio = Math.abs(nextHeight) / origElement.height;\n    if (handleDirection.length === 1) {\n      nextHeight *= widthRatio;\n      nextWidth *= heightRatio;\n    }\n    if (handleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      nextWidth = origElement.width * ratio * Math.sign(nextWidth);\n      nextHeight = origElement.height * ratio * Math.sign(nextHeight);\n    }\n  }\n\n  return {\n    nextWidth,\n    nextHeight,\n  };\n};\n\nconst getNextMultipleWidthAndHeightFromPointer = (\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  originalElementsMap: ElementsMap,\n  elementsMap: ElementsMap,\n  handleDirection: TransformHandleDirection,\n  pointerX: number,\n  pointerY: number,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldResizeFromCenter?: boolean;\n    shouldMaintainAspectRatio?: boolean;\n  } = {},\n) => {\n  const originalElementsArray = selectedElements.map(\n    (el) => originalElementsMap.get(el.id)!,\n  );\n\n  // getCommonBoundingBox() uses getBoundTextElement() which returns null for\n  // original elements from pointerDownState, so we have to find and add these\n  // bound text elements manually. Additionally, the coordinates of bound text\n  // elements aren't always up to date.\n  const boundTextElements = originalElementsArray.reduce((acc, orig) => {\n    if (!isLinearElement(orig)) {\n      return acc;\n    }\n    const textId = getBoundTextElementId(orig);\n    if (!textId) {\n      return acc;\n    }\n    const text = originalElementsMap.get(textId) ?? null;\n    if (!isBoundToContainer(text)) {\n      return acc;\n    }\n    return [\n      ...acc,\n      {\n        ...text,\n        ...LinearElementEditor.getBoundTextElementPosition(\n          orig,\n          text,\n          elementsMap,\n        ),\n      },\n    ];\n  }, [] as ExcalidrawTextElementWithContainer[]);\n\n  const originalBoundingBox = getCommonBoundingBox(\n    originalElementsArray.map((orig) => orig).concat(boundTextElements),\n  );\n\n  const { minX, minY, maxX, maxY, midX, midY } = originalBoundingBox;\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  const anchorsMap = {\n    ne: [minX, maxY],\n    se: [minX, minY],\n    sw: [maxX, minY],\n    nw: [maxX, maxY],\n    e: [minX, minY + height / 2],\n    w: [maxX, minY + height / 2],\n    n: [minX + width / 2, maxY],\n    s: [minX + width / 2, minY],\n  } as Record<TransformHandleDirection, GlobalPoint>;\n\n  // anchor point must be on the opposite side of the dragged selection handle\n  // or be the center of the selection if shouldResizeFromCenter\n  const [anchorX, anchorY] = shouldResizeFromCenter\n    ? [midX, midY]\n    : anchorsMap[handleDirection];\n\n  const resizeFromCenterScale = shouldResizeFromCenter ? 2 : 1;\n\n  const scale =\n    Math.max(\n      Math.abs(pointerX - anchorX) / width || 0,\n      Math.abs(pointerY - anchorY) / height || 0,\n    ) * resizeFromCenterScale;\n\n  let nextWidth =\n    handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n      ? Math.abs(pointerX - anchorX) * resizeFromCenterScale\n      : width;\n  let nextHeight =\n    handleDirection.includes(\"n\") || handleDirection.includes(\"s\")\n      ? Math.abs(pointerY - anchorY) * resizeFromCenterScale\n      : height;\n\n  if (shouldMaintainAspectRatio) {\n    nextWidth = width * scale * Math.sign(pointerX - anchorX);\n    nextHeight = height * scale * Math.sign(pointerY - anchorY);\n  }\n\n  const flipConditionsMap: Record<\n    TransformHandleDirection,\n    // Condition for which we should flip or not flip the selected elements\n    // - when evaluated to `true`, we flip\n    // - therefore, setting it to always `false` means we do not flip (in that direction) at all\n    [x: boolean, y: boolean]\n  > = {\n    ne: [pointerX < anchorX, pointerY > anchorY],\n    se: [pointerX < anchorX, pointerY < anchorY],\n    sw: [pointerX > anchorX, pointerY < anchorY],\n    nw: [pointerX > anchorX, pointerY > anchorY],\n    // e.g. when resizing from the \"e\" side, we do not need to consider changes in the `y` direction\n    //      and therefore, we do not need to flip in the `y` direction at all\n    e: [pointerX < anchorX, false],\n    w: [pointerX > anchorX, false],\n    n: [false, pointerY > anchorY],\n    s: [false, pointerY < anchorY],\n  };\n\n  const [flipByX, flipByY] = flipConditionsMap[handleDirection].map(\n    (condition) => condition,\n  );\n\n  return {\n    originalBoundingBox,\n    nextWidth,\n    nextHeight,\n    flipByX,\n    flipByY,\n  };\n};\n\nexport const resizeMultipleElements = (\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n  handleDirection: TransformHandleDirection,\n  scene: Scene,\n  originalElementsMap: ElementsMap,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n    flipByX = false,\n    flipByY = false,\n    nextHeight,\n    nextWidth,\n    originalBoundingBox,\n  }: {\n    nextWidth?: number;\n    nextHeight?: number;\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n    flipByX?: boolean;\n    flipByY?: boolean;\n    // added to improve performance\n    originalBoundingBox?: BoundingBox;\n  } = {},\n) => {\n  // in the case of just flipping, there is no need to specify the next width and height\n  if (\n    nextWidth === undefined &&\n    nextHeight === undefined &&\n    flipByX === undefined &&\n    flipByY === undefined\n  ) {\n    return;\n  }\n\n  // do not allow next width or height to be 0\n  if (nextHeight === 0 || nextWidth === 0) {\n    return;\n  }\n\n  if (!originalElementsMap) {\n    originalElementsMap = elementsMap;\n  }\n\n  const targetElements = selectedElements.reduce(\n    (\n      acc: {\n        /** element at resize start */\n        orig: NonDeletedExcalidrawElement;\n        /** latest element */\n        latest: NonDeletedExcalidrawElement;\n      }[],\n      element,\n    ) => {\n      const origElement = originalElementsMap!.get(element.id);\n      if (origElement) {\n        acc.push({ orig: origElement, latest: element });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  let boundingBox: BoundingBox;\n\n  if (originalBoundingBox) {\n    boundingBox = originalBoundingBox;\n  } else {\n    const boundTextElements = targetElements.reduce((acc, { orig }) => {\n      if (!isLinearElement(orig)) {\n        return acc;\n      }\n      const textId = getBoundTextElementId(orig);\n      if (!textId) {\n        return acc;\n      }\n      const text = originalElementsMap!.get(textId) ?? null;\n      if (!isBoundToContainer(text)) {\n        return acc;\n      }\n      return [\n        ...acc,\n        {\n          ...text,\n          ...LinearElementEditor.getBoundTextElementPosition(\n            orig,\n            text,\n            elementsMap,\n          ),\n        },\n      ];\n    }, [] as ExcalidrawTextElementWithContainer[]);\n\n    boundingBox = getCommonBoundingBox(\n      targetElements.map(({ orig }) => orig).concat(boundTextElements),\n    );\n  }\n  const { minX, minY, maxX, maxY, midX, midY } = boundingBox;\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  if (nextWidth === undefined && nextHeight === undefined) {\n    nextWidth = width;\n    nextHeight = height;\n  }\n\n  if (shouldMaintainAspectRatio) {\n    if (nextWidth === undefined) {\n      nextWidth = nextHeight! * (width / height);\n    } else if (nextHeight === undefined) {\n      nextHeight = nextWidth! * (height / width);\n    } else if (Math.abs(nextWidth / nextHeight - width / height) > 0.001) {\n      nextWidth = nextHeight * (width / height);\n    }\n  }\n\n  if (nextWidth && nextHeight) {\n    let scaleX =\n      handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n        ? Math.abs(nextWidth) / width\n        : 1;\n    let scaleY =\n      handleDirection.includes(\"n\") || handleDirection.includes(\"s\")\n        ? Math.abs(nextHeight) / height\n        : 1;\n\n    let scale: number;\n\n    if (handleDirection.length === 1) {\n      scale =\n        handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n          ? scaleX\n          : scaleY;\n    } else {\n      scale = Math.max(\n        Math.abs(nextWidth) / width || 0,\n        Math.abs(nextHeight) / height || 0,\n      );\n    }\n\n    const anchorsMap = {\n      ne: [minX, maxY],\n      se: [minX, minY],\n      sw: [maxX, minY],\n      nw: [maxX, maxY],\n      e: [minX, minY + height / 2],\n      w: [maxX, minY + height / 2],\n      n: [minX + width / 2, maxY],\n      s: [minX + width / 2, minY],\n    } as Record<TransformHandleDirection, GlobalPoint>;\n\n    // anchor point must be on the opposite side of the dragged selection handle\n    // or be the center of the selection if shouldResizeFromCenter\n    const [anchorX, anchorY] = shouldResizeFromCenter\n      ? [midX, midY]\n      : anchorsMap[handleDirection];\n\n    const keepAspectRatio =\n      shouldMaintainAspectRatio ||\n      targetElements.some(\n        (item) =>\n          item.latest.angle !== 0 ||\n          isTextElement(item.latest) ||\n          isInGroup(item.latest),\n      );\n\n    if (keepAspectRatio) {\n      scaleX = scale;\n      scaleY = scale;\n    }\n\n    /**\n     * to flip an element:\n     * 1. determine over which axis is the element being flipped\n     *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n     * 2. shift element's position by the amount of width or height (or both) or\n     *    mirror points in the case of linear & freedraw elemenets\n     * 3. adjust element angle\n     */\n    const [flipFactorX, flipFactorY] = [flipByX ? -1 : 1, flipByY ? -1 : 1];\n\n    const elementsAndUpdates: {\n      element: NonDeletedExcalidrawElement;\n      update: Mutable<\n        Pick<ExcalidrawElement, \"x\" | \"y\" | \"width\" | \"height\" | \"angle\">\n      > & {\n        points?: ExcalidrawLinearElement[\"points\"];\n        fontSize?: ExcalidrawTextElement[\"fontSize\"];\n        scale?: ExcalidrawImageElement[\"scale\"];\n        boundTextFontSize?: ExcalidrawTextElement[\"fontSize\"];\n        startBinding?: ExcalidrawElbowArrowElement[\"startBinding\"];\n        endBinding?: ExcalidrawElbowArrowElement[\"endBinding\"];\n        fixedSegments?: ExcalidrawElbowArrowElement[\"fixedSegments\"];\n      };\n    }[] = [];\n\n    for (const { orig, latest } of targetElements) {\n      // bounded text elements are updated along with their container elements\n      if (isTextElement(orig) && isBoundToContainer(orig)) {\n        continue;\n      }\n\n      const width = orig.width * scaleX;\n      const height = orig.height * scaleY;\n      const angle = normalizeRadians(\n        (orig.angle * flipFactorX * flipFactorY) as Radians,\n      );\n\n      const isLinearOrFreeDraw =\n        isLinearElement(orig) || isFreeDrawElement(orig);\n      const offsetX = orig.x - anchorX;\n      const offsetY = orig.y - anchorY;\n      const shiftX = flipByX && !isLinearOrFreeDraw ? width : 0;\n      const shiftY = flipByY && !isLinearOrFreeDraw ? height : 0;\n      const x = anchorX + flipFactorX * (offsetX * scaleX + shiftX);\n      const y = anchorY + flipFactorY * (offsetY * scaleY + shiftY);\n\n      const rescaledPoints = rescalePointsInElement(\n        orig,\n        width * flipFactorX,\n        height * flipFactorY,\n        false,\n      );\n\n      const update: typeof elementsAndUpdates[0][\"update\"] = {\n        x,\n        y,\n        width,\n        height,\n        angle,\n        ...rescaledPoints,\n      };\n\n      if (isElbowArrow(orig)) {\n        // Mirror fixed point binding for elbow arrows\n        // when resize goes into the negative direction\n        if (orig.startBinding) {\n          update.startBinding = {\n            ...orig.startBinding,\n            fixedPoint: [\n              flipByX\n                ? -orig.startBinding.fixedPoint[0] + 1\n                : orig.startBinding.fixedPoint[0],\n              flipByY\n                ? -orig.startBinding.fixedPoint[1] + 1\n                : orig.startBinding.fixedPoint[1],\n            ],\n          };\n        }\n        if (orig.endBinding) {\n          update.endBinding = {\n            ...orig.endBinding,\n            fixedPoint: [\n              flipByX\n                ? -orig.endBinding.fixedPoint[0] + 1\n                : orig.endBinding.fixedPoint[0],\n              flipByY\n                ? -orig.endBinding.fixedPoint[1] + 1\n                : orig.endBinding.fixedPoint[1],\n            ],\n          };\n        }\n        if (orig.fixedSegments && rescaledPoints.points) {\n          update.fixedSegments = orig.fixedSegments.map((segment) => ({\n            ...segment,\n            start: rescaledPoints.points[segment.index - 1],\n            end: rescaledPoints.points[segment.index],\n          }));\n        }\n      }\n\n      if (isImageElement(orig)) {\n        update.scale = [\n          orig.scale[0] * flipFactorX,\n          orig.scale[1] * flipFactorY,\n        ];\n      }\n\n      if (isTextElement(orig)) {\n        const metrics = measureFontSizeFromWidth(orig, elementsMap, width);\n        if (!metrics) {\n          return;\n        }\n        update.fontSize = metrics.size;\n      }\n\n      const boundTextElement = originalElementsMap.get(\n        getBoundTextElementId(orig) ?? \"\",\n      ) as ExcalidrawTextElementWithContainer | undefined;\n\n      if (boundTextElement) {\n        if (keepAspectRatio) {\n          const newFontSize = boundTextElement.fontSize * scale;\n          if (newFontSize < MIN_FONT_SIZE) {\n            return;\n          }\n          update.boundTextFontSize = newFontSize;\n        } else {\n          update.boundTextFontSize = boundTextElement.fontSize;\n        }\n      }\n\n      elementsAndUpdates.push({\n        element: latest,\n        update,\n      });\n    }\n\n    const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);\n    const resizedElementsMap = new Map<\n      ExcalidrawElement[\"id\"],\n      NonDeletedExcalidrawElement\n    >(elementsAndUpdates.map(({ element }) => [element.id, element]));\n\n    for (const {\n      element,\n      update: { boundTextFontSize, ...update },\n    } of elementsAndUpdates) {\n      const { angle } = update;\n\n      scene.mutateElement(element, update);\n\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: elementsToUpdate,\n      });\n\n      if (isBindingElement(element)) {\n        if (element.startBinding) {\n          if (!resizedElementsMap.has(element.startBinding.elementId)) {\n            unbindBindingElement(element, \"start\", scene);\n          }\n        }\n        if (element.endBinding) {\n          if (!resizedElementsMap.has(element.endBinding.elementId)) {\n            unbindBindingElement(element, \"end\", scene);\n          }\n        }\n      }\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement && boundTextFontSize) {\n        scene.mutateElement(boundTextElement, {\n          fontSize: boundTextFontSize,\n          angle: isLinearElement(element) ? undefined : angle,\n        });\n        handleBindTextResize(element, scene, handleDirection, true);\n      }\n    }\n\n    scene.triggerUpdate();\n  }\n};\n", "import {\n  pointFrom,\n  pointOnLineSegment,\n  pointRotateRads,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport {\n  SIDE_RESIZING_THRESHOLD,\n  type EditorInterface,\n} from \"@excalidraw/common\";\n\nimport type { GlobalPoint, LineSegment, LocalPoint } from \"@excalidraw/math\";\n\nimport type { AppState, Zoom } from \"@excalidraw/excalidraw/types\";\nimport type { Bounds } from \"@excalidraw/common\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport {\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getOmitSidesForEditorInterface,\n  canResizeFromSides,\n} from \"./transformHandles\";\nimport { isImageElement, isLinearElement } from \"./typeChecks\";\n\nimport type {\n  TransformHandleType,\n  TransformHandle,\n  MaybeTransformHandleType,\n} from \"./transformHandles\";\nimport type {\n  ExcalidrawElement,\n  PointerType,\n  NonDeletedExcalidrawElement,\n  ElementsMap,\n} from \"./types\";\n\nconst isInsideTransformHandle = (\n  transformHandle: TransformHandle,\n  x: number,\n  y: number,\n) =>\n  x >= transformHandle[0] &&\n  x <= transformHandle[0] + transformHandle[2] &&\n  y >= transformHandle[1] &&\n  y <= transformHandle[1] + transformHandle[3];\n\nexport const resizeTest = <Point extends GlobalPoint | LocalPoint>(\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  editorInterface: EditorInterface,\n): MaybeTransformHandleType => {\n  if (!appState.selectedElementIds[element.id]) {\n    return false;\n  }\n\n  const { rotation: rotationTransformHandle, ...transformHandles } =\n    getTransformHandles(\n      element,\n      zoom,\n      elementsMap,\n      pointerType,\n      getOmitSidesForEditorInterface(editorInterface),\n    );\n\n  if (\n    rotationTransformHandle &&\n    isInsideTransformHandle(rotationTransformHandle, x, y)\n  ) {\n    return \"rotation\" as TransformHandleType;\n  }\n\n  const filter = Object.keys(transformHandles).filter((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    if (!transformHandle) {\n      return false;\n    }\n    return isInsideTransformHandle(transformHandle, x, y);\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as TransformHandleType;\n  }\n\n  if (canResizeFromSides(editorInterface)) {\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    // do not resize from the sides for linear elements with only two points\n    if (!(isLinearElement(element) && element.points.length <= 2)) {\n      const SPACING = isImageElement(element)\n        ? 0\n        : SIDE_RESIZING_THRESHOLD / zoom.value;\n      const ZOOMED_SIDE_RESIZING_THRESHOLD =\n        SIDE_RESIZING_THRESHOLD / zoom.value;\n      const sides = getSelectionBorders(\n        pointFrom(x1 - SPACING, y1 - SPACING),\n        pointFrom(x2 + SPACING, y2 + SPACING),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n\n      for (const [dir, side] of Object.entries(sides)) {\n        // test to see if x, y are on the line segment\n        if (\n          pointOnLineSegment(\n            pointFrom(x, y),\n            side as LineSegment<Point>,\n            ZOOMED_SIDE_RESIZING_THRESHOLD,\n          )\n        ) {\n          return dir as TransformHandleType;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\nexport const getElementWithTransformHandleType = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  elementsMap: ElementsMap,\n  editorInterface: EditorInterface,\n) => {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const transformHandleType = resizeTest(\n      element,\n      elementsMap,\n      appState,\n      scenePointerX,\n      scenePointerY,\n      zoom,\n      pointerType,\n      editorInterface,\n    );\n    return transformHandleType ? { element, transformHandleType } : null;\n  }, null as { element: NonDeletedExcalidrawElement; transformHandleType: MaybeTransformHandleType } | null);\n};\n\nexport const getTransformHandleTypeFromCoords = <\n  Point extends GlobalPoint | LocalPoint,\n>(\n  [x1, y1, x2, y2]: Bounds,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  editorInterface: EditorInterface,\n): MaybeTransformHandleType => {\n  const transformHandles = getTransformHandlesFromCoords(\n    [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],\n    0 as Radians,\n    zoom,\n    pointerType,\n    getOmitSidesForEditorInterface(editorInterface),\n  );\n\n  const found = Object.keys(transformHandles).find((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    return (\n      transformHandle &&\n      isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY)\n    );\n  });\n\n  if (found) {\n    return found as MaybeTransformHandleType;\n  }\n\n  if (canResizeFromSides(editorInterface)) {\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const SPACING = SIDE_RESIZING_THRESHOLD / zoom.value;\n\n    const sides = getSelectionBorders(\n      pointFrom(x1 - SPACING, y1 - SPACING),\n      pointFrom(x2 + SPACING, y2 + SPACING),\n      pointFrom(cx, cy),\n      0 as Radians,\n    );\n\n    for (const [dir, side] of Object.entries(sides)) {\n      // test to see if x, y are on the line segment\n      if (\n        pointOnLineSegment(\n          pointFrom(scenePointerX, scenePointerY),\n          side as LineSegment<Point>,\n          SPACING,\n        )\n      ) {\n        return dir as TransformHandleType;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst RESIZE_CURSORS = [\"ns\", \"nesw\", \"ew\", \"nwse\"];\nconst rotateResizeCursor = (cursor: string, angle: number) => {\n  const index = RESIZE_CURSORS.indexOf(cursor);\n  if (index >= 0) {\n    const a = Math.round(angle / (Math.PI / 4));\n    cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];\n  }\n  return cursor;\n};\n\n/*\n * Returns bi-directional cursor for the element being resized\n */\nexport const getCursorForResizingElement = (resizingElement: {\n  element?: ExcalidrawElement;\n  transformHandleType: MaybeTransformHandleType;\n}): string => {\n  const { element, transformHandleType } = resizingElement;\n  const shouldSwapCursors =\n    element && Math.sign(element.height) * Math.sign(element.width) === -1;\n  let cursor = null;\n\n  switch (transformHandleType) {\n    case \"n\":\n    case \"s\":\n      cursor = \"ns\";\n      break;\n    case \"w\":\n    case \"e\":\n      cursor = \"ew\";\n      break;\n    case \"nw\":\n    case \"se\":\n      if (shouldSwapCursors) {\n        cursor = \"nesw\";\n      } else {\n        cursor = \"nwse\";\n      }\n      break;\n    case \"ne\":\n    case \"sw\":\n      if (shouldSwapCursors) {\n        cursor = \"nwse\";\n      } else {\n        cursor = \"nesw\";\n      }\n      break;\n    case \"rotation\":\n      return \"grab\";\n  }\n\n  if (cursor && element) {\n    cursor = rotateResizeCursor(cursor, element.angle);\n  }\n\n  return cursor ? `${cursor}-resize` : \"\";\n};\n\nconst getSelectionBorders = <Point extends LocalPoint | GlobalPoint>(\n  [x1, y1]: Point,\n  [x2, y2]: Point,\n  center: Point,\n  angle: Radians,\n) => {\n  const topLeft = pointRotateRads(pointFrom(x1, y1), center, angle);\n  const topRight = pointRotateRads(pointFrom(x2, y1), center, angle);\n  const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, angle);\n  const bottomRight = pointRotateRads(pointFrom(x2, y2), center, angle);\n\n  return {\n    n: [topLeft, topRight],\n    e: [topRight, bottomRight],\n    s: [bottomRight, bottomLeft],\n    w: [bottomLeft, topLeft],\n  };\n};\n", "import {\n  DEFAULT_TRANSFORM_HANDLE_SPACING,\n  type EditorInterface,\n} from \"@excalidraw/common\";\n\nimport { pointFrom, pointRotateRads } from \"@excalidraw/math\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  InteractiveCanvasAppState,\n  Zoom,\n} from \"@excalidraw/excalidraw/types\";\nimport type { Bounds } from \"@excalidraw/common\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport {\n  isElbowArrow,\n  isFrameLikeElement,\n  isImageElement,\n  isLinearElement,\n} from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  PointerType,\n} from \"./types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = Bounds;\nexport type TransformHandles = Partial<{\n  [T in TransformHandleType]: TransformHandle;\n}>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 11,\n  pen: 18,\n  touch: 30,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const DEFAULT_OMIT_SIDES = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nexport const OMIT_SIDES_FOR_FRAME = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: Radians,\n): TransformHandle => {\n  const [xx, yy] = pointRotateRads(\n    pointFrom(x + width / 2, y + height / 2),\n    pointFrom(cx, cy),\n    angle,\n  );\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const canResizeFromSides = (editorInterface: EditorInterface) => {\n  if (\n    editorInterface.formFactor === \"phone\" &&\n    editorInterface.userAgent.isMobileDevice\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const getOmitSidesForEditorInterface = (\n  editorInterface: EditorInterface,\n) => {\n  if (canResizeFromSides(editorInterface)) {\n    return DEFAULT_OMIT_SIDES;\n  }\n\n  return {};\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2, cx, cy]: [number, number, number, number, number, number],\n  angle: Radians,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n  margin = 4,\n  spacing = DEFAULT_TRANSFORM_HANDLE_SPACING,\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const dashedLineMargin = margin / zoom.value;\n  const centeringOffset = (size - spacing * 2) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  elementsMap: ElementsMap,\n  pointerType: PointerType = \"mouse\",\n  omitSides: { [T in TransformHandleType]?: boolean } = DEFAULT_OMIT_SIDES,\n): TransformHandles => {\n  // so that when locked element is selected (especially when you toggle lock\n  // via keyboard) the locked element is visually distinct, indicating\n  // you can't move/resize\n  if (\n    element.locked ||\n    // Elbow arrows cannot be rotated\n    isElbowArrow(element)\n  ) {\n    return {};\n  }\n\n  if (element.type === \"freedraw\" || isLinearElement(element)) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (isFrameLikeElement(element)) {\n    omitSides = {\n      ...omitSides,\n      rotation: true,\n    };\n  }\n  const margin = isLinearElement(element)\n    ? DEFAULT_TRANSFORM_HANDLE_SPACING + 8\n    : isImageElement(element)\n    ? 0\n    : DEFAULT_TRANSFORM_HANDLE_SPACING;\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element, elementsMap, true),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n    margin,\n    isImageElement(element) ? 0 : undefined,\n  );\n};\n\nexport const hasBoundingBox = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: InteractiveCanvasAppState,\n  editorInterface: EditorInterface,\n) => {\n  if (\n    appState.selectedLinearElement?.isEditing ||\n    appState.selectedLinearElement?.isDragging\n  ) {\n    return false;\n  }\n  if (elements.length > 1) {\n    return true;\n  }\n  const element = elements[0];\n  if (isElbowArrow(element)) {\n    // Elbow arrows cannot be resized as single selected elements\n    return false;\n  }\n  if (!isLinearElement(element)) {\n    return true;\n  }\n\n  // on mobile/tablet we currently don't show bbox because of resize issues\n  // (also prob best for simplicity's sake)\n  return element.points.length > 2 && !editorInterface.userAgent.isMobileDevice;\n};\n", "import type { UIAppState } from \"@excalidraw/excalidraw/types\";\n\nimport { getSelectedElements } from \"./selection\";\n\nimport type { NonDeletedExcalidrawElement } from \"./types\";\n\nexport const showSelectedShapeActions = (\n  appState: UIAppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n) =>\n  Boolean(\n    !appState.viewModeEnabled &&\n      appState.openDialog?.name !== \"elementLinkSelector\" &&\n      ((appState.activeTool.type !== \"custom\" &&\n        (appState.editingTextElement ||\n          (appState.activeTool.type !== \"selection\" &&\n            appState.activeTool.type !== \"lasso\" &&\n            appState.activeTool.type !== \"eraser\" &&\n            appState.activeTool.type !== \"hand\" &&\n            appState.activeTool.type !== \"laser\"))) ||\n        getSelectedElements(elements, appState).length),\n  );\n", "import { pointFrom, type LocalPoint } from \"@excalidraw/math\";\n\nimport {\n  DEFAULT_BOUND_TEXT_STROKE_COLOR,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  getSizeFromPoints,\n  randomId,\n  arrayToMap,\n  assertNever,\n  cloneJSON,\n  getFontString,\n  isDevEnv,\n  toBrandedType,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport type { MarkOptional } from \"@excalidraw/common/utility-types\";\n\nimport { bindBindingElement } from \"./binding\";\nimport {\n  newArrowElement,\n  newElement,\n  newFrameElement,\n  newImageElement,\n  newLinearElement,\n  newMagicFrameElement,\n  newTextElement,\n  type ElementConstructorOpts,\n} from \"./newElement\";\nimport { measureText, normalizeText } from \"./textMeasurements\";\nimport { isArrowElement } from \"./typeChecks\";\n\nimport { syncInvalidIndices } from \"./fractionalIndex\";\n\nimport { redrawTextBoundingBox } from \"./textElement\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { getCommonBounds } from \"./bounds\";\n\nimport { Scene } from \"./Scene\";\n\nimport type {\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFrameElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawIframeLikeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n  FileId,\n  FontFamilyValues,\n  NonDeletedSceneElementsMap,\n  TextAlign,\n  VerticalAlign,\n} from \"./types\";\n\nexport type ValidLinearElement = {\n  type: \"arrow\" | \"line\";\n  x: number;\n  y: number;\n  label?: {\n    text: string;\n    fontSize?: number;\n    fontFamily?: FontFamilyValues;\n    textAlign?: TextAlign;\n    verticalAlign?: VerticalAlign;\n  } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n  end?:\n    | (\n        | (\n            | {\n                type: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n                id?: ExcalidrawGenericElement[\"id\"];\n              }\n            | {\n                id: ExcalidrawGenericElement[\"id\"];\n                type?: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n              }\n          )\n        | ((\n            | {\n                type: \"text\";\n                text: string;\n              }\n            | {\n                type?: \"text\";\n                id: ExcalidrawTextElement[\"id\"];\n                text: string;\n              }\n          ) &\n            Partial<ExcalidrawTextElement>)\n      ) &\n        MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n  start?:\n    | (\n        | (\n            | {\n                type: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n                id?: ExcalidrawGenericElement[\"id\"];\n              }\n            | {\n                id: ExcalidrawGenericElement[\"id\"];\n                type?: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n              }\n          )\n        | ((\n            | {\n                type: \"text\";\n                text: string;\n              }\n            | {\n                type?: \"text\";\n                id: ExcalidrawTextElement[\"id\"];\n                text: string;\n              }\n          ) &\n            Partial<ExcalidrawTextElement>)\n      ) &\n        MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n} & Partial<ExcalidrawLinearElement>;\n\nexport type ValidContainer =\n  | {\n      type: Exclude<ExcalidrawGenericElement[\"type\"], \"selection\">;\n      id?: ExcalidrawGenericElement[\"id\"];\n      label?: {\n        text: string;\n        fontSize?: number;\n        fontFamily?: FontFamilyValues;\n        textAlign?: TextAlign;\n        verticalAlign?: VerticalAlign;\n      } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n    } & ElementConstructorOpts;\n\nexport type ExcalidrawElementSkeleton =\n  | Extract<\n      Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n      ExcalidrawIframeLikeElement | ExcalidrawFreeDrawElement\n    >\n  | ({\n      type: Extract<ExcalidrawLinearElement[\"type\"], \"line\">;\n      x: number;\n      y: number;\n    } & Partial<ExcalidrawLinearElement>)\n  | ValidContainer\n  | ValidLinearElement\n  | ({\n      type: \"text\";\n      text: string;\n      x: number;\n      y: number;\n      id?: ExcalidrawTextElement[\"id\"];\n    } & Partial<ExcalidrawTextElement>)\n  | ({\n      type: Extract<ExcalidrawImageElement[\"type\"], \"image\">;\n      x: number;\n      y: number;\n      fileId: FileId;\n    } & Partial<ExcalidrawImageElement>)\n  | ({\n      type: \"frame\";\n      children: readonly ExcalidrawElement[\"id\"][];\n      name?: string;\n    } & Partial<ExcalidrawFrameElement>)\n  | ({\n      type: \"magicframe\";\n      children: readonly ExcalidrawElement[\"id\"][];\n      name?: string;\n    } & Partial<ExcalidrawMagicFrameElement>);\n\nconst DEFAULT_LINEAR_ELEMENT_PROPS = {\n  width: 100,\n  height: 0,\n};\n\nconst DEFAULT_DIMENSION = 100;\n\nconst bindTextToContainer = (\n  container: ExcalidrawElement,\n  textProps: { text: string } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">,\n  scene: Scene,\n) => {\n  const textElement: ExcalidrawTextElement = newTextElement({\n    x: 0,\n    y: 0,\n    textAlign: TEXT_ALIGN.CENTER,\n    verticalAlign: VERTICAL_ALIGN.MIDDLE,\n    ...textProps,\n    containerId: container.id,\n    strokeColor: textProps.strokeColor ?? DEFAULT_BOUND_TEXT_STROKE_COLOR,\n  });\n\n  Object.assign(container, {\n    boundElements: (container.boundElements || []).concat({\n      type: \"text\",\n      id: textElement.id,\n    }),\n  });\n\n  redrawTextBoundingBox(textElement, container, scene);\n\n  return [container, textElement] as const;\n};\n\nconst bindLinearElementToElement = (\n  linearElement: ExcalidrawArrowElement,\n  start: ValidLinearElement[\"start\"],\n  end: ValidLinearElement[\"end\"],\n  elementStore: ElementStore,\n  scene: Scene,\n): {\n  linearElement: ExcalidrawLinearElement;\n  startBoundElement?: ExcalidrawElement;\n  endBoundElement?: ExcalidrawElement;\n} => {\n  let startBoundElement;\n  let endBoundElement;\n\n  Object.assign(linearElement, {\n    startBinding: linearElement?.startBinding || null,\n    endBinding: linearElement.endBinding || null,\n  });\n\n  if (start) {\n    const width = start?.width ?? DEFAULT_DIMENSION;\n    const height = start?.height ?? DEFAULT_DIMENSION;\n\n    let existingElement;\n    if (start.id) {\n      existingElement = elementStore.getElement(start.id);\n      if (!existingElement) {\n        console.error(`No element for start binding with id ${start.id} found`);\n      }\n    }\n\n    const startX = start.x || linearElement.x - width;\n    const startY = start.y || linearElement.y - height / 2;\n    const startType = existingElement ? existingElement.type : start.type;\n\n    if (startType) {\n      if (startType === \"text\") {\n        let text = \"\";\n        if (existingElement && existingElement.type === \"text\") {\n          text = existingElement.text;\n        } else if (start.type === \"text\") {\n          text = start.text;\n        }\n        if (!text) {\n          console.error(\n            `No text found for start binding text element for ${linearElement.id}`,\n          );\n        }\n        startBoundElement = newTextElement({\n          x: startX,\n          y: startY,\n          type: \"text\",\n          ...existingElement,\n          ...start,\n          text,\n        });\n        // to position the text correctly when coordinates not provided\n        Object.assign(startBoundElement, {\n          x: start.x || linearElement.x - startBoundElement.width,\n          y: start.y || linearElement.y - startBoundElement.height / 2,\n        });\n      } else {\n        switch (startType) {\n          case \"rectangle\":\n          case \"ellipse\":\n          case \"diamond\": {\n            startBoundElement = newElement({\n              x: startX,\n              y: startY,\n              width,\n              height,\n              ...existingElement,\n              ...start,\n              type: startType,\n            });\n            break;\n          }\n          default: {\n            assertNever(\n              linearElement as never,\n              `Unhandled element start type \"${start.type}\"`,\n              true,\n            );\n          }\n        }\n      }\n\n      bindBindingElement(\n        linearElement,\n        startBoundElement as ExcalidrawBindableElement,\n        \"orbit\",\n        \"start\",\n        scene,\n      );\n    }\n  }\n  if (end) {\n    const height = end?.height ?? DEFAULT_DIMENSION;\n    const width = end?.width ?? DEFAULT_DIMENSION;\n\n    let existingElement;\n    if (end.id) {\n      existingElement = elementStore.getElement(end.id);\n      if (!existingElement) {\n        console.error(`No element for end binding with id ${end.id} found`);\n      }\n    }\n    const endX = end.x || linearElement.x + linearElement.width;\n    const endY = end.y || linearElement.y - height / 2;\n    const endType = existingElement ? existingElement.type : end.type;\n\n    if (endType) {\n      if (endType === \"text\") {\n        let text = \"\";\n        if (existingElement && existingElement.type === \"text\") {\n          text = existingElement.text;\n        } else if (end.type === \"text\") {\n          text = end.text;\n        }\n\n        if (!text) {\n          console.error(\n            `No text found for end binding text element for ${linearElement.id}`,\n          );\n        }\n        endBoundElement = newTextElement({\n          x: endX,\n          y: endY,\n          type: \"text\",\n          ...existingElement,\n          ...end,\n          text,\n        });\n        // to position the text correctly when coordinates not provided\n        Object.assign(endBoundElement, {\n          y: end.y || linearElement.y - endBoundElement.height / 2,\n        });\n      } else {\n        switch (endType) {\n          case \"rectangle\":\n          case \"ellipse\":\n          case \"diamond\": {\n            endBoundElement = newElement({\n              x: endX,\n              y: endY,\n              width,\n              height,\n              ...existingElement,\n              ...end,\n              type: endType,\n            });\n            break;\n          }\n          default: {\n            assertNever(\n              linearElement as never,\n              `Unhandled element end type \"${endType}\"`,\n              true,\n            );\n          }\n        }\n      }\n\n      bindBindingElement(\n        linearElement,\n        endBoundElement as ExcalidrawBindableElement,\n        \"orbit\",\n        \"end\",\n        scene,\n      );\n    }\n  }\n\n  // Safe check to early return for single point\n  if (linearElement.points.length < 2) {\n    return {\n      linearElement,\n      startBoundElement,\n      endBoundElement,\n    };\n  }\n\n  // Update start/end points by 0.5 so bindings don't overlap with start/end bound element coordinates.\n  const endPointIndex = linearElement.points.length - 1;\n  const delta = 0.5;\n\n  const newPoints = cloneJSON<readonly LocalPoint[]>(linearElement.points);\n\n  // left to right so shift the arrow towards right\n  if (\n    linearElement.points[endPointIndex][0] >\n    linearElement.points[endPointIndex - 1][0]\n  ) {\n    newPoints[0][0] = delta;\n    newPoints[endPointIndex][0] -= delta;\n  }\n\n  // right to left so shift the arrow towards left\n  if (\n    linearElement.points[endPointIndex][0] <\n    linearElement.points[endPointIndex - 1][0]\n  ) {\n    newPoints[0][0] = -delta;\n    newPoints[endPointIndex][0] += delta;\n  }\n  // top to bottom so shift the arrow towards top\n  if (\n    linearElement.points[endPointIndex][1] >\n    linearElement.points[endPointIndex - 1][1]\n  ) {\n    newPoints[0][1] = delta;\n    newPoints[endPointIndex][1] -= delta;\n  }\n\n  // bottom to top so shift the arrow towards bottom\n  if (\n    linearElement.points[endPointIndex][1] <\n    linearElement.points[endPointIndex - 1][1]\n  ) {\n    newPoints[0][1] = -delta;\n    newPoints[endPointIndex][1] += delta;\n  }\n\n  Object.assign(\n    linearElement,\n    LinearElementEditor.getNormalizeElementPointsAndCoords({\n      ...linearElement,\n      points: newPoints,\n    }),\n  );\n\n  return {\n    linearElement,\n    startBoundElement,\n    endBoundElement,\n  };\n};\n\nclass ElementStore {\n  excalidrawElements = new Map<string, ExcalidrawElement>();\n\n  add = (ele?: ExcalidrawElement) => {\n    if (!ele) {\n      return;\n    }\n\n    this.excalidrawElements.set(ele.id, ele);\n  };\n\n  getElements = () => {\n    return syncInvalidIndices(Array.from(this.excalidrawElements.values()));\n  };\n\n  getElementsMap = () => {\n    return toBrandedType<NonDeletedSceneElementsMap>(\n      arrayToMap(this.getElements()),\n    );\n  };\n\n  getElement = (id: string) => {\n    return this.excalidrawElements.get(id);\n  };\n}\n\nexport const convertToExcalidrawElements = (\n  elementsSkeleton: ExcalidrawElementSkeleton[] | null,\n  opts?: { regenerateIds: boolean },\n) => {\n  if (!elementsSkeleton) {\n    return [];\n  }\n  const elements = cloneJSON(elementsSkeleton);\n  const elementStore = new ElementStore();\n  const elementsWithIds = new Map<string, ExcalidrawElementSkeleton>();\n  const oldToNewElementIdMap = new Map<string, string>();\n\n  // Create individual elements\n  for (const element of elements) {\n    let excalidrawElement: ExcalidrawElement;\n    const originalId = element.id;\n    if (opts?.regenerateIds !== false) {\n      Object.assign(element, { id: randomId() });\n    }\n\n    switch (element.type) {\n      case \"rectangle\":\n      case \"ellipse\":\n      case \"diamond\": {\n        const width =\n          element?.label?.text && element.width === undefined\n            ? 0\n            : element?.width || DEFAULT_DIMENSION;\n        const height =\n          element?.label?.text && element.height === undefined\n            ? 0\n            : element?.height || DEFAULT_DIMENSION;\n        excalidrawElement = newElement({\n          ...element,\n          width,\n          height,\n        });\n\n        break;\n      }\n      case \"line\": {\n        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;\n        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;\n        excalidrawElement = newLinearElement({\n          width,\n          height,\n          points: [pointFrom(0, 0), pointFrom(width, height)],\n          ...element,\n        });\n\n        break;\n      }\n      case \"arrow\": {\n        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;\n        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;\n        excalidrawElement = newArrowElement({\n          width,\n          height,\n          endArrowhead: \"arrow\",\n          points: [pointFrom(0, 0), pointFrom(width, height)],\n          ...element,\n          type: \"arrow\",\n        });\n\n        Object.assign(\n          excalidrawElement,\n          getSizeFromPoints(excalidrawElement.points),\n        );\n        break;\n      }\n      case \"text\": {\n        const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;\n        const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;\n        const lineHeight = element?.lineHeight || getLineHeight(fontFamily);\n        const text = element.text ?? \"\";\n        const normalizedText = normalizeText(text);\n        const metrics = measureText(\n          normalizedText,\n          getFontString({ fontFamily, fontSize }),\n          lineHeight,\n        );\n\n        excalidrawElement = newTextElement({\n          width: metrics.width,\n          height: metrics.height,\n          fontFamily,\n          fontSize,\n          ...element,\n        });\n        break;\n      }\n      case \"image\": {\n        excalidrawElement = newImageElement({\n          width: element?.width || DEFAULT_DIMENSION,\n          height: element?.height || DEFAULT_DIMENSION,\n          ...element,\n        });\n\n        break;\n      }\n      case \"frame\": {\n        excalidrawElement = newFrameElement({\n          x: 0,\n          y: 0,\n          ...element,\n        });\n        break;\n      }\n      case \"magicframe\": {\n        excalidrawElement = newMagicFrameElement({\n          x: 0,\n          y: 0,\n          ...element,\n        });\n        break;\n      }\n      case \"freedraw\":\n      case \"iframe\":\n      case \"embeddable\": {\n        excalidrawElement = element;\n        break;\n      }\n\n      default: {\n        excalidrawElement = element;\n        assertNever(\n          element,\n          `Unhandled element type \"${(element as any).type}\"`,\n          true,\n        );\n      }\n    }\n    const existingElement = elementStore.getElement(excalidrawElement.id);\n    if (existingElement) {\n      console.error(`Duplicate id found for ${excalidrawElement.id}`);\n    } else {\n      elementStore.add(excalidrawElement);\n      elementsWithIds.set(excalidrawElement.id, element);\n      if (originalId) {\n        oldToNewElementIdMap.set(originalId, excalidrawElement.id);\n      }\n    }\n  }\n\n  const elementsMap = elementStore.getElementsMap();\n  // we don't have a real scene, so we just use a temp scene to query and mutate elements\n  const scene = new Scene(elementsMap);\n\n  // Add labels and arrow bindings\n  for (const [id, element] of elementsWithIds) {\n    const excalidrawElement = elementStore.getElement(id)!;\n\n    switch (element.type) {\n      case \"rectangle\":\n      case \"ellipse\":\n      case \"diamond\":\n      case \"arrow\": {\n        if (element.label?.text) {\n          let [container, text] = bindTextToContainer(\n            excalidrawElement,\n            element?.label,\n            scene,\n          );\n          elementStore.add(container);\n          elementStore.add(text);\n\n          if (isArrowElement(container)) {\n            const originalStart =\n              element.type === \"arrow\" ? element?.start : undefined;\n            const originalEnd =\n              element.type === \"arrow\" ? element?.end : undefined;\n            if (originalStart && originalStart.id) {\n              const newStartId = oldToNewElementIdMap.get(originalStart.id);\n              if (newStartId) {\n                Object.assign(originalStart, { id: newStartId });\n              }\n            }\n            if (originalEnd && originalEnd.id) {\n              const newEndId = oldToNewElementIdMap.get(originalEnd.id);\n              if (newEndId) {\n                Object.assign(originalEnd, { id: newEndId });\n              }\n            }\n            const { linearElement, startBoundElement, endBoundElement } =\n              bindLinearElementToElement(\n                container,\n                originalStart,\n                originalEnd,\n                elementStore,\n                scene,\n              );\n            container = linearElement;\n            elementStore.add(linearElement);\n            elementStore.add(startBoundElement);\n            elementStore.add(endBoundElement);\n          }\n        } else {\n          switch (element.type) {\n            case \"arrow\": {\n              const { start, end } = element;\n              if (start && start.id) {\n                const newStartId = oldToNewElementIdMap.get(start.id);\n                Object.assign(start, { id: newStartId });\n              }\n              if (end && end.id) {\n                const newEndId = oldToNewElementIdMap.get(end.id);\n                Object.assign(end, { id: newEndId });\n              }\n              const { linearElement, startBoundElement, endBoundElement } =\n                bindLinearElementToElement(\n                  excalidrawElement as ExcalidrawArrowElement,\n                  start,\n                  end,\n                  elementStore,\n                  scene,\n                );\n\n              elementStore.add(linearElement);\n              elementStore.add(startBoundElement);\n              elementStore.add(endBoundElement);\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Once all the excalidraw elements are created, we can add frames since we\n  // need to calculate coordinates and dimensions of frame which is possible after all\n  // frame children are processed.\n  for (const [id, element] of elementsWithIds) {\n    if (element.type !== \"frame\" && element.type !== \"magicframe\") {\n      continue;\n    }\n    const frame = elementStore.getElement(id);\n\n    if (!frame) {\n      throw new Error(`Excalidraw element with id ${id} doesn't exist`);\n    }\n    const childrenElements: ExcalidrawElement[] = [];\n\n    element.children.forEach((id) => {\n      const newElementId = oldToNewElementIdMap.get(id);\n      if (!newElementId) {\n        throw new Error(`Element with ${id} wasn't mapped correctly`);\n      }\n\n      const elementInFrame = elementStore.getElement(newElementId);\n      if (!elementInFrame) {\n        throw new Error(`Frame element with id ${newElementId} doesn't exist`);\n      }\n      Object.assign(elementInFrame, { frameId: frame.id });\n\n      elementInFrame?.boundElements?.forEach((boundElement) => {\n        const ele = elementStore.getElement(boundElement.id);\n        if (!ele) {\n          throw new Error(\n            `Bound element with id ${boundElement.id} doesn't exist`,\n          );\n        }\n        Object.assign(ele, { frameId: frame.id });\n        childrenElements.push(ele);\n      });\n\n      childrenElements.push(elementInFrame);\n    });\n\n    let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);\n\n    const PADDING = 10;\n    minX = minX - PADDING;\n    minY = minY - PADDING;\n    maxX = maxX + PADDING;\n    maxY = maxY + PADDING;\n\n    const frameX = frame?.x || minX;\n    const frameY = frame?.y || minY;\n    const frameWidth = frame?.width || maxX - minX;\n    const frameHeight = frame?.height || maxY - minY;\n\n    Object.assign(frame, {\n      x: frameX,\n      y: frameY,\n      width: frameWidth,\n      height: frameHeight,\n    });\n    if (\n      isDevEnv() &&\n      element.children.length &&\n      (frame?.x || frame?.y || frame?.width || frame?.height)\n    ) {\n      console.info(\n        \"User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically\",\n      );\n    }\n  }\n\n  return elementStore.getElements();\n};\n", "import type { App } from \"@excalidraw/excalidraw/types\";\n\nimport { LinearElementEditor } from \"../linearElementEditor\";\n\nimport { handleFocusPointDrag } from \"./focus\";\n\nexport const maybeHandleArrowPointlikeDrag = ({\n  app,\n  event,\n}: {\n  app: App;\n  event: KeyboardEvent | React.KeyboardEvent<Element> | PointerEvent;\n}): boolean => {\n  const appState = app.state;\n  if (appState.selectedLinearElement && app.lastPointerMoveCoords) {\n    // Update focus point status if the binding mode is changing\n    if (appState.selectedLinearElement.draggedFocusPointBinding) {\n      handleFocusPointDrag(\n        appState.selectedLinearElement,\n        app.scene.getNonDeletedElementsMap(),\n        app.lastPointerMoveCoords,\n        app.scene,\n        appState,\n        app.getEffectiveGridSize(),\n        event.altKey,\n      );\n      return true;\n    } else if (\n      appState.selectedLinearElement.hoverPointIndex !== null &&\n      app.lastPointerMoveEvent &&\n      appState.selectedLinearElement.initialState.lastClickedPoint >= 0 &&\n      appState.selectedLinearElement.isDragging\n    ) {\n      LinearElementEditor.handlePointDragging(\n        app.lastPointerMoveEvent,\n        app,\n        app.lastPointerMoveCoords.x,\n        app.lastPointerMoveCoords.y,\n        appState.selectedLinearElement,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n"],
  "mappings": "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",
  "names": ["result", "throttle", "toIterable", "pointsEqual", "line", "polygon", "ae", "ce", "helper", "line", "line", "helper", "line", "helper", "line", "helper", "line", "helper", "curve", "r1", "r2", "b", "b", "a", "b", "distance", "distance", "distance", "arrayToMap", "invariant", "lineSegment", "pointDistance", "pointFrom", "pointFromArray", "pointRotateRads", "curve", "polygon", "curve", "pointFrom", "pointDistance", "pointRotateRads", "THEME", "isTransparent", "assertNever", "applyDarkModeFilter", "lineSegment", "pointFrom", "pointRotateRads", "BOUND_TEXT_PADDING", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "STICKY_NOTE_PADDING", "distance", "getFontString", "invariant", "pointFrom", "pointRotateRads", "vectorFromPoint", "vectorAdd", "vectorScale", "pointFromVector", "pointRotateRads", "pointFrom", "crop", "getElementAbsoluteCoords", "vectorFromPoint", "vectorAdd", "vectorScale", "pointFromVector", "pointCenter", "pointFrom", "pointRotateRads", "pointsEqual", "pointDistance", "vectorFromPoint", "lineSegment", "KEYS", "invariant", "getFeatureFlag", "deconstructLinearOrFreeDrawElement", "getSnapOutlineMidPoint", "isPathALoop", "projectFixedPointOntoDiagonal", "arrayToMap", "invariant", "isTransparent", "PRECISION", "clamp", "lineSegment", "pointDistance", "pointFrom", "pointFromVector", "pointRotateRads", "pointsEqual", "vectorFromPoint", "vectorNormalize", "vectorScale", "invariant", "lineSegment", "lineSegmentIntersectionPoints", "pointFrom", "pointFromVector", "pointRotateRads", "pointsEqual", "vectorFromPoint", "vectorNormalize", "vectorScale", "ellipse", "invariant", "ROUNDNESS", "curve", "lineSegment", "pointDistance", "pointFrom", "pointFromArray", "pointFromVector", "pointRotateRads", "rectangle", "vectorFromPoint", "vectorNormalize", "vectorScale", "pointFromArray", "lineSegment", "pointFrom", "curve", "rectangle", "distance", "pointDistance", "ROUNDNESS", "vectorNormalize", "vectorFromPoint", "vectorScale", "pointRotateRads", "point", "midpoint", "invariant", "a", "b", "pointFromVector", "BOUND_TEXT_PADDING", "DEFAULT_FONT_SIZE", "getFontString", "invariant", "pointFrom", "pointRotateRads", "line", "isTestEnv", "line", "isTestEnv", "invariant", "getFontString", "pointFrom", "pointRotateRads", "index", "BOUND_TEXT_PADDING", "DEFAULT_FONT_SIZE", "pointRotateRads", "ellipse", "pointRotateRads", "a", "ellipse", "pointsEqual", "pointFrom", "pointRotateRads", "shouldTestInside", "lineSegment", "distance", "invariant", "a", "b", "line", "l", "lineSegmentIntersectionPoints", "ellipse", "pointFromVector", "vectorScale", "vectorNormalize", "vectorFromPoint", "offset", "corners", "invariant", "isDevEnv", "isTestEnv", "pointFrom", "pointFromVector", "pointRotateRads", "pointsEqual", "vectorFromPoint", "vectorScale", "vectorFromPoint", "a", "b", "isDevEnv", "isTestEnv", "invariant", "pointsEqual", "pointFromVector", "vectorScale", "pointRotateRads", "pointFrom", "p", "getSizeFromPoints", "clamp", "pointDistance", "pointFrom", "pointScaleFromOrigin", "pointsEqual", "pointTranslate", "vector", "vectorCross", "vectorFromPoint", "vectorScale", "invariant", "isDevEnv", "pointFrom", "pointDistance", "isDevEnv", "invariant", "pointsEqual", "vectorFromPoint", "pointTranslate", "vector", "pointScaleFromOrigin", "a", "b", "vectorCross", "global", "vectorScale", "clamp", "getSizeFromPoints", "clamp", "invariant", "pointFrom", "isTransparent", "start", "end", "arrayToMap", "vectorFromPoint", "distance", "lineSegment", "pointFromVector", "vectorScale", "vectorNormalize", "pointDistance", "PRECISION", "pointRotateRads", "a", "b", "pointsEqual", "global", "duplicateElement", "element", "pointFrom", "pointsEqual", "getElementAbsoluteCoords", "invariant", "KEYS", "projectFixedPointOntoDiagonal", "isPathALoop", "distance", "pointDistance", "deconstructLinearOrFreeDrawElement", "pointCenter", "pointRotateRads", "midpoint", "vectorFromPoint", "a", "b", "nextArrow", "startBindable", "endBindable", "getFeatureFlag", "getSnapOutlineMidPoint", "lineSegment", "arrayToMap", "isPointWithinBounds", "pointFrom", "vectorCross", "vectorFromPoint", "line", "a", "b", "l", "arrayToMap", "getElementBounds", "isArrowElement", "isExcalidrawElement", "isFreeDrawElement", "isLinearElement", "isTextElement", "pointFrom", "pointRotateRads", "arrayToMap", "isShallowEqual", "selectGroupsForSelectedElements", "getElementAbsoluteCoords", "isShallowEqual", "arrayToMap", "arrayToMap", "getElementAbsoluteCoords", "isPointWithinBounds", "pointFrom", "element", "getElementAbsoluteCoords", "distance", "BOUND_TEXT_PADDING", "getFontString", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "STICKY_NOTE_PADDING", "pointFrom", "invariant", "lineSegment", "pointRotateRads", "THEME", "applyDarkModeFilter", "isTransparent", "arrowheadPoints", "options", "pointFrom", "pointRotateRads", "assertNever", "pointDistance", "getElementAbsoluteCoords", "distance", "A", "B", "getElementAbsoluteCoords", "pointRotateRads", "pointFrom", "curve", "lineSegment", "segments", "se", "ellipse", "a", "b", "pointFromArray", "invariant", "minX", "minY", "maxX", "maxY", "distance", "x3", "y3", "x4", "y4", "coords", "arrayToMap", "pointDistance", "x", "y", "pointsEqual", "arrayToMap", "assertNever", "isDevEnv", "isShallowEqual", "isTestEnv", "randomInteger", "assertNever", "COLOR_PALETTE", "isDevEnv", "isTestEnv", "randomId", "randomInteger", "arrayToMap", "getUpdatedTimestamp", "isTestEnv", "elements", "element", "isTestEnv", "getUpdatedTimestamp", "randomInteger", "arrayToMap", "elements", "element", "newElement", "duplicateElement", "assertNever", "isTestEnv", "isDevEnv", "randomId", "COLOR_PALETTE", "a", "b", "ib", "fb", "ia", "fa", "i", "c", "arrayToMap", "arrayToMap", "a", "b", "lowerBound", "upperBound", "i", "current", "randomInteger", "arrayToMap", "isDevEnv", "isTestEnv", "isFrameLikeElement", "getElementsInGroup", "syncInvalidIndices", "syncMovedIndices", "validateFractionalIndices", "getSelectedElements", "mutateElement", "throttle", "assertNever", "isShallowEqual", "isTestEnv", "isDevEnv", "delta", "randomInteger", "arrayToMap", "a", "b", "step", "pos", "getGridPoint", "getFontString", "DRAGGING_THRESHOLD", "DRAGGING_THRESHOLD", "getGridPoint", "newElement", "getFontString", "VERTICAL_ALIGN", "getFontString", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "VERTICAL_ALIGN", "randomInteger", "randomId", "getFontString", "getUpdatedTimestamp", "randomId", "randomInteger", "getUpdatedTimestamp", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "getFontString", "VERTICAL_ALIGN", "getElementAbsoluteCoords", "timeMatch", "getFontString", "VERTICAL_ALIGN", "KEYS", "invariant", "toBrandedType", "pointFrom", "KEYS", "invariant", "_VERTICAL_OFFSET", "y", "x", "pointFrom", "toBrandedType", "pointDistance", "pointFrom", "invariant", "arrayToMap", "findLastIndex", "arrayToMap", "moveArrowAboveBindable", "arrow", "findLastIndex", "pointDistance", "pointFrom", "moveArrowAboveBindable", "invariant", "MIME_TYPES", "MIME_TYPES", "pointCenter", "normalizeRadians", "pointFrom", "pointRotateRads", "SHIFT_LOCKING_ANGLE", "rescalePoints", "getFontString", "shouldRotateWithDiscreteAngle", "getElementAbsoluteCoords", "SHIFT_LOCKING_ANGLE", "normalizeRadians", "rescalePoints", "pointFrom", "getFontString", "metrics", "pointRotateRads", "pointCenter", "width", "height", "pointFrom", "pointRotateRads", "pointFrom", "pointRotateRads", "pointRotateRads", "pointFrom", "getElementAbsoluteCoords", "getElementAbsoluteCoords", "pointFrom", "a", "pointRotateRads", "pointFrom", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "TEXT_ALIGN", "VERTICAL_ALIGN", "getSizeFromPoints", "randomId", "arrayToMap", "assertNever", "getFontString", "isDevEnv", "toBrandedType", "getLineHeight", "TEXT_ALIGN", "VERTICAL_ALIGN", "assertNever", "toBrandedType", "arrayToMap", "randomId", "pointFrom", "getSizeFromPoints", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_SIZE", "getLineHeight", "getFontString", "id", "isDevEnv", "toIterable", "getNonDeletedElements", "isNonDeletedElement"]
}
